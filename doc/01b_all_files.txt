// START FILE: ../INSTALL.md
How to build and install stm32plus
==================================

This readme will help you to understand how you can build and install stm32plus.

Get the source
--------------

Firstly you need to clone the repo:

	git clone https://github.com/andysworkshop/stm32plus.git

If you're happy with building from the `master` branch then you can just go right ahead to the next step. Otherwise, you'll need to use git to checkout the tag or branch you want to build from. Tags represent releases and are the safest build option. The `master` branch is the next safest and the feature branches are for the brave.

Prerequisites
-------------

* A compatible g++ arm-none-eabi toolchain that supports C++ 14. I prefer the [ARM launchpad](https://developer.arm.com/open-source/gnu-toolchain/gnu-rm) toolchain because it supports the hardware FPU in the F4 series. Download the a compatible EABI version, install it on your system and ensure that it's in your path by attempting to execute one of the commands:

		$ arm-none-eabi-g++
		arm-none-eabi-g++.exe: no input files

* `scons`. Writing Makefiles to cope with all the variant builds was driving me crazy so I switched to _scons_ and have never looked back. If you don't already have it then google it and download and install it on to your system from the official website. Linux users can get it using their official package management interface (e.g. `apt-get`)

### Additional prerequisites for Windows systems ###
   
* cygwin, msys or any other system that makes your build environment look like Unix. I use cygwin. Attempting to build out of something as lobotomised as a Windows _cmd_ shell is not supported.

* Windows builds under cygwin _must_ use the cygwin supplied python and the source build of scons. Get python from the official cygwin update site. Get scons from [http://www.scons.org/download.php](http://www.scons.org/download.php) and select _Zip file_ or _Gzip tar file_ and install it using `setup.py` from the cygwin bash prompt.

_Do not_ get windows installer versions of python or scons. They are not compatible with cygwin.

How to build
------------

* Change directory to the top-level directory containing the `SConstruct` file.

* stm32plus supports the F0, F100 MDVL, F103 HD, F107 CL and F4 series MCUs. Decide which one you want to build for. You also need to know your external oscillator (HSE) speed and you need to decide on whether you want to build a debug (-O0), small (-Os) or fast (-O3) library. If you're using a device that does not have an external oscillator (e.g. the F0 discovery board) then just use 8000000 as a default.

You can build all of the above combinations side-by-side if you so wish by executing `scons` multiple times.

* Execute `scons` with the parameters that define the build:

		Usage: scons mode=<MODE> mcu=<MCU> hse=<HSE> [float=hard]

		<MODE>: debug/fast/small.
    		debug = -O0
    		fast  = -O3
    		small = -Os

  		<MCU>: f1hd/f1cle/f1mdvl/f051/f030/f042/f4.
    		f030   = STM32F030 series.
            f042   = STM32F042 series.
    		f051   = STM32F051 series.
    		f1hd   = STM32F103HD series.
    		f1cle  = STM32F107 series.
    		f1mdvl = STM32100 Medium Density Value Line series.
    		f4     = STM32F407/f417 series (maintained for backwards compatibility)
    		f401   = STM32F401
    		f407   = STM32F407
    		f415   = STM32F417
    		f417   = STM32F417
    		f427   = STM32F427
    		f437   = STM32F437
    		f429   = STM32F429
    		f439   = STM32F439

        <HSE or HSI>:
            Your external (HSE) or internal (HSI) oscillator speed in Hz. Some of the ST standard
            peripheral library code uses the HSE_VALUE / HSI_VALUE #define that we set here. Select
            either the 'hse' or 'hsi' option, not both.

  		[float=hard]:
    		Optional flag for an F4 build that will cause the hardware FPU to be
    		used for floating point operations. Requires the "GNU Tools for ARM Embedded
    		Processors" toolchain. Will not work with Code Sourcery Lite.

        [examples=no]:
            Optional flag that allows you to build just the library without the examples. The
            default is to build the library and the examples.

  		Examples:
    		scons mode=debug mcu=f1hd hse=8000000                       // debug / f1hd / 8MHz
    		scons mode=debug mcu=f1cle hse=25000000                     // debug / f1cle / 25MHz
    		scons mode=debug mcu=f1mdvl hse=8000000                     // debug / f1mdvl / 8MHz
    		scons mode=fast mcu=f1hd hse=8000000 install                // fast / f1hd / 8MHz
    		scons mode=small mcu=f4 hse=8000000 -j4 float=hard install  // small / f407 or f417 / 8Mhz
    		scons mode=debug mcu=f4 hse=8000000 -j4 install             // debug / f407 or f417 / 8Mhz
    		scons mode=debug mcu=f051 hse=8000000 -j4 install           // debug / f051 / 8Mhz

  		Additional Notes:
    		The -j<N> option can be passed to scons to do a parallel build. On a multicore
    		CPU this can greatly accelerate the build. Set <N> to approximately the number
    		of cores that you have.

    		The built library will be placed in the stm32plus/build subdirectory.

    		If you specify the install command-line option then that library will be installed
    		into the location given by INSTALLDIR, which defaults to /usr/local/arm-none-eabi.
    		The library, headers, and examples will be installed respectively, to the lib,
    		include, and bin subdirectories of INSTALLDIR.

    		It is safe to compile multiple combinations of mode/mcu/hse as the compiled object
    		code and library are placed in a unique directory name underneath stm32plus/build.
    		It is likewise safe to install multiple versions of the library and examples.

The `-j<N>` option can be passed to scons to do a parallel build. On a multicore CPU this can greatly accelerate the build. Set <N> to approximately the number of cores that you have.

The `install` option will install the library and the examples into subdirectories of `/usr/local/arm-none-eabi`. This location can be customised by supplying an `INSTALLDIR` argument on the command line.

#### A note on the example projects ####

The example projects are designed to run on either the 512/64Kb/72MHz STM32F103, the 256/64Kb/72Mhz STM32F107, the 128/8Kb/24MHz STM32F100, the 1024Kb/128Kb/168Mhz STM32F4 and the 64/8Kb/48MHz F051.

It is the linker script (`Linker.ld`) and the system startup code (`System.c`) that specify these things. For example, if you wanted to change the core clock then you need to look at `System.c` (`SystemCoreClock` is a key variable). If you want to change the memory size then you need to look at `Linker.ld`. The stm32plus library itself is clock-speed and memory-independent. For example, I have used stm32plus with an STM32F429 MCU just by using the F4 build and adjusting my system and linker files to reflect the higher clock speed and memory configuration.

Some examples are not suitable for all MCUs. For example, the STM32F107 does not come with SDIO or FSMC peripherals, and the STM32F103 does not have an ethernet MAC. If an example is not suitable for the MCU that you are targetting then the scons script will skip over it and the Eclipse project will not contain a configuration for it.

#### A note on the net examples

The network code requires the dynamic heap CRT library functions to be safe for re-entrant use, therefore these examples contain the following code in the `LibraryHacks.cpp` file. When writing your own code it is very important that you include this:

	/*
	 * The net code needs the heap to re-entrant so we need to ensure that an
	 * IRQ cannot be raised while the heap structures are updated
	 */
	
	extern "C" {
	  void __malloc_lock(struct _reent * /* reent */) {
	    stm32plus::IrqSuspend::suspend();
	  }
	
	  void __malloc_unlock(struct _reent * /* reent */) {
	    stm32plus::IrqSuspend::resume();
	  }
	}
// END FILE: ../INSTALL.md
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_wwdg.h
/**
  ******************************************************************************
  * @file    stm32f4xx_wwdg.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the WWDG firmware
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_WWDG_H
#define __STM32F4xx_WWDG_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup WWDG
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/

/** @defgroup WWDG_Exported_Constants
  * @{
  */ 
  
/** @defgroup WWDG_Prescaler 
  * @{
  */
  
#define WWDG_Prescaler_1    ((uint32_t)0x00000000)
#define WWDG_Prescaler_2    ((uint32_t)0x00000080)
#define WWDG_Prescaler_4    ((uint32_t)0x00000100)
#define WWDG_Prescaler_8    ((uint32_t)0x00000180)
#define IS_WWDG_PRESCALER(PRESCALER) (((PRESCALER) == WWDG_Prescaler_1) || \
                                      ((PRESCALER) == WWDG_Prescaler_2) || \
                                      ((PRESCALER) == WWDG_Prescaler_4) || \
                                      ((PRESCALER) == WWDG_Prescaler_8))
#define IS_WWDG_WINDOW_VALUE(VALUE) ((VALUE) <= 0x7F)
#define IS_WWDG_COUNTER(COUNTER) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))

/**
  * @}
  */ 

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
  
/*  Function used to set the WWDG configuration to the default reset state ****/  
void WWDG_DeInit(void);

/* Prescaler, Refresh window and Counter configuration functions **************/
void WWDG_SetPrescaler(uint32_t WWDG_Prescaler);
void WWDG_SetWindowValue(uint8_t WindowValue);
void WWDG_EnableIT(void);
void WWDG_SetCounter(uint8_t Counter);

/* WWDG activation function ***************************************************/
void WWDG_Enable(uint8_t Counter);

/* Interrupts and flags management functions **********************************/
FlagStatus WWDG_GetFlagStatus(void);
void WWDG_ClearFlag(void);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_WWDG_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_wwdg.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_ltdc.h
/**
  ******************************************************************************
  * @file    stm32f4xx_ltdc.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the LTDC firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#pragma once

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

#if defined(STM32PLUS_F4_HAS_LTDC)

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup LTDC
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
 
/** 
  * @brief  LTDC Init structure definition  
  */

typedef struct
{
  uint32_t LTDC_HSPolarity;                 /*!< configures the horizontal synchronization polarity.
                                                 This parameter can be one value of @ref LTDC_HSPolarity */

  uint32_t LTDC_VSPolarity;                 /*!< configures the vertical synchronization polarity.
                                                 This parameter can be one value of @ref LTDC_VSPolarity */

  uint32_t LTDC_DEPolarity;                 /*!< configures the data enable polarity. This parameter can
                                                 be one of value of @ref LTDC_DEPolarity */

  uint32_t LTDC_PCPolarity;                 /*!< configures the pixel clock polarity. This parameter can
                                                 be one of value of @ref LTDC_PCPolarity */

  uint32_t LTDC_HorizontalSync;             /*!< configures the number of Horizontal synchronization 
                                                 width. This parameter must range from 0x000 to 0xFFF. */

  uint32_t LTDC_VerticalSync;               /*!< configures the number of Vertical synchronization 
                                                 heigh. This parameter must range from 0x000 to 0x7FF. */

  uint32_t LTDC_AccumulatedHBP;             /*!< configures the accumulated horizontal back porch width.
                                                 This parameter must range from LTDC_HorizontalSync to 0xFFF. */

  uint32_t LTDC_AccumulatedVBP;             /*!< configures the accumulated vertical back porch heigh.
                                                 This parameter must range from LTDC_VerticalSync to 0x7FF. */
            
  uint32_t LTDC_AccumulatedActiveW;         /*!< configures the accumulated active width. This parameter 
                                                 must range from LTDC_AccumulatedHBP to 0xFFF. */

  uint32_t LTDC_AccumulatedActiveH;         /*!< configures the accumulated active heigh. This parameter 
                                                 must range from LTDC_AccumulatedVBP to 0x7FF. */

  uint32_t LTDC_TotalWidth;                 /*!< configures the total width. This parameter 
                                                 must range from LTDC_AccumulatedActiveW to 0xFFF. */

  uint32_t LTDC_TotalHeigh;                 /*!< configures the total heigh. This parameter 
                                                 must range from LTDC_AccumulatedActiveH to 0x7FF. */
            
  uint32_t LTDC_BackgroundRedValue;         /*!< configures the background red value.
                                                 This parameter must range from 0x00 to 0xFF. */

  uint32_t LTDC_BackgroundGreenValue;       /*!< configures the background green value.
                                                 This parameter must range from 0x00 to 0xFF. */ 

   uint32_t LTDC_BackgroundBlueValue;       /*!< configures the background blue value.
                                                 This parameter must range from 0x00 to 0xFF. */
} LTDC_InitTypeDef;

/** 
  * @brief  LTDC Layer structure definition  
  */

typedef struct
{
  uint32_t LTDC_HorizontalStart;            /*!< Configures the Window Horizontal Start Position.
                                                 This parameter must range from 0x000 to 0xFFF. */
            
  uint32_t LTDC_HorizontalStop;             /*!< Configures the Window Horizontal Stop Position.
                                                 This parameter must range from 0x0000 to 0xFFFF. */
  
  uint32_t LTDC_VerticalStart;              /*!< Configures the Window vertical Start Position.
                                                 This parameter must range from 0x000 to 0xFFF. */

  uint32_t LTDC_VerticalStop;               /*!< Configures the Window vaertical Stop Position.
                                                 This parameter must range from 0x0000 to 0xFFFF. */
  
  uint32_t LTDC_PixelFormat;                /*!< Specifies the pixel format. This parameter can be 
                                                 one of value of @ref LTDC_Pixelformat */

  uint32_t LTDC_ConstantAlpha;              /*!< Specifies the constant alpha used for blending.
                                                 This parameter must range from 0x00 to 0xFF. */

  uint32_t LTDC_DefaultColorBlue;           /*!< Configures the default blue value.
                                                 This parameter must range from 0x00 to 0xFF. */

  uint32_t LTDC_DefaultColorGreen;          /*!< Configures the default green value.
                                                 This parameter must range from 0x00 to 0xFF. */
            
  uint32_t LTDC_DefaultColorRed;            /*!< Configures the default red value.
                                                 This parameter must range from 0x00 to 0xFF. */

  uint32_t LTDC_DefaultColorAlpha;          /*!< Configures the default alpha value.
                                                 This parameter must range from 0x00 to 0xFF. */

  uint32_t LTDC_BlendingFactor_1;           /*!< Select the blending factor 1. This parameter 
                                                 can be one of value of @ref LTDC_BlendingFactor1 */

  uint32_t LTDC_BlendingFactor_2;           /*!< Select the blending factor 2. This parameter 
                                                 can be one of value of @ref LTDC_BlendingFactor2 */
            
  uint32_t LTDC_CFBStartAdress;             /*!< Configures the color frame buffer address */

  uint32_t LTDC_CFBLineLength;              /*!< Configures the color frame buffer line length. 
                                                 This parameter must range from 0x0000 to 0x1FFF. */

  uint32_t LTDC_CFBPitch;                   /*!< Configures the color frame buffer pitch in bytes.
                                                 This parameter must range from 0x0000 to 0x1FFF. */
                                                 
  uint32_t LTDC_CFBLineNumber;              /*!< Specifies the number of line in frame buffer. 
                                                 This parameter must range from 0x000 to 0x7FF. */
} LTDC_Layer_InitTypeDef;

/** 
  * @brief  LTDC Position structure definition  
  */

typedef struct
{
  uint32_t LTDC_POSX;                         /*!<  Current X Position */
  uint32_t LTDC_POSY;                         /*!<  Current Y Position */
} LTDC_PosTypeDef;

typedef struct
{
  uint32_t LTDC_BlueWidth;                        /*!< Blue width */
  uint32_t LTDC_GreenWidth;                       /*!< Green width */
  uint32_t LTDC_RedWidth;                         /*!< Red width */
} LTDC_RGBTypeDef;

typedef struct
{
  uint32_t LTDC_ColorKeyBlue;               /*!< Configures the color key blue value. 
                                                 This parameter must range from 0x00 to 0xFF. */

  uint32_t LTDC_ColorKeyGreen;              /*!< Configures the color key green value. 
                                                 This parameter must range from 0x00 to 0xFF. */
            
  uint32_t LTDC_ColorKeyRed;                /*!< Configures the color key red value. 
                                                 This parameter must range from 0x00 to 0xFF. */
} LTDC_ColorKeying_InitTypeDef;

typedef struct
{
  uint32_t LTDC_CLUTAdress;                 /*!< Configures the CLUT address.
                                                 This parameter must range from 0x00 to 0xFF. */

  uint32_t LTDC_BlueValue;                  /*!< Configures the blue value. 
                                                 This parameter must range from 0x00 to 0xFF. */
                                                 
  uint32_t LTDC_GreenValue;                 /*!< Configures the green value. 
                                                 This parameter must range from 0x00 to 0xFF. */

  uint32_t LTDC_RedValue;                   /*!< Configures the red value.
                                                 This parameter must range from 0x00 to 0xFF. */
} LTDC_CLUT_InitTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup LTDC_Exported_Constants
  * @}
  */
  
/** @defgroup LTDC_SYNC 
  * @{
  */

#define LTDC_HorizontalSYNC               ((uint32_t)0x00000FFF)
#define LTDC_VerticalSYNC                 ((uint32_t)0x000007FF)

#define IS_LTDC_HSYNC(HSYNC) ((HSYNC) <= LTDC_HorizontalSYNC)
#define IS_LTDC_VSYNC(VSYNC) ((VSYNC) <= LTDC_VerticalSYNC)
#define IS_LTDC_AHBP(AHBP)  ((AHBP) <= LTDC_HorizontalSYNC)
#define IS_LTDC_AVBP(AVBP) ((AVBP) <= LTDC_VerticalSYNC)
#define IS_LTDC_AAW(AAW)   ((AAW) <= LTDC_HorizontalSYNC)
#define IS_LTDC_AAH(AAH) ((AAH) <= LTDC_VerticalSYNC)
#define IS_LTDC_TOTALW(TOTALW) ((TOTALW) <= LTDC_HorizontalSYNC)
#define IS_LTDC_TOTALH(TOTALH) ((TOTALH) <= LTDC_VerticalSYNC)

/**
  * @}
  */
  
/** @defgroup LTDC_HSPolarity 
  * @{
  */
#define LTDC_HSPolarity_AL                ((uint32_t)0x00000000)                /*!< Horizontal Synchronization is active low. */
#define LTDC_HSPolarity_AH                LTDC_GCR_HSPOL                        /*!< Horizontal Synchronization is active high. */

#define IS_LTDC_HSPOL(HSPOL) (((HSPOL) == LTDC_HSPolarity_AL) || \
                              ((HSPOL) == LTDC_HSPolarity_AH))  

/**
  * @}
  */
  
/** @defgroup LTDC_VSPolarity 
  * @{
  */
#define LTDC_VSPolarity_AL                ((uint32_t)0x00000000)                /*!< Vertical Synchronization is active low. */
#define LTDC_VSPolarity_AH                LTDC_GCR_VSPOL                        /*!< Vertical Synchronization is active high. */

#define IS_LTDC_VSPOL(VSPOL) (((VSPOL) == LTDC_VSPolarity_AL) || \
                              ((VSPOL) == LTDC_VSPolarity_AH))  

/**
  * @}
  */
  
/** @defgroup LTDC_DEPolarity 
  * @{
  */
#define LTDC_DEPolarity_AL                ((uint32_t)0x00000000)                /*!< Data Enable, is active low. */
#define LTDC_DEPolarity_AH                LTDC_GCR_DEPOL                        /*!< Data Enable, is active high. */

#define IS_LTDC_DEPOL(DEPOL) (((DEPOL) ==  LTDC_VSPolarity_AL) || \
                              ((DEPOL) ==  LTDC_DEPolarity_AH))

/**
  * @}
  */

/** @defgroup LTDC_PCPolarity 
  * @{
  */
#define LTDC_PCPolarity_IPC               ((uint32_t)0x00000000)                /*!< input pixel clock. */
#define LTDC_PCPolarity_IIPC              LTDC_GCR_PCPOL                        /*!< inverted input pixel clock. */

#define IS_LTDC_PCPOL(PCPOL) (((PCPOL) ==  LTDC_PCPolarity_IPC) || \
                              ((PCPOL) ==  LTDC_PCPolarity_IIPC))

/**
  * @}
  */

/** @defgroup LTDC_Reload 
  * @{
  */
#define LTDC_IMReload                     LTDC_SRCR_IMR                         /*!< Immediately Reload. */
#define LTDC_VBReload                     LTDC_SRCR_VBR                         /*!< Vertical Blanking Reload. */

#define IS_LTDC_RELOAD(RELOAD) (((RELOAD) == LTDC_IMReload) || \
                                ((RELOAD) == LTDC_VBReload))

/**
  * @}
  */
  
/** @defgroup LTDC_Back_Color
  * @{
  */ 

#define LTDC_Back_Color                   ((uint32_t)0x000000FF)

#define IS_LTDC_BackBlueValue(BBLUE)    ((BBLUE) <= LTDC_Back_Color)
#define IS_LTDC_BackGreenValue(BGREEN)  ((BGREEN) <= LTDC_Back_Color)
#define IS_LTDC_BackRedValue(BRED)      ((BRED) <= LTDC_Back_Color) 

/**
  * @}
  */
      
/** @defgroup LTDC_Position 
  * @{
  */

#define LTDC_POS_CY                       LTDC_CPSR_CYPOS
#define LTDC_POS_CX                       LTDC_CPSR_CXPOS

#define IS_LTDC_GET_POS(POS) (((POS) <= LTDC_POS_CY))


/**
  * @}
  */
      
/** @defgroup LTDC_LIPosition 
  * @{
  */

#define IS_LTDC_LIPOS(LIPOS) ((LIPOS) <= 0x7FF)

/**
  * @}
  */
      
/** @defgroup LTDC_CurrentStatus 
  * @{
  */

#define LTDC_CD_VDES                     LTDC_CDSR_VDES
#define LTDC_CD_HDES                     LTDC_CDSR_HDES
#define LTDC_CD_VSYNC                    LTDC_CDSR_VSYNCS
#define LTDC_CD_HSYNC                    LTDC_CDSR_HSYNCS


#define IS_LTDC_GET_CD(CD) (((CD) == LTDC_CD_VDES) || ((CD) == LTDC_CD_HDES) || \
                              ((CD) == LTDC_CD_VSYNC) || ((CD) == LTDC_CD_HSYNC))


/**
  * @}
  */  

/** @defgroup LTDC_Interrupts 
  * @{
  */                           

#define LTDC_IT_LI                      LTDC_IER_LIE
#define LTDC_IT_FU                      LTDC_IER_FUIE
#define LTDC_IT_TERR                    LTDC_IER_TERRIE
#define LTDC_IT_RR                      LTDC_IER_RRIE

#define IS_LTDC_IT(IT) ((((IT) & (uint32_t)0xFFFFFFF0) == 0x00) && ((IT) != 0x00))

/**
  * @}
  */
      
/** @defgroup LTDC_Flag 
  * @{
  */

#define LTDC_FLAG_LI                     LTDC_ISR_LIF
#define LTDC_FLAG_FU                     LTDC_ISR_FUIF
#define LTDC_FLAG_TERR                   LTDC_ISR_TERRIF
#define LTDC_FLAG_RR                     LTDC_ISR_RRIF


#define IS_LTDC_FLAG(FLAG) (((FLAG) == LTDC_FLAG_LI) || ((FLAG) == LTDC_FLAG_FU) || \
                               ((FLAG) == LTDC_FLAG_TERR) || ((FLAG) == LTDC_FLAG_RR))

/**
  * @}
  */
      
/** @defgroup LTDC_Pixelformat 
  * @{
  */
#define LTDC_Pixelformat_ARGB8888                  ((uint32_t)0x00000000)
#define LTDC_Pixelformat_RGB888                    ((uint32_t)0x00000001)
#define LTDC_Pixelformat_RGB565                    ((uint32_t)0x00000002)
#define LTDC_Pixelformat_ARGB1555                  ((uint32_t)0x00000003)
#define LTDC_Pixelformat_ARGB4444                  ((uint32_t)0x00000004)
#define LTDC_Pixelformat_L8                        ((uint32_t)0x00000005)
#define LTDC_Pixelformat_AL44                      ((uint32_t)0x00000006)
#define LTDC_Pixelformat_AL88                      ((uint32_t)0x00000007)

#define IS_LTDC_Pixelformat(Pixelformat) (((Pixelformat) == LTDC_Pixelformat_ARGB8888) || ((Pixelformat) == LTDC_Pixelformat_RGB888)   || \
                        ((Pixelformat) == LTDC_Pixelformat_RGB565)   || ((Pixelformat) == LTDC_Pixelformat_ARGB1555) || \
                        ((Pixelformat) == LTDC_Pixelformat_ARGB4444) || ((Pixelformat) == LTDC_Pixelformat_L8)       || \
                        ((Pixelformat) == LTDC_Pixelformat_AL44)     || ((Pixelformat) == LTDC_Pixelformat_AL88))

/**
  * @}
  */
      
/** @defgroup LTDC_BlendingFactor1 
  * @{
  */

#define LTDC_BlendingFactor1_CA                       ((uint32_t)0x00000400)
#define LTDC_BlendingFactor1_PAxCA                    ((uint32_t)0x00000600)

#define IS_LTDC_BlendingFactor1(BlendingFactor1) (((BlendingFactor1) == LTDC_BlendingFactor1_CA) || ((BlendingFactor1) == LTDC_BlendingFactor1_PAxCA))

/**
  * @}
  */
      
/** @defgroup LTDC_BlendingFactor2
  * @{
  */

#define LTDC_BlendingFactor2_CA                       ((uint32_t)0x00000005)
#define LTDC_BlendingFactor2_PAxCA                    ((uint32_t)0x00000007)

#define IS_LTDC_BlendingFactor2(BlendingFactor2) (((BlendingFactor2) == LTDC_BlendingFactor2_CA) || ((BlendingFactor2) == LTDC_BlendingFactor2_PAxCA))


/**
  * @}
  */
      
     
/** @defgroup LTDC_LAYER_Config
  * @{
  */

#define LTDC_STOPPosition                 ((uint32_t)0x0000FFFF)
#define LTDC_STARTPosition                ((uint32_t)0x00000FFF)

#define LTDC_DefaultColorConfig           ((uint32_t)0x000000FF)
#define LTDC_ColorFrameBuffer             ((uint32_t)0x00001FFF)
#define LTDC_LineNumber                   ((uint32_t)0x000007FF)

#define IS_LTDC_HCONFIGST(HCONFIGST) ((HCONFIGST) <= LTDC_STARTPosition)
#define IS_LTDC_HCONFIGSP(HCONFIGSP) ((HCONFIGSP) <= LTDC_STOPPosition)
#define IS_LTDC_VCONFIGST(VCONFIGST)  ((VCONFIGST) <= LTDC_STARTPosition)
#define IS_LTDC_VCONFIGSP(VCONFIGSP) ((VCONFIGSP) <= LTDC_STOPPosition)

#define IS_LTDC_DEFAULTCOLOR(DEFAULTCOLOR) ((DEFAULTCOLOR) <= LTDC_DefaultColorConfig)

#define IS_LTDC_CFBP(CFBP) ((CFBP) <= LTDC_ColorFrameBuffer)
#define IS_LTDC_CFBLL(CFBLL) ((CFBLL) <= LTDC_ColorFrameBuffer)

#define IS_LTDC_CFBLNBR(CFBLNBR) ((CFBLNBR) <= LTDC_LineNumber)



/**
  * @}
  */
          
/** @defgroup LTDC_colorkeying_Config
  * @{
  */

#define LTDC_colorkeyingConfig            ((uint32_t)0x000000FF)

#define IS_LTDC_CKEYING(CKEYING) ((CKEYING) <= LTDC_colorkeyingConfig)


/**
  * @}
  */
          
/** @defgroup LTDC_CLUT_Config
  * @{
  */

#define LTDC_CLUTWR                       ((uint32_t)0x000000FF)

#define IS_LTDC_CLUTWR(CLUTWR)  ((CLUTWR) <= LTDC_CLUTWR)

/* Exported macro ------------------------------------------------------------*/
/* Exported functions ------------------------------------------------------- */

/*  Function used to set the LTDC configuration to the default reset state *****/
void LTDC_DeInit(void);

/* Initialization and Configuration functions *********************************/
void LTDC_Init(LTDC_InitTypeDef* LTDC_InitStruct);
void LTDC_StructInit(LTDC_InitTypeDef* LTDC_InitStruct);
void LTDC_Cmd(FunctionalState NewState);
void LTDC_DitherCmd(FunctionalState NewState);
LTDC_RGBTypeDef LTDC_GetRGBWidth(void);
void LTDC_RGBStructInit(LTDC_RGBTypeDef* LTDC_RGB_InitStruct);
void LTDC_LIPConfig(uint32_t LTDC_LIPositionConfig);
void LTDC_ReloadConfig(uint32_t LTDC_Reload);
void LTDC_LayerInit(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_Layer_InitTypeDef* LTDC_Layer_InitStruct);
void LTDC_LayerStructInit(LTDC_Layer_InitTypeDef * LTDC_Layer_InitStruct);
void LTDC_LayerCmd(LTDC_Layer_TypeDef* LTDC_Layerx, FunctionalState NewState);
LTDC_PosTypeDef LTDC_GetPosStatus(void);
void LTDC_PosStructInit(LTDC_PosTypeDef* LTDC_Pos_InitStruct);
FlagStatus LTDC_GetCDStatus(uint32_t LTDC_CD);
void LTDC_ColorKeyingConfig(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_ColorKeying_InitTypeDef* LTDC_colorkeying_InitStruct, FunctionalState NewState);
void LTDC_ColorKeyingStructInit(LTDC_ColorKeying_InitTypeDef* LTDC_colorkeying_InitStruct);
void LTDC_CLUTCmd(LTDC_Layer_TypeDef* LTDC_Layerx, FunctionalState NewState);
void LTDC_CLUTInit(LTDC_Layer_TypeDef* LTDC_Layerx, LTDC_CLUT_InitTypeDef* LTDC_CLUT_InitStruct);
void LTDC_CLUTStructInit(LTDC_CLUT_InitTypeDef* LTDC_CLUT_InitStruct);
void LTDC_LayerPosition(LTDC_Layer_TypeDef* LTDC_Layerx, uint16_t OffsetX, uint16_t OffsetY);
void LTDC_LayerAlpha(LTDC_Layer_TypeDef* LTDC_Layerx, uint8_t ConstantAlpha);
void LTDC_LayerAddress(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t Address);
void LTDC_LayerSize(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t Width, uint32_t Height);
void LTDC_LayerPixelFormat(LTDC_Layer_TypeDef* LTDC_Layerx, uint32_t PixelFormat);

/* Interrupts and flags management functions **********************************/
void LTDC_ITConfig(uint32_t LTDC_IT, FunctionalState NewState);
FlagStatus LTDC_GetFlagStatus(uint32_t LTDC_FLAG);
void LTDC_ClearFlag(uint32_t LTDC_FLAG);
ITStatus LTDC_GetITStatus(uint32_t LTDC_IT);
void LTDC_ClearITPendingBit(uint32_t LTDC_IT);

#endif

#ifdef __cplusplus
}
#endif


/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_ltdc.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_usart.h
/**
  ******************************************************************************
  * @file    stm32f4xx_usart.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the USART 
  *          firmware library.    
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************  
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_USART_H
#define __STM32F4xx_USART_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup USART
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/ 

/** 
  * @brief  USART Init Structure definition  
  */ 
  
typedef struct
{
  uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate.
                                           The baud rate is computed using the following formula:
                                            - IntegerDivider = ((PCLKx) / (8 * (OVR8+1) * (USART_InitStruct->USART_BaudRate)))
                                            - FractionalDivider = ((IntegerDivider - ((u32) IntegerDivider)) * 8 * (OVR8+1)) + 0.5 
                                           Where OVR8 is the "oversampling by 8 mode" configuration bit in the CR1 register. */

  uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or received in a frame.
                                           This parameter can be a value of @ref USART_Word_Length */

  uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
                                           This parameter can be a value of @ref USART_Stop_Bits */

  uint16_t USART_Parity;              /*!< Specifies the parity mode.
                                           This parameter can be a value of @ref USART_Parity
                                           @note When parity is enabled, the computed parity is inserted
                                                 at the MSB position of the transmitted data (9th bit when
                                                 the word length is set to 9 data bits; 8th bit when the
                                                 word length is set to 8 data bits). */
 
  uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled or disabled.
                                           This parameter can be a value of @ref USART_Mode */

  uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled
                                           or disabled.
                                           This parameter can be a value of @ref USART_Hardware_Flow_Control */
} USART_InitTypeDef;

/** 
  * @brief  USART Clock Init Structure definition  
  */ 
  
typedef struct
{

  uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
                               This parameter can be a value of @ref USART_Clock */

  uint16_t USART_CPOL;    /*!< Specifies the steady state of the serial clock.
                               This parameter can be a value of @ref USART_Clock_Polarity */

  uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
                               This parameter can be a value of @ref USART_Clock_Phase */

  uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted
                               data bit (MSB) has to be output on the SCLK pin in synchronous mode.
                               This parameter can be a value of @ref USART_Last_Bit */
} USART_ClockInitTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup USART_Exported_Constants
  * @{
  */ 
  
#define IS_USART_ALL_PERIPH(PERIPH) (((PERIPH) == USART1) || \
                                     ((PERIPH) == USART2) || \
                                     ((PERIPH) == USART3) || \
                                     ((PERIPH) == UART4)  || \
                                     ((PERIPH) == UART5)  || \
                                     ((PERIPH) == USART6) || \
                                     ((PERIPH) == UART7)  || \
                                     ((PERIPH) == UART8))

#define IS_USART_1236_PERIPH(PERIPH) (((PERIPH) == USART1) || \
                                      ((PERIPH) == USART2) || \
                                      ((PERIPH) == USART3) || \
                                      ((PERIPH) == USART6))

/** @defgroup USART_Word_Length 
  * @{
  */ 
  
#define USART_WordLength_8b                  ((uint16_t)0x0000)
#define USART_WordLength_9b                  ((uint16_t)0x1000)
                                    
#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
                                      ((LENGTH) == USART_WordLength_9b))
/**
  * @}
  */ 

/** @defgroup USART_Stop_Bits 
  * @{
  */ 
  
#define USART_StopBits_1                     ((uint16_t)0x0000)
#define USART_StopBits_0_5                   ((uint16_t)0x1000)
#define USART_StopBits_2                     ((uint16_t)0x2000)
#define USART_StopBits_1_5                   ((uint16_t)0x3000)
#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
                                     ((STOPBITS) == USART_StopBits_0_5) || \
                                     ((STOPBITS) == USART_StopBits_2) || \
                                     ((STOPBITS) == USART_StopBits_1_5))
/**
  * @}
  */ 

/** @defgroup USART_Parity 
  * @{
  */ 
  
#define USART_Parity_No                      ((uint16_t)0x0000)
#define USART_Parity_Even                    ((uint16_t)0x0400)
#define USART_Parity_Odd                     ((uint16_t)0x0600) 
#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
                                 ((PARITY) == USART_Parity_Even) || \
                                 ((PARITY) == USART_Parity_Odd))
/**
  * @}
  */ 

/** @defgroup USART_Mode 
  * @{
  */ 
  
#define USART_Mode_Rx                        ((uint16_t)0x0004)
#define USART_Mode_Tx                        ((uint16_t)0x0008)
#define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
/**
  * @}
  */ 

/** @defgroup USART_Hardware_Flow_Control 
  * @{
  */ 
#define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
#define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
#define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
#define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
                              (((CONTROL) == USART_HardwareFlowControl_None) || \
                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
/**
  * @}
  */ 

/** @defgroup USART_Clock 
  * @{
  */ 
#define USART_Clock_Disable                  ((uint16_t)0x0000)
#define USART_Clock_Enable                   ((uint16_t)0x0800)
#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
                               ((CLOCK) == USART_Clock_Enable))
/**
  * @}
  */ 

/** @defgroup USART_Clock_Polarity 
  * @{
  */
  
#define USART_CPOL_Low                       ((uint16_t)0x0000)
#define USART_CPOL_High                      ((uint16_t)0x0400)
#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))

/**
  * @}
  */ 

/** @defgroup USART_Clock_Phase
  * @{
  */

#define USART_CPHA_1Edge                     ((uint16_t)0x0000)
#define USART_CPHA_2Edge                     ((uint16_t)0x0200)
#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))

/**
  * @}
  */

/** @defgroup USART_Last_Bit
  * @{
  */

#define USART_LastBit_Disable                ((uint16_t)0x0000)
#define USART_LastBit_Enable                 ((uint16_t)0x0100)
#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
                                   ((LASTBIT) == USART_LastBit_Enable))
/**
  * @}
  */ 

/** @defgroup USART_Interrupt_definition 
  * @{
  */
  
#define USART_IT_PE                          ((uint16_t)0x0028)
#define USART_IT_TXE                         ((uint16_t)0x0727)
#define USART_IT_TC                          ((uint16_t)0x0626)
#define USART_IT_RXNE                        ((uint16_t)0x0525)
#define USART_IT_ORE_RX                      ((uint16_t)0x0325) /* In case interrupt is generated if the RXNEIE bit is set */
#define USART_IT_IDLE                        ((uint16_t)0x0424)
#define USART_IT_LBD                         ((uint16_t)0x0846)
#define USART_IT_CTS                         ((uint16_t)0x096A)
#define USART_IT_ERR                         ((uint16_t)0x0060)
#define USART_IT_ORE_ER                      ((uint16_t)0x0360) /* In case interrupt is generated if the EIE bit is set */
#define USART_IT_NE                          ((uint16_t)0x0260)
#define USART_IT_FE                          ((uint16_t)0x0160)

/** @defgroup USART_Legacy 
  * @{
  */
#define USART_IT_ORE                          USART_IT_ORE_ER               
/**
  * @}
  */

#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
                                ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
                                ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
                                ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
#define IS_USART_GET_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
                             ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
                             ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
                             ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
                             ((IT) == USART_IT_ORE_RX) || ((IT) == USART_IT_ORE_ER) || \
                             ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS))
/**
  * @}
  */

/** @defgroup USART_DMA_Requests 
  * @{
  */

#define USART_DMAReq_Tx                      ((uint16_t)0x0080)
#define USART_DMAReq_Rx                      ((uint16_t)0x0040)
#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFF3F) == 0x00) && ((DMAREQ) != (uint16_t)0x00))

/**
  * @}
  */ 

/** @defgroup USART_WakeUp_methods
  * @{
  */

#define USART_WakeUp_IdleLine                ((uint16_t)0x0000)
#define USART_WakeUp_AddressMark             ((uint16_t)0x0800)
#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
                                 ((WAKEUP) == USART_WakeUp_AddressMark))
/**
  * @}
  */

/** @defgroup USART_LIN_Break_Detection_Length 
  * @{
  */
  
#define USART_LINBreakDetectLength_10b      ((uint16_t)0x0000)
#define USART_LINBreakDetectLength_11b      ((uint16_t)0x0020)
#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \
                                ((LENGTH) == USART_LINBreakDetectLength_11b))
/**
  * @}
  */

/** @defgroup USART_IrDA_Low_Power 
  * @{
  */

#define USART_IrDAMode_LowPower              ((uint16_t)0x0004)
#define USART_IrDAMode_Normal                ((uint16_t)0x0000)
#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
                                  ((MODE) == USART_IrDAMode_Normal))
/**
  * @}
  */ 

/** @defgroup USART_Flags 
  * @{
  */

#define USART_FLAG_CTS                       ((uint16_t)0x0200)
#define USART_FLAG_LBD                       ((uint16_t)0x0100)
#define USART_FLAG_TXE                       ((uint16_t)0x0080)
#define USART_FLAG_TC                        ((uint16_t)0x0040)
#define USART_FLAG_RXNE                      ((uint16_t)0x0020)
#define USART_FLAG_IDLE                      ((uint16_t)0x0010)
#define USART_FLAG_ORE                       ((uint16_t)0x0008)
#define USART_FLAG_NE                        ((uint16_t)0x0004)
#define USART_FLAG_FE                        ((uint16_t)0x0002)
#define USART_FLAG_PE                        ((uint16_t)0x0001)
#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
                              
#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFC9F) == 0x00) && ((FLAG) != (uint16_t)0x00))

#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 7500001))
#define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) <= 0xF)
#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)

/**
  * @}
  */ 

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/  

/*  Function used to set the USART configuration to the default reset state ***/ 
void USART_DeInit(USART_TypeDef* USARTx);

/* Initialization and Configuration functions *********************************/
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
void USART_StructInit(USART_InitTypeDef* USART_InitStruct);
void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler);
void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState);

/* Data transfers functions ***************************************************/ 
void USART_SendData(USART_TypeDef* USARTx, uint16_t Data);
uint16_t USART_ReceiveData(USART_TypeDef* USARTx);

/* Multi-Processor Communication functions ************************************/
void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address);
void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp);
void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);

/* LIN mode functions *********************************************************/
void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength);
void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
void USART_SendBreak(USART_TypeDef* USARTx);

/* Half-duplex mode function **************************************************/
void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);

/* Smartcard mode functions ***************************************************/
void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime);

/* IrDA mode functions ********************************************************/
void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode);
void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);

/* DMA transfers management functions *****************************************/
void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);

/* Interrupts and flags management functions **********************************/
void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_USART_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_usart.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_dac.h
/**
  ******************************************************************************
  * @file    stm32f4xx_dac.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the DAC firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_DAC_H
#define __STM32F4xx_DAC_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup DAC
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief  DAC Init structure definition
  */

typedef struct
{
  uint32_t DAC_Trigger;                      /*!< Specifies the external trigger for the selected DAC channel.
                                                  This parameter can be a value of @ref DAC_trigger_selection */

  uint32_t DAC_WaveGeneration;               /*!< Specifies whether DAC channel noise waves or triangle waves
                                                  are generated, or whether no wave is generated.
                                                  This parameter can be a value of @ref DAC_wave_generation */

  uint32_t DAC_LFSRUnmask_TriangleAmplitude; /*!< Specifies the LFSR mask for noise wave generation or
                                                  the maximum amplitude triangle generation for the DAC channel. 
                                                  This parameter can be a value of @ref DAC_lfsrunmask_triangleamplitude */

  uint32_t DAC_OutputBuffer;                 /*!< Specifies whether the DAC channel output buffer is enabled or disabled.
                                                  This parameter can be a value of @ref DAC_output_buffer */
}DAC_InitTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup DAC_Exported_Constants
  * @{
  */

/** @defgroup DAC_trigger_selection 
  * @{
  */

#define DAC_Trigger_None                   ((uint32_t)0x00000000) /*!< Conversion is automatic once the DAC1_DHRxxxx register 
                                                                       has been loaded, and not by external trigger */
#define DAC_Trigger_T2_TRGO                ((uint32_t)0x00000024) /*!< TIM2 TRGO selected as external conversion trigger for DAC channel */
#define DAC_Trigger_T4_TRGO                ((uint32_t)0x0000002C) /*!< TIM4 TRGO selected as external conversion trigger for DAC channel */
#define DAC_Trigger_T5_TRGO                ((uint32_t)0x0000001C) /*!< TIM5 TRGO selected as external conversion trigger for DAC channel */
#define DAC_Trigger_T6_TRGO                ((uint32_t)0x00000004) /*!< TIM6 TRGO selected as external conversion trigger for DAC channel */
#define DAC_Trigger_T7_TRGO                ((uint32_t)0x00000014) /*!< TIM7 TRGO selected as external conversion trigger for DAC channel */
#define DAC_Trigger_T8_TRGO                ((uint32_t)0x0000000C) /*!< TIM8 TRGO selected as external conversion trigger for DAC channel */                                                                       

#define DAC_Trigger_Ext_IT9                ((uint32_t)0x00000034) /*!< EXTI Line9 event selected as external conversion trigger for DAC channel */
#define DAC_Trigger_Software               ((uint32_t)0x0000003C) /*!< Conversion started by software trigger for DAC channel */

#define IS_DAC_TRIGGER(TRIGGER) (((TRIGGER) == DAC_Trigger_None) || \
                                 ((TRIGGER) == DAC_Trigger_T6_TRGO) || \
                                 ((TRIGGER) == DAC_Trigger_T8_TRGO) || \
                                 ((TRIGGER) == DAC_Trigger_T7_TRGO) || \
                                 ((TRIGGER) == DAC_Trigger_T5_TRGO) || \
                                 ((TRIGGER) == DAC_Trigger_T2_TRGO) || \
                                 ((TRIGGER) == DAC_Trigger_T4_TRGO) || \
                                 ((TRIGGER) == DAC_Trigger_Ext_IT9) || \
                                 ((TRIGGER) == DAC_Trigger_Software))

/**
  * @}
  */

/** @defgroup DAC_wave_generation 
  * @{
  */

#define DAC_WaveGeneration_None            ((uint32_t)0x00000000)
#define DAC_WaveGeneration_Noise           ((uint32_t)0x00000040)
#define DAC_WaveGeneration_Triangle        ((uint32_t)0x00000080)
#define IS_DAC_GENERATE_WAVE(WAVE) (((WAVE) == DAC_WaveGeneration_None) || \
                                    ((WAVE) == DAC_WaveGeneration_Noise) || \
                                    ((WAVE) == DAC_WaveGeneration_Triangle))
/**
  * @}
  */

/** @defgroup DAC_lfsrunmask_triangleamplitude
  * @{
  */

#define DAC_LFSRUnmask_Bit0                ((uint32_t)0x00000000) /*!< Unmask DAC channel LFSR bit0 for noise wave generation */
#define DAC_LFSRUnmask_Bits1_0             ((uint32_t)0x00000100) /*!< Unmask DAC channel LFSR bit[1:0] for noise wave generation */
#define DAC_LFSRUnmask_Bits2_0             ((uint32_t)0x00000200) /*!< Unmask DAC channel LFSR bit[2:0] for noise wave generation */
#define DAC_LFSRUnmask_Bits3_0             ((uint32_t)0x00000300) /*!< Unmask DAC channel LFSR bit[3:0] for noise wave generation */
#define DAC_LFSRUnmask_Bits4_0             ((uint32_t)0x00000400) /*!< Unmask DAC channel LFSR bit[4:0] for noise wave generation */
#define DAC_LFSRUnmask_Bits5_0             ((uint32_t)0x00000500) /*!< Unmask DAC channel LFSR bit[5:0] for noise wave generation */
#define DAC_LFSRUnmask_Bits6_0             ((uint32_t)0x00000600) /*!< Unmask DAC channel LFSR bit[6:0] for noise wave generation */
#define DAC_LFSRUnmask_Bits7_0             ((uint32_t)0x00000700) /*!< Unmask DAC channel LFSR bit[7:0] for noise wave generation */
#define DAC_LFSRUnmask_Bits8_0             ((uint32_t)0x00000800) /*!< Unmask DAC channel LFSR bit[8:0] for noise wave generation */
#define DAC_LFSRUnmask_Bits9_0             ((uint32_t)0x00000900) /*!< Unmask DAC channel LFSR bit[9:0] for noise wave generation */
#define DAC_LFSRUnmask_Bits10_0            ((uint32_t)0x00000A00) /*!< Unmask DAC channel LFSR bit[10:0] for noise wave generation */
#define DAC_LFSRUnmask_Bits11_0            ((uint32_t)0x00000B00) /*!< Unmask DAC channel LFSR bit[11:0] for noise wave generation */
#define DAC_TriangleAmplitude_1            ((uint32_t)0x00000000) /*!< Select max triangle amplitude of 1 */
#define DAC_TriangleAmplitude_3            ((uint32_t)0x00000100) /*!< Select max triangle amplitude of 3 */
#define DAC_TriangleAmplitude_7            ((uint32_t)0x00000200) /*!< Select max triangle amplitude of 7 */
#define DAC_TriangleAmplitude_15           ((uint32_t)0x00000300) /*!< Select max triangle amplitude of 15 */
#define DAC_TriangleAmplitude_31           ((uint32_t)0x00000400) /*!< Select max triangle amplitude of 31 */
#define DAC_TriangleAmplitude_63           ((uint32_t)0x00000500) /*!< Select max triangle amplitude of 63 */
#define DAC_TriangleAmplitude_127          ((uint32_t)0x00000600) /*!< Select max triangle amplitude of 127 */
#define DAC_TriangleAmplitude_255          ((uint32_t)0x00000700) /*!< Select max triangle amplitude of 255 */
#define DAC_TriangleAmplitude_511          ((uint32_t)0x00000800) /*!< Select max triangle amplitude of 511 */
#define DAC_TriangleAmplitude_1023         ((uint32_t)0x00000900) /*!< Select max triangle amplitude of 1023 */
#define DAC_TriangleAmplitude_2047         ((uint32_t)0x00000A00) /*!< Select max triangle amplitude of 2047 */
#define DAC_TriangleAmplitude_4095         ((uint32_t)0x00000B00) /*!< Select max triangle amplitude of 4095 */

#define IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(VALUE) (((VALUE) == DAC_LFSRUnmask_Bit0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits1_0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits2_0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits3_0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits4_0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits5_0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits6_0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits7_0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits8_0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits9_0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits10_0) || \
                                                      ((VALUE) == DAC_LFSRUnmask_Bits11_0) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_1) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_3) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_7) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_15) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_31) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_63) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_127) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_255) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_511) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_1023) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_2047) || \
                                                      ((VALUE) == DAC_TriangleAmplitude_4095))
/**
  * @}
  */

/** @defgroup DAC_output_buffer 
  * @{
  */

#define DAC_OutputBuffer_Enable            ((uint32_t)0x00000000)
#define DAC_OutputBuffer_Disable           ((uint32_t)0x00000002)
#define IS_DAC_OUTPUT_BUFFER_STATE(STATE) (((STATE) == DAC_OutputBuffer_Enable) || \
                                           ((STATE) == DAC_OutputBuffer_Disable))
/**
  * @}
  */

/** @defgroup DAC_Channel_selection 
  * @{
  */

#define DAC_Channel_1                      ((uint32_t)0x00000000)
#define DAC_Channel_2                      ((uint32_t)0x00000010)
#define IS_DAC_CHANNEL(CHANNEL) (((CHANNEL) == DAC_Channel_1) || \
                                 ((CHANNEL) == DAC_Channel_2))
/**
  * @}
  */

/** @defgroup DAC_data_alignement 
  * @{
  */

#define DAC_Align_12b_R                    ((uint32_t)0x00000000)
#define DAC_Align_12b_L                    ((uint32_t)0x00000004)
#define DAC_Align_8b_R                     ((uint32_t)0x00000008)
#define IS_DAC_ALIGN(ALIGN) (((ALIGN) == DAC_Align_12b_R) || \
                             ((ALIGN) == DAC_Align_12b_L) || \
                             ((ALIGN) == DAC_Align_8b_R))
/**
  * @}
  */

/** @defgroup DAC_wave_generation 
  * @{
  */

#define DAC_Wave_Noise                     ((uint32_t)0x00000040)
#define DAC_Wave_Triangle                  ((uint32_t)0x00000080)
#define IS_DAC_WAVE(WAVE) (((WAVE) == DAC_Wave_Noise) || \
                           ((WAVE) == DAC_Wave_Triangle))
/**
  * @}
  */

/** @defgroup DAC_data 
  * @{
  */

#define IS_DAC_DATA(DATA) ((DATA) <= 0xFFF0) 
/**
  * @}
  */
  
/** @defgroup DAC_interrupts_definition 
  * @{
  */   
#define DAC_IT_DMAUDR                      ((uint32_t)0x00002000)  
#define IS_DAC_IT(IT) (((IT) == DAC_IT_DMAUDR)) 

/**
  * @}
  */ 

/** @defgroup DAC_flags_definition 
  * @{
  */ 
  
#define DAC_FLAG_DMAUDR                    ((uint32_t)0x00002000)  
#define IS_DAC_FLAG(FLAG) (((FLAG) == DAC_FLAG_DMAUDR))  

/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/  

/*  Function used to set the DAC configuration to the default reset state *****/  
void DAC_DeInit(void);

/*  DAC channels configuration: trigger, output buffer, data format functions */
void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct);
void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct);
void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState);
void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState);
void DAC_DualSoftwareTriggerCmd(FunctionalState NewState);
void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState);
void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data);
void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data);
void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1);
uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel);

/* DMA management functions ***************************************************/
void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState);

/* Interrupts and flags management functions **********************************/
void DAC_ITConfig(uint32_t DAC_Channel, uint32_t DAC_IT, FunctionalState NewState);
FlagStatus DAC_GetFlagStatus(uint32_t DAC_Channel, uint32_t DAC_FLAG);
void DAC_ClearFlag(uint32_t DAC_Channel, uint32_t DAC_FLAG);
ITStatus DAC_GetITStatus(uint32_t DAC_Channel, uint32_t DAC_IT);
void DAC_ClearITPendingBit(uint32_t DAC_Channel, uint32_t DAC_IT);

#ifdef __cplusplus
}
#endif

#endif /*__STM32F4xx_DAC_H */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_dac.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_spi.h
/**
  ******************************************************************************
  * @file    stm32f4xx_spi.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the SPI 
  *          firmware library. 
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************  
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_SPI_H
#define __STM32F4xx_SPI_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup SPI
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief  SPI Init structure definition  
  */

typedef struct
{
  uint16_t SPI_Direction;           /*!< Specifies the SPI unidirectional or bidirectional data mode.
                                         This parameter can be a value of @ref SPI_data_direction */

  uint16_t SPI_Mode;                /*!< Specifies the SPI operating mode.
                                         This parameter can be a value of @ref SPI_mode */

  uint16_t SPI_DataSize;            /*!< Specifies the SPI data size.
                                         This parameter can be a value of @ref SPI_data_size */

  uint16_t SPI_CPOL;                /*!< Specifies the serial clock steady state.
                                         This parameter can be a value of @ref SPI_Clock_Polarity */

  uint16_t SPI_CPHA;                /*!< Specifies the clock active edge for the bit capture.
                                         This parameter can be a value of @ref SPI_Clock_Phase */

  uint16_t SPI_NSS;                 /*!< Specifies whether the NSS signal is managed by
                                         hardware (NSS pin) or by software using the SSI bit.
                                         This parameter can be a value of @ref SPI_Slave_Select_management */
 
  uint16_t SPI_BaudRatePrescaler;   /*!< Specifies the Baud Rate prescaler value which will be
                                         used to configure the transmit and receive SCK clock.
                                         This parameter can be a value of @ref SPI_BaudRate_Prescaler
                                         @note The communication clock is derived from the master
                                               clock. The slave clock does not need to be set. */

  uint16_t SPI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
                                         This parameter can be a value of @ref SPI_MSB_LSB_transmission */

  uint16_t SPI_CRCPolynomial;       /*!< Specifies the polynomial used for the CRC calculation. */
}SPI_InitTypeDef;

/** 
  * @brief  I2S Init structure definition  
  */

typedef struct
{

  uint16_t I2S_Mode;         /*!< Specifies the I2S operating mode.
                                  This parameter can be a value of @ref I2S_Mode */

  uint16_t I2S_Standard;     /*!< Specifies the standard used for the I2S communication.
                                  This parameter can be a value of @ref I2S_Standard */

  uint16_t I2S_DataFormat;   /*!< Specifies the data format for the I2S communication.
                                  This parameter can be a value of @ref I2S_Data_Format */

  uint16_t I2S_MCLKOutput;   /*!< Specifies whether the I2S MCLK output is enabled or not.
                                  This parameter can be a value of @ref I2S_MCLK_Output */

  uint32_t I2S_AudioFreq;    /*!< Specifies the frequency selected for the I2S communication.
                                  This parameter can be a value of @ref I2S_Audio_Frequency */

  uint16_t I2S_CPOL;         /*!< Specifies the idle state of the I2S clock.
                                  This parameter can be a value of @ref I2S_Clock_Polarity */
}I2S_InitTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup SPI_Exported_Constants
  * @{
  */

#define IS_SPI_ALL_PERIPH(PERIPH) (((PERIPH) == SPI1) || \
                                   ((PERIPH) == SPI2) || \
                                   ((PERIPH) == SPI3) || \
                                   ((PERIPH) == SPI4) || \
                                   ((PERIPH) == SPI5) || \
                                   ((PERIPH) == SPI6))

#define IS_SPI_ALL_PERIPH_EXT(PERIPH) (((PERIPH) == SPI1)    || \
                                       ((PERIPH) == SPI2)    || \
                                       ((PERIPH) == SPI3)    || \
                                       ((PERIPH) == SPI4)    || \
                                       ((PERIPH) == SPI5)    || \
                                       ((PERIPH) == SPI6)    || \
                                       ((PERIPH) == I2S2ext) || \
                                       ((PERIPH) == I2S3ext))

#define IS_SPI_23_PERIPH(PERIPH)  (((PERIPH) == SPI2) || \
                                   ((PERIPH) == SPI3))

#define IS_SPI_23_PERIPH_EXT(PERIPH)  (((PERIPH) == SPI2)    || \
                                       ((PERIPH) == SPI3)    || \
                                       ((PERIPH) == I2S2ext) || \
                                       ((PERIPH) == I2S3ext))

#define IS_I2S_EXT_PERIPH(PERIPH)  (((PERIPH) == I2S2ext) || \
                                    ((PERIPH) == I2S3ext))


/** @defgroup SPI_data_direction 
  * @{
  */
  
#define SPI_Direction_2Lines_FullDuplex ((uint16_t)0x0000)
#define SPI_Direction_2Lines_RxOnly     ((uint16_t)0x0400)
#define SPI_Direction_1Line_Rx          ((uint16_t)0x8000)
#define SPI_Direction_1Line_Tx          ((uint16_t)0xC000)
#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
                                     ((MODE) == SPI_Direction_1Line_Rx) || \
                                     ((MODE) == SPI_Direction_1Line_Tx))
/**
  * @}
  */

/** @defgroup SPI_mode 
  * @{
  */

#define SPI_Mode_Master                 ((uint16_t)0x0104)
#define SPI_Mode_Slave                  ((uint16_t)0x0000)
#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
                           ((MODE) == SPI_Mode_Slave))
/**
  * @}
  */

/** @defgroup SPI_data_size 
  * @{
  */

#define SPI_DataSize_16b                ((uint16_t)0x0800)
#define SPI_DataSize_8b                 ((uint16_t)0x0000)
#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
                                   ((DATASIZE) == SPI_DataSize_8b))
/**
  * @}
  */ 

/** @defgroup SPI_Clock_Polarity 
  * @{
  */

#define SPI_CPOL_Low                    ((uint16_t)0x0000)
#define SPI_CPOL_High                   ((uint16_t)0x0002)
#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
                           ((CPOL) == SPI_CPOL_High))
/**
  * @}
  */

/** @defgroup SPI_Clock_Phase 
  * @{
  */

#define SPI_CPHA_1Edge                  ((uint16_t)0x0000)
#define SPI_CPHA_2Edge                  ((uint16_t)0x0001)
#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
                           ((CPHA) == SPI_CPHA_2Edge))
/**
  * @}
  */

/** @defgroup SPI_Slave_Select_management 
  * @{
  */

#define SPI_NSS_Soft                    ((uint16_t)0x0200)
#define SPI_NSS_Hard                    ((uint16_t)0x0000)
#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
                         ((NSS) == SPI_NSS_Hard))
/**
  * @}
  */ 

/** @defgroup SPI_BaudRate_Prescaler 
  * @{
  */

#define SPI_BaudRatePrescaler_2         ((uint16_t)0x0000)
#define SPI_BaudRatePrescaler_4         ((uint16_t)0x0008)
#define SPI_BaudRatePrescaler_8         ((uint16_t)0x0010)
#define SPI_BaudRatePrescaler_16        ((uint16_t)0x0018)
#define SPI_BaudRatePrescaler_32        ((uint16_t)0x0020)
#define SPI_BaudRatePrescaler_64        ((uint16_t)0x0028)
#define SPI_BaudRatePrescaler_128       ((uint16_t)0x0030)
#define SPI_BaudRatePrescaler_256       ((uint16_t)0x0038)
#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
/**
  * @}
  */ 

/** @defgroup SPI_MSB_LSB_transmission 
  * @{
  */

#define SPI_FirstBit_MSB                ((uint16_t)0x0000)
#define SPI_FirstBit_LSB                ((uint16_t)0x0080)
#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
                               ((BIT) == SPI_FirstBit_LSB))
/**
  * @}
  */

/** @defgroup SPI_I2S_Mode 
  * @{
  */

#define I2S_Mode_SlaveTx                ((uint16_t)0x0000)
#define I2S_Mode_SlaveRx                ((uint16_t)0x0100)
#define I2S_Mode_MasterTx               ((uint16_t)0x0200)
#define I2S_Mode_MasterRx               ((uint16_t)0x0300)
#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
                           ((MODE) == I2S_Mode_SlaveRx) || \
                           ((MODE) == I2S_Mode_MasterTx)|| \
                           ((MODE) == I2S_Mode_MasterRx))
/**
  * @}
  */
  

/** @defgroup SPI_I2S_Standard 
  * @{
  */

#define I2S_Standard_Phillips           ((uint16_t)0x0000)
#define I2S_Standard_MSB                ((uint16_t)0x0010)
#define I2S_Standard_LSB                ((uint16_t)0x0020)
#define I2S_Standard_PCMShort           ((uint16_t)0x0030)
#define I2S_Standard_PCMLong            ((uint16_t)0x00B0)
#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
                                   ((STANDARD) == I2S_Standard_MSB) || \
                                   ((STANDARD) == I2S_Standard_LSB) || \
                                   ((STANDARD) == I2S_Standard_PCMShort) || \
                                   ((STANDARD) == I2S_Standard_PCMLong))
/**
  * @}
  */
  
/** @defgroup SPI_I2S_Data_Format 
  * @{
  */

#define I2S_DataFormat_16b              ((uint16_t)0x0000)
#define I2S_DataFormat_16bextended      ((uint16_t)0x0001)
#define I2S_DataFormat_24b              ((uint16_t)0x0003)
#define I2S_DataFormat_32b              ((uint16_t)0x0005)
#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
                                    ((FORMAT) == I2S_DataFormat_24b) || \
                                    ((FORMAT) == I2S_DataFormat_32b))
/**
  * @}
  */

/** @defgroup SPI_I2S_MCLK_Output 
  * @{
  */

#define I2S_MCLKOutput_Enable           ((uint16_t)0x0200)
#define I2S_MCLKOutput_Disable          ((uint16_t)0x0000)
#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
/**
  * @}
  */

/** @defgroup SPI_I2S_Audio_Frequency 
  * @{
  */

#define I2S_AudioFreq_192k               ((uint32_t)192000)
#define I2S_AudioFreq_96k                ((uint32_t)96000)
#define I2S_AudioFreq_48k                ((uint32_t)48000)
#define I2S_AudioFreq_44k                ((uint32_t)44100)
#define I2S_AudioFreq_32k                ((uint32_t)32000)
#define I2S_AudioFreq_22k                ((uint32_t)22050)
#define I2S_AudioFreq_16k                ((uint32_t)16000)
#define I2S_AudioFreq_11k                ((uint32_t)11025)
#define I2S_AudioFreq_8k                 ((uint32_t)8000)
#define I2S_AudioFreq_Default            ((uint32_t)2)

#define IS_I2S_AUDIO_FREQ(FREQ) ((((FREQ) >= I2S_AudioFreq_8k) && \
                                 ((FREQ) <= I2S_AudioFreq_192k)) || \
                                 ((FREQ) == I2S_AudioFreq_Default))
/**
  * @}
  */
            
/** @defgroup SPI_I2S_Clock_Polarity 
  * @{
  */

#define I2S_CPOL_Low                    ((uint16_t)0x0000)
#define I2S_CPOL_High                   ((uint16_t)0x0008)
#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
                           ((CPOL) == I2S_CPOL_High))
/**
  * @}
  */

/** @defgroup SPI_I2S_DMA_transfer_requests 
  * @{
  */

#define SPI_I2S_DMAReq_Tx               ((uint16_t)0x0002)
#define SPI_I2S_DMAReq_Rx               ((uint16_t)0x0001)
#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (uint16_t)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
/**
  * @}
  */

/** @defgroup SPI_NSS_internal_software_management 
  * @{
  */

#define SPI_NSSInternalSoft_Set         ((uint16_t)0x0100)
#define SPI_NSSInternalSoft_Reset       ((uint16_t)0xFEFF)
#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
/**
  * @}
  */

/** @defgroup SPI_CRC_Transmit_Receive 
  * @{
  */

#define SPI_CRC_Tx                      ((uint8_t)0x00)
#define SPI_CRC_Rx                      ((uint8_t)0x01)
#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
/**
  * @}
  */

/** @defgroup SPI_direction_transmit_receive 
  * @{
  */

#define SPI_Direction_Rx                ((uint16_t)0xBFFF)
#define SPI_Direction_Tx                ((uint16_t)0x4000)
#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
                                     ((DIRECTION) == SPI_Direction_Tx))
/**
  * @}
  */

/** @defgroup SPI_I2S_interrupts_definition 
  * @{
  */

#define SPI_I2S_IT_TXE                  ((uint8_t)0x71)
#define SPI_I2S_IT_RXNE                 ((uint8_t)0x60)
#define SPI_I2S_IT_ERR                  ((uint8_t)0x50)
#define I2S_IT_UDR                      ((uint8_t)0x53)
#define SPI_I2S_IT_TIFRFE               ((uint8_t)0x58)

#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
                                  ((IT) == SPI_I2S_IT_RXNE) || \
                                  ((IT) == SPI_I2S_IT_ERR))

#define SPI_I2S_IT_OVR                  ((uint8_t)0x56)
#define SPI_IT_MODF                     ((uint8_t)0x55)
#define SPI_IT_CRCERR                   ((uint8_t)0x54)

#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_IT_CRCERR))

#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE)|| ((IT) == SPI_I2S_IT_TXE) || \
                               ((IT) == SPI_IT_CRCERR)  || ((IT) == SPI_IT_MODF) || \
                               ((IT) == SPI_I2S_IT_OVR) || ((IT) == I2S_IT_UDR) ||\
                               ((IT) == SPI_I2S_IT_TIFRFE))
/**
  * @}
  */

/** @defgroup SPI_I2S_flags_definition 
  * @{
  */

#define SPI_I2S_FLAG_RXNE               ((uint16_t)0x0001)
#define SPI_I2S_FLAG_TXE                ((uint16_t)0x0002)
#define I2S_FLAG_CHSIDE                 ((uint16_t)0x0004)
#define I2S_FLAG_UDR                    ((uint16_t)0x0008)
#define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
#define SPI_FLAG_MODF                   ((uint16_t)0x0020)
#define SPI_I2S_FLAG_OVR                ((uint16_t)0x0040)
#define SPI_I2S_FLAG_BSY                ((uint16_t)0x0080)
#define SPI_I2S_FLAG_TIFRFE             ((uint16_t)0x0100)

#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_FLAG_CRCERR))
#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
                                   ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \
                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE)|| \
                                   ((FLAG) == SPI_I2S_FLAG_TIFRFE))
/**
  * @}
  */

/** @defgroup SPI_CRC_polynomial 
  * @{
  */

#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
/**
  * @}
  */

/** @defgroup SPI_I2S_Legacy 
  * @{
  */

#define SPI_DMAReq_Tx                SPI_I2S_DMAReq_Tx
#define SPI_DMAReq_Rx                SPI_I2S_DMAReq_Rx
#define SPI_IT_TXE                   SPI_I2S_IT_TXE
#define SPI_IT_RXNE                  SPI_I2S_IT_RXNE
#define SPI_IT_ERR                   SPI_I2S_IT_ERR
#define SPI_IT_OVR                   SPI_I2S_IT_OVR
#define SPI_FLAG_RXNE                SPI_I2S_FLAG_RXNE
#define SPI_FLAG_TXE                 SPI_I2S_FLAG_TXE
#define SPI_FLAG_OVR                 SPI_I2S_FLAG_OVR
#define SPI_FLAG_BSY                 SPI_I2S_FLAG_BSY
#define SPI_DeInit                   SPI_I2S_DeInit
#define SPI_ITConfig                 SPI_I2S_ITConfig
#define SPI_DMACmd                   SPI_I2S_DMACmd
#define SPI_SendData                 SPI_I2S_SendData
#define SPI_ReceiveData              SPI_I2S_ReceiveData
#define SPI_GetFlagStatus            SPI_I2S_GetFlagStatus
#define SPI_ClearFlag                SPI_I2S_ClearFlag
#define SPI_GetITStatus              SPI_I2S_GetITStatus
#define SPI_ClearITPendingBit        SPI_I2S_ClearITPendingBit
/**
  * @}
  */
  
/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/*  Function used to set the SPI configuration to the default reset state *****/ 
void SPI_I2S_DeInit(SPI_TypeDef* SPIx);

/* Initialization and Configuration functions *********************************/
void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize);
void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction);
void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);

void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct);

/* Data transfers functions ***************************************************/ 
void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);
uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);

/* Hardware CRC Calculation functions *****************************************/
void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
void SPI_TransmitCRC(SPI_TypeDef* SPIx);
uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC);
uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);

/* DMA transfers management functions *****************************************/
void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);

/* Interrupts and flags management functions **********************************/
void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);

#ifdef __cplusplus
}
#endif

#endif /*__STM32F4xx_SPI_H */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_spi.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_pwr.h
/**
  ******************************************************************************
  * @file    stm32f4xx_pwr.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the PWR firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_PWR_H
#define __STM32F4xx_PWR_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup PWR
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/

/** @defgroup PWR_Exported_Constants
  * @{
  */ 

/** @defgroup PWR_PVD_detection_level 
  * @{
  */ 
#define PWR_PVDLevel_0                  PWR_CR_PLS_LEV0
#define PWR_PVDLevel_1                  PWR_CR_PLS_LEV1
#define PWR_PVDLevel_2                  PWR_CR_PLS_LEV2
#define PWR_PVDLevel_3                  PWR_CR_PLS_LEV3
#define PWR_PVDLevel_4                  PWR_CR_PLS_LEV4
#define PWR_PVDLevel_5                  PWR_CR_PLS_LEV5
#define PWR_PVDLevel_6                  PWR_CR_PLS_LEV6
#define PWR_PVDLevel_7                  PWR_CR_PLS_LEV7

#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_0) || ((LEVEL) == PWR_PVDLevel_1)|| \
                                 ((LEVEL) == PWR_PVDLevel_2) || ((LEVEL) == PWR_PVDLevel_3)|| \
                                 ((LEVEL) == PWR_PVDLevel_4) || ((LEVEL) == PWR_PVDLevel_5)|| \
                                 ((LEVEL) == PWR_PVDLevel_6) || ((LEVEL) == PWR_PVDLevel_7))
/**
  * @}
  */

  
/** @defgroup PWR_Regulator_state_in_STOP_mode 
  * @{
  */
#define PWR_MainRegulator_ON                        ((uint32_t)0x00000000)
#define PWR_LowPowerRegulator_ON                    PWR_CR_LPDS

/* --- PWR_Legacy ---*/
#define PWR_Regulator_ON                            PWR_MainRegulator_ON
#define PWR_Regulator_LowPower                      PWR_LowPowerRegulator_ON

#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_MainRegulator_ON) || \
                                     ((REGULATOR) == PWR_LowPowerRegulator_ON))

/**
  * @}
  */

/** @defgroup PWR_Regulator_state_in_UnderDrive_mode 
  * @{
  */
#define PWR_MainRegulator_UnderDrive_ON               PWR_CR_MRUDS
#define PWR_LowPowerRegulator_UnderDrive_ON           ((uint32_t)(PWR_CR_LPDS | PWR_CR_LPUDS))

#define IS_PWR_REGULATOR_UNDERDRIVE(REGULATOR) (((REGULATOR) == PWR_MainRegulator_UnderDrive_ON) || \
                                                ((REGULATOR) == PWR_LowPowerRegulator_UnderDrive_ON))

/**
  * @}
  */

/** @defgroup PWR_STOP_mode_entry 
  * @{
  */
#define PWR_STOPEntry_WFI               ((uint8_t)0x01)
#define PWR_STOPEntry_WFE               ((uint8_t)0x02)
#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
/**
  * @}
  */

/** @defgroup PWR_Regulator_Voltage_Scale 
  * @{
  */
#define PWR_Regulator_Voltage_Scale1    ((uint32_t)0x0000C000)
#define PWR_Regulator_Voltage_Scale2    ((uint32_t)0x00008000)
#define PWR_Regulator_Voltage_Scale3    ((uint32_t)0x00004000)
#define IS_PWR_REGULATOR_VOLTAGE(VOLTAGE) (((VOLTAGE) == PWR_Regulator_Voltage_Scale1) || \
                                           ((VOLTAGE) == PWR_Regulator_Voltage_Scale2) || \
                                           ((VOLTAGE) == PWR_Regulator_Voltage_Scale3))
/**
  * @}
  */

/** @defgroup PWR_Flag 
  * @{
  */
#define PWR_FLAG_WU                     PWR_CSR_WUF
#define PWR_FLAG_SB                     PWR_CSR_SBF
#define PWR_FLAG_PVDO                   PWR_CSR_PVDO
#define PWR_FLAG_BRR                    PWR_CSR_BRR
#define PWR_FLAG_VOSRDY                 PWR_CSR_VOSRDY
#define PWR_FLAG_ODRDY                  PWR_CSR_ODRDY
#define PWR_FLAG_ODSWRDY                PWR_CSR_ODSWRDY
#define PWR_FLAG_UDRDY                  PWR_CSR_UDSWRDY

/* --- FLAG Legacy ---*/
#define PWR_FLAG_REGRDY                  PWR_FLAG_VOSRDY               

#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
                               ((FLAG) == PWR_FLAG_PVDO) || ((FLAG) == PWR_FLAG_BRR) || \
                               ((FLAG) == PWR_FLAG_VOSRDY) || ((FLAG) == PWR_FLAG_ODRDY) || \
                               ((FLAG) == PWR_FLAG_ODSWRDY) || ((FLAG) == PWR_FLAG_UDRDY))


#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
                                 ((FLAG) == PWR_FLAG_UDRDY))

/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/* Function used to set the PWR configuration to the default reset state ******/ 
void PWR_DeInit(void);

/* Backup Domain Access function **********************************************/ 
void PWR_BackupAccessCmd(FunctionalState NewState);

/* PVD configuration functions ************************************************/ 
void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel);
void PWR_PVDCmd(FunctionalState NewState);

/* WakeUp pins configuration functions ****************************************/ 
void PWR_WakeUpPinCmd(FunctionalState NewState);

/* Main and Backup Regulators configuration functions *************************/ 
void PWR_BackupRegulatorCmd(FunctionalState NewState);
void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage);
void PWR_OverDriveCmd(FunctionalState NewState);
void PWR_OverDriveSWCmd(FunctionalState NewState);
void PWR_UnderDriveCmd(FunctionalState NewState);
void PWR_MainRegulatorLowVoltageCmd(FunctionalState NewState);
void PWR_LowRegulatorLowVoltageCmd(FunctionalState NewState);

/* FLASH Power Down configuration functions ***********************************/ 
void PWR_FlashPowerDownCmd(FunctionalState NewState);

/* Low Power modes configuration functions ************************************/ 
void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
void PWR_EnterUnderDriveSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry);
void PWR_EnterSTANDBYMode(void);

/* Flags management functions *************************************************/ 
FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG);
void PWR_ClearFlag(uint32_t PWR_FLAG);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_PWR_H */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_pwr.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_iwdg.h
/**
  ******************************************************************************
  * @file    stm32f4xx_iwdg.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the IWDG 
  *          firmware library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_IWDG_H
#define __STM32F4xx_IWDG_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup IWDG
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/

/** @defgroup IWDG_Exported_Constants
  * @{
  */
  
/** @defgroup IWDG_WriteAccess
  * @{
  */
#define IWDG_WriteAccess_Enable     ((uint16_t)0x5555)
#define IWDG_WriteAccess_Disable    ((uint16_t)0x0000)
#define IS_IWDG_WRITE_ACCESS(ACCESS) (((ACCESS) == IWDG_WriteAccess_Enable) || \
                                      ((ACCESS) == IWDG_WriteAccess_Disable))
/**
  * @}
  */

/** @defgroup IWDG_prescaler 
  * @{
  */
#define IWDG_Prescaler_4            ((uint8_t)0x00)
#define IWDG_Prescaler_8            ((uint8_t)0x01)
#define IWDG_Prescaler_16           ((uint8_t)0x02)
#define IWDG_Prescaler_32           ((uint8_t)0x03)
#define IWDG_Prescaler_64           ((uint8_t)0x04)
#define IWDG_Prescaler_128          ((uint8_t)0x05)
#define IWDG_Prescaler_256          ((uint8_t)0x06)
#define IS_IWDG_PRESCALER(PRESCALER) (((PRESCALER) == IWDG_Prescaler_4)  || \
                                      ((PRESCALER) == IWDG_Prescaler_8)  || \
                                      ((PRESCALER) == IWDG_Prescaler_16) || \
                                      ((PRESCALER) == IWDG_Prescaler_32) || \
                                      ((PRESCALER) == IWDG_Prescaler_64) || \
                                      ((PRESCALER) == IWDG_Prescaler_128)|| \
                                      ((PRESCALER) == IWDG_Prescaler_256))
/**
  * @}
  */

/** @defgroup IWDG_Flag 
  * @{
  */
#define IWDG_FLAG_PVU               ((uint16_t)0x0001)
#define IWDG_FLAG_RVU               ((uint16_t)0x0002)
#define IS_IWDG_FLAG(FLAG) (((FLAG) == IWDG_FLAG_PVU) || ((FLAG) == IWDG_FLAG_RVU))
#define IS_IWDG_RELOAD(RELOAD) ((RELOAD) <= 0xFFF)
/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/

/* Prescaler and Counter configuration functions ******************************/
void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess);
void IWDG_SetPrescaler(uint8_t IWDG_Prescaler);
void IWDG_SetReload(uint16_t Reload);
void IWDG_ReloadCounter(void);

/* IWDG activation function ***************************************************/
void IWDG_Enable(void);

/* Flag management function ***************************************************/
FlagStatus IWDG_GetFlagStatus(uint16_t IWDG_FLAG);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_IWDG_H */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_iwdg.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_hash.h
/**
  ******************************************************************************
  * @file    stm32f4xx_hash.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the HASH 
  *          firmware library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#pragma once

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

#if defined(STM32PLUS_F4_HAS_CRYPTO)


/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup HASH
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief   HASH Init structure definition
  */ 
typedef struct
{
  uint32_t HASH_AlgoSelection; /*!< SHA-1, SHA-224, SHA-256 or MD5. This parameter
                                    can be a value of @ref HASH_Algo_Selection */
  uint32_t HASH_AlgoMode;      /*!< HASH or HMAC. This parameter can be a value 
                                    of @ref HASH_processor_Algorithm_Mode */
  uint32_t HASH_DataType;      /*!< 32-bit data, 16-bit data, 8-bit data or 
                                    bit string. This parameter can be a value of
                                    @ref HASH_Data_Type */
  uint32_t HASH_HMACKeyType;   /*!< HMAC Short key or HMAC Long Key. This parameter
                                    can be a value of @ref HASH_HMAC_Long_key_only_for_HMAC_mode */
}HASH_InitTypeDef;

/** 
  * @brief  HASH message digest result structure definition  
  */ 
typedef struct
{
  uint32_t Data[8];      /*!< Message digest result : 8x 32bit wors for SHA-256,
                                                      7x 32bit wors for SHA-224,
                                                      5x 32bit words for SHA-1 or
                                                      4x 32bit words for MD5  */
} HASH_MsgDigest; 

/** 
  * @brief  HASH context swapping structure definition  
  */ 
typedef struct
{
  uint32_t HASH_IMR; 
  uint32_t HASH_STR;      
  uint32_t HASH_CR;     
  uint32_t HASH_CSR[54];       
}HASH_Context;

/* Exported constants --------------------------------------------------------*/

/** @defgroup HASH_Exported_Constants
  * @{
  */ 

/** @defgroup HASH_Algo_Selection 
  * @{
  */ 
#define HASH_AlgoSelection_SHA1      ((uint32_t)0x0000) /*!< HASH function is SHA1   */
#define HASH_AlgoSelection_SHA224    HASH_CR_ALGO_1     /*!< HASH function is SHA224 */
#define HASH_AlgoSelection_SHA256    HASH_CR_ALGO       /*!< HASH function is SHA256 */
#define HASH_AlgoSelection_MD5       HASH_CR_ALGO_0     /*!< HASH function is MD5    */

#define IS_HASH_ALGOSELECTION(ALGOSELECTION) (((ALGOSELECTION) == HASH_AlgoSelection_SHA1) || \
                                              ((ALGOSELECTION) == HASH_AlgoSelection_SHA224) || \
                                              ((ALGOSELECTION) == HASH_AlgoSelection_SHA256) || \
                                              ((ALGOSELECTION) == HASH_AlgoSelection_MD5))
/**
  * @}
  */

/** @defgroup HASH_processor_Algorithm_Mode 
  * @{
  */ 
#define HASH_AlgoMode_HASH         ((uint32_t)0x00000000) /*!< Algorithm is HASH */ 
#define HASH_AlgoMode_HMAC         HASH_CR_MODE           /*!< Algorithm is HMAC */

#define IS_HASH_ALGOMODE(ALGOMODE) (((ALGOMODE) == HASH_AlgoMode_HASH) || \
                                    ((ALGOMODE) == HASH_AlgoMode_HMAC))
/**
  * @}
  */

/** @defgroup HASH_Data_Type  
  * @{
  */  
#define HASH_DataType_32b          ((uint32_t)0x0000) /*!< 32-bit data. No swapping                     */
#define HASH_DataType_16b          HASH_CR_DATATYPE_0 /*!< 16-bit data. Each half word is swapped       */
#define HASH_DataType_8b           HASH_CR_DATATYPE_1 /*!< 8-bit data. All bytes are swapped            */
#define HASH_DataType_1b           HASH_CR_DATATYPE   /*!< 1-bit data. In the word all bits are swapped */

#define IS_HASH_DATATYPE(DATATYPE) (((DATATYPE) == HASH_DataType_32b)|| \
                                    ((DATATYPE) == HASH_DataType_16b)|| \
                                    ((DATATYPE) == HASH_DataType_8b) || \
                                    ((DATATYPE) == HASH_DataType_1b))
/**
  * @}
  */

/** @defgroup HASH_HMAC_Long_key_only_for_HMAC_mode  
  * @{
  */ 
#define HASH_HMACKeyType_ShortKey      ((uint32_t)0x00000000) /*!< HMAC Key is <= 64 bytes */
#define HASH_HMACKeyType_LongKey       HASH_CR_LKEY           /*!< HMAC Key is > 64 bytes  */

#define IS_HASH_HMAC_KEYTYPE(KEYTYPE) (((KEYTYPE) == HASH_HMACKeyType_ShortKey) || \
                                       ((KEYTYPE) == HASH_HMACKeyType_LongKey))
/**
  * @}
  */

/** @defgroup Number_of_valid_bits_in_last_word_of_the_message   
  * @{
  */  
#define IS_HASH_VALIDBITSNUMBER(VALIDBITS) ((VALIDBITS) <= 0x1F)

/**
  * @}
  */

/** @defgroup HASH_interrupts_definition   
  * @{
  */  
#define HASH_IT_DINI               HASH_IMR_DINIM  /*!< A new block can be entered into the input buffer (DIN) */
#define HASH_IT_DCI                HASH_IMR_DCIM   /*!< Digest calculation complete                            */

#define IS_HASH_IT(IT) ((((IT) & (uint32_t)0xFFFFFFFC) == 0x00000000) && ((IT) != 0x00000000))
#define IS_HASH_GET_IT(IT) (((IT) == HASH_IT_DINI) || ((IT) == HASH_IT_DCI))
				   
/**
  * @}
  */

/** @defgroup HASH_flags_definition   
  * @{
  */  
#define HASH_FLAG_DINIS            HASH_SR_DINIS  /*!< 16 locations are free in the DIN : A new block can be entered into the input buffer */
#define HASH_FLAG_DCIS             HASH_SR_DCIS   /*!< Digest calculation complete                                                         */
#define HASH_FLAG_DMAS             HASH_SR_DMAS   /*!< DMA interface is enabled (DMAE=1) or a transfer is ongoing                          */
#define HASH_FLAG_BUSY             HASH_SR_BUSY   /*!< The hash core is Busy : processing a block of data                                  */
#define HASH_FLAG_DINNE            HASH_CR_DINNE  /*!< DIN not empty : The input buffer contains at least one word of data                 */

#define IS_HASH_GET_FLAG(FLAG) (((FLAG) == HASH_FLAG_DINIS) || \
                                ((FLAG) == HASH_FLAG_DCIS)  || \
                                ((FLAG) == HASH_FLAG_DMAS)  || \
                                ((FLAG) == HASH_FLAG_BUSY)  || \
                                ((FLAG) == HASH_FLAG_DINNE)) 

#define IS_HASH_CLEAR_FLAG(FLAG)(((FLAG) == HASH_FLAG_DINIS) || \
                                 ((FLAG) == HASH_FLAG_DCIS))                                 

/**
  * @}
  */ 

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 
  
/*  Function used to set the HASH configuration to the default reset state ****/
void HASH_DeInit(void);

/* HASH Configuration function ************************************************/
void HASH_Init(HASH_InitTypeDef* HASH_InitStruct);
void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct);
void HASH_Reset(void);

/* HASH Message Digest generation functions ***********************************/
void HASH_DataIn(uint32_t Data);
uint8_t HASH_GetInFIFOWordsNbr(void);
void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber);
void HASH_StartDigest(void);
void HASH_AutoStartDigest(FunctionalState NewState);
void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest);

/* HASH Context swapping functions ********************************************/
void HASH_SaveContext(HASH_Context* HASH_ContextSave);
void HASH_RestoreContext(HASH_Context* HASH_ContextRestore);

/* HASH DMA interface function ************************************************/
void HASH_DMACmd(FunctionalState NewState);

/* HASH Interrupts and flags management functions *****************************/
void HASH_ITConfig(uint32_t HASH_IT, FunctionalState NewState);
FlagStatus HASH_GetFlagStatus(uint32_t HASH_FLAG);
void HASH_ClearFlag(uint32_t HASH_FLAG);
ITStatus HASH_GetITStatus(uint32_t HASH_IT);
void HASH_ClearITPendingBit(uint32_t HASH_IT);

/* High Level SHA1 functions **************************************************/
ErrorStatus HASH_SHA1(uint8_t *Input, uint32_t Ilen, uint8_t Output[20]);
ErrorStatus HMAC_SHA1(uint8_t *Key, uint32_t Keylen,
                      uint8_t *Input, uint32_t Ilen,
                      uint8_t Output[20]);

/* High Level MD5 functions ***************************************************/
ErrorStatus HASH_MD5(uint8_t *Input, uint32_t Ilen, uint8_t Output[16]);
ErrorStatus HMAC_MD5(uint8_t *Key, uint32_t Keylen,
                     uint8_t *Input, uint32_t Ilen,
                     uint8_t Output[16]);

#endif

#ifdef __cplusplus
}
#endif


/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_hash.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_gpio.h
/**
  ******************************************************************************
  * @file    stm32f4xx_gpio.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the GPIO firmware
  *          library.  
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_GPIO_H
#define __STM32F4xx_GPIO_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup GPIO
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/

#define IS_GPIO_ALL_PERIPH(PERIPH) (((PERIPH) == GPIOA) || \
                                    ((PERIPH) == GPIOB) || \
                                    ((PERIPH) == GPIOC) || \
                                    ((PERIPH) == GPIOD) || \
                                    ((PERIPH) == GPIOE) || \
                                    ((PERIPH) == GPIOF) || \
                                    ((PERIPH) == GPIOG) || \
                                    ((PERIPH) == GPIOH) || \
                                    ((PERIPH) == GPIOI) || \
                                    ((PERIPH) == GPIOJ) || \
                                    ((PERIPH) == GPIOK))

/** 
  * @brief  GPIO Configuration Mode enumeration 
  */   
typedef enum
{ 
  GPIO_Mode_IN   = 0x00, /*!< GPIO Input Mode */
  GPIO_Mode_OUT  = 0x01, /*!< GPIO Output Mode */
  GPIO_Mode_AF   = 0x02, /*!< GPIO Alternate function Mode */
  GPIO_Mode_AN   = 0x03  /*!< GPIO Analog Mode */
}GPIOMode_TypeDef;
#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_IN)  || ((MODE) == GPIO_Mode_OUT) || \
                            ((MODE) == GPIO_Mode_AF)|| ((MODE) == GPIO_Mode_AN))

/** 
  * @brief  GPIO Output type enumeration 
  */  
typedef enum
{ 
  GPIO_OType_PP = 0x00,
  GPIO_OType_OD = 0x01
}GPIOOType_TypeDef;
#define IS_GPIO_OTYPE(OTYPE) (((OTYPE) == GPIO_OType_PP) || ((OTYPE) == GPIO_OType_OD))


/** 
  * @brief  GPIO Output Maximum frequency enumeration 
  */  
typedef enum
{ 
  GPIO_Low_Speed     = 0x00, /*!< Low speed    */
  GPIO_Medium_Speed  = 0x01, /*!< Medium speed */
  GPIO_Fast_Speed    = 0x02, /*!< Fast speed   */
  GPIO_High_Speed    = 0x03  /*!< High speed   */
}GPIOSpeed_TypeDef;

/* Add legacy definition */
#define  GPIO_Speed_2MHz    GPIO_Low_Speed    
#define  GPIO_Speed_25MHz   GPIO_Medium_Speed 
#define  GPIO_Speed_50MHz   GPIO_Fast_Speed 
#define  GPIO_Speed_100MHz  GPIO_High_Speed  
  
#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Low_Speed) || ((SPEED) == GPIO_Medium_Speed) || \
                              ((SPEED) == GPIO_Fast_Speed)||  ((SPEED) == GPIO_High_Speed)) 

/** 
  * @brief  GPIO Configuration PullUp PullDown enumeration 
  */ 
typedef enum
{ 
  GPIO_PuPd_NOPULL = 0x00,
  GPIO_PuPd_UP     = 0x01,
  GPIO_PuPd_DOWN   = 0x02
}GPIOPuPd_TypeDef;
#define IS_GPIO_PUPD(PUPD) (((PUPD) == GPIO_PuPd_NOPULL) || ((PUPD) == GPIO_PuPd_UP) || \
                            ((PUPD) == GPIO_PuPd_DOWN))

/** 
  * @brief  GPIO Bit SET and Bit RESET enumeration 
  */ 
typedef enum
{ 
  Bit_RESET = 0,
  Bit_SET
}BitAction;
#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))


/** 
  * @brief   GPIO Init structure definition  
  */ 
typedef struct
{
  uint32_t GPIO_Pin;              /*!< Specifies the GPIO pins to be configured.
                                       This parameter can be any value of @ref GPIO_pins_define */

  GPIOMode_TypeDef GPIO_Mode;     /*!< Specifies the operating mode for the selected pins.
                                       This parameter can be a value of @ref GPIOMode_TypeDef */

  GPIOSpeed_TypeDef GPIO_Speed;   /*!< Specifies the speed for the selected pins.
                                       This parameter can be a value of @ref GPIOSpeed_TypeDef */

  GPIOOType_TypeDef GPIO_OType;   /*!< Specifies the operating output type for the selected pins.
                                       This parameter can be a value of @ref GPIOOType_TypeDef */

  GPIOPuPd_TypeDef GPIO_PuPd;     /*!< Specifies the operating Pull-up/Pull down for the selected pins.
                                       This parameter can be a value of @ref GPIOPuPd_TypeDef */
}GPIO_InitTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup GPIO_Exported_Constants
  * @{
  */ 

/** @defgroup GPIO_pins_define 
  * @{
  */ 
#define GPIO_Pin_0                 ((uint16_t)0x0001)  /* Pin 0 selected */
#define GPIO_Pin_1                 ((uint16_t)0x0002)  /* Pin 1 selected */
#define GPIO_Pin_2                 ((uint16_t)0x0004)  /* Pin 2 selected */
#define GPIO_Pin_3                 ((uint16_t)0x0008)  /* Pin 3 selected */
#define GPIO_Pin_4                 ((uint16_t)0x0010)  /* Pin 4 selected */
#define GPIO_Pin_5                 ((uint16_t)0x0020)  /* Pin 5 selected */
#define GPIO_Pin_6                 ((uint16_t)0x0040)  /* Pin 6 selected */
#define GPIO_Pin_7                 ((uint16_t)0x0080)  /* Pin 7 selected */
#define GPIO_Pin_8                 ((uint16_t)0x0100)  /* Pin 8 selected */
#define GPIO_Pin_9                 ((uint16_t)0x0200)  /* Pin 9 selected */
#define GPIO_Pin_10                ((uint16_t)0x0400)  /* Pin 10 selected */
#define GPIO_Pin_11                ((uint16_t)0x0800)  /* Pin 11 selected */
#define GPIO_Pin_12                ((uint16_t)0x1000)  /* Pin 12 selected */
#define GPIO_Pin_13                ((uint16_t)0x2000)  /* Pin 13 selected */
#define GPIO_Pin_14                ((uint16_t)0x4000)  /* Pin 14 selected */
#define GPIO_Pin_15                ((uint16_t)0x8000)  /* Pin 15 selected */
#define GPIO_Pin_All               ((uint16_t)0xFFFF)  /* All pins selected */

#define GPIO_PIN_MASK              ((uint32_t)0x0000FFFF) /* PIN mask for assert test */
#define IS_GPIO_PIN(PIN)           (((PIN) & GPIO_PIN_MASK ) != (uint32_t)0x00)
#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
                              ((PIN) == GPIO_Pin_1) || \
                              ((PIN) == GPIO_Pin_2) || \
                              ((PIN) == GPIO_Pin_3) || \
                              ((PIN) == GPIO_Pin_4) || \
                              ((PIN) == GPIO_Pin_5) || \
                              ((PIN) == GPIO_Pin_6) || \
                              ((PIN) == GPIO_Pin_7) || \
                              ((PIN) == GPIO_Pin_8) || \
                              ((PIN) == GPIO_Pin_9) || \
                              ((PIN) == GPIO_Pin_10) || \
                              ((PIN) == GPIO_Pin_11) || \
                              ((PIN) == GPIO_Pin_12) || \
                              ((PIN) == GPIO_Pin_13) || \
                              ((PIN) == GPIO_Pin_14) || \
                              ((PIN) == GPIO_Pin_15))
/**
  * @}
  */ 


/** @defgroup GPIO_Pin_sources 
  * @{
  */ 
#define GPIO_PinSource0            ((uint8_t)0x00)
#define GPIO_PinSource1            ((uint8_t)0x01)
#define GPIO_PinSource2            ((uint8_t)0x02)
#define GPIO_PinSource3            ((uint8_t)0x03)
#define GPIO_PinSource4            ((uint8_t)0x04)
#define GPIO_PinSource5            ((uint8_t)0x05)
#define GPIO_PinSource6            ((uint8_t)0x06)
#define GPIO_PinSource7            ((uint8_t)0x07)
#define GPIO_PinSource8            ((uint8_t)0x08)
#define GPIO_PinSource9            ((uint8_t)0x09)
#define GPIO_PinSource10           ((uint8_t)0x0A)
#define GPIO_PinSource11           ((uint8_t)0x0B)
#define GPIO_PinSource12           ((uint8_t)0x0C)
#define GPIO_PinSource13           ((uint8_t)0x0D)
#define GPIO_PinSource14           ((uint8_t)0x0E)
#define GPIO_PinSource15           ((uint8_t)0x0F)

#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
                                       ((PINSOURCE) == GPIO_PinSource1) || \
                                       ((PINSOURCE) == GPIO_PinSource2) || \
                                       ((PINSOURCE) == GPIO_PinSource3) || \
                                       ((PINSOURCE) == GPIO_PinSource4) || \
                                       ((PINSOURCE) == GPIO_PinSource5) || \
                                       ((PINSOURCE) == GPIO_PinSource6) || \
                                       ((PINSOURCE) == GPIO_PinSource7) || \
                                       ((PINSOURCE) == GPIO_PinSource8) || \
                                       ((PINSOURCE) == GPIO_PinSource9) || \
                                       ((PINSOURCE) == GPIO_PinSource10) || \
                                       ((PINSOURCE) == GPIO_PinSource11) || \
                                       ((PINSOURCE) == GPIO_PinSource12) || \
                                       ((PINSOURCE) == GPIO_PinSource13) || \
                                       ((PINSOURCE) == GPIO_PinSource14) || \
                                       ((PINSOURCE) == GPIO_PinSource15))
/**
  * @}
  */ 

/** @defgroup GPIO_Alternat_function_selection_define 
  * @{
  */ 
/** 
  * @brief   AF 0 selection  
  */ 
#define GPIO_AF_RTC_50Hz      ((uint8_t)0x00)  /* RTC_50Hz Alternate Function mapping */
#define GPIO_AF_MCO           ((uint8_t)0x00)  /* MCO (MCO1 and MCO2) Alternate Function mapping */
#define GPIO_AF_TAMPER        ((uint8_t)0x00)  /* TAMPER (TAMPER_1 and TAMPER_2) Alternate Function mapping */
#define GPIO_AF_SWJ           ((uint8_t)0x00)  /* SWJ (SWD and JTAG) Alternate Function mapping */
#define GPIO_AF_TRACE         ((uint8_t)0x00)  /* TRACE Alternate Function mapping */

/** 
  * @brief   AF 1 selection  
  */ 
#define GPIO_AF_TIM1          ((uint8_t)0x01)  /* TIM1 Alternate Function mapping */
#define GPIO_AF_TIM2          ((uint8_t)0x01)  /* TIM2 Alternate Function mapping */

/** 
  * @brief   AF 2 selection  
  */ 
#define GPIO_AF_TIM3          ((uint8_t)0x02)  /* TIM3 Alternate Function mapping */
#define GPIO_AF_TIM4          ((uint8_t)0x02)  /* TIM4 Alternate Function mapping */
#define GPIO_AF_TIM5          ((uint8_t)0x02)  /* TIM5 Alternate Function mapping */

/** 
  * @brief   AF 3 selection  
  */ 
#define GPIO_AF_TIM8          ((uint8_t)0x03)  /* TIM8 Alternate Function mapping */
#define GPIO_AF_TIM9          ((uint8_t)0x03)  /* TIM9 Alternate Function mapping */
#define GPIO_AF_TIM10         ((uint8_t)0x03)  /* TIM10 Alternate Function mapping */
#define GPIO_AF_TIM11         ((uint8_t)0x03)  /* TIM11 Alternate Function mapping */

/** 
  * @brief   AF 4 selection  
  */ 
#define GPIO_AF_I2C1          ((uint8_t)0x04)  /* I2C1 Alternate Function mapping */
#define GPIO_AF_I2C2          ((uint8_t)0x04)  /* I2C2 Alternate Function mapping */
#define GPIO_AF_I2C3          ((uint8_t)0x04)  /* I2C3 Alternate Function mapping */

/** 
  * @brief   AF 5 selection  
  */ 
#define GPIO_AF_SPI1          ((uint8_t)0x05)  /* SPI1/I2S1 Alternate Function mapping */
#define GPIO_AF_SPI2          ((uint8_t)0x05)  /* SPI2/I2S2 Alternate Function mapping */
#define GPIO_AF5_SPI3         ((uint8_t)0x05)  /* SPI3/I2S3 Alternate Function mapping (Only for STM32F411xE Devices) */
#define GPIO_AF_SPI4          ((uint8_t)0x05)  /* SPI4/I2S4 Alternate Function mapping */
#define GPIO_AF_SPI5          ((uint8_t)0x05)  /* SPI5 Alternate Function mapping      */
#define GPIO_AF_SPI6          ((uint8_t)0x05)  /* SPI6 Alternate Function mapping      */

/** 
  * @brief   AF 6 selection  
  */ 
#define GPIO_AF_SPI3          ((uint8_t)0x06)  /* SPI3/I2S3 Alternate Function mapping */
#define GPIO_AF6_SPI2         ((uint8_t)0x06)  /* SPI2 Alternate Function mapping (Only for STM32F411xE Devices) */
#define GPIO_AF6_SPI4         ((uint8_t)0x06)  /* SPI4 Alternate Function mapping (Only for STM32F411xE Devices) */
#define GPIO_AF6_SPI5         ((uint8_t)0x06)  /* SPI5 Alternate Function mapping (Only for STM32F411xE Devices) */
#define GPIO_AF_SAI1          ((uint8_t)0x06)  /* SAI1 Alternate Function mapping      */

/** 
  * @brief   AF 7 selection  
  */ 
#define GPIO_AF_USART1         ((uint8_t)0x07)  /* USART1 Alternate Function mapping  */
#define GPIO_AF_USART2         ((uint8_t)0x07)  /* USART2 Alternate Function mapping  */
#define GPIO_AF_USART3         ((uint8_t)0x07)  /* USART3 Alternate Function mapping  */
#define GPIO_AF7_SPI3          ((uint8_t)0x07)  /* SPI3/I2S3ext Alternate Function mapping */

/** 
  * @brief   AF 7 selection Legacy 
  */ 
#define GPIO_AF_I2S3ext   GPIO_AF7_SPI3

/** 
  * @brief   AF 8 selection  
  */ 
#define GPIO_AF_UART4         ((uint8_t)0x08)  /* UART4 Alternate Function mapping  */
#define GPIO_AF_UART5         ((uint8_t)0x08)  /* UART5 Alternate Function mapping  */
#define GPIO_AF_USART6        ((uint8_t)0x08)  /* USART6 Alternate Function mapping */
#define GPIO_AF_UART7         ((uint8_t)0x08)  /* UART7 Alternate Function mapping  */
#define GPIO_AF_UART8         ((uint8_t)0x08)  /* UART8 Alternate Function mapping  */

/** 
  * @brief   AF 9 selection 
  */ 
#define GPIO_AF_CAN1          ((uint8_t)0x09)  /* CAN1 Alternate Function mapping  */
#define GPIO_AF_CAN2          ((uint8_t)0x09)  /* CAN2 Alternate Function mapping  */
#define GPIO_AF_TIM12         ((uint8_t)0x09)  /* TIM12 Alternate Function mapping */
#define GPIO_AF_TIM13         ((uint8_t)0x09)  /* TIM13 Alternate Function mapping */
#define GPIO_AF_TIM14         ((uint8_t)0x09)  /* TIM14 Alternate Function mapping */

#define GPIO_AF9_I2C2         ((uint8_t)0x09)  /* I2C2 Alternate Function mapping (Only for STM32F401xx/STM32F411xE Devices) */
#define GPIO_AF9_I2C3         ((uint8_t)0x09)  /* I2C3 Alternate Function mapping (Only for STM32F401xx/STM32F411xE Devices) */

/** 
  * @brief   AF 10 selection  
  */ 
#define GPIO_AF_OTG_FS         ((uint8_t)0xA)  /* OTG_FS Alternate Function mapping */
#define GPIO_AF_OTG_HS         ((uint8_t)0xA)  /* OTG_HS Alternate Function mapping */

/** 
  * @brief   AF 11 selection  
  */ 
#define GPIO_AF_ETH             ((uint8_t)0x0B)  /* ETHERNET Alternate Function mapping */

/** 
  * @brief   AF 12 selection  
  */ 
#if defined (STM32F40_41xxx)
#define GPIO_AF_FSMC             ((uint8_t)0xC)  /* FSMC Alternate Function mapping                     */
#endif /* STM32F40_41xxx */

#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
#define GPIO_AF_FMC              ((uint8_t)0xC)  /* FMC Alternate Function mapping                      */
#endif /* STM32F427_437xx ||  STM32F429_439xx */

#define GPIO_AF_OTG_HS_FS        ((uint8_t)0xC)  /* OTG HS configured in FS, Alternate Function mapping */
#define GPIO_AF_SDIO             ((uint8_t)0xC)  /* SDIO Alternate Function mapping                     */

/** 
  * @brief   AF 13 selection  
  */ 
#define GPIO_AF_DCMI          ((uint8_t)0x0D)  /* DCMI Alternate Function mapping */

/** 
  * @brief   AF 14 selection  
  */

#define GPIO_AF_LTDC          ((uint8_t)0x0E)  /* LCD-TFT Alternate Function mapping */

/** 
  * @brief   AF 15 selection  
  */ 
#define GPIO_AF_EVENTOUT      ((uint8_t)0x0F)  /* EVENTOUT Alternate Function mapping */

#if defined (STM32F40_41xxx)
#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     || \
                          ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    || \
                          ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     || \
                          ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      || \
                          ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      || \
                          ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      || \
                          ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      || \
                          ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      || \
                          ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     || \
                          ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     || \
                          ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    || \
                          ((AF) == GPIO_AF_USART3)    || ((AF) == GPIO_AF_UART4)     || \
                          ((AF) == GPIO_AF_UART5)     || ((AF) == GPIO_AF_USART6)    || \
                          ((AF) == GPIO_AF_CAN1)      || ((AF) == GPIO_AF_CAN2)      || \
                          ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    || \
                          ((AF) == GPIO_AF_ETH)       || ((AF) == GPIO_AF_OTG_HS_FS) || \
                          ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_DCMI)      || \
                          ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_FSMC))
#endif /* STM32F40_41xxx */

#if defined (STM32F401xx)
#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     || \
                          ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    || \
                          ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     || \
                          ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      || \
                          ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      || \
                          ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      || \
                          ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      || \
                          ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      || \
                          ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     || \
                          ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     || \
                          ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    || \
                          ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_USART6)    || \
                          ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    || \
                          ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_SPI4))
#endif /* STM32F401xx */

#if defined (STM32F411xE)
#define IS_GPIO_AF(AF)   (((AF) < 16) && ((AF) != 11) && ((AF) != 13) && ((AF) != 14))
#endif /* STM32F411xE */

#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
#define IS_GPIO_AF(AF)   (((AF) == GPIO_AF_RTC_50Hz)  || ((AF) == GPIO_AF_TIM14)     || \
                          ((AF) == GPIO_AF_MCO)       || ((AF) == GPIO_AF_TAMPER)    || \
                          ((AF) == GPIO_AF_SWJ)       || ((AF) == GPIO_AF_TRACE)     || \
                          ((AF) == GPIO_AF_TIM1)      || ((AF) == GPIO_AF_TIM2)      || \
                          ((AF) == GPIO_AF_TIM3)      || ((AF) == GPIO_AF_TIM4)      || \
                          ((AF) == GPIO_AF_TIM5)      || ((AF) == GPIO_AF_TIM8)      || \
                          ((AF) == GPIO_AF_I2C1)      || ((AF) == GPIO_AF_I2C2)      || \
                          ((AF) == GPIO_AF_I2C3)      || ((AF) == GPIO_AF_SPI1)      || \
                          ((AF) == GPIO_AF_SPI2)      || ((AF) == GPIO_AF_TIM13)     || \
                          ((AF) == GPIO_AF_SPI3)      || ((AF) == GPIO_AF_TIM14)     || \
                          ((AF) == GPIO_AF_USART1)    || ((AF) == GPIO_AF_USART2)    || \
                          ((AF) == GPIO_AF_USART3)    || ((AF) == GPIO_AF_UART4)     || \
                          ((AF) == GPIO_AF_UART5)     || ((AF) == GPIO_AF_USART6)    || \
                          ((AF) == GPIO_AF_CAN1)      || ((AF) == GPIO_AF_CAN2)      || \
                          ((AF) == GPIO_AF_OTG_FS)    || ((AF) == GPIO_AF_OTG_HS)    || \
                          ((AF) == GPIO_AF_ETH)       || ((AF) == GPIO_AF_OTG_HS_FS) || \
                          ((AF) == GPIO_AF_SDIO)      || ((AF) == GPIO_AF_DCMI)      || \
                          ((AF) == GPIO_AF_EVENTOUT)  || ((AF) == GPIO_AF_SPI4)      || \
                          ((AF) == GPIO_AF_SPI5)      || ((AF) == GPIO_AF_SPI6)      || \
                          ((AF) == GPIO_AF_UART7)     || ((AF) == GPIO_AF_UART8)     || \
                          ((AF) == GPIO_AF_FMC)       ||  ((AF) == GPIO_AF_SAI1)     || \
                          ((AF) == GPIO_AF_LTDC))
#endif /* STM32F427_437xx ||  STM32F429_439xx */
                          
/**
  * @}
  */ 

/** @defgroup GPIO_Legacy 
  * @{
  */
    
#define GPIO_Mode_AIN           GPIO_Mode_AN

#define GPIO_AF_OTG1_FS         GPIO_AF_OTG_FS
#define GPIO_AF_OTG2_HS         GPIO_AF_OTG_HS
#define GPIO_AF_OTG2_FS         GPIO_AF_OTG_HS_FS

/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/

/*  Function used to set the GPIO configuration to the default reset state ****/
void GPIO_DeInit(GPIO_TypeDef* GPIOx);

/* Initialization and Configuration functions *********************************/
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);

/* GPIO Read and Write functions **********************************************/
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);
void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);
void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);

/* GPIO Alternate functions configuration function ****************************/
void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF);

#ifdef __cplusplus
}
#endif

#endif /*__STM32F4xx_GPIO_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_gpio.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_exti.h
/**
  ******************************************************************************
  * @file    stm32f4xx_exti.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the EXTI firmware
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_EXTI_H
#define __STM32F4xx_EXTI_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup EXTI
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief  EXTI mode enumeration  
  */

typedef enum
{
  EXTI_Mode_Interrupt = 0x00,
  EXTI_Mode_Event = 0x04
}EXTIMode_TypeDef;

#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))

/** 
  * @brief  EXTI Trigger enumeration  
  */

typedef enum
{
  EXTI_Trigger_Rising = 0x08,
  EXTI_Trigger_Falling = 0x0C,  
  EXTI_Trigger_Rising_Falling = 0x10
}EXTITrigger_TypeDef;

#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
/** 
  * @brief  EXTI Init Structure definition  
  */

typedef struct
{
  uint32_t EXTI_Line;               /*!< Specifies the EXTI lines to be enabled or disabled.
                                         This parameter can be any combination value of @ref EXTI_Lines */
   
  EXTIMode_TypeDef EXTI_Mode;       /*!< Specifies the mode for the EXTI lines.
                                         This parameter can be a value of @ref EXTIMode_TypeDef */

  EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines.
                                         This parameter can be a value of @ref EXTITrigger_TypeDef */

  FunctionalState EXTI_LineCmd;     /*!< Specifies the new state of the selected EXTI lines.
                                         This parameter can be set either to ENABLE or DISABLE */ 
}EXTI_InitTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup EXTI_Exported_Constants
  * @{
  */

/** @defgroup EXTI_Lines 
  * @{
  */

#define EXTI_Line0       ((uint32_t)0x00001)     /*!< External interrupt line 0 */
#define EXTI_Line1       ((uint32_t)0x00002)     /*!< External interrupt line 1 */
#define EXTI_Line2       ((uint32_t)0x00004)     /*!< External interrupt line 2 */
#define EXTI_Line3       ((uint32_t)0x00008)     /*!< External interrupt line 3 */
#define EXTI_Line4       ((uint32_t)0x00010)     /*!< External interrupt line 4 */
#define EXTI_Line5       ((uint32_t)0x00020)     /*!< External interrupt line 5 */
#define EXTI_Line6       ((uint32_t)0x00040)     /*!< External interrupt line 6 */
#define EXTI_Line7       ((uint32_t)0x00080)     /*!< External interrupt line 7 */
#define EXTI_Line8       ((uint32_t)0x00100)     /*!< External interrupt line 8 */
#define EXTI_Line9       ((uint32_t)0x00200)     /*!< External interrupt line 9 */
#define EXTI_Line10      ((uint32_t)0x00400)     /*!< External interrupt line 10 */
#define EXTI_Line11      ((uint32_t)0x00800)     /*!< External interrupt line 11 */
#define EXTI_Line12      ((uint32_t)0x01000)     /*!< External interrupt line 12 */
#define EXTI_Line13      ((uint32_t)0x02000)     /*!< External interrupt line 13 */
#define EXTI_Line14      ((uint32_t)0x04000)     /*!< External interrupt line 14 */
#define EXTI_Line15      ((uint32_t)0x08000)     /*!< External interrupt line 15 */
#define EXTI_Line16      ((uint32_t)0x10000)     /*!< External interrupt line 16 Connected to the PVD Output */
#define EXTI_Line17      ((uint32_t)0x20000)     /*!< External interrupt line 17 Connected to the RTC Alarm event */
#define EXTI_Line18      ((uint32_t)0x40000)     /*!< External interrupt line 18 Connected to the USB OTG FS Wakeup from suspend event */                                    
#define EXTI_Line19      ((uint32_t)0x80000)     /*!< External interrupt line 19 Connected to the Ethernet Wakeup event */
#define EXTI_Line20      ((uint32_t)0x00100000)  /*!< External interrupt line 20 Connected to the USB OTG HS (configured in FS) Wakeup event  */
#define EXTI_Line21      ((uint32_t)0x00200000)  /*!< External interrupt line 21 Connected to the RTC Tamper and Time Stamp events */                                               
#define EXTI_Line22      ((uint32_t)0x00400000)  /*!< External interrupt line 22 Connected to the RTC Wakeup event */                                               
                                          
#define IS_EXTI_LINE(LINE) ((((LINE) & (uint32_t)0xFF800000) == 0x00) && ((LINE) != (uint16_t)0x00))

#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
                                ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
                                ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
                                ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
                                ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
                                ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
                                ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
                                ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
                                ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
                                ((LINE) == EXTI_Line18) || ((LINE) == EXTI_Line19) || \
                                ((LINE) == EXTI_Line20) || ((LINE) == EXTI_Line21) ||\
                                ((LINE) == EXTI_Line22))
                    
/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/

/*  Function used to set the EXTI configuration to the default reset state *****/
void EXTI_DeInit(void);

/* Initialization and Configuration functions *********************************/
void EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
void EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
void EXTI_GenerateSWInterrupt(uint32_t EXTI_Line);

/* Interrupts and flags management functions **********************************/
FlagStatus EXTI_GetFlagStatus(uint32_t EXTI_Line);
void EXTI_ClearFlag(uint32_t EXTI_Line);
ITStatus EXTI_GetITStatus(uint32_t EXTI_Line);
void EXTI_ClearITPendingBit(uint32_t EXTI_Line);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_EXTI_H */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_exti.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_cryp.h
/**
  ******************************************************************************
  * @file    stm32f4xx_cryp.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the Cryptographic
  *          processor(CRYP) firmware library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#pragma once

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

#if defined(STM32PLUS_F4_HAS_CRYPTO)


/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup CRYP
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief   CRYP Init structure definition  
  */ 
typedef struct
{
  uint32_t CRYP_AlgoDir;   /*!< Encrypt or Decrypt. This parameter can be a 
                                value of @ref CRYP_Algorithm_Direction */
  uint32_t CRYP_AlgoMode;  /*!< TDES-ECB, TDES-CBC, DES-ECB, DES-CBC, AES-ECB, 
                                AES-CBC, AES-CTR, AES-Key, AES-GCM and AES-CCM.
                                This parameter can be a value of @ref CRYP_Algorithm_Mode */
  uint32_t CRYP_DataType;  /*!< 32-bit data, 16-bit data, bit data or bit string.
                                This parameter can be a value of @ref CRYP_Data_Type */ 
  uint32_t CRYP_KeySize;   /*!< Used only in AES mode only : 128, 192 or 256 bit 
                                key length. This parameter can be a value of 
                                @ref CRYP_Key_Size_for_AES_only */
}CRYP_InitTypeDef;

/** 
  * @brief   CRYP Key(s) structure definition  
  */ 
typedef struct
{
  uint32_t CRYP_Key0Left;  /*!< Key 0 Left  */
  uint32_t CRYP_Key0Right; /*!< Key 0 Right */
  uint32_t CRYP_Key1Left;  /*!< Key 1 left  */
  uint32_t CRYP_Key1Right; /*!< Key 1 Right */
  uint32_t CRYP_Key2Left;  /*!< Key 2 left  */
  uint32_t CRYP_Key2Right; /*!< Key 2 Right */
  uint32_t CRYP_Key3Left;  /*!< Key 3 left  */
  uint32_t CRYP_Key3Right; /*!< Key 3 Right */
}CRYP_KeyInitTypeDef;
/** 
  * @brief   CRYP Initialization Vectors (IV) structure definition  
  */ 
typedef struct
{
  uint32_t CRYP_IV0Left;  /*!< Init Vector 0 Left  */
  uint32_t CRYP_IV0Right; /*!< Init Vector 0 Right */
  uint32_t CRYP_IV1Left;  /*!< Init Vector 1 left  */
  uint32_t CRYP_IV1Right; /*!< Init Vector 1 Right */
}CRYP_IVInitTypeDef;

/** 
  * @brief  CRYP context swapping structure definition  
  */ 
typedef struct
{
  /*!< Current Configuration */
  uint32_t CR_CurrentConfig;
  /*!< IV */
  uint32_t CRYP_IV0LR;
  uint32_t CRYP_IV0RR;
  uint32_t CRYP_IV1LR;
  uint32_t CRYP_IV1RR;
  /*!< KEY */
  uint32_t CRYP_K0LR;
  uint32_t CRYP_K0RR;
  uint32_t CRYP_K1LR;
  uint32_t CRYP_K1RR;
  uint32_t CRYP_K2LR;
  uint32_t CRYP_K2RR;
  uint32_t CRYP_K3LR;
  uint32_t CRYP_K3RR;
  uint32_t CRYP_CSGCMCCMR[8];
  uint32_t CRYP_CSGCMR[8];
}CRYP_Context;


/* Exported constants --------------------------------------------------------*/

/** @defgroup CRYP_Exported_Constants
  * @{
  */

/** @defgroup CRYP_Algorithm_Direction 
  * @{
  */
#define CRYP_AlgoDir_Encrypt      ((uint16_t)0x0000)
#define CRYP_AlgoDir_Decrypt      ((uint16_t)0x0004)
#define IS_CRYP_ALGODIR(ALGODIR) (((ALGODIR) == CRYP_AlgoDir_Encrypt) || \
                                  ((ALGODIR) == CRYP_AlgoDir_Decrypt))

/**
  * @}
  */ 
 
/** @defgroup CRYP_Algorithm_Mode 
  * @{
  */

/*!< TDES Modes */
#define CRYP_AlgoMode_TDES_ECB    ((uint32_t)0x00000000)
#define CRYP_AlgoMode_TDES_CBC    ((uint32_t)0x00000008)

/*!< DES Modes */
#define CRYP_AlgoMode_DES_ECB     ((uint32_t)0x00000010)
#define CRYP_AlgoMode_DES_CBC     ((uint32_t)0x00000018)

/*!< AES Modes */
#define CRYP_AlgoMode_AES_ECB     ((uint32_t)0x00000020)
#define CRYP_AlgoMode_AES_CBC     ((uint32_t)0x00000028)
#define CRYP_AlgoMode_AES_CTR     ((uint32_t)0x00000030)
#define CRYP_AlgoMode_AES_Key     ((uint32_t)0x00000038)
#define CRYP_AlgoMode_AES_GCM     ((uint32_t)0x00080000)
#define CRYP_AlgoMode_AES_CCM     ((uint32_t)0x00080008)

#define IS_CRYP_ALGOMODE(ALGOMODE) (((ALGOMODE) == CRYP_AlgoMode_TDES_ECB) || \
                                   ((ALGOMODE) == CRYP_AlgoMode_TDES_CBC)|| \
                                   ((ALGOMODE) == CRYP_AlgoMode_DES_ECB) || \
                                   ((ALGOMODE) == CRYP_AlgoMode_DES_CBC) || \
                                   ((ALGOMODE) == CRYP_AlgoMode_AES_ECB) || \
                                   ((ALGOMODE) == CRYP_AlgoMode_AES_CBC) || \
                                   ((ALGOMODE) == CRYP_AlgoMode_AES_CTR) || \
                                   ((ALGOMODE) == CRYP_AlgoMode_AES_Key) || \
                                   ((ALGOMODE) == CRYP_AlgoMode_AES_GCM) || \
                                   ((ALGOMODE) == CRYP_AlgoMode_AES_CCM))
/**
  * @}
  */ 

/** @defgroup CRYP_Phase 
  * @{
  */

/*!< The phases are valid only for AES-GCM and AES-CCM modes */
#define CRYP_Phase_Init           ((uint32_t)0x00000000)
#define CRYP_Phase_Header         CRYP_CR_GCM_CCMPH_0
#define CRYP_Phase_Payload        CRYP_CR_GCM_CCMPH_1
#define CRYP_Phase_Final          CRYP_CR_GCM_CCMPH

#define IS_CRYP_PHASE(PHASE) (((PHASE) == CRYP_Phase_Init)    || \
                              ((PHASE) == CRYP_Phase_Header)  || \
                              ((PHASE) == CRYP_Phase_Payload) || \
                              ((PHASE) == CRYP_Phase_Final))

/**
  * @}
  */ 

/** @defgroup CRYP_Data_Type 
  * @{
  */
#define CRYP_DataType_32b         ((uint16_t)0x0000)
#define CRYP_DataType_16b         ((uint16_t)0x0040)
#define CRYP_DataType_8b          ((uint16_t)0x0080)
#define CRYP_DataType_1b          ((uint16_t)0x00C0)
#define IS_CRYP_DATATYPE(DATATYPE) (((DATATYPE) == CRYP_DataType_32b) || \
                                    ((DATATYPE) == CRYP_DataType_16b)|| \
                                    ((DATATYPE) == CRYP_DataType_8b)|| \
                                    ((DATATYPE) == CRYP_DataType_1b))  
/**
  * @}
  */
                                     
/** @defgroup CRYP_Key_Size_for_AES_only 
  * @{
  */
#define CRYP_KeySize_128b         ((uint16_t)0x0000)
#define CRYP_KeySize_192b         ((uint16_t)0x0100)
#define CRYP_KeySize_256b         ((uint16_t)0x0200)
#define IS_CRYP_KEYSIZE(KEYSIZE) (((KEYSIZE) == CRYP_KeySize_128b)|| \
                                  ((KEYSIZE) == CRYP_KeySize_192b)|| \
                                  ((KEYSIZE) == CRYP_KeySize_256b))
/**
  * @}
  */

/** @defgroup CRYP_flags_definition 
  * @{
  */
#define CRYP_FLAG_BUSY            ((uint8_t)0x10)  /*!< The CRYP core is currently 
                                                        processing a block of data 
                                                        or a key preparation (for 
                                                        AES decryption). */
#define CRYP_FLAG_IFEM            ((uint8_t)0x01)  /*!< Input Fifo Empty */
#define CRYP_FLAG_IFNF            ((uint8_t)0x02)  /*!< Input Fifo is Not Full */
#define CRYP_FLAG_INRIS           ((uint8_t)0x22)  /*!< Raw interrupt pending */
#define CRYP_FLAG_OFNE            ((uint8_t)0x04)  /*!< Input Fifo service raw 
                                                        interrupt status */
#define CRYP_FLAG_OFFU            ((uint8_t)0x08)  /*!< Output Fifo is Full */
#define CRYP_FLAG_OUTRIS          ((uint8_t)0x21)  /*!< Output Fifo service raw 
                                                        interrupt status */

#define IS_CRYP_GET_FLAG(FLAG) (((FLAG) == CRYP_FLAG_IFEM)  || \
                                ((FLAG) == CRYP_FLAG_IFNF)  || \
                                ((FLAG) == CRYP_FLAG_OFNE)  || \
                                ((FLAG) == CRYP_FLAG_OFFU)  || \
                                ((FLAG) == CRYP_FLAG_BUSY)  || \
                                ((FLAG) == CRYP_FLAG_OUTRIS)|| \
                                ((FLAG) == CRYP_FLAG_INRIS))
/**
  * @}
  */

/** @defgroup CRYP_interrupts_definition 
  * @{
  */
#define CRYP_IT_INI               ((uint8_t)0x01) /*!< IN Fifo Interrupt */
#define CRYP_IT_OUTI              ((uint8_t)0x02) /*!< OUT Fifo Interrupt */
#define IS_CRYP_CONFIG_IT(IT) ((((IT) & (uint8_t)0xFC) == 0x00) && ((IT) != 0x00))
#define IS_CRYP_GET_IT(IT) (((IT) == CRYP_IT_INI) || ((IT) == CRYP_IT_OUTI))

/**
  * @}
  */

/** @defgroup CRYP_Encryption_Decryption_modes_definition 
  * @{
  */
#define MODE_ENCRYPT             ((uint8_t)0x01)
#define MODE_DECRYPT             ((uint8_t)0x00)

/**
  * @}
  */

/** @defgroup CRYP_DMA_transfer_requests 
  * @{
  */
#define CRYP_DMAReq_DataIN             ((uint8_t)0x01)
#define CRYP_DMAReq_DataOUT            ((uint8_t)0x02)
#define IS_CRYP_DMAREQ(DMAREQ) ((((DMAREQ) & (uint8_t)0xFC) == 0x00) && ((DMAREQ) != 0x00))
/**
  * @}
  */ 

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/

/*  Function used to set the CRYP configuration to the default reset state ****/
void CRYP_DeInit(void);

/* CRYP Initialization and Configuration functions ****************************/
void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct);
void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct);
void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct);
void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct);
void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct);
void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct);
void CRYP_Cmd(FunctionalState NewState);
void CRYP_PhaseConfig(uint32_t CRYP_Phase);
void CRYP_FIFOFlush(void);
/* CRYP Data processing functions *********************************************/
void CRYP_DataIn(uint32_t Data);
uint32_t CRYP_DataOut(void);

/* CRYP Context swapping functions ********************************************/
ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
                             CRYP_KeyInitTypeDef* CRYP_KeyInitStruct);
void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore);

/* CRYP DMA interface function ************************************************/
void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState);

/* Interrupts and flags management functions **********************************/
void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState);
ITStatus CRYP_GetITStatus(uint8_t CRYP_IT);
FunctionalState CRYP_GetCmdStatus(void);
FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG);

/* High Level AES functions **************************************************/
ErrorStatus CRYP_AES_ECB(uint8_t Mode,
                         uint8_t *Key, uint16_t Keysize,
                         uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output);

ErrorStatus CRYP_AES_CBC(uint8_t Mode,
                         uint8_t InitVectors[16],
                         uint8_t *Key, uint16_t Keysize,
                         uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output);

ErrorStatus CRYP_AES_CTR(uint8_t Mode,
                         uint8_t InitVectors[16],
                         uint8_t *Key, uint16_t Keysize,
                         uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output);

ErrorStatus CRYP_AES_GCM(uint8_t Mode, uint8_t InitVectors[16],
                         uint8_t *Key, uint16_t Keysize,
                         uint8_t *Input, uint32_t ILength,
                         uint8_t *Header, uint32_t HLength,
                         uint8_t *Output, uint8_t *AuthTAG);

ErrorStatus CRYP_AES_CCM(uint8_t Mode, 
                         uint8_t* Nonce, uint32_t NonceSize,
                         uint8_t* Key, uint16_t Keysize,
                         uint8_t* Input, uint32_t ILength,
                         uint8_t* Header, uint32_t HLength, uint8_t *HBuffer,
                         uint8_t* Output,
                         uint8_t* AuthTAG, uint32_t TAGSize);

/* High Level TDES functions **************************************************/
ErrorStatus CRYP_TDES_ECB(uint8_t Mode,
                           uint8_t Key[24], 
                           uint8_t *Input, uint32_t Ilength,
                           uint8_t *Output);

ErrorStatus CRYP_TDES_CBC(uint8_t Mode,
                          uint8_t Key[24],
                          uint8_t InitVectors[8],
                          uint8_t *Input, uint32_t Ilength,
                          uint8_t *Output);

/* High Level DES functions **************************************************/
ErrorStatus CRYP_DES_ECB(uint8_t Mode,
                         uint8_t Key[8],
                         uint8_t *Input, uint32_t Ilength,
                         uint8_t *Output);

ErrorStatus CRYP_DES_CBC(uint8_t Mode,
                         uint8_t Key[8],
                         uint8_t InitVectors[8],
                         uint8_t *Input,uint32_t Ilength,
                         uint8_t *Output);

#endif

#ifdef __cplusplus
}
#endif

/**
  * @}
  */

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_cryp.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_flash.h
/**
  ******************************************************************************
  * @file    stm32f4xx_flash.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the FLASH 
  *          firmware library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_FLASH_H
#define __STM32F4xx_FLASH_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup FLASH
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
/** 
  * @brief FLASH Status  
  */ 
typedef enum
{ 
  FLASH_BUSY = 1,
  FLASH_ERROR_RD,
  FLASH_ERROR_PGS,
  FLASH_ERROR_PGP,
  FLASH_ERROR_PGA,
  FLASH_ERROR_WRP,
  FLASH_ERROR_PROGRAM,
  FLASH_ERROR_OPERATION,
  FLASH_COMPLETE
}FLASH_Status;

/* Exported constants --------------------------------------------------------*/

/** @defgroup FLASH_Exported_Constants
  * @{
  */  

/** @defgroup Flash_Latency 
  * @{
  */ 
#define FLASH_Latency_0                ((uint8_t)0x0000)  /*!< FLASH Zero Latency cycle      */
#define FLASH_Latency_1                ((uint8_t)0x0001)  /*!< FLASH One Latency cycle       */
#define FLASH_Latency_2                ((uint8_t)0x0002)  /*!< FLASH Two Latency cycles      */
#define FLASH_Latency_3                ((uint8_t)0x0003)  /*!< FLASH Three Latency cycles    */
#define FLASH_Latency_4                ((uint8_t)0x0004)  /*!< FLASH Four Latency cycles     */
#define FLASH_Latency_5                ((uint8_t)0x0005)  /*!< FLASH Five Latency cycles     */
#define FLASH_Latency_6                ((uint8_t)0x0006)  /*!< FLASH Six Latency cycles      */
#define FLASH_Latency_7                ((uint8_t)0x0007)  /*!< FLASH Seven Latency cycles    */
#define FLASH_Latency_8                ((uint8_t)0x0008)  /*!< FLASH Eight Latency cycles    */
#define FLASH_Latency_9                ((uint8_t)0x0009)  /*!< FLASH Nine Latency cycles     */
#define FLASH_Latency_10               ((uint8_t)0x000A)  /*!< FLASH Ten Latency cycles      */
#define FLASH_Latency_11               ((uint8_t)0x000B)  /*!< FLASH Eleven Latency cycles   */
#define FLASH_Latency_12               ((uint8_t)0x000C)  /*!< FLASH Twelve Latency cycles   */
#define FLASH_Latency_13               ((uint8_t)0x000D)  /*!< FLASH Thirteen Latency cycles */
#define FLASH_Latency_14               ((uint8_t)0x000E)  /*!< FLASH Fourteen Latency cycles */
#define FLASH_Latency_15               ((uint8_t)0x000F)  /*!< FLASH Fifteen Latency cycles  */


#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0)  || \
                                   ((LATENCY) == FLASH_Latency_1)  || \
                                   ((LATENCY) == FLASH_Latency_2)  || \
                                   ((LATENCY) == FLASH_Latency_3)  || \
                                   ((LATENCY) == FLASH_Latency_4)  || \
                                   ((LATENCY) == FLASH_Latency_5)  || \
                                   ((LATENCY) == FLASH_Latency_6)  || \
                                   ((LATENCY) == FLASH_Latency_7)  || \
                                   ((LATENCY) == FLASH_Latency_8)  || \
                                   ((LATENCY) == FLASH_Latency_9)  || \
                                   ((LATENCY) == FLASH_Latency_10) || \
                                   ((LATENCY) == FLASH_Latency_11) || \
                                   ((LATENCY) == FLASH_Latency_12) || \
                                   ((LATENCY) == FLASH_Latency_13) || \
                                   ((LATENCY) == FLASH_Latency_14) || \
                                   ((LATENCY) == FLASH_Latency_15))
/**
  * @}
  */ 

/** @defgroup FLASH_Voltage_Range 
  * @{
  */ 
#define VoltageRange_1        ((uint8_t)0x00)  /*!< Device operating range: 1.8V to 2.1V */
#define VoltageRange_2        ((uint8_t)0x01)  /*!<Device operating range: 2.1V to 2.7V */
#define VoltageRange_3        ((uint8_t)0x02)  /*!<Device operating range: 2.7V to 3.6V */
#define VoltageRange_4        ((uint8_t)0x03)  /*!<Device operating range: 2.7V to 3.6V + External Vpp */

#define IS_VOLTAGERANGE(RANGE)(((RANGE) == VoltageRange_1) || \
                               ((RANGE) == VoltageRange_2) || \
                               ((RANGE) == VoltageRange_3) || \
                               ((RANGE) == VoltageRange_4))
/**
  * @}
  */ 

/** @defgroup FLASH_Sectors
  * @{
  */
#define FLASH_Sector_0     ((uint16_t)0x0000) /*!< Sector Number 0   */
#define FLASH_Sector_1     ((uint16_t)0x0008) /*!< Sector Number 1   */
#define FLASH_Sector_2     ((uint16_t)0x0010) /*!< Sector Number 2   */
#define FLASH_Sector_3     ((uint16_t)0x0018) /*!< Sector Number 3   */
#define FLASH_Sector_4     ((uint16_t)0x0020) /*!< Sector Number 4   */
#define FLASH_Sector_5     ((uint16_t)0x0028) /*!< Sector Number 5   */
#define FLASH_Sector_6     ((uint16_t)0x0030) /*!< Sector Number 6   */
#define FLASH_Sector_7     ((uint16_t)0x0038) /*!< Sector Number 7   */
#define FLASH_Sector_8     ((uint16_t)0x0040) /*!< Sector Number 8   */
#define FLASH_Sector_9     ((uint16_t)0x0048) /*!< Sector Number 9   */
#define FLASH_Sector_10    ((uint16_t)0x0050) /*!< Sector Number 10  */
#define FLASH_Sector_11    ((uint16_t)0x0058) /*!< Sector Number 11  */
#define FLASH_Sector_12    ((uint16_t)0x0080) /*!< Sector Number 12  */
#define FLASH_Sector_13    ((uint16_t)0x0088) /*!< Sector Number 13  */
#define FLASH_Sector_14    ((uint16_t)0x0090) /*!< Sector Number 14  */
#define FLASH_Sector_15    ((uint16_t)0x0098) /*!< Sector Number 15  */
#define FLASH_Sector_16    ((uint16_t)0x00A0) /*!< Sector Number 16  */
#define FLASH_Sector_17    ((uint16_t)0x00A8) /*!< Sector Number 17  */
#define FLASH_Sector_18    ((uint16_t)0x00B0) /*!< Sector Number 18  */
#define FLASH_Sector_19    ((uint16_t)0x00B8) /*!< Sector Number 19  */
#define FLASH_Sector_20    ((uint16_t)0x00C0) /*!< Sector Number 20  */
#define FLASH_Sector_21    ((uint16_t)0x00C8) /*!< Sector Number 21  */
#define FLASH_Sector_22    ((uint16_t)0x00D0) /*!< Sector Number 22  */
#define FLASH_Sector_23    ((uint16_t)0x00D8) /*!< Sector Number 23  */

#define IS_FLASH_SECTOR(SECTOR) (((SECTOR) == FLASH_Sector_0)   || ((SECTOR) == FLASH_Sector_1)   ||\
                                 ((SECTOR) == FLASH_Sector_2)   || ((SECTOR) == FLASH_Sector_3)   ||\
                                 ((SECTOR) == FLASH_Sector_4)   || ((SECTOR) == FLASH_Sector_5)   ||\
                                 ((SECTOR) == FLASH_Sector_6)   || ((SECTOR) == FLASH_Sector_7)   ||\
                                 ((SECTOR) == FLASH_Sector_8)   || ((SECTOR) == FLASH_Sector_9)   ||\
                                 ((SECTOR) == FLASH_Sector_10)  || ((SECTOR) == FLASH_Sector_11)  ||\
                                 ((SECTOR) == FLASH_Sector_12)  || ((SECTOR) == FLASH_Sector_13)  ||\
                                 ((SECTOR) == FLASH_Sector_14)  || ((SECTOR) == FLASH_Sector_15)  ||\
                                 ((SECTOR) == FLASH_Sector_16)  || ((SECTOR) == FLASH_Sector_17)  ||\
                                 ((SECTOR) == FLASH_Sector_18)  || ((SECTOR) == FLASH_Sector_19)  ||\
                                 ((SECTOR) == FLASH_Sector_20)  || ((SECTOR) == FLASH_Sector_21)  ||\
                                 ((SECTOR) == FLASH_Sector_22)  || ((SECTOR) == FLASH_Sector_23))

#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x081FFFFF)) ||\
                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))  
#endif /* STM32F427_437xx ||  STM32F429_439xx */

#if defined (STM32F40_41xxx)
#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x080FFFFF)) ||\
                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F))) 
#endif /* STM32F40_41xxx */

#if defined (STM32F401xx)
#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0803FFFF)) ||\
                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))
#endif /* STM32F401xx */

#if defined (STM32F411xE)
#define IS_FLASH_ADDRESS(ADDRESS) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) <= 0x0807FFFF)) ||\
                                   (((ADDRESS) >= 0x1FFF7800) && ((ADDRESS) <= 0x1FFF7A0F)))
#endif /* STM32F411xE */

/**
  * @}
  */ 

/** @defgroup Option_Bytes_Write_Protection 
  * @{
  */ 
#define OB_WRP_Sector_0       ((uint32_t)0x00000001) /*!< Write protection of Sector0     */
#define OB_WRP_Sector_1       ((uint32_t)0x00000002) /*!< Write protection of Sector1     */
#define OB_WRP_Sector_2       ((uint32_t)0x00000004) /*!< Write protection of Sector2     */
#define OB_WRP_Sector_3       ((uint32_t)0x00000008) /*!< Write protection of Sector3     */
#define OB_WRP_Sector_4       ((uint32_t)0x00000010) /*!< Write protection of Sector4     */
#define OB_WRP_Sector_5       ((uint32_t)0x00000020) /*!< Write protection of Sector5     */
#define OB_WRP_Sector_6       ((uint32_t)0x00000040) /*!< Write protection of Sector6     */
#define OB_WRP_Sector_7       ((uint32_t)0x00000080) /*!< Write protection of Sector7     */
#define OB_WRP_Sector_8       ((uint32_t)0x00000100) /*!< Write protection of Sector8     */
#define OB_WRP_Sector_9       ((uint32_t)0x00000200) /*!< Write protection of Sector9     */
#define OB_WRP_Sector_10      ((uint32_t)0x00000400) /*!< Write protection of Sector10    */
#define OB_WRP_Sector_11      ((uint32_t)0x00000800) /*!< Write protection of Sector11    */
#define OB_WRP_Sector_12      ((uint32_t)0x00000001) /*!< Write protection of Sector12    */
#define OB_WRP_Sector_13      ((uint32_t)0x00000002) /*!< Write protection of Sector13    */
#define OB_WRP_Sector_14      ((uint32_t)0x00000004) /*!< Write protection of Sector14    */
#define OB_WRP_Sector_15      ((uint32_t)0x00000008) /*!< Write protection of Sector15    */
#define OB_WRP_Sector_16      ((uint32_t)0x00000010) /*!< Write protection of Sector16    */
#define OB_WRP_Sector_17      ((uint32_t)0x00000020) /*!< Write protection of Sector17    */
#define OB_WRP_Sector_18      ((uint32_t)0x00000040) /*!< Write protection of Sector18    */
#define OB_WRP_Sector_19      ((uint32_t)0x00000080) /*!< Write protection of Sector19    */
#define OB_WRP_Sector_20      ((uint32_t)0x00000100) /*!< Write protection of Sector20    */
#define OB_WRP_Sector_21      ((uint32_t)0x00000200) /*!< Write protection of Sector21    */
#define OB_WRP_Sector_22      ((uint32_t)0x00000400) /*!< Write protection of Sector22    */
#define OB_WRP_Sector_23      ((uint32_t)0x00000800) /*!< Write protection of Sector23    */
#define OB_WRP_Sector_All     ((uint32_t)0x00000FFF) /*!< Write protection of all Sectors */

#define IS_OB_WRP(SECTOR)((((SECTOR) & (uint32_t)0xFFFFF000) == 0x00000000) && ((SECTOR) != 0x00000000))
/**
  * @}
  */

/** @defgroup  Selection_Protection_Mode
  * @{
  */
#define OB_PcROP_Disable   ((uint8_t)0x00) /*!< Disabled PcROP, nWPRi bits used for Write Protection on sector i */
#define OB_PcROP_Enable    ((uint8_t)0x80) /*!< Enable PcROP, nWPRi bits used for PCRoP Protection on sector i   */
#define IS_OB_PCROP_SELECT(PCROP) (((PCROP) == OB_PcROP_Disable) || ((PCROP) == OB_PcROP_Enable))
/**
  * @}
  */

/** @defgroup Option_Bytes_PC_ReadWrite_Protection 
  * @{
  */ 
#define OB_PCROP_Sector_0        ((uint32_t)0x00000001) /*!< PC Read/Write protection of Sector0      */
#define OB_PCROP_Sector_1        ((uint32_t)0x00000002) /*!< PC Read/Write protection of Sector1      */
#define OB_PCROP_Sector_2        ((uint32_t)0x00000004) /*!< PC Read/Write protection of Sector2      */
#define OB_PCROP_Sector_3        ((uint32_t)0x00000008) /*!< PC Read/Write protection of Sector3      */
#define OB_PCROP_Sector_4        ((uint32_t)0x00000010) /*!< PC Read/Write protection of Sector4      */
#define OB_PCROP_Sector_5        ((uint32_t)0x00000020) /*!< PC Read/Write protection of Sector5      */
#define OB_PCROP_Sector_6        ((uint32_t)0x00000040) /*!< PC Read/Write protection of Sector6      */
#define OB_PCROP_Sector_7        ((uint32_t)0x00000080) /*!< PC Read/Write protection of Sector7      */
#define OB_PCROP_Sector_8        ((uint32_t)0x00000100) /*!< PC Read/Write protection of Sector8      */
#define OB_PCROP_Sector_9        ((uint32_t)0x00000200) /*!< PC Read/Write protection of Sector9      */
#define OB_PCROP_Sector_10       ((uint32_t)0x00000400) /*!< PC Read/Write protection of Sector10     */
#define OB_PCROP_Sector_11       ((uint32_t)0x00000800) /*!< PC Read/Write protection of Sector11     */
#define OB_PCROP_Sector_12       ((uint32_t)0x00000001) /*!< PC Read/Write protection of Sector12     */
#define OB_PCROP_Sector_13       ((uint32_t)0x00000002) /*!< PC Read/Write protection of Sector13     */
#define OB_PCROP_Sector_14       ((uint32_t)0x00000004) /*!< PC Read/Write protection of Sector14     */
#define OB_PCROP_Sector_15       ((uint32_t)0x00000008) /*!< PC Read/Write protection of Sector15     */
#define OB_PCROP_Sector_16       ((uint32_t)0x00000010) /*!< PC Read/Write protection of Sector16     */
#define OB_PCROP_Sector_17       ((uint32_t)0x00000020) /*!< PC Read/Write protection of Sector17     */
#define OB_PCROP_Sector_18       ((uint32_t)0x00000040) /*!< PC Read/Write protection of Sector18     */
#define OB_PCROP_Sector_19       ((uint32_t)0x00000080) /*!< PC Read/Write protection of Sector19     */
#define OB_PCROP_Sector_20       ((uint32_t)0x00000100) /*!< PC Read/Write protection of Sector20     */
#define OB_PCROP_Sector_21       ((uint32_t)0x00000200) /*!< PC Read/Write protection of Sector21     */
#define OB_PCROP_Sector_22       ((uint32_t)0x00000400) /*!< PC Read/Write protection of Sector22     */
#define OB_PCROP_Sector_23       ((uint32_t)0x00000800) /*!< PC Read/Write protection of Sector23     */
#define OB_PCROP_Sector_All      ((uint32_t)0x00000FFF) /*!< PC Read/Write protection of all Sectors  */

#define IS_OB_PCROP(SECTOR)((((SECTOR) & (uint32_t)0xFFFFF000) == 0x00000000) && ((SECTOR) != 0x00000000))
/**
  * @}
  */

/** @defgroup FLASH_Option_Bytes_Read_Protection 
  * @{
  */
#define OB_RDP_Level_0   ((uint8_t)0xAA)
#define OB_RDP_Level_1   ((uint8_t)0x55)
/*#define OB_RDP_Level_2   ((uint8_t)0xCC)*/ /*!< Warning: When enabling read protection level 2 
                                                  it's no more possible to go back to level 1 or 0 */
#define IS_OB_RDP(LEVEL) (((LEVEL) == OB_RDP_Level_0)||\
                          ((LEVEL) == OB_RDP_Level_1))/*||\
                          ((LEVEL) == OB_RDP_Level_2))*/
/**
  * @}
  */ 

/** @defgroup FLASH_Option_Bytes_IWatchdog 
  * @{
  */ 
#define OB_IWDG_SW                     ((uint8_t)0x20)  /*!< Software IWDG selected */
#define OB_IWDG_HW                     ((uint8_t)0x00)  /*!< Hardware IWDG selected */
#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
/**
  * @}
  */ 

/** @defgroup FLASH_Option_Bytes_nRST_STOP 
  * @{
  */ 
#define OB_STOP_NoRST                  ((uint8_t)0x40) /*!< No reset generated when entering in STOP */
#define OB_STOP_RST                    ((uint8_t)0x00) /*!< Reset generated when entering in STOP */
#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
/**
  * @}
  */ 


/** @defgroup FLASH_Option_Bytes_nRST_STDBY 
  * @{
  */ 
#define OB_STDBY_NoRST                 ((uint8_t)0x80) /*!< No reset generated when entering in STANDBY */
#define OB_STDBY_RST                   ((uint8_t)0x00) /*!< Reset generated when entering in STANDBY */
#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
/**
  * @}
  */
  
/** @defgroup FLASH_BOR_Reset_Level 
  * @{
  */  
#define OB_BOR_LEVEL3          ((uint8_t)0x00)  /*!< Supply voltage ranges from 2.70 to 3.60 V */
#define OB_BOR_LEVEL2          ((uint8_t)0x04)  /*!< Supply voltage ranges from 2.40 to 2.70 V */
#define OB_BOR_LEVEL1          ((uint8_t)0x08)  /*!< Supply voltage ranges from 2.10 to 2.40 V */
#define OB_BOR_OFF             ((uint8_t)0x0C)  /*!< Supply voltage ranges from 1.62 to 2.10 V */
#define IS_OB_BOR(LEVEL) (((LEVEL) == OB_BOR_LEVEL1) || ((LEVEL) == OB_BOR_LEVEL2) ||\
                          ((LEVEL) == OB_BOR_LEVEL3) || ((LEVEL) == OB_BOR_OFF))
/**
  * @}
  */
  
/** @defgroup FLASH_Dual_Boot
  * @{
  */
#define OB_Dual_BootEnabled   ((uint8_t)0x10) /*!< Dual Bank Boot Enable                             */
#define OB_Dual_BootDisabled  ((uint8_t)0x00) /*!< Dual Bank Boot Disable, always boot on User Flash */
#define IS_OB_BOOT(BOOT) (((BOOT) == OB_Dual_BootEnabled) || ((BOOT) == OB_Dual_BootDisabled))
/**
  * @}
  */

/** @defgroup FLASH_Interrupts 
  * @{
  */ 
#define FLASH_IT_EOP                   ((uint32_t)0x01000000)  /*!< End of FLASH Operation Interrupt source */
#define FLASH_IT_ERR                   ((uint32_t)0x02000000)  /*!< Error Interrupt source */
#define IS_FLASH_IT(IT) ((((IT) & (uint32_t)0xFCFFFFFF) == 0x00000000) && ((IT) != 0x00000000))
/**
  * @}
  */ 

/** @defgroup FLASH_Flags 
  * @{
  */ 
#define FLASH_FLAG_EOP                 ((uint32_t)0x00000001)  /*!< FLASH End of Operation flag               */
#define FLASH_FLAG_OPERR               ((uint32_t)0x00000002)  /*!< FLASH operation Error flag                */
#define FLASH_FLAG_WRPERR              ((uint32_t)0x00000010)  /*!< FLASH Write protected error flag          */
#define FLASH_FLAG_PGAERR              ((uint32_t)0x00000020)  /*!< FLASH Programming Alignment error flag    */
#define FLASH_FLAG_PGPERR              ((uint32_t)0x00000040)  /*!< FLASH Programming Parallelism error flag  */
#define FLASH_FLAG_PGSERR              ((uint32_t)0x00000080)  /*!< FLASH Programming Sequence error flag     */
#define FLASH_FLAG_RDERR               ((uint32_t)0x00000100)  /*!< Read Protection error flag (PCROP)        */
#define FLASH_FLAG_BSY                 ((uint32_t)0x00010000)  /*!< FLASH Busy flag                           */ 
#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFE0C) == 0x00000000) && ((FLAG) != 0x00000000))
#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_EOP)    || ((FLAG) == FLASH_FLAG_OPERR)  || \
                                  ((FLAG) == FLASH_FLAG_WRPERR) || ((FLAG) == FLASH_FLAG_PGAERR) || \
                                  ((FLAG) == FLASH_FLAG_PGPERR) || ((FLAG) == FLASH_FLAG_PGSERR) || \
                                  ((FLAG) == FLASH_FLAG_BSY)    || ((FLAG) == FLASH_FLAG_RDERR))
/**
  * @}
  */

/** @defgroup FLASH_Program_Parallelism   
  * @{
  */
#define FLASH_PSIZE_BYTE           ((uint32_t)0x00000000)
#define FLASH_PSIZE_HALF_WORD      ((uint32_t)0x00000100)
#define FLASH_PSIZE_WORD           ((uint32_t)0x00000200)
#define FLASH_PSIZE_DOUBLE_WORD    ((uint32_t)0x00000300)
#define CR_PSIZE_MASK              ((uint32_t)0xFFFFFCFF)
/**
  * @}
  */ 

/** @defgroup FLASH_Keys 
  * @{
  */ 
#define RDP_KEY                  ((uint16_t)0x00A5)
#define FLASH_KEY1               ((uint32_t)0x45670123)
#define FLASH_KEY2               ((uint32_t)0xCDEF89AB)
#define FLASH_OPT_KEY1           ((uint32_t)0x08192A3B)
#define FLASH_OPT_KEY2           ((uint32_t)0x4C5D6E7F)
/**
  * @}
  */ 

/** 
  * @brief   ACR register byte 0 (Bits[7:0]) base address  
  */ 
#define ACR_BYTE0_ADDRESS           ((uint32_t)0x40023C00) 
/** 
  * @brief   OPTCR register byte 0 (Bits[7:0]) base address  
  */ 
#define OPTCR_BYTE0_ADDRESS         ((uint32_t)0x40023C14)
/** 
  * @brief   OPTCR register byte 1 (Bits[15:8]) base address  
  */ 
#define OPTCR_BYTE1_ADDRESS         ((uint32_t)0x40023C15)
/** 
  * @brief   OPTCR register byte 2 (Bits[23:16]) base address  
  */ 
#define OPTCR_BYTE2_ADDRESS         ((uint32_t)0x40023C16)
/** 
  * @brief   OPTCR register byte 3 (Bits[31:24]) base address  
  */ 
#define OPTCR_BYTE3_ADDRESS         ((uint32_t)0x40023C17)

/** 
  * @brief   OPTCR1 register byte 0 (Bits[7:0]) base address  
  */ 
#define OPTCR1_BYTE2_ADDRESS         ((uint32_t)0x40023C1A)

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 
 
/* FLASH Interface configuration functions ************************************/
void FLASH_SetLatency(uint32_t FLASH_Latency);
void FLASH_PrefetchBufferCmd(FunctionalState NewState);
void FLASH_InstructionCacheCmd(FunctionalState NewState);
void FLASH_DataCacheCmd(FunctionalState NewState);
void FLASH_InstructionCacheReset(void);
void FLASH_DataCacheReset(void);

/* FLASH Memory Programming functions *****************************************/   
void         FLASH_Unlock(void);
void         FLASH_Lock(void);
FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange);
FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange);
FLASH_Status FLASH_EraseAllBank1Sectors(uint8_t VoltageRange);
FLASH_Status FLASH_EraseAllBank2Sectors(uint8_t VoltageRange);
FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data);
FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data);
FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data);
FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data);

/* Option Bytes Programming functions *****************************************/ 
void         FLASH_OB_Unlock(void);
void         FLASH_OB_Lock(void);
void         FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState);
void         FLASH_OB_WRP1Config(uint32_t OB_WRP, FunctionalState NewState);
void         FLASH_OB_PCROPSelectionConfig(uint8_t OB_PcROP);
void         FLASH_OB_PCROPConfig(uint32_t OB_PCROP, FunctionalState NewState);
void         FLASH_OB_PCROP1Config(uint32_t OB_PCROP, FunctionalState NewState);
void         FLASH_OB_RDPConfig(uint8_t OB_RDP);
void         FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY);
void         FLASH_OB_BORConfig(uint8_t OB_BOR);
void         FLASH_OB_BootConfig(uint8_t OB_BOOT);
FLASH_Status FLASH_OB_Launch(void);
uint8_t      FLASH_OB_GetUser(void);
uint16_t     FLASH_OB_GetWRP(void);
uint16_t     FLASH_OB_GetWRP1(void);
uint16_t     FLASH_OB_GetPCROP(void);
uint16_t     FLASH_OB_GetPCROP1(void);
FlagStatus   FLASH_OB_GetRDP(void);
uint8_t      FLASH_OB_GetBOR(void);

/* Interrupts and flags management functions **********************************/
void         FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState);
FlagStatus   FLASH_GetFlagStatus(uint32_t FLASH_FLAG);
void         FLASH_ClearFlag(uint32_t FLASH_FLAG);
FLASH_Status FLASH_GetStatus(void);
FLASH_Status FLASH_WaitForLastOperation(void);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_FLASH_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_flash.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_can.h
/**
  ******************************************************************************
  * @file    stm32f4xx_can.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the CAN firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#pragma once

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

#if defined(STM32PLUS_F4_HAS_CAN)

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup CAN
  * @{
  */

/* Exported types ------------------------------------------------------------*/

#define IS_CAN_ALL_PERIPH(PERIPH) (((PERIPH) == CAN1) || \
                                   ((PERIPH) == CAN2))

/** 
  * @brief  CAN init structure definition
  */
typedef struct
{
  uint16_t CAN_Prescaler;   /*!< Specifies the length of a time quantum. 
                                 It ranges from 1 to 1024. */
  
  uint8_t CAN_Mode;         /*!< Specifies the CAN operating mode.
                                 This parameter can be a value of @ref CAN_operating_mode */

  uint8_t CAN_SJW;          /*!< Specifies the maximum number of time quanta 
                                 the CAN hardware is allowed to lengthen or 
                                 shorten a bit to perform resynchronization.
                                 This parameter can be a value of @ref CAN_synchronisation_jump_width */

  uint8_t CAN_BS1;          /*!< Specifies the number of time quanta in Bit 
                                 Segment 1. This parameter can be a value of 
                                 @ref CAN_time_quantum_in_bit_segment_1 */

  uint8_t CAN_BS2;          /*!< Specifies the number of time quanta in Bit Segment 2.
                                 This parameter can be a value of @ref CAN_time_quantum_in_bit_segment_2 */
  
  FunctionalState CAN_TTCM; /*!< Enable or disable the time triggered communication mode.
                                This parameter can be set either to ENABLE or DISABLE. */
  
  FunctionalState CAN_ABOM;  /*!< Enable or disable the automatic bus-off management.
                                  This parameter can be set either to ENABLE or DISABLE. */

  FunctionalState CAN_AWUM;  /*!< Enable or disable the automatic wake-up mode. 
                                  This parameter can be set either to ENABLE or DISABLE. */

  FunctionalState CAN_NART;  /*!< Enable or disable the non-automatic retransmission mode.
                                  This parameter can be set either to ENABLE or DISABLE. */

  FunctionalState CAN_RFLM;  /*!< Enable or disable the Receive FIFO Locked mode.
                                  This parameter can be set either to ENABLE or DISABLE. */

  FunctionalState CAN_TXFP;  /*!< Enable or disable the transmit FIFO priority.
                                  This parameter can be set either to ENABLE or DISABLE. */
} CAN_InitTypeDef;

/** 
  * @brief  CAN filter init structure definition
  */
typedef struct
{
  uint16_t CAN_FilterIdHigh;         /*!< Specifies the filter identification number (MSBs for a 32-bit
                                              configuration, first one for a 16-bit configuration).
                                              This parameter can be a value between 0x0000 and 0xFFFF */

  uint16_t CAN_FilterIdLow;          /*!< Specifies the filter identification number (LSBs for a 32-bit
                                              configuration, second one for a 16-bit configuration).
                                              This parameter can be a value between 0x0000 and 0xFFFF */

  uint16_t CAN_FilterMaskIdHigh;     /*!< Specifies the filter mask number or identification number,
                                              according to the mode (MSBs for a 32-bit configuration,
                                              first one for a 16-bit configuration).
                                              This parameter can be a value between 0x0000 and 0xFFFF */

  uint16_t CAN_FilterMaskIdLow;      /*!< Specifies the filter mask number or identification number,
                                              according to the mode (LSBs for a 32-bit configuration,
                                              second one for a 16-bit configuration).
                                              This parameter can be a value between 0x0000 and 0xFFFF */

  uint16_t CAN_FilterFIFOAssignment; /*!< Specifies the FIFO (0 or 1) which will be assigned to the filter.
                                              This parameter can be a value of @ref CAN_filter_FIFO */
  
  uint8_t CAN_FilterNumber;          /*!< Specifies the filter which will be initialized. It ranges from 0 to 13. */

  uint8_t CAN_FilterMode;            /*!< Specifies the filter mode to be initialized.
                                              This parameter can be a value of @ref CAN_filter_mode */

  uint8_t CAN_FilterScale;           /*!< Specifies the filter scale.
                                              This parameter can be a value of @ref CAN_filter_scale */

  FunctionalState CAN_FilterActivation; /*!< Enable or disable the filter.
                                              This parameter can be set either to ENABLE or DISABLE. */
} CAN_FilterInitTypeDef;

/** 
  * @brief  CAN Tx message structure definition  
  */
typedef struct
{
  uint32_t StdId;  /*!< Specifies the standard identifier.
                        This parameter can be a value between 0 to 0x7FF. */

  uint32_t ExtId;  /*!< Specifies the extended identifier.
                        This parameter can be a value between 0 to 0x1FFFFFFF. */

  uint8_t IDE;     /*!< Specifies the type of identifier for the message that 
                        will be transmitted. This parameter can be a value 
                        of @ref CAN_identifier_type */

  uint8_t RTR;     /*!< Specifies the type of frame for the message that will 
                        be transmitted. This parameter can be a value of 
                        @ref CAN_remote_transmission_request */

  uint8_t DLC;     /*!< Specifies the length of the frame that will be 
                        transmitted. This parameter can be a value between 
                        0 to 8 */

  uint8_t Data[8]; /*!< Contains the data to be transmitted. It ranges from 0 
                        to 0xFF. */
} CanTxMsg;

/** 
  * @brief  CAN Rx message structure definition  
  */
typedef struct
{
  uint32_t StdId;  /*!< Specifies the standard identifier.
                        This parameter can be a value between 0 to 0x7FF. */

  uint32_t ExtId;  /*!< Specifies the extended identifier.
                        This parameter can be a value between 0 to 0x1FFFFFFF. */

  uint8_t IDE;     /*!< Specifies the type of identifier for the message that 
                        will be received. This parameter can be a value of 
                        @ref CAN_identifier_type */

  uint8_t RTR;     /*!< Specifies the type of frame for the received message.
                        This parameter can be a value of 
                        @ref CAN_remote_transmission_request */

  uint8_t DLC;     /*!< Specifies the length of the frame that will be received.
                        This parameter can be a value between 0 to 8 */

  uint8_t Data[8]; /*!< Contains the data to be received. It ranges from 0 to 
                        0xFF. */

  uint8_t FMI;     /*!< Specifies the index of the filter the message stored in 
                        the mailbox passes through. This parameter can be a 
                        value between 0 to 0xFF */
} CanRxMsg;

/* Exported constants --------------------------------------------------------*/

/** @defgroup CAN_Exported_Constants
  * @{
  */

/** @defgroup CAN_InitStatus 
  * @{
  */

#define CAN_InitStatus_Failed              ((uint8_t)0x00) /*!< CAN initialization failed */
#define CAN_InitStatus_Success             ((uint8_t)0x01) /*!< CAN initialization OK */


/* Legacy defines */
#define CANINITFAILED    CAN_InitStatus_Failed
#define CANINITOK        CAN_InitStatus_Success
/**
  * @}
  */

/** @defgroup CAN_operating_mode 
  * @{
  */

#define CAN_Mode_Normal             ((uint8_t)0x00)  /*!< normal mode */
#define CAN_Mode_LoopBack           ((uint8_t)0x01)  /*!< loopback mode */
#define CAN_Mode_Silent             ((uint8_t)0x02)  /*!< silent mode */
#define CAN_Mode_Silent_LoopBack    ((uint8_t)0x03)  /*!< loopback combined with silent mode */

#define IS_CAN_MODE(MODE) (((MODE) == CAN_Mode_Normal) || \
                           ((MODE) == CAN_Mode_LoopBack)|| \
                           ((MODE) == CAN_Mode_Silent) || \
                           ((MODE) == CAN_Mode_Silent_LoopBack))
/**
  * @}
  */


 /**
  * @defgroup CAN_operating_mode 
  * @{
  */  
#define CAN_OperatingMode_Initialization  ((uint8_t)0x00) /*!< Initialization mode */
#define CAN_OperatingMode_Normal          ((uint8_t)0x01) /*!< Normal mode */
#define CAN_OperatingMode_Sleep           ((uint8_t)0x02) /*!< sleep mode */


#define IS_CAN_OPERATING_MODE(MODE) (((MODE) == CAN_OperatingMode_Initialization) ||\
                                    ((MODE) == CAN_OperatingMode_Normal)|| \
																		((MODE) == CAN_OperatingMode_Sleep))
/**
  * @}
  */
  
/**
  * @defgroup CAN_operating_mode_status
  * @{
  */  

#define CAN_ModeStatus_Failed    ((uint8_t)0x00)                /*!< CAN entering the specific mode failed */
#define CAN_ModeStatus_Success   ((uint8_t)!CAN_ModeStatus_Failed)   /*!< CAN entering the specific mode Succeed */
/**
  * @}
  */

/** @defgroup CAN_synchronisation_jump_width 
  * @{
  */
#define CAN_SJW_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
#define CAN_SJW_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
#define CAN_SJW_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
#define CAN_SJW_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */

#define IS_CAN_SJW(SJW) (((SJW) == CAN_SJW_1tq) || ((SJW) == CAN_SJW_2tq)|| \
                         ((SJW) == CAN_SJW_3tq) || ((SJW) == CAN_SJW_4tq))
/**
  * @}
  */

/** @defgroup CAN_time_quantum_in_bit_segment_1 
  * @{
  */
#define CAN_BS1_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
#define CAN_BS1_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
#define CAN_BS1_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
#define CAN_BS1_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
#define CAN_BS1_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
#define CAN_BS1_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
#define CAN_BS1_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
#define CAN_BS1_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */
#define CAN_BS1_9tq                 ((uint8_t)0x08)  /*!< 9 time quantum */
#define CAN_BS1_10tq                ((uint8_t)0x09)  /*!< 10 time quantum */
#define CAN_BS1_11tq                ((uint8_t)0x0A)  /*!< 11 time quantum */
#define CAN_BS1_12tq                ((uint8_t)0x0B)  /*!< 12 time quantum */
#define CAN_BS1_13tq                ((uint8_t)0x0C)  /*!< 13 time quantum */
#define CAN_BS1_14tq                ((uint8_t)0x0D)  /*!< 14 time quantum */
#define CAN_BS1_15tq                ((uint8_t)0x0E)  /*!< 15 time quantum */
#define CAN_BS1_16tq                ((uint8_t)0x0F)  /*!< 16 time quantum */

#define IS_CAN_BS1(BS1) ((BS1) <= CAN_BS1_16tq)
/**
  * @}
  */

/** @defgroup CAN_time_quantum_in_bit_segment_2 
  * @{
  */
#define CAN_BS2_1tq                 ((uint8_t)0x00)  /*!< 1 time quantum */
#define CAN_BS2_2tq                 ((uint8_t)0x01)  /*!< 2 time quantum */
#define CAN_BS2_3tq                 ((uint8_t)0x02)  /*!< 3 time quantum */
#define CAN_BS2_4tq                 ((uint8_t)0x03)  /*!< 4 time quantum */
#define CAN_BS2_5tq                 ((uint8_t)0x04)  /*!< 5 time quantum */
#define CAN_BS2_6tq                 ((uint8_t)0x05)  /*!< 6 time quantum */
#define CAN_BS2_7tq                 ((uint8_t)0x06)  /*!< 7 time quantum */
#define CAN_BS2_8tq                 ((uint8_t)0x07)  /*!< 8 time quantum */

#define IS_CAN_BS2(BS2) ((BS2) <= CAN_BS2_8tq)
/**
  * @}
  */

/** @defgroup CAN_clock_prescaler 
  * @{
  */
#define IS_CAN_PRESCALER(PRESCALER) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))
/**
  * @}
  */

/** @defgroup CAN_filter_number 
  * @{
  */
#define IS_CAN_FILTER_NUMBER(NUMBER) ((NUMBER) <= 27)
/**
  * @}
  */

/** @defgroup CAN_filter_mode 
  * @{
  */
#define CAN_FilterMode_IdMask       ((uint8_t)0x00)  /*!< identifier/mask mode */
#define CAN_FilterMode_IdList       ((uint8_t)0x01)  /*!< identifier list mode */

#define IS_CAN_FILTER_MODE(MODE) (((MODE) == CAN_FilterMode_IdMask) || \
                                  ((MODE) == CAN_FilterMode_IdList))
/**
  * @}
  */

/** @defgroup CAN_filter_scale 
  * @{
  */
#define CAN_FilterScale_16bit       ((uint8_t)0x00) /*!< Two 16-bit filters */
#define CAN_FilterScale_32bit       ((uint8_t)0x01) /*!< One 32-bit filter */

#define IS_CAN_FILTER_SCALE(SCALE) (((SCALE) == CAN_FilterScale_16bit) || \
                                    ((SCALE) == CAN_FilterScale_32bit))
/**
  * @}
  */

/** @defgroup CAN_filter_FIFO
  * @{
  */
#define CAN_Filter_FIFO0             ((uint8_t)0x00)  /*!< Filter FIFO 0 assignment for filter x */
#define CAN_Filter_FIFO1             ((uint8_t)0x01)  /*!< Filter FIFO 1 assignment for filter x */
#define IS_CAN_FILTER_FIFO(FIFO) (((FIFO) == CAN_FilterFIFO0) || \
                                  ((FIFO) == CAN_FilterFIFO1))

/* Legacy defines */
#define CAN_FilterFIFO0  CAN_Filter_FIFO0
#define CAN_FilterFIFO1  CAN_Filter_FIFO1
/**
  * @}
  */

/** @defgroup CAN_Start_bank_filter_for_slave_CAN 
  * @{
  */
#define IS_CAN_BANKNUMBER(BANKNUMBER) (((BANKNUMBER) >= 1) && ((BANKNUMBER) <= 27))
/**
  * @}
  */

/** @defgroup CAN_Tx 
  * @{
  */
#define IS_CAN_TRANSMITMAILBOX(TRANSMITMAILBOX) ((TRANSMITMAILBOX) <= ((uint8_t)0x02))
#define IS_CAN_STDID(STDID)   ((STDID) <= ((uint32_t)0x7FF))
#define IS_CAN_EXTID(EXTID)   ((EXTID) <= ((uint32_t)0x1FFFFFFF))
#define IS_CAN_DLC(DLC)       ((DLC) <= ((uint8_t)0x08))
/**
  * @}
  */

/** @defgroup CAN_identifier_type 
  * @{
  */
#define CAN_Id_Standard             ((uint32_t)0x00000000)  /*!< Standard Id */
#define CAN_Id_Extended             ((uint32_t)0x00000004)  /*!< Extended Id */
#define IS_CAN_IDTYPE(IDTYPE) (((IDTYPE) == CAN_Id_Standard) || \
                               ((IDTYPE) == CAN_Id_Extended))

/* Legacy defines */
#define CAN_ID_STD      CAN_Id_Standard           
#define CAN_ID_EXT      CAN_Id_Extended
/**
  * @}
  */

/** @defgroup CAN_remote_transmission_request 
  * @{
  */
#define CAN_RTR_Data                ((uint32_t)0x00000000)  /*!< Data frame */
#define CAN_RTR_Remote              ((uint32_t)0x00000002)  /*!< Remote frame */
#define IS_CAN_RTR(RTR) (((RTR) == CAN_RTR_Data) || ((RTR) == CAN_RTR_Remote))

/* Legacy defines */
#define CAN_RTR_DATA     CAN_RTR_Data         
#define CAN_RTR_REMOTE   CAN_RTR_Remote
/**
  * @}
  */

/** @defgroup CAN_transmit_constants 
  * @{
  */
#define CAN_TxStatus_Failed         ((uint8_t)0x00)/*!< CAN transmission failed */
#define CAN_TxStatus_Ok             ((uint8_t)0x01) /*!< CAN transmission succeeded */
#define CAN_TxStatus_Pending        ((uint8_t)0x02) /*!< CAN transmission pending */
#define CAN_TxStatus_NoMailBox      ((uint8_t)0x04) /*!< CAN cell did not provide 
                                                         an empty mailbox */
/* Legacy defines */	
#define CANTXFAILED                  CAN_TxStatus_Failed
#define CANTXOK                      CAN_TxStatus_Ok
#define CANTXPENDING                 CAN_TxStatus_Pending
#define CAN_NO_MB                    CAN_TxStatus_NoMailBox
/**
  * @}
  */

/** @defgroup CAN_receive_FIFO_number_constants 
  * @{
  */
#define CAN_FIFO0                 ((uint8_t)0x00) /*!< CAN FIFO 0 used to receive */
#define CAN_FIFO1                 ((uint8_t)0x01) /*!< CAN FIFO 1 used to receive */

#define IS_CAN_FIFO(FIFO) (((FIFO) == CAN_FIFO0) || ((FIFO) == CAN_FIFO1))
/**
  * @}
  */

/** @defgroup CAN_sleep_constants 
  * @{
  */
#define CAN_Sleep_Failed     ((uint8_t)0x00) /*!< CAN did not enter the sleep mode */
#define CAN_Sleep_Ok         ((uint8_t)0x01) /*!< CAN entered the sleep mode */

/* Legacy defines */	
#define CANSLEEPFAILED   CAN_Sleep_Failed
#define CANSLEEPOK       CAN_Sleep_Ok
/**
  * @}
  */

/** @defgroup CAN_wake_up_constants 
  * @{
  */
#define CAN_WakeUp_Failed        ((uint8_t)0x00) /*!< CAN did not leave the sleep mode */
#define CAN_WakeUp_Ok            ((uint8_t)0x01) /*!< CAN leaved the sleep mode */

/* Legacy defines */
#define CANWAKEUPFAILED   CAN_WakeUp_Failed        
#define CANWAKEUPOK       CAN_WakeUp_Ok        
/**
  * @}
  */

/**
  * @defgroup CAN_Error_Code_constants
  * @{
  */                                                         
#define CAN_ErrorCode_NoErr           ((uint8_t)0x00) /*!< No Error */ 
#define	CAN_ErrorCode_StuffErr        ((uint8_t)0x10) /*!< Stuff Error */ 
#define	CAN_ErrorCode_FormErr         ((uint8_t)0x20) /*!< Form Error */ 
#define	CAN_ErrorCode_ACKErr          ((uint8_t)0x30) /*!< Acknowledgment Error */ 
#define	CAN_ErrorCode_BitRecessiveErr ((uint8_t)0x40) /*!< Bit Recessive Error */ 
#define	CAN_ErrorCode_BitDominantErr  ((uint8_t)0x50) /*!< Bit Dominant Error */ 
#define	CAN_ErrorCode_CRCErr          ((uint8_t)0x60) /*!< CRC Error  */ 
#define	CAN_ErrorCode_SoftwareSetErr  ((uint8_t)0x70) /*!< Software Set Error */ 
/**
  * @}
  */

/** @defgroup CAN_flags 
  * @{
  */
/* If the flag is 0x3XXXXXXX, it means that it can be used with CAN_GetFlagStatus()
   and CAN_ClearFlag() functions. */
/* If the flag is 0x1XXXXXXX, it means that it can only be used with 
   CAN_GetFlagStatus() function.  */

/* Transmit Flags */
#define CAN_FLAG_RQCP0             ((uint32_t)0x38000001) /*!< Request MailBox0 Flag */
#define CAN_FLAG_RQCP1             ((uint32_t)0x38000100) /*!< Request MailBox1 Flag */
#define CAN_FLAG_RQCP2             ((uint32_t)0x38010000) /*!< Request MailBox2 Flag */

/* Receive Flags */
#define CAN_FLAG_FMP0              ((uint32_t)0x12000003) /*!< FIFO 0 Message Pending Flag */
#define CAN_FLAG_FF0               ((uint32_t)0x32000008) /*!< FIFO 0 Full Flag            */
#define CAN_FLAG_FOV0              ((uint32_t)0x32000010) /*!< FIFO 0 Overrun Flag         */
#define CAN_FLAG_FMP1              ((uint32_t)0x14000003) /*!< FIFO 1 Message Pending Flag */
#define CAN_FLAG_FF1               ((uint32_t)0x34000008) /*!< FIFO 1 Full Flag            */
#define CAN_FLAG_FOV1              ((uint32_t)0x34000010) /*!< FIFO 1 Overrun Flag         */

/* Operating Mode Flags */
#define CAN_FLAG_WKU               ((uint32_t)0x31000008) /*!< Wake up Flag */
#define CAN_FLAG_SLAK              ((uint32_t)0x31000012) /*!< Sleep acknowledge Flag */
/* @note When SLAK interrupt is disabled (SLKIE=0), no polling on SLAKI is possible. 
         In this case the SLAK bit can be polled.*/

/* Error Flags */
#define CAN_FLAG_EWG               ((uint32_t)0x10F00001) /*!< Error Warning Flag   */
#define CAN_FLAG_EPV               ((uint32_t)0x10F00002) /*!< Error Passive Flag   */
#define CAN_FLAG_BOF               ((uint32_t)0x10F00004) /*!< Bus-Off Flag         */
#define CAN_FLAG_LEC               ((uint32_t)0x30F00070) /*!< Last error code Flag */

#define IS_CAN_GET_FLAG(FLAG) (((FLAG) == CAN_FLAG_LEC)  || ((FLAG) == CAN_FLAG_BOF)   || \
                               ((FLAG) == CAN_FLAG_EPV)  || ((FLAG) == CAN_FLAG_EWG)   || \
                               ((FLAG) == CAN_FLAG_WKU)  || ((FLAG) == CAN_FLAG_FOV0)  || \
                               ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FMP0)  || \
                               ((FLAG) == CAN_FLAG_FOV1) || ((FLAG) == CAN_FLAG_FF1)   || \
                               ((FLAG) == CAN_FLAG_FMP1) || ((FLAG) == CAN_FLAG_RQCP2) || \
                               ((FLAG) == CAN_FLAG_RQCP1)|| ((FLAG) == CAN_FLAG_RQCP0) || \
                               ((FLAG) == CAN_FLAG_SLAK ))

#define IS_CAN_CLEAR_FLAG(FLAG)(((FLAG) == CAN_FLAG_LEC) || ((FLAG) == CAN_FLAG_RQCP2) || \
                                ((FLAG) == CAN_FLAG_RQCP1)  || ((FLAG) == CAN_FLAG_RQCP0) || \
                                ((FLAG) == CAN_FLAG_FF0)  || ((FLAG) == CAN_FLAG_FOV0) ||\
                                ((FLAG) == CAN_FLAG_FF1) || ((FLAG) == CAN_FLAG_FOV1) || \
                                ((FLAG) == CAN_FLAG_WKU) || ((FLAG) == CAN_FLAG_SLAK))
/**
  * @}
  */

  
/** @defgroup CAN_interrupts 
  * @{
  */ 
#define CAN_IT_TME                  ((uint32_t)0x00000001) /*!< Transmit mailbox empty Interrupt*/

/* Receive Interrupts */
#define CAN_IT_FMP0                 ((uint32_t)0x00000002) /*!< FIFO 0 message pending Interrupt*/
#define CAN_IT_FF0                  ((uint32_t)0x00000004) /*!< FIFO 0 full Interrupt*/
#define CAN_IT_FOV0                 ((uint32_t)0x00000008) /*!< FIFO 0 overrun Interrupt*/
#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!< FIFO 1 message pending Interrupt*/
#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!< FIFO 1 full Interrupt*/
#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!< FIFO 1 overrun Interrupt*/

/* Operating Mode Interrupts */
#define CAN_IT_WKU                  ((uint32_t)0x00010000) /*!< Wake-up Interrupt*/
#define CAN_IT_SLK                  ((uint32_t)0x00020000) /*!< Sleep acknowledge Interrupt*/

/* Error Interrupts */
#define CAN_IT_EWG                  ((uint32_t)0x00000100) /*!< Error warning Interrupt*/
#define CAN_IT_EPV                  ((uint32_t)0x00000200) /*!< Error passive Interrupt*/
#define CAN_IT_BOF                  ((uint32_t)0x00000400) /*!< Bus-off Interrupt*/
#define CAN_IT_LEC                  ((uint32_t)0x00000800) /*!< Last error code Interrupt*/
#define CAN_IT_ERR                  ((uint32_t)0x00008000) /*!< Error Interrupt*/

/* Flags named as Interrupts : kept only for FW compatibility */
#define CAN_IT_RQCP0   CAN_IT_TME
#define CAN_IT_RQCP1   CAN_IT_TME
#define CAN_IT_RQCP2   CAN_IT_TME


#define IS_CAN_IT(IT)        (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FMP0)  ||\
                             ((IT) == CAN_IT_FF0)  || ((IT) == CAN_IT_FOV0)  ||\
                             ((IT) == CAN_IT_FMP1) || ((IT) == CAN_IT_FF1)   ||\
                             ((IT) == CAN_IT_FOV1) || ((IT) == CAN_IT_EWG)   ||\
                             ((IT) == CAN_IT_EPV)  || ((IT) == CAN_IT_BOF)   ||\
                             ((IT) == CAN_IT_LEC)  || ((IT) == CAN_IT_ERR)   ||\
                             ((IT) == CAN_IT_WKU)  || ((IT) == CAN_IT_SLK))

#define IS_CAN_CLEAR_IT(IT) (((IT) == CAN_IT_TME) || ((IT) == CAN_IT_FF0)    ||\
                             ((IT) == CAN_IT_FOV0)|| ((IT) == CAN_IT_FF1)    ||\
                             ((IT) == CAN_IT_FOV1)|| ((IT) == CAN_IT_EWG)    ||\
                             ((IT) == CAN_IT_EPV) || ((IT) == CAN_IT_BOF)    ||\
                             ((IT) == CAN_IT_LEC) || ((IT) == CAN_IT_ERR)    ||\
                             ((IT) == CAN_IT_WKU) || ((IT) == CAN_IT_SLK))
/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/  

/*  Function used to set the CAN configuration to the default reset state *****/ 
void CAN_DeInit(CAN_TypeDef* CANx);

/* Initialization and Configuration functions *********************************/ 
uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct);
void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct);
void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct);
void CAN_SlaveStartBank(uint8_t CAN_BankNumber); 
void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState);
void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState);

/* CAN Frames Transmission functions ******************************************/
uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage);
uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox);
void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox);

/* CAN Frames Reception functions *********************************************/
void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage);
void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber);
uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber);

/* Operation modes functions **************************************************/
uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode);
uint8_t CAN_Sleep(CAN_TypeDef* CANx);
uint8_t CAN_WakeUp(CAN_TypeDef* CANx);

/* CAN Bus Error management functions *****************************************/
uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx);
uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx);
uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx);

/* Interrupts and flags management functions **********************************/
void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState);
FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG);
ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT);
void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT);

#endif

#ifdef __cplusplus
}
#endif

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_can.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_fsmc.h
/**
  ******************************************************************************
  * @file    stm32f4xx_fsmc.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the FSMC firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#pragma once

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

#if defined(STM32PLUS_F4_HAS_FSMC)

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup FSMC
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief  Timing parameters For NOR/SRAM Banks  
  */
typedef struct
{
  uint32_t FSMC_AddressSetupTime;       /*!< Defines the number of HCLK cycles to configure
                                             the duration of the address setup time. 
                                             This parameter can be a value between 0 and 0xF.
                                             @note This parameter is not used with synchronous NOR Flash memories. */

  uint32_t FSMC_AddressHoldTime;        /*!< Defines the number of HCLK cycles to configure
                                             the duration of the address hold time.
                                             This parameter can be a value between 0 and 0xF. 
                                             @note This parameter is not used with synchronous NOR Flash memories.*/

  uint32_t FSMC_DataSetupTime;          /*!< Defines the number of HCLK cycles to configure
                                             the duration of the data setup time.
                                             This parameter can be a value between 0 and 0xFF.
                                             @note This parameter is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */

  uint32_t FSMC_BusTurnAroundDuration;  /*!< Defines the number of HCLK cycles to configure
                                             the duration of the bus turnaround.
                                             This parameter can be a value between 0 and 0xF.
                                             @note This parameter is only used for multiplexed NOR Flash memories. */

  uint32_t FSMC_CLKDivision;            /*!< Defines the period of CLK clock output signal, expressed in number of HCLK cycles.
                                             This parameter can be a value between 1 and 0xF.
                                             @note This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */

  uint32_t FSMC_DataLatency;            /*!< Defines the number of memory clock cycles to issue
                                             to the memory before getting the first data.
                                             The parameter value depends on the memory type as shown below:
                                              - It must be set to 0 in case of a CRAM
                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
                                              - It may assume a value between 0 and 0xF in NOR Flash memories
                                                with synchronous burst mode enable */

  uint32_t FSMC_AccessMode;             /*!< Specifies the asynchronous access mode. 
                                             This parameter can be a value of @ref FSMC_Access_Mode */
}FSMC_NORSRAMTimingInitTypeDef;

/** 
  * @brief  FSMC NOR/SRAM Init structure definition
  */
typedef struct
{
  uint32_t FSMC_Bank;                /*!< Specifies the NOR/SRAM memory bank that will be used.
                                          This parameter can be a value of @ref FSMC_NORSRAM_Bank */

  uint32_t FSMC_DataAddressMux;      /*!< Specifies whether the address and data values are
                                          multiplexed on the data bus or not. 
                                          This parameter can be a value of @ref FSMC_Data_Address_Bus_Multiplexing */

  uint32_t FSMC_MemoryType;          /*!< Specifies the type of external memory attached to
                                          the corresponding memory bank.
                                          This parameter can be a value of @ref FSMC_Memory_Type */

  uint32_t FSMC_MemoryDataWidth;     /*!< Specifies the external memory device width.
                                          This parameter can be a value of @ref FSMC_Data_Width */

  uint32_t FSMC_BurstAccessMode;     /*!< Enables or disables the burst access mode for Flash memory,
                                          valid only with synchronous burst Flash memories.
                                          This parameter can be a value of @ref FSMC_Burst_Access_Mode */

  uint32_t FSMC_AsynchronousWait;     /*!< Enables or disables wait signal during asynchronous transfers,
                                          valid only with asynchronous Flash memories.
                                          This parameter can be a value of @ref FSMC_AsynchronousWait */                                          

  uint32_t FSMC_WaitSignalPolarity;  /*!< Specifies the wait signal polarity, valid only when accessing
                                          the Flash memory in burst mode.
                                          This parameter can be a value of @ref FSMC_Wait_Signal_Polarity */

  uint32_t FSMC_WrapMode;            /*!< Enables or disables the Wrapped burst access mode for Flash
                                          memory, valid only when accessing Flash memories in burst mode.
                                          This parameter can be a value of @ref FSMC_Wrap_Mode */

  uint32_t FSMC_WaitSignalActive;    /*!< Specifies if the wait signal is asserted by the memory one
                                          clock cycle before the wait state or during the wait state,
                                          valid only when accessing memories in burst mode. 
                                          This parameter can be a value of @ref FSMC_Wait_Timing */

  uint32_t FSMC_WriteOperation;      /*!< Enables or disables the write operation in the selected bank by the FSMC. 
                                          This parameter can be a value of @ref FSMC_Write_Operation */

  uint32_t FSMC_WaitSignal;          /*!< Enables or disables the wait state insertion via wait
                                          signal, valid for Flash memory access in burst mode. 
                                          This parameter can be a value of @ref FSMC_Wait_Signal */

  uint32_t FSMC_ExtendedMode;        /*!< Enables or disables the extended mode.
                                          This parameter can be a value of @ref FSMC_Extended_Mode */

  uint32_t FSMC_WriteBurst;          /*!< Enables or disables the write burst operation.
                                          This parameter can be a value of @ref FSMC_Write_Burst */ 

  FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the  Extended Mode is not used*/  

  FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct;     /*!< Timing Parameters for write access if the  Extended Mode is used*/      
}FSMC_NORSRAMInitTypeDef;

/** 
  * @brief  Timing parameters For FSMC NAND and PCCARD Banks
  */
typedef struct
{
  uint32_t FSMC_SetupTime;      /*!< Defines the number of HCLK cycles to setup address before
                                     the command assertion for NAND Flash read or write access
                                     to common/Attribute or I/O memory space (depending on
                                     the memory space timing to be configured).
                                     This parameter can be a value between 0 and 0xFF.*/

  uint32_t FSMC_WaitSetupTime;  /*!< Defines the minimum number of HCLK cycles to assert the
                                     command for NAND Flash read or write access to
                                     common/Attribute or I/O memory space (depending on the
                                     memory space timing to be configured). 
                                     This parameter can be a number between 0x00 and 0xFF */

  uint32_t FSMC_HoldSetupTime;  /*!< Defines the number of HCLK clock cycles to hold address
                                     (and data for write access) after the command de-assertion
                                     for NAND Flash read or write access to common/Attribute
                                     or I/O memory space (depending on the memory space timing
                                     to be configured).
                                     This parameter can be a number between 0x00 and 0xFF */

  uint32_t FSMC_HiZSetupTime;   /*!< Defines the number of HCLK clock cycles during which the
                                     data bus is kept in HiZ after the start of a NAND Flash
                                     write access to common/Attribute or I/O memory space (depending
                                     on the memory space timing to be configured).
                                     This parameter can be a number between 0x00 and 0xFF */
}FSMC_NAND_PCCARDTimingInitTypeDef;

/** 
  * @brief  FSMC NAND Init structure definition
  */
typedef struct
{
  uint32_t FSMC_Bank;              /*!< Specifies the NAND memory bank that will be used.
                                      This parameter can be a value of @ref FSMC_NAND_Bank */

  uint32_t FSMC_Waitfeature;      /*!< Enables or disables the Wait feature for the NAND Memory Bank.
                                       This parameter can be any value of @ref FSMC_Wait_feature */

  uint32_t FSMC_MemoryDataWidth;  /*!< Specifies the external memory device width.
                                       This parameter can be any value of @ref FSMC_Data_Width */

  uint32_t FSMC_ECC;              /*!< Enables or disables the ECC computation.
                                       This parameter can be any value of @ref FSMC_ECC */

  uint32_t FSMC_ECCPageSize;      /*!< Defines the page size for the extended ECC.
                                       This parameter can be any value of @ref FSMC_ECC_Page_Size */

  uint32_t FSMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the
                                       delay between CLE low and RE low.
                                       This parameter can be a value between 0 and 0xFF. */

  uint32_t FSMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the
                                       delay between ALE low and RE low.
                                       This parameter can be a number between 0x0 and 0xFF */ 

  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct;   /*!< FSMC Common Space Timing */ 

  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct; /*!< FSMC Attribute Space Timing */
}FSMC_NANDInitTypeDef;

/** 
  * @brief  FSMC PCCARD Init structure definition
  */

typedef struct
{
  uint32_t FSMC_Waitfeature;    /*!< Enables or disables the Wait feature for the Memory Bank.
                                    This parameter can be any value of @ref FSMC_Wait_feature */

  uint32_t FSMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the
                                     delay between CLE low and RE low.
                                     This parameter can be a value between 0 and 0xFF. */

  uint32_t FSMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the
                                     delay between ALE low and RE low.
                                     This parameter can be a number between 0x0 and 0xFF */ 

  
  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_CommonSpaceTimingStruct; /*!< FSMC Common Space Timing */

  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_AttributeSpaceTimingStruct;  /*!< FSMC Attribute Space Timing */ 
  
  FSMC_NAND_PCCARDTimingInitTypeDef*  FSMC_IOSpaceTimingStruct; /*!< FSMC IO Space Timing */  
}FSMC_PCCARDInitTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup FSMC_Exported_Constants
  * @{
  */

/** @defgroup FSMC_NORSRAM_Bank 
  * @{
  */
#define FSMC_Bank1_NORSRAM1                      ((uint32_t)0x00000000)
#define FSMC_Bank1_NORSRAM2                      ((uint32_t)0x00000002)
#define FSMC_Bank1_NORSRAM3                      ((uint32_t)0x00000004)
#define FSMC_Bank1_NORSRAM4                      ((uint32_t)0x00000006)
/**
  * @}
  */

/** @defgroup FSMC_NAND_Bank 
  * @{
  */  
#define FSMC_Bank2_NAND                          ((uint32_t)0x00000010)
#define FSMC_Bank3_NAND                          ((uint32_t)0x00000100)
/**
  * @}
  */

/** @defgroup FSMC_PCCARD_Bank 
  * @{
  */    
#define FSMC_Bank4_PCCARD                        ((uint32_t)0x00001000)
/**
  * @}
  */

#define IS_FSMC_NORSRAM_BANK(BANK) (((BANK) == FSMC_Bank1_NORSRAM1) || \
                                    ((BANK) == FSMC_Bank1_NORSRAM2) || \
                                    ((BANK) == FSMC_Bank1_NORSRAM3) || \
                                    ((BANK) == FSMC_Bank1_NORSRAM4))

#define IS_FSMC_NAND_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
                                 ((BANK) == FSMC_Bank3_NAND))

#define IS_FSMC_GETFLAG_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
                                    ((BANK) == FSMC_Bank3_NAND) || \
                                    ((BANK) == FSMC_Bank4_PCCARD))

#define IS_FSMC_IT_BANK(BANK) (((BANK) == FSMC_Bank2_NAND) || \
                               ((BANK) == FSMC_Bank3_NAND) || \
                               ((BANK) == FSMC_Bank4_PCCARD))

/** @defgroup FSMC_NOR_SRAM_Controller 
  * @{
  */

/** @defgroup FSMC_Data_Address_Bus_Multiplexing 
  * @{
  */

#define FSMC_DataAddressMux_Disable                ((uint32_t)0x00000000)
#define FSMC_DataAddressMux_Enable                 ((uint32_t)0x00000002)
#define IS_FSMC_MUX(MUX) (((MUX) == FSMC_DataAddressMux_Disable) || \
                          ((MUX) == FSMC_DataAddressMux_Enable))
/**
  * @}
  */

/** @defgroup FSMC_Memory_Type 
  * @{
  */

#define FSMC_MemoryType_SRAM                     ((uint32_t)0x00000000)
#define FSMC_MemoryType_PSRAM                    ((uint32_t)0x00000004)
#define FSMC_MemoryType_NOR                      ((uint32_t)0x00000008)
#define IS_FSMC_MEMORY(MEMORY) (((MEMORY) == FSMC_MemoryType_SRAM) || \
                                ((MEMORY) == FSMC_MemoryType_PSRAM)|| \
                                ((MEMORY) == FSMC_MemoryType_NOR))
/**
  * @}
  */

/** @defgroup FSMC_Data_Width 
  * @{
  */

#define FSMC_MemoryDataWidth_8b                  ((uint32_t)0x00000000)
#define FSMC_MemoryDataWidth_16b                 ((uint32_t)0x00000010)
#define IS_FSMC_MEMORY_WIDTH(WIDTH) (((WIDTH) == FSMC_MemoryDataWidth_8b) || \
                                     ((WIDTH) == FSMC_MemoryDataWidth_16b))
/**
  * @}
  */

/** @defgroup FSMC_Burst_Access_Mode 
  * @{
  */

#define FSMC_BurstAccessMode_Disable             ((uint32_t)0x00000000) 
#define FSMC_BurstAccessMode_Enable              ((uint32_t)0x00000100)
#define IS_FSMC_BURSTMODE(STATE) (((STATE) == FSMC_BurstAccessMode_Disable) || \
                                  ((STATE) == FSMC_BurstAccessMode_Enable))
/**
  * @}
  */
    
/** @defgroup FSMC_AsynchronousWait 
  * @{
  */
#define FSMC_AsynchronousWait_Disable            ((uint32_t)0x00000000)
#define FSMC_AsynchronousWait_Enable             ((uint32_t)0x00008000)
#define IS_FSMC_ASYNWAIT(STATE) (((STATE) == FSMC_AsynchronousWait_Disable) || \
                                 ((STATE) == FSMC_AsynchronousWait_Enable))
/**
  * @}
  */

/** @defgroup FSMC_Wait_Signal_Polarity 
  * @{
  */
#define FSMC_WaitSignalPolarity_Low              ((uint32_t)0x00000000)
#define FSMC_WaitSignalPolarity_High             ((uint32_t)0x00000200)
#define IS_FSMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FSMC_WaitSignalPolarity_Low) || \
                                         ((POLARITY) == FSMC_WaitSignalPolarity_High))
/**
  * @}
  */

/** @defgroup FSMC_Wrap_Mode 
  * @{
  */
#define FSMC_WrapMode_Disable                    ((uint32_t)0x00000000)
#define FSMC_WrapMode_Enable                     ((uint32_t)0x00000400) 
#define IS_FSMC_WRAP_MODE(MODE) (((MODE) == FSMC_WrapMode_Disable) || \
                                 ((MODE) == FSMC_WrapMode_Enable))
/**
  * @}
  */

/** @defgroup FSMC_Wait_Timing 
  * @{
  */
#define FSMC_WaitSignalActive_BeforeWaitState    ((uint32_t)0x00000000)
#define FSMC_WaitSignalActive_DuringWaitState    ((uint32_t)0x00000800) 
#define IS_FSMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FSMC_WaitSignalActive_BeforeWaitState) || \
                                            ((ACTIVE) == FSMC_WaitSignalActive_DuringWaitState))
/**
  * @}
  */

/** @defgroup FSMC_Write_Operation 
  * @{
  */
#define FSMC_WriteOperation_Disable                     ((uint32_t)0x00000000)
#define FSMC_WriteOperation_Enable                      ((uint32_t)0x00001000)
#define IS_FSMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FSMC_WriteOperation_Disable) || \
                                            ((OPERATION) == FSMC_WriteOperation_Enable))                         
/**
  * @}
  */

/** @defgroup FSMC_Wait_Signal 
  * @{
  */
#define FSMC_WaitSignal_Disable                  ((uint32_t)0x00000000)
#define FSMC_WaitSignal_Enable                   ((uint32_t)0x00002000) 
#define IS_FSMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FSMC_WaitSignal_Disable) || \
                                      ((SIGNAL) == FSMC_WaitSignal_Enable))
/**
  * @}
  */

/** @defgroup FSMC_Extended_Mode 
  * @{
  */
#define FSMC_ExtendedMode_Disable                ((uint32_t)0x00000000)
#define FSMC_ExtendedMode_Enable                 ((uint32_t)0x00004000)

#define IS_FSMC_EXTENDED_MODE(MODE) (((MODE) == FSMC_ExtendedMode_Disable) || \
                                     ((MODE) == FSMC_ExtendedMode_Enable)) 
/**
  * @}
  */

/** @defgroup FSMC_Write_Burst 
  * @{
  */

#define FSMC_WriteBurst_Disable                  ((uint32_t)0x00000000)
#define FSMC_WriteBurst_Enable                   ((uint32_t)0x00080000) 
#define IS_FSMC_WRITE_BURST(BURST) (((BURST) == FSMC_WriteBurst_Disable) || \
                                    ((BURST) == FSMC_WriteBurst_Enable))
/**
  * @}
  */

/** @defgroup FSMC_Address_Setup_Time 
  * @{
  */
#define IS_FSMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 0xF)
/**
  * @}
  */

/** @defgroup FSMC_Address_Hold_Time 
  * @{
  */
#define IS_FSMC_ADDRESS_HOLD_TIME(TIME) ((TIME) <= 0xF)
/**
  * @}
  */

/** @defgroup FSMC_Data_Setup_Time 
  * @{
  */
#define IS_FSMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 0xFF))
/**
  * @}
  */

/** @defgroup FSMC_Bus_Turn_around_Duration 
  * @{
  */
#define IS_FSMC_TURNAROUND_TIME(TIME) ((TIME) <= 0xF)
/**
  * @}
  */

/** @defgroup FSMC_CLK_Division 
  * @{
  */
#define IS_FSMC_CLK_DIV(DIV) ((DIV) <= 0xF)
/**
  * @}
  */

/** @defgroup FSMC_Data_Latency 
  * @{
  */
#define IS_FSMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 0xF)
/**
  * @}
  */

/** @defgroup FSMC_Access_Mode 
  * @{
  */
#define FSMC_AccessMode_A                        ((uint32_t)0x00000000)
#define FSMC_AccessMode_B                        ((uint32_t)0x10000000) 
#define FSMC_AccessMode_C                        ((uint32_t)0x20000000)
#define FSMC_AccessMode_D                        ((uint32_t)0x30000000)
#define IS_FSMC_ACCESS_MODE(MODE) (((MODE) == FSMC_AccessMode_A) || \
                                   ((MODE) == FSMC_AccessMode_B) || \
                                   ((MODE) == FSMC_AccessMode_C) || \
                                   ((MODE) == FSMC_AccessMode_D))
/**
  * @}
  */

/**
  * @}
  */
  
/** @defgroup FSMC_NAND_PCCARD_Controller 
  * @{
  */

/** @defgroup FSMC_Wait_feature 
  * @{
  */
#define FSMC_Waitfeature_Disable                 ((uint32_t)0x00000000)
#define FSMC_Waitfeature_Enable                  ((uint32_t)0x00000002)
#define IS_FSMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FSMC_Waitfeature_Disable) || \
                                       ((FEATURE) == FSMC_Waitfeature_Enable))
/**
  * @}
  */


/** @defgroup FSMC_ECC 
  * @{
  */
#define FSMC_ECC_Disable                         ((uint32_t)0x00000000)
#define FSMC_ECC_Enable                          ((uint32_t)0x00000040)
#define IS_FSMC_ECC_STATE(STATE) (((STATE) == FSMC_ECC_Disable) || \
                                  ((STATE) == FSMC_ECC_Enable))
/**
  * @}
  */

/** @defgroup FSMC_ECC_Page_Size 
  * @{
  */
#define FSMC_ECCPageSize_256Bytes                ((uint32_t)0x00000000)
#define FSMC_ECCPageSize_512Bytes                ((uint32_t)0x00020000)
#define FSMC_ECCPageSize_1024Bytes               ((uint32_t)0x00040000)
#define FSMC_ECCPageSize_2048Bytes               ((uint32_t)0x00060000)
#define FSMC_ECCPageSize_4096Bytes               ((uint32_t)0x00080000)
#define FSMC_ECCPageSize_8192Bytes               ((uint32_t)0x000A0000)
#define IS_FSMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FSMC_ECCPageSize_256Bytes) || \
                                    ((SIZE) == FSMC_ECCPageSize_512Bytes) || \
                                    ((SIZE) == FSMC_ECCPageSize_1024Bytes) || \
                                    ((SIZE) == FSMC_ECCPageSize_2048Bytes) || \
                                    ((SIZE) == FSMC_ECCPageSize_4096Bytes) || \
                                    ((SIZE) == FSMC_ECCPageSize_8192Bytes))
/**
  * @}
  */

/** @defgroup FSMC_TCLR_Setup_Time 
  * @{
  */
#define IS_FSMC_TCLR_TIME(TIME) ((TIME) <= 0xFF)
/**
  * @}
  */

/** @defgroup FSMC_TAR_Setup_Time 
  * @{
  */
#define IS_FSMC_TAR_TIME(TIME) ((TIME) <= 0xFF)
/**
  * @}
  */

/** @defgroup FSMC_Setup_Time 
  * @{
  */
#define IS_FSMC_SETUP_TIME(TIME) ((TIME) <= 0xFF)
/**
  * @}
  */

/** @defgroup FSMC_Wait_Setup_Time 
  * @{
  */
#define IS_FSMC_WAIT_TIME(TIME) ((TIME) <= 0xFF)
/**
  * @}
  */

/** @defgroup FSMC_Hold_Setup_Time 
  * @{
  */
#define IS_FSMC_HOLD_TIME(TIME) ((TIME) <= 0xFF)
/**
  * @}
  */

/** @defgroup FSMC_HiZ_Setup_Time 
  * @{
  */
#define IS_FSMC_HIZ_TIME(TIME) ((TIME) <= 0xFF)
/**
  * @}
  */

/** @defgroup FSMC_Interrupt_sources 
  * @{
  */
#define FSMC_IT_RisingEdge                       ((uint32_t)0x00000008)
#define FSMC_IT_Level                            ((uint32_t)0x00000010)
#define FSMC_IT_FallingEdge                      ((uint32_t)0x00000020)
#define IS_FSMC_IT(IT) ((((IT) & (uint32_t)0xFFFFFFC7) == 0x00000000) && ((IT) != 0x00000000))
#define IS_FSMC_GET_IT(IT) (((IT) == FSMC_IT_RisingEdge) || \
                            ((IT) == FSMC_IT_Level) || \
                            ((IT) == FSMC_IT_FallingEdge)) 
/**
  * @}
  */

/** @defgroup FSMC_Flags 
  * @{
  */
#define FSMC_FLAG_RisingEdge                     ((uint32_t)0x00000001)
#define FSMC_FLAG_Level                          ((uint32_t)0x00000002)
#define FSMC_FLAG_FallingEdge                    ((uint32_t)0x00000004)
#define FSMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
#define IS_FSMC_GET_FLAG(FLAG) (((FLAG) == FSMC_FLAG_RisingEdge) || \
                                ((FLAG) == FSMC_FLAG_Level) || \
                                ((FLAG) == FSMC_FLAG_FallingEdge) || \
                                ((FLAG) == FSMC_FLAG_FEMPT))

#define IS_FSMC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))
/**
  * @}
  */

/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/* NOR/SRAM Controller functions **********************************************/
void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank);
void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct);
void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState);

/* NAND Controller functions **************************************************/
void FSMC_NANDDeInit(uint32_t FSMC_Bank);
void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct);
void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState);
void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState);
uint32_t FSMC_GetECC(uint32_t FSMC_Bank);

/* PCCARD Controller functions ************************************************/
void FSMC_PCCARDDeInit(void);
void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct);
void FSMC_PCCARDCmd(FunctionalState NewState);

/* Interrupts and flags management functions **********************************/
void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState);
FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG);
ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT);
void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT);

#endif

#ifdef __cplusplus
}
#endif

/**
  * @}
  */

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_fsmc.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_flash_ramfunc.h
/**
  ******************************************************************************
  * @file    stm32f4xx_flash_ramfunc.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   Header file of FLASH RAMFUNC driver.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */


/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_FLASH_RAMFUNC_H
#define __STM32F4xx_FLASH_RAMFUNC_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup FLASH RAMFUNC
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/
/** 
  * @brief  __RAM_FUNC definition
  */ 
#if defined ( __CC_ARM   )
/* ARM Compiler
   ------------
   RAM functions are defined using the toolchain options. 
   Functions that are executed in RAM should reside in a separate source module.
   Using the 'Options for File' dialog you can simply change the 'Code / Const' 
   area of a module to a memory space in physical RAM.
   Available memory areas are declared in the 'Target' tab of the 'Options for Target'
   dialog. 
*/
#define __RAM_FUNC void 

#elif defined ( __ICCARM__ )
/* ICCARM Compiler
   ---------------
   RAM functions are defined using a specific toolchain keyword "__ramfunc". 
*/
#define __RAM_FUNC __ramfunc void

#elif defined   (  __GNUC__  )
/* GNU Compiler
   ------------
  RAM functions are defined using a specific toolchain attribute 
   "__attribute__((section(".RamFunc")))".
*/
#define __RAM_FUNC void  __attribute__((section(".RamFunc")))

#endif
/* Exported constants --------------------------------------------------------*/
/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
__RAM_FUNC FLASH_FlashInterfaceCmd(FunctionalState NewState);
__RAM_FUNC FLASH_FlashSleepModeCmd(FunctionalState NewState);


#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_FLASH_RAMFUNC_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_flash_ramfunc.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/misc.h
/**
  ******************************************************************************
  * @file    misc.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the miscellaneous
  *          firmware library functions (add-on to CMSIS functions).
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __MISC_H
#define __MISC_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup MISC
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief  NVIC Init Structure definition  
  */

typedef struct
{
  uint8_t NVIC_IRQChannel;                    /*!< Specifies the IRQ channel to be enabled or disabled.
                                                   This parameter can be an enumerator of @ref IRQn_Type 
                                                   enumeration (For the complete STM32 Devices IRQ Channels
                                                   list, please refer to stm32f4xx.h file) */

  uint8_t NVIC_IRQChannelPreemptionPriority;  /*!< Specifies the pre-emption priority for the IRQ channel
                                                   specified in NVIC_IRQChannel. This parameter can be a value
                                                   between 0 and 15 as described in the table @ref MISC_NVIC_Priority_Table
                                                   A lower priority value indicates a higher priority */

  uint8_t NVIC_IRQChannelSubPriority;         /*!< Specifies the subpriority level for the IRQ channel specified
                                                   in NVIC_IRQChannel. This parameter can be a value
                                                   between 0 and 15 as described in the table @ref MISC_NVIC_Priority_Table
                                                   A lower priority value indicates a higher priority */

  FunctionalState NVIC_IRQChannelCmd;         /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel
                                                   will be enabled or disabled. 
                                                   This parameter can be set either to ENABLE or DISABLE */   
} NVIC_InitTypeDef;
 
/* Exported constants --------------------------------------------------------*/

/** @defgroup MISC_Exported_Constants
  * @{
  */

/** @defgroup MISC_Vector_Table_Base 
  * @{
  */

#define NVIC_VectTab_RAM             ((uint32_t)0x20000000)
#define NVIC_VectTab_FLASH           ((uint32_t)0x08000000)
#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
                                  ((VECTTAB) == NVIC_VectTab_FLASH))
/**
  * @}
  */

/** @defgroup MISC_System_Low_Power 
  * @{
  */

#define NVIC_LP_SEVONPEND            ((uint8_t)0x10)
#define NVIC_LP_SLEEPDEEP            ((uint8_t)0x04)
#define NVIC_LP_SLEEPONEXIT          ((uint8_t)0x02)
#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
                        ((LP) == NVIC_LP_SLEEPDEEP) || \
                        ((LP) == NVIC_LP_SLEEPONEXIT))
/**
  * @}
  */

/** @defgroup MISC_Preemption_Priority_Group 
  * @{
  */

#define NVIC_PriorityGroup_0         ((uint32_t)0x700) /*!< 0 bits for pre-emption priority
                                                            4 bits for subpriority */
#define NVIC_PriorityGroup_1         ((uint32_t)0x600) /*!< 1 bits for pre-emption priority
                                                            3 bits for subpriority */
#define NVIC_PriorityGroup_2         ((uint32_t)0x500) /*!< 2 bits for pre-emption priority
                                                            2 bits for subpriority */
#define NVIC_PriorityGroup_3         ((uint32_t)0x400) /*!< 3 bits for pre-emption priority
                                                            1 bits for subpriority */
#define NVIC_PriorityGroup_4         ((uint32_t)0x300) /*!< 4 bits for pre-emption priority
                                                            0 bits for subpriority */

#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
                                       ((GROUP) == NVIC_PriorityGroup_1) || \
                                       ((GROUP) == NVIC_PriorityGroup_2) || \
                                       ((GROUP) == NVIC_PriorityGroup_3) || \
                                       ((GROUP) == NVIC_PriorityGroup_4))

#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)

#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)

#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x000FFFFF)

/**
  * @}
  */

/** @defgroup MISC_SysTick_clock_source 
  * @{
  */

#define SysTick_CLKSource_HCLK_Div8    ((uint32_t)0xFFFFFFFB)
#define SysTick_CLKSource_HCLK         ((uint32_t)0x00000004)
#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/

void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup);
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset);
void NVIC_SystemLPConfig(uint8_t LowPowerMode, FunctionalState NewState);
void SysTick_CLKSourceConfig(uint32_t SysTick_CLKSource);

#ifdef __cplusplus
}
#endif

#endif /* __MISC_H */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/misc.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_fmc.h
/**
  ******************************************************************************
  * @file    stm32f4xx_fmc.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the FMC firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#pragma once

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

#if defined(STM32PLUS_F4_HAS_FMC)

#if defined(STM32PLUS_F427) || defined(STM32PLUS_F437) || defined(STM32PLUS_F439)

// solve a compatibility issue with this version of the peripheral headers
// and the newer version of CMSIS that uses Bank2_3 for these MCUs

#define FMC_Bank2           ((FMC_Bank2_3_TypeDef *) FMC_Bank2_3_R_BASE)
#define FMC_Bank3           ((FMC_Bank2_3_TypeDef *) FMC_Bank2_3_R_BASE)

#endif


/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup FMC
  * @{
  */

/* Exported types ------------------------------------------------------------*/  

/** 
  * @brief  Timing parameters For NOR/SRAM Banks  
  */
typedef struct
{
  uint32_t FMC_AddressSetupTime;       /*!< Defines the number of HCLK cycles to configure
                                             the duration of the address setup time. 
                                             This parameter can be a value between 0 and 15.
                                             @note This parameter is not used with synchronous NOR Flash memories. */

  uint32_t FMC_AddressHoldTime;        /*!< Defines the number of HCLK cycles to configure
                                             the duration of the address hold time.
                                             This parameter can be a value between 1 and 15. 
                                             @note This parameter is not used with synchronous NOR Flash memories.*/

  uint32_t FMC_DataSetupTime;          /*!< Defines the number of HCLK cycles to configure
                                             the duration of the data setup time.
                                             This parameter can be a value between 1 and 255.
                                             @note This parameter is used for SRAMs, ROMs and asynchronous multiplexed NOR Flash memories. */

  uint32_t FMC_BusTurnAroundDuration;  /*!< Defines the number of HCLK cycles to configure
                                             the duration of the bus turnaround.
                                             This parameter can be a value between 0 and 15.
                                             @note This parameter is only used for multiplexed NOR Flash memories. */

  uint32_t FMC_CLKDivision;            /*!< Defines the period of CLK clock output signal, expressed in number of HCLK cycles.
                                             This parameter can be a value between 1 and 15.
                                             @note This parameter is not used for asynchronous NOR Flash, SRAM or ROM accesses. */

  uint32_t FMC_DataLatency;            /*!< Defines the number of memory clock cycles to issue
                                             to the memory before getting the first data.
                                             The parameter value depends on the memory type as shown below:
                                              - It must be set to 0 in case of a CRAM
                                              - It is don't care in asynchronous NOR, SRAM or ROM accesses
                                              - It may assume a value between 0 and 15 in NOR Flash memories
                                                with synchronous burst mode enable */

  uint32_t FMC_AccessMode;             /*!< Specifies the asynchronous access mode. 
                                             This parameter can be a value of @ref FMC_Access_Mode */
}FMC_NORSRAMTimingInitTypeDef;

/** 
  * @brief  FMC NOR/SRAM Init structure definition
  */
typedef struct
{
  uint32_t FMC_Bank;                /*!< Specifies the NOR/SRAM memory bank that will be used.
                                          This parameter can be a value of @ref FMC_NORSRAM_Bank */

  uint32_t FMC_DataAddressMux;      /*!< Specifies whether the address and data values are
                                          multiplexed on the databus or not. 
                                          This parameter can be a value of @ref FMC_Data_Address_Bus_Multiplexing */

  uint32_t FMC_MemoryType;          /*!< Specifies the type of external memory attached to
                                          the corresponding memory bank.
                                          This parameter can be a value of @ref FMC_Memory_Type */

  uint32_t FMC_MemoryDataWidth;     /*!< Specifies the external memory device width.
                                          This parameter can be a value of @ref FMC_NORSRAM_Data_Width */

  uint32_t FMC_BurstAccessMode;     /*!< Enables or disables the burst access mode for Flash memory,
                                          valid only with synchronous burst Flash memories.
                                          This parameter can be a value of @ref FMC_Burst_Access_Mode */                                        

  uint32_t FMC_WaitSignalPolarity;  /*!< Specifies the wait signal polarity, valid only when accessing
                                          the Flash memory in burst mode.
                                          This parameter can be a value of @ref FMC_Wait_Signal_Polarity */

  uint32_t FMC_WrapMode;            /*!< Enables or disables the Wrapped burst access mode for Flash
                                          memory, valid only when accessing Flash memories in burst mode.
                                          This parameter can be a value of @ref FMC_Wrap_Mode */

  uint32_t FMC_WaitSignalActive;    /*!< Specifies if the wait signal is asserted by the memory one
                                          clock cycle before the wait state or during the wait state,
                                          valid only when accessing memories in burst mode. 
                                          This parameter can be a value of @ref FMC_Wait_Timing */

  uint32_t FMC_WriteOperation;      /*!< Enables or disables the write operation in the selected bank by the FMC. 
                                          This parameter can be a value of @ref FMC_Write_Operation */

  uint32_t FMC_WaitSignal;          /*!< Enables or disables the wait state insertion via wait
                                          signal, valid for Flash memory access in burst mode. 
                                          This parameter can be a value of @ref FMC_Wait_Signal */

  uint32_t FMC_ExtendedMode;        /*!< Enables or disables the extended mode.
                                          This parameter can be a value of @ref FMC_Extended_Mode */
  
  uint32_t FMC_AsynchronousWait;     /*!< Enables or disables wait signal during asynchronous transfers,
                                          valid only with asynchronous Flash memories.
                                          This parameter can be a value of @ref FMC_AsynchronousWait */  

  uint32_t FMC_WriteBurst;          /*!< Enables or disables the write burst operation.
                                          This parameter can be a value of @ref FMC_Write_Burst */ 

  uint32_t FMC_ContinousClock;       /*!< Enables or disables the FMC clock output to external memory devices.
                                          This parameter is only enabled through the FMC_BCR1 register, and don't care 
                                          through FMC_BCR2..4 registers.
                                          This parameter can be a value of @ref FMC_Continous_Clock */ 

  
  FMC_NORSRAMTimingInitTypeDef* FMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the  Extended Mode is not used*/  

  FMC_NORSRAMTimingInitTypeDef* FMC_WriteTimingStruct;     /*!< Timing Parameters for write access if the  Extended Mode is used*/      
}FMC_NORSRAMInitTypeDef;

/** 
  * @brief  Timing parameters For FMC NAND and PCCARD Banks
  */
typedef struct
{
  uint32_t FMC_SetupTime;      /*!< Defines the number of HCLK cycles to setup address before
                                     the command assertion for NAND-Flash read or write access
                                     to common/Attribute or I/O memory space (depending on
                                     the memory space timing to be configured).
                                     This parameter can be a value between 0 and 255.*/

  uint32_t FMC_WaitSetupTime;  /*!< Defines the minimum number of HCLK cycles to assert the
                                     command for NAND-Flash read or write access to
                                     common/Attribute or I/O memory space (depending on the
                                     memory space timing to be configured). 
                                     This parameter can be a number between 0 and 255 */

  uint32_t FMC_HoldSetupTime;  /*!< Defines the number of HCLK clock cycles to hold address
                                     (and data for write access) after the command de-assertion
                                     for NAND-Flash read or write access to common/Attribute
                                     or I/O memory space (depending on the memory space timing
                                     to be configured).
                                     This parameter can be a number between 0 and 255 */

  uint32_t FMC_HiZSetupTime;   /*!< Defines the number of HCLK clock cycles during which the
                                     databus is kept in HiZ after the start of a NAND-Flash
                                     write access to common/Attribute or I/O memory space (depending
                                     on the memory space timing to be configured).
                                     This parameter can be a number between 0 and 255 */
}FMC_NAND_PCCARDTimingInitTypeDef;

/** 
  * @brief  FMC NAND Init structure definition
  */
typedef struct
{
  uint32_t FMC_Bank;              /*!< Specifies the NAND memory bank that will be used.
                                      This parameter can be a value of @ref FMC_NAND_Bank */

  uint32_t FMC_Waitfeature;      /*!< Enables or disables the Wait feature for the NAND Memory Bank.
                                       This parameter can be any value of @ref FMC_Wait_feature */

  uint32_t FMC_MemoryDataWidth;  /*!< Specifies the external memory device width.
                                       This parameter can be any value of @ref FMC_NAND_Data_Width */

  uint32_t FMC_ECC;              /*!< Enables or disables the ECC computation.
                                       This parameter can be any value of @ref FMC_ECC */

  uint32_t FMC_ECCPageSize;      /*!< Defines the page size for the extended ECC.
                                       This parameter can be any value of @ref FMC_ECC_Page_Size */

  uint32_t FMC_TCLRSetupTime;    /*!< Defines the number of HCLK cycles to configure the
                                       delay between CLE low and RE low.
                                       This parameter can be a value between 0 and 255. */

  uint32_t FMC_TARSetupTime;     /*!< Defines the number of HCLK cycles to configure the
                                       delay between ALE low and RE low.
                                       This parameter can be a number between 0 and 255 */ 

  FMC_NAND_PCCARDTimingInitTypeDef*  FMC_CommonSpaceTimingStruct;   /*!< FMC Common Space Timing */ 

  FMC_NAND_PCCARDTimingInitTypeDef*  FMC_AttributeSpaceTimingStruct; /*!< FMC Attribute Space Timing */
}FMC_NANDInitTypeDef;

/** 
  * @brief  FMC PCCARD Init structure definition
  */

typedef struct
{
  uint32_t FMC_Waitfeature;    /*!< Enables or disables the Wait feature for the Memory Bank.
                                    This parameter can be any value of @ref FMC_Wait_feature */

  uint32_t FMC_TCLRSetupTime;  /*!< Defines the number of HCLK cycles to configure the
                                     delay between CLE low and RE low.
                                     This parameter can be a value between 0 and 255. */

  uint32_t FMC_TARSetupTime;   /*!< Defines the number of HCLK cycles to configure the
                                     delay between ALE low and RE low.
                                     This parameter can be a number between 0 and 255 */ 

  
  FMC_NAND_PCCARDTimingInitTypeDef*  FMC_CommonSpaceTimingStruct; /*!< FMC Common Space Timing */

  FMC_NAND_PCCARDTimingInitTypeDef*  FMC_AttributeSpaceTimingStruct;  /*!< FMC Attribute Space Timing */ 
  
  FMC_NAND_PCCARDTimingInitTypeDef*  FMC_IOSpaceTimingStruct; /*!< FMC IO Space Timing */  
}FMC_PCCARDInitTypeDef;

/** 
  * @brief  Timing parameters for FMC SDRAM Banks
  */
  
typedef struct
{
  uint32_t FMC_LoadToActiveDelay;      /*!< Defines the delay between a Load Mode Register command and 
                                            an active or Refresh command in number of memory clock cycles.
                                            This parameter can be a value between 1 and 16. */
  
  uint32_t FMC_ExitSelfRefreshDelay;   /*!< Defines the delay from releasing the self refresh command to 
                                            issuing the Activate command in number of memory clock cycles.
                                            This parameter can be a value between 1 and 16. */
   
  uint32_t FMC_SelfRefreshTime;        /*!< Defines the minimum Self Refresh period in number of memory clock 
                                            cycles.
                                            This parameter can be a value between 1 and 16. */
                                            
  uint32_t FMC_RowCycleDelay;          /*!< Defines the delay between the Refresh command and the Activate command
                                            and the delay between two consecutive Refresh commands in number of 
                                            memory clock cycles.
                                            This parameter can be a value between 1 and 16. */
                                            
  uint32_t FMC_WriteRecoveryTime;      /*!< Defines the Write recovery Time in number of memory clock cycles.
                                            This parameter can be a value between 1 and 16. */
                                            
  uint32_t FMC_RPDelay;                /*!< Defines the delay between a Precharge Command and an other command 
                                            in number of memory clock cycles.
                                            This parameter can be a value between 1 and 16. */
                                            
  uint32_t FMC_RCDDelay;               /*!< Defines the delay between the Activate Command and a Read/Write command
                                            in number of memory clock cycles.
                                            This parameter can be a value between 1 and 16. */
                                            
}FMC_SDRAMTimingInitTypeDef;

/** 
  * @brief  Command parameters for FMC SDRAM Banks
  */


typedef struct
{
  uint32_t FMC_CommandMode;            /*!< Defines the command issued to the SDRAM device.
                                            This parameter can be a value of @ref FMC_Command_Mode. */
                                            
  uint32_t FMC_CommandTarget;          /*!< Defines which bank (1 or 2) the command will be issued to.
                                            This parameter can be a value of @ref FMC_Command_Target. */
                                            
  uint32_t FMC_AutoRefreshNumber;      /*!< Defines the number of consecutive auto refresh command issued
                                            in auto refresh mode.
                                            This parameter can be a value between 1 and 16. */                                           
                                                                                                             
  uint32_t FMC_ModeRegisterDefinition; /*!< Defines the SDRAM Mode register content */
  
}FMC_SDRAMCommandTypeDef;

/** 
  * @brief  FMC SDRAM Init structure definition
  */

typedef struct
{
  uint32_t FMC_Bank;                   /*!< Specifies the SDRAM memory bank that will be used.
                                          This parameter can be a value of @ref FMC_SDRAM_Bank */

  uint32_t FMC_ColumnBitsNumber;       /*!< Defines the number of bits of column address.
                                            This parameter can be a value of @ref FMC_ColumnBits_Number. */
                                            
  uint32_t FMC_RowBitsNumber;          /*!< Defines the number of bits of column address..
                                            This parameter can be a value of @ref FMC_RowBits_Number. */
                                            
  uint32_t FMC_SDMemoryDataWidth;        /*!< Defines the memory device width.
                                            This parameter can be a value of @ref FMC_SDMemory_Data_Width. */
                                            
  uint32_t FMC_InternalBankNumber;     /*!< Defines the number of bits of column address.
                                            This parameter can be of @ref FMC_InternalBank_Number. */
                                            
  uint32_t FMC_CASLatency;             /*!< Defines the SDRAM CAS latency in number of memory clock cycles.
                                            This parameter can be a value of @ref FMC_CAS_Latency. */
                                            
  uint32_t FMC_WriteProtection;        /*!< Enables the SDRAM bank to be accessed in write mode.
                                            This parameter can be a value of @ref FMC_Write_Protection. */
                                            
  uint32_t FMC_SDClockPeriod;          /*!< Define the SDRAM Clock Period for both SDRAM Banks and they allow to disable
                                            the clock before changing frequency.
                                            This parameter can be a value of @ref FMC_SDClock_Period. */
                                            
  uint32_t FMC_ReadBurst;              /*!< This bit enable the SDRAM controller to anticipate the next read commands 
                                            during the CAS latency and stores data in the Read FIFO.
                                            This parameter can be a value of @ref FMC_Read_Burst. */
                                            
  uint32_t FMC_ReadPipeDelay;          /*!< Define the delay in system clock cycles on read data path.
                                            This parameter can be a value of @ref FMC_ReadPipe_Delay. */
                                            
  FMC_SDRAMTimingInitTypeDef* FMC_SDRAMTimingStruct;   /*!< Timing Parameters for write and read access*/                                            
  
}FMC_SDRAMInitTypeDef;


/* Exported constants --------------------------------------------------------*/

/** @defgroup FMC_Exported_Constants
  * @{
  */ 

/** @defgroup FMC_NORSRAM_Bank 
  * @{
  */
#define FMC_Bank1_NORSRAM1                      ((uint32_t)0x00000000)
#define FMC_Bank1_NORSRAM2                      ((uint32_t)0x00000002)
#define FMC_Bank1_NORSRAM3                      ((uint32_t)0x00000004)
#define FMC_Bank1_NORSRAM4                      ((uint32_t)0x00000006)

#define IS_FMC_NORSRAM_BANK(BANK) (((BANK) == FMC_Bank1_NORSRAM1) || \
                                   ((BANK) == FMC_Bank1_NORSRAM2) || \
                                   ((BANK) == FMC_Bank1_NORSRAM3) || \
                                   ((BANK) == FMC_Bank1_NORSRAM4))
/**
  * @}
  */

/** @defgroup FMC_NAND_Bank 
  * @{
  */  
#define FMC_Bank2_NAND                          ((uint32_t)0x00000010)
#define FMC_Bank3_NAND                          ((uint32_t)0x00000100)

#define IS_FMC_NAND_BANK(BANK) (((BANK) == FMC_Bank2_NAND) || \
                                ((BANK) == FMC_Bank3_NAND))
/**
  * @}
  */

/** @defgroup FMC_PCCARD_Bank 
  * @{
  */    
#define FMC_Bank4_PCCARD                        ((uint32_t)0x00001000)
/**
  * @}                                                         
  */

/** @defgroup FMC_SDRAM_Bank
  * @{
  */
#define FMC_Bank1_SDRAM                    ((uint32_t)0x00000000)
#define FMC_Bank2_SDRAM                    ((uint32_t)0x00000001)

#define IS_FMC_SDRAM_BANK(BANK) (((BANK) == FMC_Bank1_SDRAM) || \
                                 ((BANK) == FMC_Bank2_SDRAM)) 

/**
  * @}
  */                               

                              
/** @defgroup FMC_NOR_SRAM_Controller 
  * @{
  */

/** @defgroup FMC_Data_Address_Bus_Multiplexing 
  * @{
  */

#define FMC_DataAddressMux_Disable                ((uint32_t)0x00000000)
#define FMC_DataAddressMux_Enable                 ((uint32_t)0x00000002)

#define IS_FMC_MUX(MUX) (((MUX) == FMC_DataAddressMux_Disable) || \
                         ((MUX) == FMC_DataAddressMux_Enable))
/**
  * @}
  */

/** @defgroup FMC_Memory_Type 
  * @{
  */

#define FMC_MemoryType_SRAM                     ((uint32_t)0x00000000)
#define FMC_MemoryType_PSRAM                    ((uint32_t)0x00000004)
#define FMC_MemoryType_NOR                      ((uint32_t)0x00000008)

#define IS_FMC_MEMORY(MEMORY) (((MEMORY) == FMC_MemoryType_SRAM) || \
                               ((MEMORY) == FMC_MemoryType_PSRAM)|| \
                               ((MEMORY) == FMC_MemoryType_NOR))
/**
  * @}
  */

/** @defgroup FMC_NORSRAM_Data_Width 
  * @{
  */

#define FMC_NORSRAM_MemoryDataWidth_8b                  ((uint32_t)0x00000000)
#define FMC_NORSRAM_MemoryDataWidth_16b                 ((uint32_t)0x00000010)
#define FMC_NORSRAM_MemoryDataWidth_32b                 ((uint32_t)0x00000020)

#define IS_FMC_NORSRAM_MEMORY_WIDTH(WIDTH) (((WIDTH) == FMC_NORSRAM_MemoryDataWidth_8b)  || \
                                            ((WIDTH) == FMC_NORSRAM_MemoryDataWidth_16b) || \
                                            ((WIDTH) == FMC_NORSRAM_MemoryDataWidth_32b))
/**
  * @}
  */

/** @defgroup FMC_Burst_Access_Mode 
  * @{
  */

#define FMC_BurstAccessMode_Disable             ((uint32_t)0x00000000) 
#define FMC_BurstAccessMode_Enable              ((uint32_t)0x00000100)

#define IS_FMC_BURSTMODE(STATE) (((STATE) == FMC_BurstAccessMode_Disable) || \
                                  ((STATE) == FMC_BurstAccessMode_Enable))
/**
  * @}
  */
    
/** @defgroup FMC_AsynchronousWait 
  * @{
  */
#define FMC_AsynchronousWait_Disable            ((uint32_t)0x00000000)
#define FMC_AsynchronousWait_Enable             ((uint32_t)0x00008000)

#define IS_FMC_ASYNWAIT(STATE) (((STATE) == FMC_AsynchronousWait_Disable) || \
                                 ((STATE) == FMC_AsynchronousWait_Enable))
/**
  * @}
  */

/** @defgroup FMC_Wait_Signal_Polarity 
  * @{
  */
#define FMC_WaitSignalPolarity_Low              ((uint32_t)0x00000000)
#define FMC_WaitSignalPolarity_High             ((uint32_t)0x00000200)

#define IS_FMC_WAIT_POLARITY(POLARITY) (((POLARITY) == FMC_WaitSignalPolarity_Low) || \
                                         ((POLARITY) == FMC_WaitSignalPolarity_High))
/**
  * @}
  */

/** @defgroup FMC_Wrap_Mode 
  * @{
  */
#define FMC_WrapMode_Disable                    ((uint32_t)0x00000000)
#define FMC_WrapMode_Enable                     ((uint32_t)0x00000400) 

#define IS_FMC_WRAP_MODE(MODE) (((MODE) == FMC_WrapMode_Disable) || \
                                 ((MODE) == FMC_WrapMode_Enable))
/**
  * @}
  */

/** @defgroup FMC_Wait_Timing 
  * @{
  */
#define FMC_WaitSignalActive_BeforeWaitState    ((uint32_t)0x00000000)
#define FMC_WaitSignalActive_DuringWaitState    ((uint32_t)0x00000800) 

#define IS_FMC_WAIT_SIGNAL_ACTIVE(ACTIVE) (((ACTIVE) == FMC_WaitSignalActive_BeforeWaitState) || \
                                            ((ACTIVE) == FMC_WaitSignalActive_DuringWaitState))
/**
  * @}
  */

/** @defgroup FMC_Write_Operation 
  * @{
  */
#define FMC_WriteOperation_Disable                     ((uint32_t)0x00000000)
#define FMC_WriteOperation_Enable                      ((uint32_t)0x00001000)

#define IS_FMC_WRITE_OPERATION(OPERATION) (((OPERATION) == FMC_WriteOperation_Disable) || \
                                            ((OPERATION) == FMC_WriteOperation_Enable))                         
/**
  * @}
  */

/** @defgroup FMC_Wait_Signal 
  * @{
  */
#define FMC_WaitSignal_Disable                  ((uint32_t)0x00000000)
#define FMC_WaitSignal_Enable                   ((uint32_t)0x00002000) 

#define IS_FMC_WAITE_SIGNAL(SIGNAL) (((SIGNAL) == FMC_WaitSignal_Disable) || \
                                      ((SIGNAL) == FMC_WaitSignal_Enable))
/**
  * @}
  */

/** @defgroup FMC_Extended_Mode 
  * @{
  */
#define FMC_ExtendedMode_Disable                ((uint32_t)0x00000000)
#define FMC_ExtendedMode_Enable                 ((uint32_t)0x00004000)

#define IS_FMC_EXTENDED_MODE(MODE) (((MODE) == FMC_ExtendedMode_Disable) || \
                                     ((MODE) == FMC_ExtendedMode_Enable)) 
/**
  * @}
  */

/** @defgroup FMC_Write_Burst 
  * @{
  */

#define FMC_WriteBurst_Disable                  ((uint32_t)0x00000000)
#define FMC_WriteBurst_Enable                   ((uint32_t)0x00080000) 

#define IS_FMC_WRITE_BURST(BURST) (((BURST) == FMC_WriteBurst_Disable) || \
                                    ((BURST) == FMC_WriteBurst_Enable))
/**
  * @}
  */
  
/** @defgroup FMC_Continous_Clock 
  * @{
  */

#define FMC_CClock_SyncOnly                     ((uint32_t)0x00000000)
#define FMC_CClock_SyncAsync                    ((uint32_t)0x00100000) 

#define IS_FMC_CONTINOUS_CLOCK(CCLOCK) (((CCLOCK) == FMC_CClock_SyncOnly) || \
                                        ((CCLOCK) == FMC_CClock_SyncAsync))
/**
  * @}
  */  

/** @defgroup FMC_Address_Setup_Time 
  * @{
  */
#define IS_FMC_ADDRESS_SETUP_TIME(TIME) ((TIME) <= 15)
/**
  * @}
  */

/** @defgroup FMC_Address_Hold_Time 
  * @{
  */
#define IS_FMC_ADDRESS_HOLD_TIME(TIME) (((TIME) > 0) && ((TIME) <= 15))
/**
  * @}
  */

/** @defgroup FMC_Data_Setup_Time 
  * @{
  */
#define IS_FMC_DATASETUP_TIME(TIME) (((TIME) > 0) && ((TIME) <= 255))
/**
  * @}
  */

/** @defgroup FMC_Bus_Turn_around_Duration 
  * @{
  */
#define IS_FMC_TURNAROUND_TIME(TIME) ((TIME) <= 15)
/**
  * @}
  */

/** @defgroup FMC_CLK_Division 
  * @{
  */
#define IS_FMC_CLK_DIV(DIV) (((DIV) > 0) && ((DIV) <= 15))
/**
  * @}
  */

/** @defgroup FMC_Data_Latency 
  * @{
  */
#define IS_FMC_DATA_LATENCY(LATENCY) ((LATENCY) <= 15)
/**
  * @}
  */

/** @defgroup FMC_Access_Mode 
  * @{
  */
#define FMC_AccessMode_A                        ((uint32_t)0x00000000)
#define FMC_AccessMode_B                        ((uint32_t)0x10000000) 
#define FMC_AccessMode_C                        ((uint32_t)0x20000000)
#define FMC_AccessMode_D                        ((uint32_t)0x30000000)

#define IS_FMC_ACCESS_MODE(MODE) (((MODE) == FMC_AccessMode_A)  || \
                                   ((MODE) == FMC_AccessMode_B) || \
                                   ((MODE) == FMC_AccessMode_C) || \
                                   ((MODE) == FMC_AccessMode_D))
/**
  * @}
  */

/**
  * @}
  */
  
/** @defgroup FMC_NAND_PCCARD_Controller 
  * @{
  */

/** @defgroup FMC_Wait_feature 
  * @{
  */
#define FMC_Waitfeature_Disable                 ((uint32_t)0x00000000)
#define FMC_Waitfeature_Enable                  ((uint32_t)0x00000002)

#define IS_FMC_WAIT_FEATURE(FEATURE) (((FEATURE) == FMC_Waitfeature_Disable) || \
                                       ((FEATURE) == FMC_Waitfeature_Enable))
/**
  * @}
  */

/** @defgroup FMC_NAND_Data_Width 
  * @{
  */
#define FMC_NAND_MemoryDataWidth_8b             ((uint32_t)0x00000000)
#define FMC_NAND_MemoryDataWidth_16b            ((uint32_t)0x00000010)

#define IS_FMC_NAND_MEMORY_WIDTH(WIDTH) (((WIDTH) == FMC_NAND_MemoryDataWidth_8b) || \
                                         ((WIDTH) == FMC_NAND_MemoryDataWidth_16b))
/**
  * @}
  */

/** @defgroup FMC_ECC 
  * @{
  */
#define FMC_ECC_Disable                         ((uint32_t)0x00000000)
#define FMC_ECC_Enable                          ((uint32_t)0x00000040)

#define IS_FMC_ECC_STATE(STATE) (((STATE) == FMC_ECC_Disable) || \
                                  ((STATE) == FMC_ECC_Enable))
/**
  * @}
  */

/** @defgroup FMC_ECC_Page_Size 
  * @{
  */
#define FMC_ECCPageSize_256Bytes                ((uint32_t)0x00000000)
#define FMC_ECCPageSize_512Bytes                ((uint32_t)0x00020000)
#define FMC_ECCPageSize_1024Bytes               ((uint32_t)0x00040000)
#define FMC_ECCPageSize_2048Bytes               ((uint32_t)0x00060000)
#define FMC_ECCPageSize_4096Bytes               ((uint32_t)0x00080000)
#define FMC_ECCPageSize_8192Bytes               ((uint32_t)0x000A0000)

#define IS_FMC_ECCPAGE_SIZE(SIZE) (((SIZE) == FMC_ECCPageSize_256Bytes)   || \
                                    ((SIZE) == FMC_ECCPageSize_512Bytes)  || \
                                    ((SIZE) == FMC_ECCPageSize_1024Bytes) || \
                                    ((SIZE) == FMC_ECCPageSize_2048Bytes) || \
                                    ((SIZE) == FMC_ECCPageSize_4096Bytes) || \
                                    ((SIZE) == FMC_ECCPageSize_8192Bytes))
/**
  * @}
  */

/** @defgroup FMC_TCLR_Setup_Time 
  * @{
  */
#define IS_FMC_TCLR_TIME(TIME) ((TIME) <= 255)
/**
  * @}
  */

/** @defgroup FMC_TAR_Setup_Time 
  * @{
  */
#define IS_FMC_TAR_TIME(TIME) ((TIME) <= 255)
/**
  * @}
  */

/** @defgroup FMC_Setup_Time 
  * @{
  */
#define IS_FMC_SETUP_TIME(TIME) ((TIME) <= 255)
/**
  * @}
  */

/** @defgroup FMC_Wait_Setup_Time 
  * @{
  */
#define IS_FMC_WAIT_TIME(TIME) ((TIME) <= 255)
/**
  * @}
  */

/** @defgroup FMC_Hold_Setup_Time 
  * @{
  */
#define IS_FMC_HOLD_TIME(TIME) ((TIME) <= 255)
/**
  * @}
  */

/** @defgroup FMC_HiZ_Setup_Time 
  * @{
  */
#define IS_FMC_HIZ_TIME(TIME) ((TIME) <= 255)
/**
  * @}
  */

/**
  * @}
  */  


/** @defgroup FMC_NOR_SRAM_Controller 
  * @{
  */
        
/** @defgroup FMC_ColumnBits_Number 
  * @{
  */
#define FMC_ColumnBits_Number_8b           ((uint32_t)0x00000000)
#define FMC_ColumnBits_Number_9b           ((uint32_t)0x00000001)
#define FMC_ColumnBits_Number_10b          ((uint32_t)0x00000002)
#define FMC_ColumnBits_Number_11b          ((uint32_t)0x00000003)

#define IS_FMC_COLUMNBITS_NUMBER(COLUMN) (((COLUMN) == FMC_ColumnBits_Number_8b)  || \
                                          ((COLUMN) == FMC_ColumnBits_Number_9b)  || \
                                          ((COLUMN) == FMC_ColumnBits_Number_10b) || \
                                          ((COLUMN) == FMC_ColumnBits_Number_11b))

/**
  * @}
  */
  
/** @defgroup FMC_RowBits_Number 
  * @{
  */
#define FMC_RowBits_Number_11b             ((uint32_t)0x00000000)
#define FMC_RowBits_Number_12b             ((uint32_t)0x00000004)
#define FMC_RowBits_Number_13b             ((uint32_t)0x00000008)

#define IS_FMC_ROWBITS_NUMBER(ROW) (((ROW) == FMC_RowBits_Number_11b) || \
                                    ((ROW) == FMC_RowBits_Number_12b) || \
                                    ((ROW) == FMC_RowBits_Number_13b))

/**
  * @}
  */  

/** @defgroup FMC_SDMemory_Data_Width 
  * @{
  */
#define FMC_SDMemory_Width_8b                ((uint32_t)0x00000000)
#define FMC_SDMemory_Width_16b               ((uint32_t)0x00000010)
#define FMC_SDMemory_Width_32b               ((uint32_t)0x00000020)

#define IS_FMC_SDMEMORY_WIDTH(WIDTH) (((WIDTH) == FMC_SDMemory_Width_8b)  || \
                                      ((WIDTH) == FMC_SDMemory_Width_16b) || \
                                      ((WIDTH) == FMC_SDMemory_Width_32b))

/**
  * @}
  */
  
/** @defgroup FMC_InternalBank_Number
  * @{
  */
#define FMC_InternalBank_Number_2          ((uint32_t)0x00000000)
#define FMC_InternalBank_Number_4          ((uint32_t)0x00000040)

#define IS_FMC_INTERNALBANK_NUMBER(NUMBER) (((NUMBER) == FMC_InternalBank_Number_2) || \
                                            ((NUMBER) == FMC_InternalBank_Number_4)) 

/**
  * @}
  */  
  
  
/** @defgroup FMC_CAS_Latency 
  * @{
  */
#define FMC_CAS_Latency_1                  ((uint32_t)0x00000080)
#define FMC_CAS_Latency_2                  ((uint32_t)0x00000100)
#define FMC_CAS_Latency_3                  ((uint32_t)0x00000180)

#define IS_FMC_CAS_LATENCY(LATENCY) (((LATENCY) == FMC_CAS_Latency_1) || \
                                     ((LATENCY) == FMC_CAS_Latency_2) || \
                                     ((LATENCY) == FMC_CAS_Latency_3))

/**
  * @}
  */  

/** @defgroup FMC_Write_Protection
  * @{
  */
#define FMC_Write_Protection_Disable       ((uint32_t)0x00000000)
#define FMC_Write_Protection_Enable        ((uint32_t)0x00000200)

#define IS_FMC_WRITE_PROTECTION(WRITE) (((WRITE) == FMC_Write_Protection_Disable) || \
                                        ((WRITE) == FMC_Write_Protection_Enable))

/**
  * @}
  */  
  

/** @defgroup FMC_SDClock_Period
  * @{
  */
#define FMC_SDClock_Disable                ((uint32_t)0x00000000)
#define FMC_SDClock_Period_2               ((uint32_t)0x00000800)
#define FMC_SDClock_Period_3               ((uint32_t)0x00000C00)

#define IS_FMC_SDCLOCK_PERIOD(PERIOD) (((PERIOD) == FMC_SDClock_Disable) || \
                                       ((PERIOD) == FMC_SDClock_Period_2) || \
                                       ((PERIOD) == FMC_SDClock_Period_3))

/**
  * @}
  */ 
  
/** @defgroup FMC_Read_Burst
  * @{
  */
#define FMC_Read_Burst_Disable             ((uint32_t)0x00000000)
#define FMC_Read_Burst_Enable              ((uint32_t)0x00001000)

#define IS_FMC_READ_BURST(RBURST) (((RBURST) == FMC_Read_Burst_Disable) || \
                                   ((RBURST) == FMC_Read_Burst_Enable))

/**
  * @}
  */

/** @defgroup FMC_ReadPipe_Delay
  * @{
  */
#define FMC_ReadPipe_Delay_0               ((uint32_t)0x00000000)
#define FMC_ReadPipe_Delay_1               ((uint32_t)0x00002000)
#define FMC_ReadPipe_Delay_2               ((uint32_t)0x00004000)

#define IS_FMC_READPIPE_DELAY(DELAY) (((DELAY) == FMC_ReadPipe_Delay_0) || \
                                      ((DELAY) == FMC_ReadPipe_Delay_1) || \
                                      ((DELAY) == FMC_ReadPipe_Delay_2))

/**
  * @}
  */
  
/** @defgroup FMC_LoadToActive_Delay
  * @{
  */
#define IS_FMC_LOADTOACTIVE_DELAY(DELAY) (((DELAY) > 0) && ((DELAY) <= 16))
/**
  * @}
  */
  
/** @defgroup FMC_ExitSelfRefresh_Delay
  * @{
  */
#define IS_FMC_EXITSELFREFRESH_DELAY(DELAY) (((DELAY) > 0) && ((DELAY) <= 16))
/**
  * @}
  */ 
     
/** @defgroup FMC_SelfRefresh_Time
  * @{
  */  
#define IS_FMC_SELFREFRESH_TIME(TIME) (((TIME) > 0) && ((TIME) <= 16))
/**
  * @}
  */
  
/** @defgroup FMC_RowCycle_Delay
  * @{
  */  
#define IS_FMC_ROWCYCLE_DELAY(DELAY) (((DELAY) > 0) && ((DELAY) <= 16))
/**
  * @}
  */  
  
/** @defgroup FMC_Write_Recovery_Time
  * @{
  */  
#define IS_FMC_WRITE_RECOVERY_TIME(TIME) (((TIME) > 0) && ((TIME) <= 16))
/**
  * @}
  */         
  
/** @defgroup FMC_RP_Delay
  * @{
  */  
#define IS_FMC_RP_DELAY(DELAY) (((DELAY) > 0) && ((DELAY) <= 16))
/**
  * @}
  */ 
  
/** @defgroup FMC_RCD_Delay 
  * @{
  */  
#define IS_FMC_RCD_DELAY(DELAY) (((DELAY) > 0) && ((DELAY) <= 16))

/**
  * @}
  */  
  
/** @defgroup FMC_Command_Mode
  * @{
  */
#define FMC_Command_Mode_normal            ((uint32_t)0x00000000)
#define FMC_Command_Mode_CLK_Enabled       ((uint32_t)0x00000001)
#define FMC_Command_Mode_PALL              ((uint32_t)0x00000002)
#define FMC_Command_Mode_AutoRefresh       ((uint32_t)0x00000003)
#define FMC_Command_Mode_LoadMode          ((uint32_t)0x00000004)
#define FMC_Command_Mode_Selfrefresh       ((uint32_t)0x00000005)
#define FMC_Command_Mode_PowerDown         ((uint32_t)0x00000006)

#define IS_FMC_COMMAND_MODE(COMMAND) (((COMMAND) == FMC_Command_Mode_normal)      || \
                                      ((COMMAND) == FMC_Command_Mode_CLK_Enabled) || \
                                      ((COMMAND) == FMC_Command_Mode_PALL)        || \
                                      ((COMMAND) == FMC_Command_Mode_AutoRefresh) || \
                                      ((COMMAND) == FMC_Command_Mode_LoadMode)    || \
                                      ((COMMAND) == FMC_Command_Mode_Selfrefresh) || \
                                      ((COMMAND) == FMC_Command_Mode_PowerDown))

/**
  * @}
  */

/** @defgroup FMC_Command_Target
  * @{
  */
#define FMC_Command_Target_bank2           ((uint32_t)0x00000008)
#define FMC_Command_Target_bank1           ((uint32_t)0x00000010)
#define FMC_Command_Target_bank1_2         ((uint32_t)0x00000018)

#define IS_FMC_COMMAND_TARGET(TARGET) (((TARGET) == FMC_Command_Target_bank1) || \
                                       ((TARGET) == FMC_Command_Target_bank2) || \
                                       ((TARGET) == FMC_Command_Target_bank1_2))

/**
  * @}
  */   
  
/** @defgroup FMC_AutoRefresh_Number
  * @{
  */  
#define IS_FMC_AUTOREFRESH_NUMBER(NUMBER) (((NUMBER) > 0) && ((NUMBER) <= 16))

/**
  * @}
  */

/** @defgroup FMC_ModeRegister_Definition
  * @{
  */
#define IS_FMC_MODE_REGISTER(CONTENT) ((CONTENT) <= 8191)

/**
  * @}
  */
  

/** @defgroup FMC_Mode_Status 
  * @{
  */
#define FMC_NormalMode_Status                     ((uint32_t)0x00000000)
#define FMC_SelfRefreshMode_Status                FMC_SDSR_MODES1_0
#define FMC_PowerDownMode_Status                  FMC_SDSR_MODES1_1

#define IS_FMC_MODE_STATUS(STATUS) (((STATUS) == FMC_NormalMode_Status)       || \
                                    ((STATUS) == FMC_SelfRefreshMode_Status)  || \
                                    ((STATUS) == FMC_PowerDownMode_Status))


/**
  * @}
  */      

/**
  * @}
  */  

/** @defgroup FMC_Interrupt_sources 
  * @{
  */
#define FMC_IT_RisingEdge                       ((uint32_t)0x00000008)
#define FMC_IT_Level                            ((uint32_t)0x00000010)
#define FMC_IT_FallingEdge                      ((uint32_t)0x00000020)
#define FMC_IT_Refresh                          ((uint32_t)0x00004000)

#define IS_FMC_IT(IT) ((((IT) & (uint32_t)0xFFFFBFC7) == 0x00000000) && ((IT) != 0x00000000))
#define IS_FMC_GET_IT(IT) (((IT) == FMC_IT_RisingEdge)  || \
                           ((IT) == FMC_IT_Level)       || \
                           ((IT) == FMC_IT_FallingEdge) || \
                           ((IT) == FMC_IT_Refresh)) 
                           
#define IS_FMC_IT_BANK(BANK) (((BANK) == FMC_Bank2_NAND)   || \
                              ((BANK) == FMC_Bank3_NAND)   || \
                              ((BANK) == FMC_Bank4_PCCARD) || \
                              ((BANK) == FMC_Bank1_SDRAM)  || \
                              ((BANK) == FMC_Bank2_SDRAM))                           
/**
  * @}
  */

/** @defgroup FMC_Flags 
  * @{
  */
#define FMC_FLAG_RisingEdge                     ((uint32_t)0x00000001)
#define FMC_FLAG_Level                          ((uint32_t)0x00000002)
#define FMC_FLAG_FallingEdge                    ((uint32_t)0x00000004)
#define FMC_FLAG_FEMPT                          ((uint32_t)0x00000040)
#define FMC_FLAG_Refresh                        FMC_SDSR_RE
#define FMC_FLAG_Busy                           FMC_SDSR_BUSY

#define IS_FMC_GET_FLAG(FLAG) (((FLAG) == FMC_FLAG_RisingEdge)       || \
                               ((FLAG) == FMC_FLAG_Level)            || \
                               ((FLAG) == FMC_FLAG_FallingEdge)      || \
                               ((FLAG) == FMC_FLAG_FEMPT)            || \
                               ((FLAG) == FMC_FLAG_Refresh)          || \
                               ((FLAG) == FMC_SDSR_BUSY))

#define IS_FMC_GETFLAG_BANK(BANK) (((BANK) == FMC_Bank2_NAND)    || \
                                   ((BANK) == FMC_Bank3_NAND)    || \
                                   ((BANK) == FMC_Bank4_PCCARD)  || \
                                   ((BANK) == FMC_Bank1_SDRAM)   || \
                                   ((BANK) == FMC_Bank2_SDRAM)   || \
                                   ((BANK) == (FMC_Bank1_SDRAM | FMC_Bank2_SDRAM)))
                                   
#define IS_FMC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))


/**
  * @}
  */

/** @defgroup FMC_Refresh_count
  * @{
  */
#define IS_FMC_REFRESH_COUNT(COUNT) ((COUNT) <= 8191)

/**
  * @}
  */

/**
  * @}
  */


/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/* NOR/SRAM Controller functions **********************************************/
void FMC_NORSRAMDeInit(uint32_t FMC_Bank);
void FMC_NORSRAMInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct);
void FMC_NORSRAMStructInit(FMC_NORSRAMInitTypeDef* FMC_NORSRAMInitStruct);
void FMC_NORSRAMCmd(uint32_t FMC_Bank, FunctionalState NewState);

/* NAND Controller functions **************************************************/
void     FMC_NANDDeInit(uint32_t FMC_Bank);
void     FMC_NANDInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct);
void     FMC_NANDStructInit(FMC_NANDInitTypeDef* FMC_NANDInitStruct);
void     FMC_NANDCmd(uint32_t FMC_Bank, FunctionalState NewState);
void     FMC_NANDECCCmd(uint32_t FMC_Bank, FunctionalState NewState);
uint32_t FMC_GetECC(uint32_t FMC_Bank);

/* PCCARD Controller functions ************************************************/
void FMC_PCCARDDeInit(void);
void FMC_PCCARDInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct);
void FMC_PCCARDStructInit(FMC_PCCARDInitTypeDef* FMC_PCCARDInitStruct);
void FMC_PCCARDCmd(FunctionalState NewState);

/* SDRAM Controller functions ************************************************/
void     FMC_SDRAMDeInit(uint32_t FMC_Bank);
void     FMC_SDRAMInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct);
void     FMC_SDRAMStructInit(FMC_SDRAMInitTypeDef* FMC_SDRAMInitStruct);
void     FMC_SDRAMCmdConfig(FMC_SDRAMCommandTypeDef* FMC_SDRAMCommandStruct);
uint32_t FMC_GetModeStatus(uint32_t SDRAM_Bank);
void     FMC_SetRefreshCount(uint32_t FMC_Count);
void     FMC_SetAutoRefresh_Number(uint32_t FMC_Number);
void     FMC_SDRAMWriteProtectionConfig(uint32_t SDRAM_Bank, FunctionalState NewState);

/* Interrupts and flags management functions **********************************/
void       FMC_ITConfig(uint32_t FMC_Bank, uint32_t FMC_IT, FunctionalState NewState);
FlagStatus FMC_GetFlagStatus(uint32_t FMC_Bank, uint32_t FMC_FLAG);
void       FMC_ClearFlag(uint32_t FMC_Bank, uint32_t FMC_FLAG);
ITStatus   FMC_GetITStatus(uint32_t FMC_Bank, uint32_t FMC_IT);
void       FMC_ClearITPendingBit(uint32_t FMC_Bank, uint32_t FMC_IT);

#endif

#ifdef __cplusplus
}
#endif

/**
  * @}
  */

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_fmc.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_adc.h
/**
  ******************************************************************************
  * @file    stm32f4xx_adc.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the ADC firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_ADC_H
#define __STM32F4xx_ADC_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup ADC
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief   ADC Init structure definition  
  */ 
typedef struct
{
  uint32_t ADC_Resolution;                /*!< Configures the ADC resolution dual mode. 
                                               This parameter can be a value of @ref ADC_resolution */                                   
  FunctionalState ADC_ScanConvMode;       /*!< Specifies whether the conversion 
                                               is performed in Scan (multichannels) 
                                               or Single (one channel) mode.
                                               This parameter can be set to ENABLE or DISABLE */ 
  FunctionalState ADC_ContinuousConvMode; /*!< Specifies whether the conversion 
                                               is performed in Continuous or Single mode.
                                               This parameter can be set to ENABLE or DISABLE. */
  uint32_t ADC_ExternalTrigConvEdge;      /*!< Select the external trigger edge and
                                               enable the trigger of a regular group. 
                                               This parameter can be a value of 
                                               @ref ADC_external_trigger_edge_for_regular_channels_conversion */
  uint32_t ADC_ExternalTrigConv;          /*!< Select the external event used to trigger 
                                               the start of conversion of a regular group.
                                               This parameter can be a value of 
                                               @ref ADC_extrenal_trigger_sources_for_regular_channels_conversion */
  uint32_t ADC_DataAlign;                 /*!< Specifies whether the ADC data  alignment
                                               is left or right. This parameter can be 
                                               a value of @ref ADC_data_align */
  uint8_t  ADC_NbrOfConversion;           /*!< Specifies the number of ADC conversions
                                               that will be done using the sequencer for
                                               regular channel group.
                                               This parameter must range from 1 to 16. */
}ADC_InitTypeDef;
  
/** 
  * @brief   ADC Common Init structure definition  
  */ 
typedef struct 
{
  uint32_t ADC_Mode;                      /*!< Configures the ADC to operate in 
                                               independent or multi mode. 
                                               This parameter can be a value of @ref ADC_Common_mode */                                              
  uint32_t ADC_Prescaler;                 /*!< Select the frequency of the clock 
                                               to the ADC. The clock is common for all the ADCs.
                                               This parameter can be a value of @ref ADC_Prescaler */
  uint32_t ADC_DMAAccessMode;             /*!< Configures the Direct memory access 
                                              mode for multi ADC mode.
                                               This parameter can be a value of 
                                               @ref ADC_Direct_memory_access_mode_for_multi_mode */
  uint32_t ADC_TwoSamplingDelay;          /*!< Configures the Delay between 2 sampling phases.
                                               This parameter can be a value of 
                                               @ref ADC_delay_between_2_sampling_phases */
  
}ADC_CommonInitTypeDef;


/* Exported constants --------------------------------------------------------*/

/** @defgroup ADC_Exported_Constants
  * @{
  */ 
#define IS_ADC_ALL_PERIPH(PERIPH) (((PERIPH) == ADC1) || \
                                   ((PERIPH) == ADC2) || \
                                   ((PERIPH) == ADC3))  

/** @defgroup ADC_Common_mode 
  * @{
  */ 
#define ADC_Mode_Independent                       ((uint32_t)0x00000000)       
#define ADC_DualMode_RegSimult_InjecSimult         ((uint32_t)0x00000001)
#define ADC_DualMode_RegSimult_AlterTrig           ((uint32_t)0x00000002)
#define ADC_DualMode_InjecSimult                   ((uint32_t)0x00000005)
#define ADC_DualMode_RegSimult                     ((uint32_t)0x00000006)
#define ADC_DualMode_Interl                        ((uint32_t)0x00000007)
#define ADC_DualMode_AlterTrig                     ((uint32_t)0x00000009)
#define ADC_TripleMode_RegSimult_InjecSimult       ((uint32_t)0x00000011)
#define ADC_TripleMode_RegSimult_AlterTrig         ((uint32_t)0x00000012)
#define ADC_TripleMode_InjecSimult                 ((uint32_t)0x00000015)
#define ADC_TripleMode_RegSimult                   ((uint32_t)0x00000016)
#define ADC_TripleMode_Interl                      ((uint32_t)0x00000017)
#define ADC_TripleMode_AlterTrig                   ((uint32_t)0x00000019)
#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) || \
                           ((MODE) == ADC_DualMode_RegSimult_InjecSimult) || \
                           ((MODE) == ADC_DualMode_RegSimult_AlterTrig) || \
                           ((MODE) == ADC_DualMode_InjecSimult) || \
                           ((MODE) == ADC_DualMode_RegSimult) || \
                           ((MODE) == ADC_DualMode_Interl) || \
                           ((MODE) == ADC_DualMode_AlterTrig) || \
                           ((MODE) == ADC_TripleMode_RegSimult_InjecSimult) || \
                           ((MODE) == ADC_TripleMode_RegSimult_AlterTrig) || \
                           ((MODE) == ADC_TripleMode_InjecSimult) || \
                           ((MODE) == ADC_TripleMode_RegSimult) || \
                           ((MODE) == ADC_TripleMode_Interl) || \
                           ((MODE) == ADC_TripleMode_AlterTrig))
/**
  * @}
  */ 


/** @defgroup ADC_Prescaler 
  * @{
  */ 
#define ADC_Prescaler_Div2                         ((uint32_t)0x00000000)
#define ADC_Prescaler_Div4                         ((uint32_t)0x00010000)
#define ADC_Prescaler_Div6                         ((uint32_t)0x00020000)
#define ADC_Prescaler_Div8                         ((uint32_t)0x00030000)
#define IS_ADC_PRESCALER(PRESCALER) (((PRESCALER) == ADC_Prescaler_Div2) || \
                                     ((PRESCALER) == ADC_Prescaler_Div4) || \
                                     ((PRESCALER) == ADC_Prescaler_Div6) || \
                                     ((PRESCALER) == ADC_Prescaler_Div8))
/**
  * @}
  */ 


/** @defgroup ADC_Direct_memory_access_mode_for_multi_mode 
  * @{
  */ 
#define ADC_DMAAccessMode_Disabled      ((uint32_t)0x00000000)     /* DMA mode disabled */
#define ADC_DMAAccessMode_1             ((uint32_t)0x00004000)     /* DMA mode 1 enabled (2 / 3 half-words one by one - 1 then 2 then 3)*/
#define ADC_DMAAccessMode_2             ((uint32_t)0x00008000)     /* DMA mode 2 enabled (2 / 3 half-words by pairs - 2&1 then 1&3 then 3&2)*/
#define ADC_DMAAccessMode_3             ((uint32_t)0x0000C000)     /* DMA mode 3 enabled (2 / 3 bytes by pairs - 2&1 then 1&3 then 3&2) */
#define IS_ADC_DMA_ACCESS_MODE(MODE) (((MODE) == ADC_DMAAccessMode_Disabled) || \
                                      ((MODE) == ADC_DMAAccessMode_1) || \
                                      ((MODE) == ADC_DMAAccessMode_2) || \
                                      ((MODE) == ADC_DMAAccessMode_3))
                                     
/**
  * @}
  */ 


/** @defgroup ADC_delay_between_2_sampling_phases 
  * @{
  */ 
#define ADC_TwoSamplingDelay_5Cycles               ((uint32_t)0x00000000)
#define ADC_TwoSamplingDelay_6Cycles               ((uint32_t)0x00000100)
#define ADC_TwoSamplingDelay_7Cycles               ((uint32_t)0x00000200)
#define ADC_TwoSamplingDelay_8Cycles               ((uint32_t)0x00000300)
#define ADC_TwoSamplingDelay_9Cycles               ((uint32_t)0x00000400)
#define ADC_TwoSamplingDelay_10Cycles              ((uint32_t)0x00000500)
#define ADC_TwoSamplingDelay_11Cycles              ((uint32_t)0x00000600)
#define ADC_TwoSamplingDelay_12Cycles              ((uint32_t)0x00000700)
#define ADC_TwoSamplingDelay_13Cycles              ((uint32_t)0x00000800)
#define ADC_TwoSamplingDelay_14Cycles              ((uint32_t)0x00000900)
#define ADC_TwoSamplingDelay_15Cycles              ((uint32_t)0x00000A00)
#define ADC_TwoSamplingDelay_16Cycles              ((uint32_t)0x00000B00)
#define ADC_TwoSamplingDelay_17Cycles              ((uint32_t)0x00000C00)
#define ADC_TwoSamplingDelay_18Cycles              ((uint32_t)0x00000D00)
#define ADC_TwoSamplingDelay_19Cycles              ((uint32_t)0x00000E00)
#define ADC_TwoSamplingDelay_20Cycles              ((uint32_t)0x00000F00)
#define IS_ADC_SAMPLING_DELAY(DELAY) (((DELAY) == ADC_TwoSamplingDelay_5Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_6Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_7Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_8Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_9Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_10Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_11Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_12Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_13Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_14Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_15Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_16Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_17Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_18Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_19Cycles) || \
                                      ((DELAY) == ADC_TwoSamplingDelay_20Cycles))
                                     
/**
  * @}
  */ 


/** @defgroup ADC_resolution 
  * @{
  */ 
#define ADC_Resolution_12b                         ((uint32_t)0x00000000)
#define ADC_Resolution_10b                         ((uint32_t)0x01000000)
#define ADC_Resolution_8b                          ((uint32_t)0x02000000)
#define ADC_Resolution_6b                          ((uint32_t)0x03000000)
#define IS_ADC_RESOLUTION(RESOLUTION) (((RESOLUTION) == ADC_Resolution_12b) || \
                                       ((RESOLUTION) == ADC_Resolution_10b) || \
                                       ((RESOLUTION) == ADC_Resolution_8b) || \
                                       ((RESOLUTION) == ADC_Resolution_6b))
                                      
/**
  * @}
  */ 


/** @defgroup ADC_external_trigger_edge_for_regular_channels_conversion 
  * @{
  */ 
#define ADC_ExternalTrigConvEdge_None          ((uint32_t)0x00000000)
#define ADC_ExternalTrigConvEdge_Rising        ((uint32_t)0x10000000)
#define ADC_ExternalTrigConvEdge_Falling       ((uint32_t)0x20000000)
#define ADC_ExternalTrigConvEdge_RisingFalling ((uint32_t)0x30000000)
#define IS_ADC_EXT_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigConvEdge_None) || \
                             ((EDGE) == ADC_ExternalTrigConvEdge_Rising) || \
                             ((EDGE) == ADC_ExternalTrigConvEdge_Falling) || \
                             ((EDGE) == ADC_ExternalTrigConvEdge_RisingFalling))
/**
  * @}
  */ 


/** @defgroup ADC_extrenal_trigger_sources_for_regular_channels_conversion 
  * @{
  */ 
#define ADC_ExternalTrigConv_T1_CC1                ((uint32_t)0x00000000)
#define ADC_ExternalTrigConv_T1_CC2                ((uint32_t)0x01000000)
#define ADC_ExternalTrigConv_T1_CC3                ((uint32_t)0x02000000)
#define ADC_ExternalTrigConv_T2_CC2                ((uint32_t)0x03000000)
#define ADC_ExternalTrigConv_T2_CC3                ((uint32_t)0x04000000)
#define ADC_ExternalTrigConv_T2_CC4                ((uint32_t)0x05000000)
#define ADC_ExternalTrigConv_T2_TRGO               ((uint32_t)0x06000000)
#define ADC_ExternalTrigConv_T3_CC1                ((uint32_t)0x07000000)
#define ADC_ExternalTrigConv_T3_TRGO               ((uint32_t)0x08000000)
#define ADC_ExternalTrigConv_T4_CC4                ((uint32_t)0x09000000)
#define ADC_ExternalTrigConv_T5_CC1                ((uint32_t)0x0A000000)
#define ADC_ExternalTrigConv_T5_CC2                ((uint32_t)0x0B000000)
#define ADC_ExternalTrigConv_T5_CC3                ((uint32_t)0x0C000000)
#define ADC_ExternalTrigConv_T8_CC1                ((uint32_t)0x0D000000)
#define ADC_ExternalTrigConv_T8_TRGO               ((uint32_t)0x0E000000)
#define ADC_ExternalTrigConv_Ext_IT11              ((uint32_t)0x0F000000)
#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC4) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_TRGO) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC2) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) || \
                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11))
/**
  * @}
  */ 


/** @defgroup ADC_data_align 
  * @{
  */ 
#define ADC_DataAlign_Right                        ((uint32_t)0x00000000)
#define ADC_DataAlign_Left                         ((uint32_t)0x00000800)
#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
                                  ((ALIGN) == ADC_DataAlign_Left))
/**
  * @}
  */ 


/** @defgroup ADC_channels 
  * @{
  */ 
#define ADC_Channel_0                               ((uint8_t)0x00)
#define ADC_Channel_1                               ((uint8_t)0x01)
#define ADC_Channel_2                               ((uint8_t)0x02)
#define ADC_Channel_3                               ((uint8_t)0x03)
#define ADC_Channel_4                               ((uint8_t)0x04)
#define ADC_Channel_5                               ((uint8_t)0x05)
#define ADC_Channel_6                               ((uint8_t)0x06)
#define ADC_Channel_7                               ((uint8_t)0x07)
#define ADC_Channel_8                               ((uint8_t)0x08)
#define ADC_Channel_9                               ((uint8_t)0x09)
#define ADC_Channel_10                              ((uint8_t)0x0A)
#define ADC_Channel_11                              ((uint8_t)0x0B)
#define ADC_Channel_12                              ((uint8_t)0x0C)
#define ADC_Channel_13                              ((uint8_t)0x0D)
#define ADC_Channel_14                              ((uint8_t)0x0E)
#define ADC_Channel_15                              ((uint8_t)0x0F)
#define ADC_Channel_16                              ((uint8_t)0x10)
#define ADC_Channel_17                              ((uint8_t)0x11)
#define ADC_Channel_18                              ((uint8_t)0x12)

#if defined (STM32F40_41xxx)
#define ADC_Channel_TempSensor                      ((uint8_t)ADC_Channel_16)
#endif /* STM32F40_41xxx */

#if defined (STM32F427_437xx) || defined (STM32F429_439xx) || defined (STM32F401xx) || defined (STM32F411xE)
#define ADC_Channel_TempSensor                      ((uint8_t)ADC_Channel_18)
#endif /* STM32F427_437xx || STM32F429_439xx || STM32F401xx || STM32F411xE */

#define ADC_Channel_Vrefint                         ((uint8_t)ADC_Channel_17)
#define ADC_Channel_Vbat                            ((uint8_t)ADC_Channel_18)

#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || \
                                 ((CHANNEL) == ADC_Channel_1) || \
                                 ((CHANNEL) == ADC_Channel_2) || \
                                 ((CHANNEL) == ADC_Channel_3) || \
                                 ((CHANNEL) == ADC_Channel_4) || \
                                 ((CHANNEL) == ADC_Channel_5) || \
                                 ((CHANNEL) == ADC_Channel_6) || \
                                 ((CHANNEL) == ADC_Channel_7) || \
                                 ((CHANNEL) == ADC_Channel_8) || \
                                 ((CHANNEL) == ADC_Channel_9) || \
                                 ((CHANNEL) == ADC_Channel_10) || \
                                 ((CHANNEL) == ADC_Channel_11) || \
                                 ((CHANNEL) == ADC_Channel_12) || \
                                 ((CHANNEL) == ADC_Channel_13) || \
                                 ((CHANNEL) == ADC_Channel_14) || \
                                 ((CHANNEL) == ADC_Channel_15) || \
                                 ((CHANNEL) == ADC_Channel_16) || \
                                 ((CHANNEL) == ADC_Channel_17) || \
                                 ((CHANNEL) == ADC_Channel_18))
/**
  * @}
  */ 


/** @defgroup ADC_sampling_times 
  * @{
  */ 
#define ADC_SampleTime_3Cycles                    ((uint8_t)0x00)
#define ADC_SampleTime_15Cycles                   ((uint8_t)0x01)
#define ADC_SampleTime_28Cycles                   ((uint8_t)0x02)
#define ADC_SampleTime_56Cycles                   ((uint8_t)0x03)
#define ADC_SampleTime_84Cycles                   ((uint8_t)0x04)
#define ADC_SampleTime_112Cycles                  ((uint8_t)0x05)
#define ADC_SampleTime_144Cycles                  ((uint8_t)0x06)
#define ADC_SampleTime_480Cycles                  ((uint8_t)0x07)
#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_3Cycles) || \
                                  ((TIME) == ADC_SampleTime_15Cycles) || \
                                  ((TIME) == ADC_SampleTime_28Cycles) || \
                                  ((TIME) == ADC_SampleTime_56Cycles) || \
                                  ((TIME) == ADC_SampleTime_84Cycles) || \
                                  ((TIME) == ADC_SampleTime_112Cycles) || \
                                  ((TIME) == ADC_SampleTime_144Cycles) || \
                                  ((TIME) == ADC_SampleTime_480Cycles))
/**
  * @}
  */ 


/** @defgroup ADC_external_trigger_edge_for_injected_channels_conversion 
  * @{
  */ 
#define ADC_ExternalTrigInjecConvEdge_None          ((uint32_t)0x00000000)
#define ADC_ExternalTrigInjecConvEdge_Rising        ((uint32_t)0x00100000)
#define ADC_ExternalTrigInjecConvEdge_Falling       ((uint32_t)0x00200000)
#define ADC_ExternalTrigInjecConvEdge_RisingFalling ((uint32_t)0x00300000)
#define IS_ADC_EXT_INJEC_TRIG_EDGE(EDGE) (((EDGE) == ADC_ExternalTrigInjecConvEdge_None) || \
                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_Rising) || \
                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_Falling) || \
                                          ((EDGE) == ADC_ExternalTrigInjecConvEdge_RisingFalling))
                                            
/**
  * @}
  */ 


/** @defgroup ADC_extrenal_trigger_sources_for_injected_channels_conversion 
  * @{
  */ 
#define ADC_ExternalTrigInjecConv_T1_CC4            ((uint32_t)0x00000000)
#define ADC_ExternalTrigInjecConv_T1_TRGO           ((uint32_t)0x00010000)
#define ADC_ExternalTrigInjecConv_T2_CC1            ((uint32_t)0x00020000)
#define ADC_ExternalTrigInjecConv_T2_TRGO           ((uint32_t)0x00030000)
#define ADC_ExternalTrigInjecConv_T3_CC2            ((uint32_t)0x00040000)
#define ADC_ExternalTrigInjecConv_T3_CC4            ((uint32_t)0x00050000)
#define ADC_ExternalTrigInjecConv_T4_CC1            ((uint32_t)0x00060000)
#define ADC_ExternalTrigInjecConv_T4_CC2            ((uint32_t)0x00070000)
#define ADC_ExternalTrigInjecConv_T4_CC3            ((uint32_t)0x00080000)
#define ADC_ExternalTrigInjecConv_T4_TRGO           ((uint32_t)0x00090000)
#define ADC_ExternalTrigInjecConv_T5_CC4            ((uint32_t)0x000A0000)
#define ADC_ExternalTrigInjecConv_T5_TRGO           ((uint32_t)0x000B0000)
#define ADC_ExternalTrigInjecConv_T8_CC2            ((uint32_t)0x000C0000)
#define ADC_ExternalTrigInjecConv_T8_CC3            ((uint32_t)0x000D0000)
#define ADC_ExternalTrigInjecConv_T8_CC4            ((uint32_t)0x000E0000)
#define ADC_ExternalTrigInjecConv_Ext_IT15          ((uint32_t)0x000F0000)
#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC2) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC1) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC2) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC3) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) || \
                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15))
/**
  * @}
  */ 


/** @defgroup ADC_injected_channel_selection 
  * @{
  */ 
#define ADC_InjectedChannel_1                       ((uint8_t)0x14)
#define ADC_InjectedChannel_2                       ((uint8_t)0x18)
#define ADC_InjectedChannel_3                       ((uint8_t)0x1C)
#define ADC_InjectedChannel_4                       ((uint8_t)0x20)
#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
                                          ((CHANNEL) == ADC_InjectedChannel_4))
/**
  * @}
  */ 


/** @defgroup ADC_analog_watchdog_selection 
  * @{
  */ 
#define ADC_AnalogWatchdog_SingleRegEnable         ((uint32_t)0x00800200)
#define ADC_AnalogWatchdog_SingleInjecEnable       ((uint32_t)0x00400200)
#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((uint32_t)0x00C00200)
#define ADC_AnalogWatchdog_AllRegEnable            ((uint32_t)0x00800000)
#define ADC_AnalogWatchdog_AllInjecEnable          ((uint32_t)0x00400000)
#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((uint32_t)0x00C00000)
#define ADC_AnalogWatchdog_None                    ((uint32_t)0x00000000)
#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \
                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \
                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) || \
                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \
                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \
                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
/**
  * @}
  */ 


/** @defgroup ADC_interrupts_definition 
  * @{
  */ 
#define ADC_IT_EOC                                 ((uint16_t)0x0205)  
#define ADC_IT_AWD                                 ((uint16_t)0x0106)  
#define ADC_IT_JEOC                                ((uint16_t)0x0407)  
#define ADC_IT_OVR                                 ((uint16_t)0x201A)  
#define IS_ADC_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \
                       ((IT) == ADC_IT_JEOC)|| ((IT) == ADC_IT_OVR)) 
/**
  * @}
  */ 


/** @defgroup ADC_flags_definition 
  * @{
  */ 
#define ADC_FLAG_AWD                               ((uint8_t)0x01)
#define ADC_FLAG_EOC                               ((uint8_t)0x02)
#define ADC_FLAG_JEOC                              ((uint8_t)0x04)
#define ADC_FLAG_JSTRT                             ((uint8_t)0x08)
#define ADC_FLAG_STRT                              ((uint8_t)0x10)
#define ADC_FLAG_OVR                               ((uint8_t)0x20)   
  
#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (uint8_t)0xC0) == 0x00) && ((FLAG) != 0x00))   
#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || \
                               ((FLAG) == ADC_FLAG_EOC) || \
                               ((FLAG) == ADC_FLAG_JEOC) || \
                               ((FLAG)== ADC_FLAG_JSTRT) || \
                               ((FLAG) == ADC_FLAG_STRT) || \
                               ((FLAG)== ADC_FLAG_OVR))     
/**
  * @}
  */ 


/** @defgroup ADC_thresholds 
  * @{
  */ 
#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
/**
  * @}
  */ 


/** @defgroup ADC_injected_offset 
  * @{
  */ 
#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
/**
  * @}
  */ 


/** @defgroup ADC_injected_length 
  * @{
  */ 
#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
/**
  * @}
  */ 


/** @defgroup ADC_injected_rank 
  * @{
  */ 
#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
/**
  * @}
  */ 


/** @defgroup ADC_regular_length 
  * @{
  */ 
#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))
/**
  * @}
  */ 


/** @defgroup ADC_regular_rank 
  * @{
  */ 
#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x10))
/**
  * @}
  */ 


/** @defgroup ADC_regular_discontinuous_mode_number 
  * @{
  */ 
#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
/**
  * @}
  */ 


/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/  

/*  Function used to set the ADC configuration to the default reset state *****/  
void ADC_DeInit(void);

/* Initialization and Configuration functions *********************************/
void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
void ADC_CommonInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct);
void ADC_CommonStructInit(ADC_CommonInitTypeDef* ADC_CommonInitStruct);
void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);

/* Analog Watchdog configuration functions ************************************/
void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog);
void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,uint16_t LowThreshold);
void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel);

/* Temperature Sensor, Vrefint and VBAT management functions ******************/
void ADC_TempSensorVrefintCmd(FunctionalState NewState);
void ADC_VBATCmd(FunctionalState NewState);

/* Regular Channels Configuration functions ***********************************/
void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
void ADC_SoftwareStartConv(ADC_TypeDef* ADCx);
FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
void ADC_EOCOnEachRegularChannelCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
void ADC_ContinuousModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number);
void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx);
uint32_t ADC_GetMultiModeConversionValue(void);

/* Regular Channels DMA Configuration functions *******************************/
void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
void ADC_DMARequestAfterLastTransferCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
void ADC_MultiModeDMARequestAfterLastTransferCmd(FunctionalState NewState);

/* Injected channels Configuration functions **********************************/
void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime);
void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length);
void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset);
void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv);
void ADC_ExternalTrigInjectedConvEdgeConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConvEdge);
void ADC_SoftwareStartInjectedConv(ADC_TypeDef* ADCx);
FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel);

/* Interrupts and flags management functions **********************************/
void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState);
FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG);
ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT);
void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT);

#ifdef __cplusplus
}
#endif

#endif /*__STM32F4xx_ADC_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_adc.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_syscfg.h
/**
  ******************************************************************************
  * @file    stm32f4xx_syscfg.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the SYSCFG firmware
  *          library. 
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_SYSCFG_H
#define __STM32F4xx_SYSCFG_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup SYSCFG
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/
  
/** @defgroup SYSCFG_Exported_Constants 
  * @{
  */ 

/** @defgroup SYSCFG_EXTI_Port_Sources 
  * @{
  */ 
#define EXTI_PortSourceGPIOA       ((uint8_t)0x00)
#define EXTI_PortSourceGPIOB       ((uint8_t)0x01)
#define EXTI_PortSourceGPIOC       ((uint8_t)0x02)
#define EXTI_PortSourceGPIOD       ((uint8_t)0x03)
#define EXTI_PortSourceGPIOE       ((uint8_t)0x04)
#define EXTI_PortSourceGPIOF       ((uint8_t)0x05)
#define EXTI_PortSourceGPIOG       ((uint8_t)0x06)
#define EXTI_PortSourceGPIOH       ((uint8_t)0x07)
#define EXTI_PortSourceGPIOI       ((uint8_t)0x08)
#define EXTI_PortSourceGPIOJ       ((uint8_t)0x09)
#define EXTI_PortSourceGPIOK       ((uint8_t)0x0A)

#define IS_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == EXTI_PortSourceGPIOA) || \
                                         ((PORTSOURCE) == EXTI_PortSourceGPIOB) || \
                                         ((PORTSOURCE) == EXTI_PortSourceGPIOC) || \
                                         ((PORTSOURCE) == EXTI_PortSourceGPIOD) || \
                                         ((PORTSOURCE) == EXTI_PortSourceGPIOE) || \
                                         ((PORTSOURCE) == EXTI_PortSourceGPIOF) || \
                                         ((PORTSOURCE) == EXTI_PortSourceGPIOG) || \
                                         ((PORTSOURCE) == EXTI_PortSourceGPIOH) || \
                                         ((PORTSOURCE) == EXTI_PortSourceGPIOI) || \
                                         ((PORTSOURCE) == EXTI_PortSourceGPIOJ) || \
                                         ((PORTSOURCE) == EXTI_PortSourceGPIOK))
                                         
/**
  * @}
  */ 


/** @defgroup SYSCFG_EXTI_Pin_Sources 
  * @{
  */ 
#define EXTI_PinSource0            ((uint8_t)0x00)
#define EXTI_PinSource1            ((uint8_t)0x01)
#define EXTI_PinSource2            ((uint8_t)0x02)
#define EXTI_PinSource3            ((uint8_t)0x03)
#define EXTI_PinSource4            ((uint8_t)0x04)
#define EXTI_PinSource5            ((uint8_t)0x05)
#define EXTI_PinSource6            ((uint8_t)0x06)
#define EXTI_PinSource7            ((uint8_t)0x07)
#define EXTI_PinSource8            ((uint8_t)0x08)
#define EXTI_PinSource9            ((uint8_t)0x09)
#define EXTI_PinSource10           ((uint8_t)0x0A)
#define EXTI_PinSource11           ((uint8_t)0x0B)
#define EXTI_PinSource12           ((uint8_t)0x0C)
#define EXTI_PinSource13           ((uint8_t)0x0D)
#define EXTI_PinSource14           ((uint8_t)0x0E)
#define EXTI_PinSource15           ((uint8_t)0x0F)
#define IS_EXTI_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == EXTI_PinSource0)  || \
                                       ((PINSOURCE) == EXTI_PinSource1)  || \
                                       ((PINSOURCE) == EXTI_PinSource2)  || \
                                       ((PINSOURCE) == EXTI_PinSource3)  || \
                                       ((PINSOURCE) == EXTI_PinSource4)  || \
                                       ((PINSOURCE) == EXTI_PinSource5)  || \
                                       ((PINSOURCE) == EXTI_PinSource6)  || \
                                       ((PINSOURCE) == EXTI_PinSource7)  || \
                                       ((PINSOURCE) == EXTI_PinSource8)  || \
                                       ((PINSOURCE) == EXTI_PinSource9)  || \
                                       ((PINSOURCE) == EXTI_PinSource10) || \
                                       ((PINSOURCE) == EXTI_PinSource11) || \
                                       ((PINSOURCE) == EXTI_PinSource12) || \
                                       ((PINSOURCE) == EXTI_PinSource13) || \
                                       ((PINSOURCE) == EXTI_PinSource14) || \
                                       ((PINSOURCE) == EXTI_PinSource15))
/**
  * @}
  */ 


/** @defgroup SYSCFG_Memory_Remap_Config 
  * @{
  */ 
#define SYSCFG_MemoryRemap_Flash       ((uint8_t)0x00)
#define SYSCFG_MemoryRemap_SystemFlash ((uint8_t)0x01)
#define SYSCFG_MemoryRemap_SRAM        ((uint8_t)0x03)
#define SYSCFG_MemoryRemap_SDRAM       ((uint8_t)0x04)

#if defined (STM32F40_41xxx)
#define SYSCFG_MemoryRemap_FSMC        ((uint8_t)0x02) 
#endif /* STM32F40_41xxx */

#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
#define SYSCFG_MemoryRemap_FMC         ((uint8_t)0x02) 
#endif /* STM32F427_437xx ||  STM32F429_439xx */  

#if defined (STM32F40_41xxx) 
#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       || \
                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM)        || \
                                               ((REMAP) == SYSCFG_MemoryRemap_FSMC))
#endif /* STM32F40_41xxx */

#if defined (STM32F401xx) || defined (STM32F411xE)
#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       || \
                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM))
#endif /* STM32F401xx || STM32F411xE */

#if defined (STM32F427_437xx) || defined (STM32F429_439xx)
#define IS_SYSCFG_MEMORY_REMAP_CONFING(REMAP) (((REMAP) == SYSCFG_MemoryRemap_Flash)       || \
                                               ((REMAP) == SYSCFG_MemoryRemap_SystemFlash) || \
                                               ((REMAP) == SYSCFG_MemoryRemap_SRAM)        || \
                                               ((REMAP) == SYSCFG_MemoryRemap_SDRAM)       || \
                                               ((REMAP) == SYSCFG_MemoryRemap_FMC))
#endif /* STM32F427_437xx ||  STM32F429_439xx */
                                                                                              
/**
  * @}
  */ 


/** @defgroup SYSCFG_ETHERNET_Media_Interface 
  * @{
  */ 
#define SYSCFG_ETH_MediaInterface_MII    ((uint32_t)0x00000000)
#define SYSCFG_ETH_MediaInterface_RMII   ((uint32_t)0x00000001)

#define IS_SYSCFG_ETH_MEDIA_INTERFACE(INTERFACE) (((INTERFACE) == SYSCFG_ETH_MediaInterface_MII) || \
                                                 ((INTERFACE) == SYSCFG_ETH_MediaInterface_RMII))
/**
  * @}
  */ 

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 
 
void SYSCFG_DeInit(void);
void       SYSCFG_MemoryRemapConfig(uint8_t SYSCFG_MemoryRemap);
void       SYSCFG_MemorySwappingBank(FunctionalState NewState);
void       SYSCFG_EXTILineConfig(uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex);
void       SYSCFG_ETH_MediaInterfaceConfig(uint32_t SYSCFG_ETH_MediaInterface); 
void       SYSCFG_CompensationCellCmd(FunctionalState NewState); 
FlagStatus SYSCFG_GetCompensationCellStatus(void);

#ifdef __cplusplus
}
#endif

#endif /*__STM32F4xx_SYSCFG_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_syscfg.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_sai.h
/**
  ******************************************************************************
  * @file    stm32f4xx_sai.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the SAI 
  *          firmware library.  
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#pragma once

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

#if defined(STM32PLUS_F4_HAS_SAI)


/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup SAI
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief  SAI Block Init structure definition  
  */

typedef struct
{
  uint32_t SAI_AudioMode;           /*!< Specifies the SAI Block Audio Mode.
                                         This parameter can be a value of @ref SAI_Block_Mode */

  uint32_t SAI_Protocol;             /*!< Specifies the SAI Block Protocol.
                                         This parameter can be a value of @ref SAI_Block_Protocol */

  uint32_t SAI_DataSize;            /*!< Specifies the SAI Block data size.
                                         This parameter can be a value of @ref SAI_Block_Data_Size 
                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/

  uint32_t SAI_FirstBit;            /*!< Specifies whether data transfers start from MSB or LSB bit.
                                         This parameter can be a value of @ref SAI_Block_MSB_LSB_transmission 
                                         @note this value has no meaning when AC'97 or SPDIF protocols are selected.*/

  uint32_t SAI_ClockStrobing;       /*!< Specifies the SAI Block clock strobing edge sensitivity.
                                         This parameter can be a value of @ref SAI_Block_Clock_Strobing */

  uint32_t SAI_Synchro;             /*!< Specifies SAI Block synchronization
                                         This parameter can be a value of @ref SAI_Block_Synchronization */
 
  uint32_t SAI_OUTDRIV;             /*!< Specifies when SAI Block outputs are driven.
                                         This parameter can be a value of @ref SAI_Block_Output_Drive
                                         @note this value has to be set before enabling the audio block  
                                               but after the audio block configuration. */

  uint32_t SAI_NoDivider;            /*!< Specifies whether Master Clock will be divided or not.
                                         This parameter can be a value of @ref SAI_Block_NoDivider */

  uint32_t SAI_MasterDivider;       /*!< Specifies SAI Block Master Clock Divider. 
                                         @note the Master Clock Frequency is calculated accordingly to the  
                                               following formula : MCLK_x = SAI_CK_x/(MCKDIV[3:0]*2)*/
                                               
  uint32_t SAI_FIFOThreshold;      /*!< Specifies SAI Block FIFO Threshold.
                                         This parameter can be a value of @ref SAI_Block_Fifo_Threshold */                                                                                             
}SAI_InitTypeDef;

/** 
  * @brief  SAI Block Frame Init structure definition  
  */

typedef struct
{

  uint32_t SAI_FrameLength;         /*!< Specifies the Frame Length, the number of SCK clocks 
                                         for each audio frame.
                                         This parameter must be a number between 8 and 256.
                                         @note If master Clock MCLK_x pin is declared as an output, the frame length
                                               should be Aligned to a number equal to power of 2 in order to keep 
                                              in an audio frame, an integer number of MCLK pulses by bit Clock.                                                 
                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/
                                   
  uint32_t SAI_ActiveFrameLength;   /*!< Specifies the Frame synchronization active level length.
                                         This Parameter specifies the length in number of bit clock (SCK + 1)  
                                         of the active level of FS signal in audio frame.
                                         This parameter must be a number between 1 and 128. 
                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/

  uint32_t SAI_FSDefinition;        /*!< Specifies the Frame Synchronization definition.
                                         This parameter can be a value of @ref SAI_Block_FS_Definition 
                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/

  uint32_t SAI_FSPolarity;          /*!< Specifies the Frame Synchronization Polarity.
                                         This parameter can be a value of @ref SAI_Block_FS_Polarity 
                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/

  uint32_t SAI_FSOffset;            /*!< Specifies the Frame Synchronization Offset.
                                         This parameter can be a value of @ref SAI_Block_FS_Offset 
                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/

}SAI_FrameInitTypeDef;

/**
  * @brief   SAI Block Slot Init Structure definition
  */    

typedef struct
{
  uint32_t SAI_FirstBitOffset;      /*!< Specifies the position of first data transfer bit in the slot.
                                         This parameter must be a number between 0 and 24. 
                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/

  uint32_t SAI_SlotSize;            /*!< Specifies the Slot Size.
                                         This parameter can be a value of @ref SAI_Block_Slot_Size 
                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/

  uint32_t SAI_SlotNumber;          /*!< Specifies the number of slot in the audio frame.
                                         This parameter must be a number between 1 and 16. 
                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/

  uint32_t SAI_SlotActive;          /*!< Specifies the slots in audio frame that will be activated.
                                         This parameter can be a value of @ ref SAI_Block_Slot_Active 
                                         @note this value is ignored when AC'97 or SPDIF protocols are selected.*/ 
}SAI_SlotInitTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup SAI_Exported_Constants
  * @{
  */

#define IS_SAI_PERIPH(PERIPH) ((PERIPH) == SAI1)

#define IS_SAI_BLOCK_PERIPH(PERIPH) (((PERIPH) == SAI1_Block_A) || \
                                     ((PERIPH) == SAI1_Block_B))


/** @defgroup SAI_Block_Mode 
  * @{
  */
#define SAI_Mode_MasterTx               ((uint32_t)0x00000000)
#define SAI_Mode_MasterRx               ((uint32_t)0x00000001)  
#define SAI_Mode_SlaveTx                ((uint32_t)0x00000002)
#define SAI_Mode_SlaveRx                ((uint32_t)0x00000003)
#define IS_SAI_BLOCK_MODE(MODE) (((MODE) == SAI_Mode_MasterTx) || \
                                 ((MODE) == SAI_Mode_MasterRx) || \
                                 ((MODE) == SAI_Mode_SlaveTx)  || \
                                 ((MODE) == SAI_Mode_SlaveRx))
/**
  * @}
  */

/** @defgroup SAI_Block_Protocol 
  * @{
  */

#define SAI_Free_Protocol                 ((uint32_t)0x00000000)
#define SAI_SPDIF_Protocol                ((uint32_t)SAI_xCR1_PRTCFG_0)
#define SAI_AC97_Protocol                 ((uint32_t)SAI_xCR1_PRTCFG_1)
#define IS_SAI_BLOCK_PROTOCOL(PROTOCOL) (((PROTOCOL) == SAI_Free_Protocol)  || \
                                         ((PROTOCOL) == SAI_SPDIF_Protocol) || \
                                         ((PROTOCOL) == SAI_AC97_Protocol))
/**
  * @}
  */

/** @defgroup SAI_Block_Data_Size 
  * @{
  */

#define SAI_DataSize_8b                   ((uint32_t)0x00000040)
#define SAI_DataSize_10b                  ((uint32_t)0x00000060)
#define SAI_DataSize_16b                  ((uint32_t)0x00000080)
#define SAI_DataSize_20b                  ((uint32_t)0x000000A0)
#define SAI_DataSize_24b                  ((uint32_t)0x000000C0)
#define SAI_DataSize_32b                  ((uint32_t)0x000000E0)
#define IS_SAI_BLOCK_DATASIZE(DATASIZE) (((DATASIZE) == SAI_DataSize_8b)  || \
                                         ((DATASIZE) == SAI_DataSize_10b) || \
                                         ((DATASIZE) == SAI_DataSize_16b) || \
                                         ((DATASIZE) == SAI_DataSize_20b) || \
                                         ((DATASIZE) == SAI_DataSize_24b) || \
                                         ((DATASIZE) == SAI_DataSize_32b))
/**
  * @}
  */ 

/** @defgroup SAI_Block_MSB_LSB_transmission 
  * @{
  */

#define SAI_FirstBit_MSB                  ((uint32_t)0x00000000)
#define SAI_FirstBit_LSB                  ((uint32_t)SAI_xCR1_LSBFIRST)
#define IS_SAI_BLOCK_FIRST_BIT(BIT) (((BIT) == SAI_FirstBit_MSB) || \
                                     ((BIT) == SAI_FirstBit_LSB))
/**
  * @}
  */

/** @defgroup SAI_Block_Clock_Strobing 
  * @{
  */

#define SAI_ClockStrobing_FallingEdge     ((uint32_t)0x00000000)
#define SAI_ClockStrobing_RisingEdge      ((uint32_t)SAI_xCR1_CKSTR)
#define IS_SAI_BLOCK_CLOCK_STROBING(CLOCK) (((CLOCK) == SAI_ClockStrobing_FallingEdge) || \
                                            ((CLOCK) == SAI_ClockStrobing_RisingEdge))
/**
  * @}
  */

/** @defgroup SAI_Block_Synchronization 
  * @{
  */

#define SAI_Asynchronous                   ((uint32_t)0x00000000)
#define SAI_Synchronous                    ((uint32_t)SAI_xCR1_SYNCEN_0)
#define IS_SAI_BLOCK_SYNCHRO(SYNCHRO) (((SYNCHRO) == SAI_Synchronous) || \
                                       ((SYNCHRO) == SAI_Asynchronous))
/**
  * @}
  */ 

/** @defgroup SAI_Block_Output_Drive 
  * @{
  */

#define SAI_OutputDrive_Disabled          ((uint32_t)0x00000000)
#define SAI_OutputDrive_Enabled           ((uint32_t)SAI_xCR1_OUTDRIV)
#define IS_SAI_BLOCK_OUTPUT_DRIVE(DRIVE) (((DRIVE) == SAI_OutputDrive_Disabled) || \
                                          ((DRIVE) == SAI_OutputDrive_Enabled))
/**
  * @}
  */ 



/** @defgroup SAI_Block_NoDivider 
  * @{
  */

#define SAI_MasterDivider_Enabled         ((uint32_t)0x00000000)
#define SAI_MasterDivider_Disabled        ((uint32_t)SAI_xCR1_NODIV)
#define IS_SAI_BLOCK_NODIVIDER(NODIVIDER) (((NODIVIDER) == SAI_MasterDivider_Enabled) || \
                                           ((NODIVIDER) == SAI_MasterDivider_Disabled))
/**
  * @}
  */
  

/** @defgroup SAI_Block_Master_Divider 
  * @{
  */
#define IS_SAI_BLOCK_MASTER_DIVIDER(DIVIDER) ((DIVIDER) <= 15)

/**
  * @}
  */
  
/** @defgroup SAI_Block_Frame_Length 
  * @{
  */
#define IS_SAI_BLOCK_FRAME_LENGTH(LENGTH) ((8 <= (LENGTH)) && ((LENGTH) <= 256))

/**
  * @}
  */
    
/** @defgroup SAI_Block_Active_FrameLength 
  * @{
  */
#define IS_SAI_BLOCK_ACTIVE_FRAME(LENGTH) ((1 <= (LENGTH)) && ((LENGTH) <= 128))

/**
  * @}
  */

/** @defgroup SAI_Block_FS_Definition 
  * @{
  */

#define SAI_FS_StartFrame                 ((uint32_t)0x00000000)
#define I2S_FS_ChannelIdentification      ((uint32_t)SAI_xFRCR_FSDEF)
#define IS_SAI_BLOCK_FS_DEFINITION(DEFINITION) (((DEFINITION) == SAI_FS_StartFrame) || \
                                                ((DEFINITION) == I2S_FS_ChannelIdentification))
/**
  * @}
  */

/** @defgroup SAI_Block_FS_Polarity 
  * @{
  */

#define SAI_FS_ActiveLow                  ((uint32_t)0x00000000)
#define SAI_FS_ActiveHigh                 ((uint32_t)SAI_xFRCR_FSPO)
#define IS_SAI_BLOCK_FS_POLARITY(POLARITY) (((POLARITY) == SAI_FS_ActiveLow) || \
                                            ((POLARITY) == SAI_FS_ActiveHigh))
/**
  * @}
  */
            
/** @defgroup SAI_Block_FS_Offset 
  * @{
  */
  
#define SAI_FS_FirstBit                   ((uint32_t)0x00000000)
#define SAI_FS_BeforeFirstBit             ((uint32_t)SAI_xFRCR_FSOFF)
#define IS_SAI_BLOCK_FS_OFFSET(OFFSET) (((OFFSET) == SAI_FS_FirstBit) || \
                                        ((OFFSET) == SAI_FS_BeforeFirstBit))
/**
  * @}
  */
  
/** @defgroup SAI_Block_Slot_FirstBit_Offset
  * @{
  */
#define IS_SAI_BLOCK_FIRSTBIT_OFFSET(OFFSET) ((OFFSET) <= 24)

/**
  * @}
  */

  /** @defgroup SAI_Block_Slot_Size
  * @{
  */
#define SAI_SlotSize_DataSize             ((uint32_t)0x00000000)  
#define SAI_SlotSize_16b                  ((uint32_t)SAI_xSLOTR_SLOTSZ_0)
#define SAI_SlotSize_32b                  ((uint32_t)SAI_xSLOTR_SLOTSZ_1)
#define IS_SAI_BLOCK_SLOT_SIZE(SIZE) (((SIZE) == SAI_SlotSize_DataSize) || \
                                      ((SIZE) == SAI_SlotSize_16b)      || \
                                      ((SIZE) == SAI_SlotSize_32b))

/**
  * @}
  */

/** @defgroup SAI_Block_Slot_Number
  * @{
  */
#define IS_SAI_BLOCK_SLOT_NUMBER(NUMBER) ((1 <= (NUMBER)) && ((NUMBER) <= 16))

/**
  * @}
  */
  
/** @defgroup SAI_Block_Slot_Active
  * @{
  */
#define SAI_Slot_NotActive           ((uint32_t)0x00000000)  
#define SAI_SlotActive_0             ((uint32_t)0x00010000)  
#define SAI_SlotActive_1             ((uint32_t)0x00020000)
#define SAI_SlotActive_2             ((uint32_t)0x00040000)
#define SAI_SlotActive_3             ((uint32_t)0x00080000)
#define SAI_SlotActive_4             ((uint32_t)0x00100000)
#define SAI_SlotActive_5             ((uint32_t)0x00200000)
#define SAI_SlotActive_6             ((uint32_t)0x00400000)
#define SAI_SlotActive_7             ((uint32_t)0x00800000)
#define SAI_SlotActive_8             ((uint32_t)0x01000000)
#define SAI_SlotActive_9             ((uint32_t)0x02000000)
#define SAI_SlotActive_10            ((uint32_t)0x04000000)
#define SAI_SlotActive_11            ((uint32_t)0x08000000)
#define SAI_SlotActive_12            ((uint32_t)0x10000000)
#define SAI_SlotActive_13            ((uint32_t)0x20000000)
#define SAI_SlotActive_14            ((uint32_t)0x40000000)
#define SAI_SlotActive_15            ((uint32_t)0x80000000)
#define SAI_SlotActive_ALL           ((uint32_t)0xFFFF0000)

#define IS_SAI_SLOT_ACTIVE(ACTIVE) ((ACTIVE) != 0)

/**
  * @}
  */

/** @defgroup SAI_Mono_Streo_Mode
  * @{
  */

#define SAI_MonoMode                      ((uint32_t)SAI_xCR1_MONO)
#define SAI_StreoMode                     ((uint32_t)0x00000000)
#define IS_SAI_BLOCK_MONO_STREO_MODE(MODE) (((MODE) == SAI_MonoMode) ||\
                                            ((MODE) == SAI_StreoMode))
/**
  * @}
  */

/** @defgroup SAI_TRIState_Management
  * @{
  */

#define SAI_Output_NotReleased              ((uint32_t)0x00000000)
#define SAI_Output_Released                 ((uint32_t)SAI_xCR2_TRIS)
#define IS_SAI_BLOCK_TRISTATE_MANAGEMENT(STATE) (((STATE) == SAI_Output_NotReleased) ||\
                                                 ((STATE) == SAI_Output_Released))
/**
  * @}
  */

/** @defgroup SAI_Block_Fifo_Threshold 
  * @{
  */

#define SAI_Threshold_FIFOEmpty           ((uint32_t)0x00000000)
#define SAI_FIFOThreshold_1QuarterFull    ((uint32_t)0x00000001)
#define SAI_FIFOThreshold_HalfFull        ((uint32_t)0x00000002) 
#define SAI_FIFOThreshold_3QuartersFull   ((uint32_t)0x00000003)
#define SAI_FIFOThreshold_Full            ((uint32_t)0x00000004)
#define IS_SAI_BLOCK_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == SAI_Threshold_FIFOEmpty)         || \
                                                ((THRESHOLD) == SAI_FIFOThreshold_1QuarterFull)  || \
                                                ((THRESHOLD) == SAI_FIFOThreshold_HalfFull)      || \
                                                ((THRESHOLD) == SAI_FIFOThreshold_3QuartersFull) || \
                                                ((THRESHOLD) == SAI_FIFOThreshold_Full))
/**
  * @}
  */
  
/** @defgroup SAI_Block_Companding_Mode
  * @{
  */
  
#define SAI_NoCompanding                  ((uint32_t)0x00000000)
#define SAI_ULaw_1CPL_Companding          ((uint32_t)0x00008000)
#define SAI_ALaw_1CPL_Companding          ((uint32_t)0x0000C000)
#define SAI_ULaw_2CPL_Companding          ((uint32_t)0x0000A000)
#define SAI_ALaw_2CPL_Companding          ((uint32_t)0x0000E000)
#define IS_SAI_BLOCK_COMPANDING_MODE(MODE)    (((MODE) == SAI_NoCompanding)        || \
                                              ((MODE) == SAI_ULaw_1CPL_Companding) || \
                                              ((MODE) == SAI_ALaw_1CPL_Companding) || \
                                              ((MODE) == SAI_ULaw_2CPL_Companding) || \
                                              ((MODE) == SAI_ALaw_2CPL_Companding))
/**
  * @}
  */

/** @defgroup SAI_Block_Mute_Value
  * @{
  */
  
#define SAI_ZeroValue                     ((uint32_t)0x00000000)
#define SAI_LastSentValue                 ((uint32_t)SAI_xCR2_MUTEVAL)
#define IS_SAI_BLOCK_MUTE_VALUE(VALUE)    (((VALUE) == SAI_ZeroValue)     || \
                                           ((VALUE) == SAI_LastSentValue))
/**
  * @}
  */

/** @defgroup SAI_Block_Mute_Frame_Counter
  * @{
  */
  
#define IS_SAI_BLOCK_MUTE_COUNTER(COUNTER) ((COUNTER) <= 63)

/**
  * @}
  */

/** @defgroup SAI_Block_Interrupts_Definition 
  * @{
  */

#define SAI_IT_OVRUDR                     ((uint32_t)SAI_xIMR_OVRUDRIE)
#define SAI_IT_MUTEDET                    ((uint32_t)SAI_xIMR_MUTEDETIE)
#define SAI_IT_WCKCFG                     ((uint32_t)SAI_xIMR_WCKCFGIE)
#define SAI_IT_FREQ                       ((uint32_t)SAI_xIMR_FREQIE)
#define SAI_IT_CNRDY                      ((uint32_t)SAI_xIMR_CNRDYIE)
#define SAI_IT_AFSDET                     ((uint32_t)SAI_xIMR_AFSDETIE)
#define SAI_IT_LFSDET                     ((uint32_t)SAI_xIMR_LFSDETIE)

#define IS_SAI_BLOCK_CONFIG_IT(IT) (((IT) == SAI_IT_OVRUDR)  || \
                                    ((IT) == SAI_IT_MUTEDET) || \
                                    ((IT) == SAI_IT_WCKCFG)  || \
                                    ((IT) == SAI_IT_FREQ)    || \
                                    ((IT) == SAI_IT_CNRDY)   || \
                                    ((IT) == SAI_IT_AFSDET)  || \
                                    ((IT) == SAI_IT_LFSDET))
/**
  * @}
  */

/** @defgroup SAI_Block_Flags_Definition 
  * @{
  */

#define SAI_FLAG_OVRUDR                   ((uint32_t)SAI_xSR_OVRUDR)
#define SAI_FLAG_MUTEDET                  ((uint32_t)SAI_xSR_MUTEDET)
#define SAI_FLAG_WCKCFG                   ((uint32_t)SAI_xSR_WCKCFG)
#define SAI_FLAG_FREQ                     ((uint32_t)SAI_xSR_FREQ)
#define SAI_FLAG_CNRDY                    ((uint32_t)SAI_xSR_CNRDY)
#define SAI_FLAG_AFSDET                   ((uint32_t)SAI_xSR_AFSDET)
#define SAI_FLAG_LFSDET                   ((uint32_t)SAI_xSR_LFSDET)

#define IS_SAI_BLOCK_GET_FLAG(FLAG) (((FLAG) == SAI_FLAG_OVRUDR)  || \
                                    ((FLAG) == SAI_FLAG_MUTEDET) || \
                                    ((FLAG) == SAI_FLAG_WCKCFG)  || \
                                    ((FLAG) == SAI_FLAG_FREQ)    || \
                                    ((FLAG) == SAI_FLAG_CNRDY)   || \
                                    ((FLAG) == SAI_FLAG_AFSDET)  || \
                                    ((FLAG) == SAI_FLAG_LFSDET))
                                   
#define IS_SAI_BLOCK_CLEAR_FLAG(FLAG) (((FLAG) == SAI_FLAG_OVRUDR)  || \
                                       ((FLAG) == SAI_FLAG_MUTEDET) || \
                                       ((FLAG) == SAI_FLAG_WCKCFG)  || \
                                       ((FLAG) == SAI_FLAG_FREQ)    || \
                                       ((FLAG) == SAI_FLAG_CNRDY)   || \
                                       ((FLAG) == SAI_FLAG_AFSDET)  || \
                                       ((FLAG) == SAI_FLAG_LFSDET))
/**
  * @}
  */
  
/** @defgroup SAI_Block_Fifo_Status_Level 
  * @{
  */
#define SAI_FIFOStatus_Empty              ((uint32_t)0x00000000)
#define SAI_FIFOStatus_Less1QuarterFull   ((uint32_t)0x00010000)
#define SAI_FIFOStatus_1QuarterFull       ((uint32_t)0x00020000)
#define SAI_FIFOStatus_HalfFull           ((uint32_t)0x00030000) 
#define SAI_FIFOStatus_3QuartersFull      ((uint32_t)0x00040000)
#define SAI_FIFOStatus_Full               ((uint32_t)0x00050000)

#define IS_SAI_BLOCK_FIFO_STATUS(STATUS) (((STATUS) == SAI_FIFOStatus_Less1QuarterFull ) || \
                                          ((STATUS) == SAI_FIFOStatus_HalfFull)          || \
                                          ((STATUS) == SAI_FIFOStatus_1QuarterFull)      || \
                                          ((STATUS) == SAI_FIFOStatus_3QuartersFull)     || \
                                          ((STATUS) == SAI_FIFOStatus_Full)              || \
                                          ((STATUS) == SAI_FIFOStatus_Empty)) 
/**
  * @}
  */

  
/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/*  Function used to set the SAI configuration to the default reset state *****/ 
void SAI_DeInit(SAI_TypeDef* SAIx);

/* Initialization and Configuration functions *********************************/
void SAI_Init(SAI_Block_TypeDef* SAI_Block_x, SAI_InitTypeDef* SAI_InitStruct);
void SAI_FrameInit(SAI_Block_TypeDef* SAI_Block_x, SAI_FrameInitTypeDef* SAI_FrameInitStruct);
void SAI_SlotInit(SAI_Block_TypeDef* SAI_Block_x, SAI_SlotInitTypeDef* SAI_SlotInitStruct);
void SAI_StructInit(SAI_InitTypeDef* SAI_InitStruct);
void SAI_FrameStructInit(SAI_FrameInitTypeDef* SAI_FrameInitStruct);
void SAI_SlotStructInit(SAI_SlotInitTypeDef* SAI_SlotInitStruct);

void SAI_Cmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState);
void SAI_MonoModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_Mono_StreoMode);
void SAI_TRIStateConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_TRIState);
void SAI_CompandingModeConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_CompandingMode);
void SAI_MuteModeCmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState);
void SAI_MuteValueConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteValue);
void SAI_MuteFrameCounterConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_MuteCounter);
void SAI_FlushFIFO(SAI_Block_TypeDef* SAI_Block_x);

/* Data transfers functions ***************************************************/ 
void SAI_SendData(SAI_Block_TypeDef* SAI_Block_x, uint32_t Data);
uint32_t SAI_ReceiveData(SAI_Block_TypeDef* SAI_Block_x);

/* DMA transfers management functions *****************************************/
void SAI_DMACmd(SAI_Block_TypeDef* SAI_Block_x, FunctionalState NewState);

/* Interrupts and flags management functions **********************************/
void SAI_ITConfig(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT, FunctionalState NewState);
FlagStatus SAI_GetFlagStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG);
void SAI_ClearFlag(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_FLAG);
ITStatus SAI_GetITStatus(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT);
void SAI_ClearITPendingBit(SAI_Block_TypeDef* SAI_Block_x, uint32_t SAI_IT);
FunctionalState SAI_GetCmdStatus(SAI_Block_TypeDef* SAI_Block_x);
uint32_t SAI_GetFIFOStatus(SAI_Block_TypeDef* SAI_Block_x);

#endif

#ifdef __cplusplus
}
#endif

/**
  * @}
  */

/**
  * @}
  */

/******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_sai.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_rtc.h
/**
  ******************************************************************************
  * @file    stm32f4xx_rtc.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the RTC firmware
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ****************************************************************************** 
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_RTC_H
#define __STM32F4xx_RTC_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup RTC
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief  RTC Init structures definition  
  */ 
typedef struct
{
  uint32_t RTC_HourFormat;   /*!< Specifies the RTC Hour Format.
                             This parameter can be a value of @ref RTC_Hour_Formats */
  
  uint32_t RTC_AsynchPrediv; /*!< Specifies the RTC Asynchronous Predivider value.
                             This parameter must be set to a value lower than 0x7F */
  
  uint32_t RTC_SynchPrediv;  /*!< Specifies the RTC Synchronous Predivider value.
                             This parameter must be set to a value lower than 0x7FFF */
}RTC_InitTypeDef;

/** 
  * @brief  RTC Time structure definition  
  */
typedef struct
{
  uint8_t RTC_Hours;    /*!< Specifies the RTC Time Hour.
                        This parameter must be set to a value in the 0-12 range
                        if the RTC_HourFormat_12 is selected or 0-23 range if
                        the RTC_HourFormat_24 is selected. */

  uint8_t RTC_Minutes;  /*!< Specifies the RTC Time Minutes.
                        This parameter must be set to a value in the 0-59 range. */
  
  uint8_t RTC_Seconds;  /*!< Specifies the RTC Time Seconds.
                        This parameter must be set to a value in the 0-59 range. */

  uint8_t RTC_H12;      /*!< Specifies the RTC AM/PM Time.
                        This parameter can be a value of @ref RTC_AM_PM_Definitions */
}RTC_TimeTypeDef; 

/** 
  * @brief  RTC Date structure definition  
  */
typedef struct
{
  uint8_t RTC_WeekDay; /*!< Specifies the RTC Date WeekDay.
                        This parameter can be a value of @ref RTC_WeekDay_Definitions */
  
  uint8_t RTC_Month;   /*!< Specifies the RTC Date Month (in BCD format).
                        This parameter can be a value of @ref RTC_Month_Date_Definitions */

  uint8_t RTC_Date;     /*!< Specifies the RTC Date.
                        This parameter must be set to a value in the 1-31 range. */
  
  uint8_t RTC_Year;     /*!< Specifies the RTC Date Year.
                        This parameter must be set to a value in the 0-99 range. */
}RTC_DateTypeDef;

/** 
  * @brief  RTC Alarm structure definition  
  */
typedef struct
{
  RTC_TimeTypeDef RTC_AlarmTime;     /*!< Specifies the RTC Alarm Time members. */

  uint32_t RTC_AlarmMask;            /*!< Specifies the RTC Alarm Masks.
                                     This parameter can be a value of @ref RTC_AlarmMask_Definitions */

  uint32_t RTC_AlarmDateWeekDaySel;  /*!< Specifies the RTC Alarm is on Date or WeekDay.
                                     This parameter can be a value of @ref RTC_AlarmDateWeekDay_Definitions */
  
  uint8_t RTC_AlarmDateWeekDay;      /*!< Specifies the RTC Alarm Date/WeekDay.
                                     If the Alarm Date is selected, this parameter
                                     must be set to a value in the 1-31 range.
                                     If the Alarm WeekDay is selected, this 
                                     parameter can be a value of @ref RTC_WeekDay_Definitions */
}RTC_AlarmTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup RTC_Exported_Constants
  * @{
  */ 


/** @defgroup RTC_Hour_Formats 
  * @{
  */ 
#define RTC_HourFormat_24              ((uint32_t)0x00000000)
#define RTC_HourFormat_12              ((uint32_t)0x00000040)
#define IS_RTC_HOUR_FORMAT(FORMAT)     (((FORMAT) == RTC_HourFormat_12) || \
                                        ((FORMAT) == RTC_HourFormat_24))
/**
  * @}
  */ 

/** @defgroup RTC_Asynchronous_Predivider 
  * @{
  */ 
#define IS_RTC_ASYNCH_PREDIV(PREDIV)   ((PREDIV) <= 0x7F)
 
/**
  * @}
  */ 


/** @defgroup RTC_Synchronous_Predivider 
  * @{
  */ 
#define IS_RTC_SYNCH_PREDIV(PREDIV)    ((PREDIV) <= 0x7FFF)

/**
  * @}
  */ 

/** @defgroup RTC_Time_Definitions 
  * @{
  */ 
#define IS_RTC_HOUR12(HOUR)            (((HOUR) > 0) && ((HOUR) <= 12))
#define IS_RTC_HOUR24(HOUR)            ((HOUR) <= 23)
#define IS_RTC_MINUTES(MINUTES)        ((MINUTES) <= 59)
#define IS_RTC_SECONDS(SECONDS)        ((SECONDS) <= 59)

/**
  * @}
  */ 

/** @defgroup RTC_AM_PM_Definitions 
  * @{
  */ 
#define RTC_H12_AM                     ((uint8_t)0x00)
#define RTC_H12_PM                     ((uint8_t)0x40)
#define IS_RTC_H12(PM) (((PM) == RTC_H12_AM) || ((PM) == RTC_H12_PM))

/**
  * @}
  */ 

/** @defgroup RTC_Year_Date_Definitions 
  * @{
  */ 
#define IS_RTC_YEAR(YEAR)              ((YEAR) <= 99)

/**
  * @}
  */ 

/** @defgroup RTC_Month_Date_Definitions 
  * @{
  */ 

/* Coded in BCD format */
#define RTC_Month_January              ((uint8_t)0x01)
#define RTC_Month_February             ((uint8_t)0x02)
#define RTC_Month_March                ((uint8_t)0x03)
#define RTC_Month_April                ((uint8_t)0x04)
#define RTC_Month_May                  ((uint8_t)0x05)
#define RTC_Month_June                 ((uint8_t)0x06)
#define RTC_Month_July                 ((uint8_t)0x07)
#define RTC_Month_August               ((uint8_t)0x08)
#define RTC_Month_September            ((uint8_t)0x09)
#define RTC_Month_October              ((uint8_t)0x10)
#define RTC_Month_November             ((uint8_t)0x11)
#define RTC_Month_December             ((uint8_t)0x12)
#define IS_RTC_MONTH(MONTH)            (((MONTH) >= 1) && ((MONTH) <= 12))
#define IS_RTC_DATE(DATE)              (((DATE) >= 1) && ((DATE) <= 31))

/**
  * @}
  */ 

/** @defgroup RTC_WeekDay_Definitions 
  * @{
  */ 
  
#define RTC_Weekday_Monday             ((uint8_t)0x01)
#define RTC_Weekday_Tuesday            ((uint8_t)0x02)
#define RTC_Weekday_Wednesday          ((uint8_t)0x03)
#define RTC_Weekday_Thursday           ((uint8_t)0x04)
#define RTC_Weekday_Friday             ((uint8_t)0x05)
#define RTC_Weekday_Saturday           ((uint8_t)0x06)
#define RTC_Weekday_Sunday             ((uint8_t)0x07)
#define IS_RTC_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
                                 ((WEEKDAY) == RTC_Weekday_Tuesday) || \
                                 ((WEEKDAY) == RTC_Weekday_Wednesday) || \
                                 ((WEEKDAY) == RTC_Weekday_Thursday) || \
                                 ((WEEKDAY) == RTC_Weekday_Friday) || \
                                 ((WEEKDAY) == RTC_Weekday_Saturday) || \
                                 ((WEEKDAY) == RTC_Weekday_Sunday))
/**
  * @}
  */ 


/** @defgroup RTC_Alarm_Definitions
  * @{
  */ 
#define IS_RTC_ALARM_DATE_WEEKDAY_DATE(DATE) (((DATE) > 0) && ((DATE) <= 31))
#define IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(WEEKDAY) (((WEEKDAY) == RTC_Weekday_Monday) || \
                                                    ((WEEKDAY) == RTC_Weekday_Tuesday) || \
                                                    ((WEEKDAY) == RTC_Weekday_Wednesday) || \
                                                    ((WEEKDAY) == RTC_Weekday_Thursday) || \
                                                    ((WEEKDAY) == RTC_Weekday_Friday) || \
                                                    ((WEEKDAY) == RTC_Weekday_Saturday) || \
                                                    ((WEEKDAY) == RTC_Weekday_Sunday))

/**
  * @}
  */ 


/** @defgroup RTC_AlarmDateWeekDay_Definitions 
  * @{
  */ 
#define RTC_AlarmDateWeekDaySel_Date      ((uint32_t)0x00000000)
#define RTC_AlarmDateWeekDaySel_WeekDay   ((uint32_t)0x40000000)

#define IS_RTC_ALARM_DATE_WEEKDAY_SEL(SEL) (((SEL) == RTC_AlarmDateWeekDaySel_Date) || \
                                            ((SEL) == RTC_AlarmDateWeekDaySel_WeekDay))

/**
  * @}
  */ 


/** @defgroup RTC_AlarmMask_Definitions 
  * @{
  */ 
#define RTC_AlarmMask_None                ((uint32_t)0x00000000)
#define RTC_AlarmMask_DateWeekDay         ((uint32_t)0x80000000)
#define RTC_AlarmMask_Hours               ((uint32_t)0x00800000)
#define RTC_AlarmMask_Minutes             ((uint32_t)0x00008000)
#define RTC_AlarmMask_Seconds             ((uint32_t)0x00000080)
#define RTC_AlarmMask_All                 ((uint32_t)0x80808080)
#define IS_ALARM_MASK(MASK)  (((MASK) & 0x7F7F7F7F) == (uint32_t)RESET)

/**
  * @}
  */ 

/** @defgroup RTC_Alarms_Definitions 
  * @{
  */ 
#define RTC_Alarm_A                       ((uint32_t)0x00000100)
#define RTC_Alarm_B                       ((uint32_t)0x00000200)
#define IS_RTC_ALARM(ALARM)     (((ALARM) == RTC_Alarm_A) || ((ALARM) == RTC_Alarm_B))
#define IS_RTC_CMD_ALARM(ALARM) (((ALARM) & (RTC_Alarm_A | RTC_Alarm_B)) != (uint32_t)RESET)

/**
  * @}
  */ 

  /** @defgroup RTC_Alarm_Sub_Seconds_Masks_Definitions
  * @{
  */ 
#define RTC_AlarmSubSecondMask_All         ((uint32_t)0x00000000) /*!< All Alarm SS fields are masked. 
                                                                       There is no comparison on sub seconds 
                                                                       for Alarm */
#define RTC_AlarmSubSecondMask_SS14_1      ((uint32_t)0x01000000) /*!< SS[14:1] are don't care in Alarm 
                                                                       comparison. Only SS[0] is compared. */
#define RTC_AlarmSubSecondMask_SS14_2      ((uint32_t)0x02000000) /*!< SS[14:2] are don't care in Alarm 
                                                                       comparison. Only SS[1:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_3      ((uint32_t)0x03000000) /*!< SS[14:3] are don't care in Alarm 
                                                                       comparison. Only SS[2:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_4      ((uint32_t)0x04000000) /*!< SS[14:4] are don't care in Alarm 
                                                                       comparison. Only SS[3:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_5      ((uint32_t)0x05000000) /*!< SS[14:5] are don't care in Alarm 
                                                                       comparison. Only SS[4:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_6      ((uint32_t)0x06000000) /*!< SS[14:6] are don't care in Alarm 
                                                                       comparison. Only SS[5:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_7      ((uint32_t)0x07000000) /*!< SS[14:7] are don't care in Alarm 
                                                                       comparison. Only SS[6:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_8      ((uint32_t)0x08000000) /*!< SS[14:8] are don't care in Alarm 
                                                                       comparison. Only SS[7:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_9      ((uint32_t)0x09000000) /*!< SS[14:9] are don't care in Alarm 
                                                                       comparison. Only SS[8:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_10     ((uint32_t)0x0A000000) /*!< SS[14:10] are don't care in Alarm 
                                                                       comparison. Only SS[9:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_11     ((uint32_t)0x0B000000) /*!< SS[14:11] are don't care in Alarm 
                                                                       comparison. Only SS[10:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_12     ((uint32_t)0x0C000000) /*!< SS[14:12] are don't care in Alarm 
                                                                       comparison.Only SS[11:0] are compared */
#define RTC_AlarmSubSecondMask_SS14_13     ((uint32_t)0x0D000000) /*!< SS[14:13] are don't care in Alarm 
                                                                       comparison. Only SS[12:0] are compared */
#define RTC_AlarmSubSecondMask_SS14        ((uint32_t)0x0E000000) /*!< SS[14] is don't care in Alarm 
                                                                       comparison.Only SS[13:0] are compared */
#define RTC_AlarmSubSecondMask_None        ((uint32_t)0x0F000000) /*!< SS[14:0] are compared and must match 
                                                                       to activate alarm. */
#define IS_RTC_ALARM_SUB_SECOND_MASK(MASK)   (((MASK) == RTC_AlarmSubSecondMask_All) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_1) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_2) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_3) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_4) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_5) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_6) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_7) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_8) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_9) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_10) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_11) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_12) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14_13) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_SS14) || \
                                              ((MASK) == RTC_AlarmSubSecondMask_None))
/**
  * @}
  */ 

/** @defgroup RTC_Alarm_Sub_Seconds_Value
  * @{
  */ 

#define IS_RTC_ALARM_SUB_SECOND_VALUE(VALUE) ((VALUE) <= 0x00007FFF)

/**
  * @}
  */ 

/** @defgroup RTC_Wakeup_Timer_Definitions 
  * @{
  */ 
#define RTC_WakeUpClock_RTCCLK_Div16        ((uint32_t)0x00000000)
#define RTC_WakeUpClock_RTCCLK_Div8         ((uint32_t)0x00000001)
#define RTC_WakeUpClock_RTCCLK_Div4         ((uint32_t)0x00000002)
#define RTC_WakeUpClock_RTCCLK_Div2         ((uint32_t)0x00000003)
#define RTC_WakeUpClock_CK_SPRE_16bits      ((uint32_t)0x00000004)
#define RTC_WakeUpClock_CK_SPRE_17bits      ((uint32_t)0x00000006)
#define IS_RTC_WAKEUP_CLOCK(CLOCK) (((CLOCK) == RTC_WakeUpClock_RTCCLK_Div16) || \
                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div8) || \
                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div4) || \
                                    ((CLOCK) == RTC_WakeUpClock_RTCCLK_Div2) || \
                                    ((CLOCK) == RTC_WakeUpClock_CK_SPRE_16bits) || \
                                    ((CLOCK) == RTC_WakeUpClock_CK_SPRE_17bits))
#define IS_RTC_WAKEUP_COUNTER(COUNTER)  ((COUNTER) <= 0xFFFF)
/**
  * @}
  */ 

/** @defgroup RTC_Time_Stamp_Edges_definitions 
  * @{
  */ 
#define RTC_TimeStampEdge_Rising          ((uint32_t)0x00000000)
#define RTC_TimeStampEdge_Falling         ((uint32_t)0x00000008)
#define IS_RTC_TIMESTAMP_EDGE(EDGE) (((EDGE) == RTC_TimeStampEdge_Rising) || \
                                     ((EDGE) == RTC_TimeStampEdge_Falling))
/**
  * @}
  */ 

/** @defgroup RTC_Output_selection_Definitions 
  * @{
  */ 
#define RTC_Output_Disable             ((uint32_t)0x00000000)
#define RTC_Output_AlarmA              ((uint32_t)0x00200000)
#define RTC_Output_AlarmB              ((uint32_t)0x00400000)
#define RTC_Output_WakeUp              ((uint32_t)0x00600000)
 
#define IS_RTC_OUTPUT(OUTPUT) (((OUTPUT) == RTC_Output_Disable) || \
                               ((OUTPUT) == RTC_Output_AlarmA) || \
                               ((OUTPUT) == RTC_Output_AlarmB) || \
                               ((OUTPUT) == RTC_Output_WakeUp))

/**
  * @}
  */ 

/** @defgroup RTC_Output_Polarity_Definitions 
  * @{
  */ 
#define RTC_OutputPolarity_High           ((uint32_t)0x00000000)
#define RTC_OutputPolarity_Low            ((uint32_t)0x00100000)
#define IS_RTC_OUTPUT_POL(POL) (((POL) == RTC_OutputPolarity_High) || \
                                ((POL) == RTC_OutputPolarity_Low))
/**
  * @}
  */ 


/** @defgroup RTC_Digital_Calibration_Definitions 
  * @{
  */ 
#define RTC_CalibSign_Positive            ((uint32_t)0x00000000) 
#define RTC_CalibSign_Negative            ((uint32_t)0x00000080)
#define IS_RTC_CALIB_SIGN(SIGN) (((SIGN) == RTC_CalibSign_Positive) || \
                                 ((SIGN) == RTC_CalibSign_Negative))
#define IS_RTC_CALIB_VALUE(VALUE) ((VALUE) < 0x20)

/**
  * @}
  */ 

 /** @defgroup RTC_Calib_Output_selection_Definitions 
  * @{
  */ 
#define RTC_CalibOutput_512Hz            ((uint32_t)0x00000000) 
#define RTC_CalibOutput_1Hz              ((uint32_t)0x00080000)
#define IS_RTC_CALIB_OUTPUT(OUTPUT)  (((OUTPUT) == RTC_CalibOutput_512Hz) || \
                                      ((OUTPUT) == RTC_CalibOutput_1Hz))
/**
  * @}
  */ 

/** @defgroup RTC_Smooth_calib_period_Definitions 
  * @{
  */ 
#define RTC_SmoothCalibPeriod_32sec   ((uint32_t)0x00000000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation
                                                             period is 32s,  else 2exp20 RTCCLK seconds */
#define RTC_SmoothCalibPeriod_16sec   ((uint32_t)0x00002000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
                                                             period is 16s, else 2exp19 RTCCLK seconds */
#define RTC_SmoothCalibPeriod_8sec    ((uint32_t)0x00004000) /*!<  if RTCCLK = 32768 Hz, Smooth calibation 
                                                             period is 8s, else 2exp18 RTCCLK seconds */
#define IS_RTC_SMOOTH_CALIB_PERIOD(PERIOD) (((PERIOD) == RTC_SmoothCalibPeriod_32sec) || \
                                             ((PERIOD) == RTC_SmoothCalibPeriod_16sec) || \
                                             ((PERIOD) == RTC_SmoothCalibPeriod_8sec))
                                          
/**
  * @}
  */ 

/** @defgroup RTC_Smooth_calib_Plus_pulses_Definitions 
  * @{
  */ 
#define RTC_SmoothCalibPlusPulses_Set    ((uint32_t)0x00008000) /*!<  The number of RTCCLK pulses added  
                                                                during a X -second window = Y - CALM[8:0]. 
                                                                 with Y = 512, 256, 128 when X = 32, 16, 8 */
#define RTC_SmoothCalibPlusPulses_Reset  ((uint32_t)0x00000000) /*!<  The number of RTCCLK pulses subbstited
                                                                 during a 32-second window =   CALM[8:0]. */
#define IS_RTC_SMOOTH_CALIB_PLUS(PLUS) (((PLUS) == RTC_SmoothCalibPlusPulses_Set) || \
                                         ((PLUS) == RTC_SmoothCalibPlusPulses_Reset))

/**
  * @}
  */ 

/** @defgroup RTC_Smooth_calib_Minus_pulses_Definitions 
  * @{
  */ 
#define  IS_RTC_SMOOTH_CALIB_MINUS(VALUE) ((VALUE) <= 0x000001FF)

/**
  * @}
  */

/** @defgroup RTC_DayLightSaving_Definitions 
  * @{
  */ 
#define RTC_DayLightSaving_SUB1H   ((uint32_t)0x00020000)
#define RTC_DayLightSaving_ADD1H   ((uint32_t)0x00010000)
#define IS_RTC_DAYLIGHT_SAVING(SAVE) (((SAVE) == RTC_DayLightSaving_SUB1H) || \
                                      ((SAVE) == RTC_DayLightSaving_ADD1H))

#define RTC_StoreOperation_Reset        ((uint32_t)0x00000000)
#define RTC_StoreOperation_Set          ((uint32_t)0x00040000)
#define IS_RTC_STORE_OPERATION(OPERATION) (((OPERATION) == RTC_StoreOperation_Reset) || \
                                           ((OPERATION) == RTC_StoreOperation_Set))
/**
  * @}
  */ 

/** @defgroup RTC_Tamper_Trigger_Definitions 
  * @{
  */ 
#define RTC_TamperTrigger_RisingEdge            ((uint32_t)0x00000000)
#define RTC_TamperTrigger_FallingEdge           ((uint32_t)0x00000001)
#define RTC_TamperTrigger_LowLevel              ((uint32_t)0x00000000)
#define RTC_TamperTrigger_HighLevel             ((uint32_t)0x00000001)
#define IS_RTC_TAMPER_TRIGGER(TRIGGER) (((TRIGGER) == RTC_TamperTrigger_RisingEdge) || \
                                        ((TRIGGER) == RTC_TamperTrigger_FallingEdge) || \
                                        ((TRIGGER) == RTC_TamperTrigger_LowLevel) || \
                                        ((TRIGGER) == RTC_TamperTrigger_HighLevel)) 

/**
  * @}
  */ 

/** @defgroup RTC_Tamper_Filter_Definitions 
  * @{
  */ 
#define RTC_TamperFilter_Disable   ((uint32_t)0x00000000) /*!< Tamper filter is disabled */

#define RTC_TamperFilter_2Sample   ((uint32_t)0x00000800) /*!< Tamper is activated after 2 
                                                          consecutive samples at the active level */
#define RTC_TamperFilter_4Sample   ((uint32_t)0x00001000) /*!< Tamper is activated after 4 
                                                          consecutive samples at the active level */
#define RTC_TamperFilter_8Sample   ((uint32_t)0x00001800) /*!< Tamper is activated after 8 
                                                          consecutive samples at the active leve. */
#define IS_RTC_TAMPER_FILTER(FILTER) (((FILTER) == RTC_TamperFilter_Disable) || \
                                      ((FILTER) == RTC_TamperFilter_2Sample) || \
                                      ((FILTER) == RTC_TamperFilter_4Sample) || \
                                      ((FILTER) == RTC_TamperFilter_8Sample))
/**
  * @}
  */ 

/** @defgroup RTC_Tamper_Sampling_Frequencies_Definitions 
  * @{
  */ 
#define RTC_TamperSamplingFreq_RTCCLK_Div32768  ((uint32_t)0x00000000) /*!< Each of the tamper inputs are sampled
                                                                           with a frequency =  RTCCLK / 32768 */
#define RTC_TamperSamplingFreq_RTCCLK_Div16384  ((uint32_t)0x000000100) /*!< Each of the tamper inputs are sampled
                                                                            with a frequency =  RTCCLK / 16384 */
#define RTC_TamperSamplingFreq_RTCCLK_Div8192   ((uint32_t)0x00000200) /*!< Each of the tamper inputs are sampled
                                                                           with a frequency =  RTCCLK / 8192  */
#define RTC_TamperSamplingFreq_RTCCLK_Div4096   ((uint32_t)0x00000300) /*!< Each of the tamper inputs are sampled
                                                                           with a frequency =  RTCCLK / 4096  */
#define RTC_TamperSamplingFreq_RTCCLK_Div2048   ((uint32_t)0x00000400) /*!< Each of the tamper inputs are sampled
                                                                           with a frequency =  RTCCLK / 2048  */
#define RTC_TamperSamplingFreq_RTCCLK_Div1024   ((uint32_t)0x00000500) /*!< Each of the tamper inputs are sampled
                                                                           with a frequency =  RTCCLK / 1024  */
#define RTC_TamperSamplingFreq_RTCCLK_Div512    ((uint32_t)0x00000600) /*!< Each of the tamper inputs are sampled
                                                                           with a frequency =  RTCCLK / 512   */
#define RTC_TamperSamplingFreq_RTCCLK_Div256    ((uint32_t)0x00000700) /*!< Each of the tamper inputs are sampled
                                                                           with a frequency =  RTCCLK / 256   */
#define IS_RTC_TAMPER_SAMPLING_FREQ(FREQ) (((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div32768) || \
                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div16384) || \
                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div8192) || \
                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div4096) || \
                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div2048) || \
                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div1024) || \
                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div512) || \
                                           ((FREQ) ==RTC_TamperSamplingFreq_RTCCLK_Div256))

/**
  * @}
  */

  /** @defgroup RTC_Tamper_Pin_Precharge_Duration_Definitions 
  * @{
  */ 
#define RTC_TamperPrechargeDuration_1RTCCLK ((uint32_t)0x00000000)  /*!< Tamper pins are pre-charged before 
                                                                         sampling during 1 RTCCLK cycle */
#define RTC_TamperPrechargeDuration_2RTCCLK ((uint32_t)0x00002000)  /*!< Tamper pins are pre-charged before 
                                                                         sampling during 2 RTCCLK cycles */
#define RTC_TamperPrechargeDuration_4RTCCLK ((uint32_t)0x00004000)  /*!< Tamper pins are pre-charged before 
                                                                         sampling during 4 RTCCLK cycles */
#define RTC_TamperPrechargeDuration_8RTCCLK ((uint32_t)0x00006000)  /*!< Tamper pins are pre-charged before 
                                                                         sampling during 8 RTCCLK cycles */

#define IS_RTC_TAMPER_PRECHARGE_DURATION(DURATION) (((DURATION) == RTC_TamperPrechargeDuration_1RTCCLK) || \
                                                    ((DURATION) == RTC_TamperPrechargeDuration_2RTCCLK) || \
                                                    ((DURATION) == RTC_TamperPrechargeDuration_4RTCCLK) || \
                                                    ((DURATION) == RTC_TamperPrechargeDuration_8RTCCLK))
/**
  * @}
  */

/** @defgroup RTC_Tamper_Pins_Definitions 
  * @{
  */ 
#define RTC_Tamper_1                    RTC_TAFCR_TAMP1E
#define IS_RTC_TAMPER(TAMPER) (((TAMPER) == RTC_Tamper_1))

/**
  * @}
  */

/** @defgroup RTC_Tamper_Pin_Selection 
  * @{
  */ 
#define RTC_TamperPin_PC13                 ((uint32_t)0x00000000)
#define RTC_TamperPin_PI8                  ((uint32_t)0x00010000)
#define IS_RTC_TAMPER_PIN(PIN) (((PIN) == RTC_TamperPin_PC13) || \
                                ((PIN) == RTC_TamperPin_PI8))
/**
  * @}
  */ 

/** @defgroup RTC_TimeStamp_Pin_Selection 
  * @{
  */ 
#define RTC_TimeStampPin_PC13              ((uint32_t)0x00000000)
#define RTC_TimeStampPin_PI8               ((uint32_t)0x00020000)
#define IS_RTC_TIMESTAMP_PIN(PIN) (((PIN) == RTC_TimeStampPin_PC13) || \
                                   ((PIN) == RTC_TimeStampPin_PI8))
/**
  * @}
  */ 

/** @defgroup RTC_Output_Type_ALARM_OUT 
  * @{
  */ 
#define RTC_OutputType_OpenDrain           ((uint32_t)0x00000000)
#define RTC_OutputType_PushPull            ((uint32_t)0x00040000)
#define IS_RTC_OUTPUT_TYPE(TYPE) (((TYPE) == RTC_OutputType_OpenDrain) || \
                                  ((TYPE) == RTC_OutputType_PushPull))

/**
  * @}
  */ 

/** @defgroup RTC_Add_1_Second_Parameter_Definitions
  * @{
  */ 
#define RTC_ShiftAdd1S_Reset      ((uint32_t)0x00000000)
#define RTC_ShiftAdd1S_Set        ((uint32_t)0x80000000)
#define IS_RTC_SHIFT_ADD1S(SEL) (((SEL) == RTC_ShiftAdd1S_Reset) || \
                                 ((SEL) == RTC_ShiftAdd1S_Set))
/**
  * @}
  */ 

/** @defgroup RTC_Substract_Fraction_Of_Second_Value
  * @{
  */ 
#define IS_RTC_SHIFT_SUBFS(FS) ((FS) <= 0x00007FFF)

/**
  * @}
  */

/** @defgroup RTC_Backup_Registers_Definitions 
  * @{
  */

#define RTC_BKP_DR0                       ((uint32_t)0x00000000)
#define RTC_BKP_DR1                       ((uint32_t)0x00000001)
#define RTC_BKP_DR2                       ((uint32_t)0x00000002)
#define RTC_BKP_DR3                       ((uint32_t)0x00000003)
#define RTC_BKP_DR4                       ((uint32_t)0x00000004)
#define RTC_BKP_DR5                       ((uint32_t)0x00000005)
#define RTC_BKP_DR6                       ((uint32_t)0x00000006)
#define RTC_BKP_DR7                       ((uint32_t)0x00000007)
#define RTC_BKP_DR8                       ((uint32_t)0x00000008)
#define RTC_BKP_DR9                       ((uint32_t)0x00000009)
#define RTC_BKP_DR10                      ((uint32_t)0x0000000A)
#define RTC_BKP_DR11                      ((uint32_t)0x0000000B)
#define RTC_BKP_DR12                      ((uint32_t)0x0000000C)
#define RTC_BKP_DR13                      ((uint32_t)0x0000000D)
#define RTC_BKP_DR14                      ((uint32_t)0x0000000E)
#define RTC_BKP_DR15                      ((uint32_t)0x0000000F)
#define RTC_BKP_DR16                      ((uint32_t)0x00000010)
#define RTC_BKP_DR17                      ((uint32_t)0x00000011)
#define RTC_BKP_DR18                      ((uint32_t)0x00000012)
#define RTC_BKP_DR19                      ((uint32_t)0x00000013)
#define IS_RTC_BKP(BKP)                   (((BKP) == RTC_BKP_DR0) || \
                                           ((BKP) == RTC_BKP_DR1) || \
                                           ((BKP) == RTC_BKP_DR2) || \
                                           ((BKP) == RTC_BKP_DR3) || \
                                           ((BKP) == RTC_BKP_DR4) || \
                                           ((BKP) == RTC_BKP_DR5) || \
                                           ((BKP) == RTC_BKP_DR6) || \
                                           ((BKP) == RTC_BKP_DR7) || \
                                           ((BKP) == RTC_BKP_DR8) || \
                                           ((BKP) == RTC_BKP_DR9) || \
                                           ((BKP) == RTC_BKP_DR10) || \
                                           ((BKP) == RTC_BKP_DR11) || \
                                           ((BKP) == RTC_BKP_DR12) || \
                                           ((BKP) == RTC_BKP_DR13) || \
                                           ((BKP) == RTC_BKP_DR14) || \
                                           ((BKP) == RTC_BKP_DR15) || \
                                           ((BKP) == RTC_BKP_DR16) || \
                                           ((BKP) == RTC_BKP_DR17) || \
                                           ((BKP) == RTC_BKP_DR18) || \
                                           ((BKP) == RTC_BKP_DR19))
/**
  * @}
  */ 

/** @defgroup RTC_Input_parameter_format_definitions 
  * @{
  */ 
#define RTC_Format_BIN                    ((uint32_t)0x000000000)
#define RTC_Format_BCD                    ((uint32_t)0x000000001)
#define IS_RTC_FORMAT(FORMAT) (((FORMAT) == RTC_Format_BIN) || ((FORMAT) == RTC_Format_BCD))

/**
  * @}
  */ 

/** @defgroup RTC_Flags_Definitions 
  * @{
  */ 
#define RTC_FLAG_RECALPF                  ((uint32_t)0x00010000)
#define RTC_FLAG_TAMP1F                   ((uint32_t)0x00002000)
#define RTC_FLAG_TSOVF                    ((uint32_t)0x00001000)
#define RTC_FLAG_TSF                      ((uint32_t)0x00000800)
#define RTC_FLAG_WUTF                     ((uint32_t)0x00000400)
#define RTC_FLAG_ALRBF                    ((uint32_t)0x00000200)
#define RTC_FLAG_ALRAF                    ((uint32_t)0x00000100)
#define RTC_FLAG_INITF                    ((uint32_t)0x00000040)
#define RTC_FLAG_RSF                      ((uint32_t)0x00000020)
#define RTC_FLAG_INITS                    ((uint32_t)0x00000010)
#define RTC_FLAG_SHPF                     ((uint32_t)0x00000008)
#define RTC_FLAG_WUTWF                    ((uint32_t)0x00000004)
#define RTC_FLAG_ALRBWF                   ((uint32_t)0x00000002)
#define RTC_FLAG_ALRAWF                   ((uint32_t)0x00000001)
#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_TSOVF) || ((FLAG) == RTC_FLAG_TSF) || \
                               ((FLAG) == RTC_FLAG_WUTF) || ((FLAG) == RTC_FLAG_ALRBF) || \
                               ((FLAG) == RTC_FLAG_ALRAF) || ((FLAG) == RTC_FLAG_INITF) || \
                               ((FLAG) == RTC_FLAG_RSF) || ((FLAG) == RTC_FLAG_WUTWF) || \
                               ((FLAG) == RTC_FLAG_ALRBWF) || ((FLAG) == RTC_FLAG_ALRAWF) || \
                               ((FLAG) == RTC_FLAG_TAMP1F) || ((FLAG) == RTC_FLAG_RECALPF) || \
                                ((FLAG) == RTC_FLAG_SHPF))
#define IS_RTC_CLEAR_FLAG(FLAG) (((FLAG) != (uint32_t)RESET) && (((FLAG) & 0xFFFF00DF) == (uint32_t)RESET))
/**
  * @}
  */ 

/** @defgroup RTC_Interrupts_Definitions 
  * @{
  */ 
#define RTC_IT_TS                         ((uint32_t)0x00008000)
#define RTC_IT_WUT                        ((uint32_t)0x00004000)
#define RTC_IT_ALRB                       ((uint32_t)0x00002000)
#define RTC_IT_ALRA                       ((uint32_t)0x00001000)
#define RTC_IT_TAMP                       ((uint32_t)0x00000004) /* Used only to Enable the Tamper Interrupt */
#define RTC_IT_TAMP1                      ((uint32_t)0x00020000)

#define IS_RTC_CONFIG_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFFF0FFB) == (uint32_t)RESET))
#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_TS) || ((IT) == RTC_IT_WUT) || \
                           ((IT) == RTC_IT_ALRB) || ((IT) == RTC_IT_ALRA) || \
                           ((IT) == RTC_IT_TAMP1))
#define IS_RTC_CLEAR_IT(IT) (((IT) != (uint32_t)RESET) && (((IT) & 0xFFFD0FFF) == (uint32_t)RESET))

/**
  * @}
  */ 

/** @defgroup RTC_Legacy 
  * @{
  */ 
#define RTC_DigitalCalibConfig  RTC_CoarseCalibConfig
#define RTC_DigitalCalibCmd     RTC_CoarseCalibCmd

/**
  * @}
  */ 

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/*  Function used to set the RTC configuration to the default reset state *****/
ErrorStatus RTC_DeInit(void);

/* Initialization and Configuration functions *********************************/
ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct);
void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct);
void RTC_WriteProtectionCmd(FunctionalState NewState);
ErrorStatus RTC_EnterInitMode(void);
void RTC_ExitInitMode(void);
ErrorStatus RTC_WaitForSynchro(void);
ErrorStatus RTC_RefClockCmd(FunctionalState NewState);
void RTC_BypassShadowCmd(FunctionalState NewState);

/* Time and Date configuration functions **************************************/
ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct);
void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct);
uint32_t RTC_GetSubSecond(void);
ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);
void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct);
void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct);

/* Alarms (Alarm A and Alarm B) configuration functions  **********************/
void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct);
void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct);
ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState);
void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask);
uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm);

/* WakeUp Timer configuration functions ***************************************/
void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock);
void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter);
uint32_t RTC_GetWakeUpCounter(void);
ErrorStatus RTC_WakeUpCmd(FunctionalState NewState);

/* Daylight Saving configuration functions ************************************/
void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation);
uint32_t RTC_GetStoreOperation(void);

/* Output pin Configuration function ******************************************/
void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity);

/* Digital Calibration configuration functions *********************************/
ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value);
ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState);
void RTC_CalibOutputCmd(FunctionalState NewState);
void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput);
ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod, 
                                  uint32_t RTC_SmoothCalibPlusPulses,
                                  uint32_t RTC_SmouthCalibMinusPulsesValue);

/* TimeStamp configuration functions ******************************************/
void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState);
void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct,
                                      RTC_DateTypeDef* RTC_StampDateStruct);
uint32_t RTC_GetTimeStampSubSecond(void);

/* Tampers configuration functions ********************************************/
void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger);
void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState);
void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter);
void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq);
void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration);
void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState);
void RTC_TamperPullUpCmd(FunctionalState NewState);

/* Backup Data Registers configuration functions ******************************/
void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data);
uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR);

/* RTC Tamper and TimeStamp Pins Selection and Output Type Config configuration
   functions ******************************************************************/
void RTC_TamperPinSelection(uint32_t RTC_TamperPin);
void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin);
void RTC_OutputTypeConfig(uint32_t RTC_OutputType);

/* RTC_Shift_control_synchonisation_functions *********************************/
ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS);

/* Interrupts and flags management functions **********************************/
void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState);
FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG);
void RTC_ClearFlag(uint32_t RTC_FLAG);
ITStatus RTC_GetITStatus(uint32_t RTC_IT);
void RTC_ClearITPendingBit(uint32_t RTC_IT);

#ifdef __cplusplus
}
#endif

#endif /*__STM32F4xx_RTC_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_rtc.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_dbgmcu.h
/**
  ******************************************************************************
  * @file    stm32f4xx_dbgmcu.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the DBGMCU firmware library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_DBGMCU_H
#define __STM32F4xx_DBGMCU_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup DBGMCU
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/

/** @defgroup DBGMCU_Exported_Constants
  * @{
  */ 
#define DBGMCU_SLEEP                 ((uint32_t)0x00000001)
#define DBGMCU_STOP                  ((uint32_t)0x00000002)
#define DBGMCU_STANDBY               ((uint32_t)0x00000004)
#define IS_DBGMCU_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFF8) == 0x00) && ((PERIPH) != 0x00))

#define DBGMCU_TIM2_STOP             ((uint32_t)0x00000001)
#define DBGMCU_TIM3_STOP             ((uint32_t)0x00000002)
#define DBGMCU_TIM4_STOP             ((uint32_t)0x00000004)
#define DBGMCU_TIM5_STOP             ((uint32_t)0x00000008)
#define DBGMCU_TIM6_STOP             ((uint32_t)0x00000010)
#define DBGMCU_TIM7_STOP             ((uint32_t)0x00000020)
#define DBGMCU_TIM12_STOP            ((uint32_t)0x00000040)
#define DBGMCU_TIM13_STOP            ((uint32_t)0x00000080)
#define DBGMCU_TIM14_STOP            ((uint32_t)0x00000100)
#define DBGMCU_RTC_STOP              ((uint32_t)0x00000400)
#define DBGMCU_WWDG_STOP             ((uint32_t)0x00000800)
#define DBGMCU_IWDG_STOP             ((uint32_t)0x00001000)
#define DBGMCU_I2C1_SMBUS_TIMEOUT    ((uint32_t)0x00200000)
#define DBGMCU_I2C2_SMBUS_TIMEOUT    ((uint32_t)0x00400000)
#define DBGMCU_I2C3_SMBUS_TIMEOUT    ((uint32_t)0x00800000)
#define DBGMCU_CAN1_STOP             ((uint32_t)0x02000000)
#define DBGMCU_CAN2_STOP             ((uint32_t)0x04000000)
#define IS_DBGMCU_APB1PERIPH(PERIPH) ((((PERIPH) & 0xF91FE200) == 0x00) && ((PERIPH) != 0x00))

#define DBGMCU_TIM1_STOP             ((uint32_t)0x00000001)
#define DBGMCU_TIM8_STOP             ((uint32_t)0x00000002)
#define DBGMCU_TIM9_STOP             ((uint32_t)0x00010000)
#define DBGMCU_TIM10_STOP            ((uint32_t)0x00020000)
#define DBGMCU_TIM11_STOP            ((uint32_t)0x00040000)
#define IS_DBGMCU_APB2PERIPH(PERIPH) ((((PERIPH) & 0xFFF8FFFC) == 0x00) && ((PERIPH) != 0x00))
/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 
uint32_t DBGMCU_GetREVID(void);
uint32_t DBGMCU_GetDEVID(void);
void DBGMCU_Config(uint32_t DBGMCU_Periph, FunctionalState NewState);
void DBGMCU_APB1PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);
void DBGMCU_APB2PeriphConfig(uint32_t DBGMCU_Periph, FunctionalState NewState);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_DBGMCU_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_dbgmcu.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_i2c.h
/**
  ******************************************************************************
  * @file    stm32f4xx_i2c.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the I2C firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************  
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_I2C_H
#define __STM32F4xx_I2C_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup I2C
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief  I2C Init structure definition  
  */

typedef struct
{
  uint32_t I2C_ClockSpeed;          /*!< Specifies the clock frequency.
                                         This parameter must be set to a value lower than 400kHz */

  uint16_t I2C_Mode;                /*!< Specifies the I2C mode.
                                         This parameter can be a value of @ref I2C_mode */

  uint16_t I2C_DutyCycle;           /*!< Specifies the I2C fast mode duty cycle.
                                         This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode */

  uint16_t I2C_OwnAddress1;         /*!< Specifies the first device own address.
                                         This parameter can be a 7-bit or 10-bit address. */

  uint16_t I2C_Ack;                 /*!< Enables or disables the acknowledgement.
                                         This parameter can be a value of @ref I2C_acknowledgement */

  uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7-bit or 10-bit address is acknowledged.
                                         This parameter can be a value of @ref I2C_acknowledged_address */
}I2C_InitTypeDef;

/* Exported constants --------------------------------------------------------*/


/** @defgroup I2C_Exported_Constants
  * @{
  */

#define IS_I2C_ALL_PERIPH(PERIPH) (((PERIPH) == I2C1) || \
                                   ((PERIPH) == I2C2) || \
                                   ((PERIPH) == I2C3))

/** @defgroup I2C_Digital_Filter
  * @{
  */

#define IS_I2C_DIGITAL_FILTER(FILTER)   ((FILTER) <= 0x0000000F)
/**
  * @}
  */


/** @defgroup I2C_mode 
  * @{
  */

#define I2C_Mode_I2C                    ((uint16_t)0x0000)
#define I2C_Mode_SMBusDevice            ((uint16_t)0x0002)  
#define I2C_Mode_SMBusHost              ((uint16_t)0x000A)
#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \
                           ((MODE) == I2C_Mode_SMBusDevice) || \
                           ((MODE) == I2C_Mode_SMBusHost))
/**
  * @}
  */

/** @defgroup I2C_duty_cycle_in_fast_mode 
  * @{
  */

#define I2C_DutyCycle_16_9              ((uint16_t)0x4000) /*!< I2C fast mode Tlow/Thigh = 16/9 */
#define I2C_DutyCycle_2                 ((uint16_t)0xBFFF) /*!< I2C fast mode Tlow/Thigh = 2 */
#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \
                                  ((CYCLE) == I2C_DutyCycle_2))
/**
  * @}
  */ 

/** @defgroup I2C_acknowledgement
  * @{
  */

#define I2C_Ack_Enable                  ((uint16_t)0x0400)
#define I2C_Ack_Disable                 ((uint16_t)0x0000)
#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \
                                 ((STATE) == I2C_Ack_Disable))
/**
  * @}
  */

/** @defgroup I2C_transfer_direction 
  * @{
  */

#define  I2C_Direction_Transmitter      ((uint8_t)0x00)
#define  I2C_Direction_Receiver         ((uint8_t)0x01)
#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
                                     ((DIRECTION) == I2C_Direction_Receiver))
/**
  * @}
  */

/** @defgroup I2C_acknowledged_address 
  * @{
  */

#define I2C_AcknowledgedAddress_7bit    ((uint16_t)0x4000)
#define I2C_AcknowledgedAddress_10bit   ((uint16_t)0xC000)
#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
/**
  * @}
  */ 

/** @defgroup I2C_registers 
  * @{
  */

#define I2C_Register_CR1                ((uint8_t)0x00)
#define I2C_Register_CR2                ((uint8_t)0x04)
#define I2C_Register_OAR1               ((uint8_t)0x08)
#define I2C_Register_OAR2               ((uint8_t)0x0C)
#define I2C_Register_DR                 ((uint8_t)0x10)
#define I2C_Register_SR1                ((uint8_t)0x14)
#define I2C_Register_SR2                ((uint8_t)0x18)
#define I2C_Register_CCR                ((uint8_t)0x1C)
#define I2C_Register_TRISE              ((uint8_t)0x20)
#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \
                                   ((REGISTER) == I2C_Register_CR2) || \
                                   ((REGISTER) == I2C_Register_OAR1) || \
                                   ((REGISTER) == I2C_Register_OAR2) || \
                                   ((REGISTER) == I2C_Register_DR) || \
                                   ((REGISTER) == I2C_Register_SR1) || \
                                   ((REGISTER) == I2C_Register_SR2) || \
                                   ((REGISTER) == I2C_Register_CCR) || \
                                   ((REGISTER) == I2C_Register_TRISE))
/**
  * @}
  */

/** @defgroup I2C_NACK_position 
  * @{
  */

#define I2C_NACKPosition_Next           ((uint16_t)0x0800)
#define I2C_NACKPosition_Current        ((uint16_t)0xF7FF)
#define IS_I2C_NACK_POSITION(POSITION)  (((POSITION) == I2C_NACKPosition_Next) || \
                                         ((POSITION) == I2C_NACKPosition_Current))
/**
  * @}
  */ 

/** @defgroup I2C_SMBus_alert_pin_level 
  * @{
  */

#define I2C_SMBusAlert_Low              ((uint16_t)0x2000)
#define I2C_SMBusAlert_High             ((uint16_t)0xDFFF)
#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \
                                   ((ALERT) == I2C_SMBusAlert_High))
/**
  * @}
  */

/** @defgroup I2C_PEC_position 
  * @{
  */

#define I2C_PECPosition_Next            ((uint16_t)0x0800)
#define I2C_PECPosition_Current         ((uint16_t)0xF7FF)
#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \
                                       ((POSITION) == I2C_PECPosition_Current))
/**
  * @}
  */ 

/** @defgroup I2C_interrupts_definition 
  * @{
  */

#define I2C_IT_BUF                      ((uint16_t)0x0400)
#define I2C_IT_EVT                      ((uint16_t)0x0200)
#define I2C_IT_ERR                      ((uint16_t)0x0100)
#define IS_I2C_CONFIG_IT(IT) ((((IT) & (uint16_t)0xF8FF) == 0x00) && ((IT) != 0x00))
/**
  * @}
  */ 

/** @defgroup I2C_interrupts_definition 
  * @{
  */

#define I2C_IT_SMBALERT                 ((uint32_t)0x01008000)
#define I2C_IT_TIMEOUT                  ((uint32_t)0x01004000)
#define I2C_IT_PECERR                   ((uint32_t)0x01001000)
#define I2C_IT_OVR                      ((uint32_t)0x01000800)
#define I2C_IT_AF                       ((uint32_t)0x01000400)
#define I2C_IT_ARLO                     ((uint32_t)0x01000200)
#define I2C_IT_BERR                     ((uint32_t)0x01000100)
#define I2C_IT_TXE                      ((uint32_t)0x06000080)
#define I2C_IT_RXNE                     ((uint32_t)0x06000040)
#define I2C_IT_STOPF                    ((uint32_t)0x02000010)
#define I2C_IT_ADD10                    ((uint32_t)0x02000008)
#define I2C_IT_BTF                      ((uint32_t)0x02000004)
#define I2C_IT_ADDR                     ((uint32_t)0x02000002)
#define I2C_IT_SB                       ((uint32_t)0x02000001)

#define IS_I2C_CLEAR_IT(IT) ((((IT) & (uint16_t)0x20FF) == 0x00) && ((IT) != (uint16_t)0x00))

#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
                           ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
                           ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
                           ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) || \
                           ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \
                           ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
                           ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
/**
  * @}
  */

/** @defgroup I2C_flags_definition 
  * @{
  */

/** 
  * @brief  SR2 register flags  
  */

#define I2C_FLAG_DUALF                  ((uint32_t)0x00800000)
#define I2C_FLAG_SMBHOST                ((uint32_t)0x00400000)
#define I2C_FLAG_SMBDEFAULT             ((uint32_t)0x00200000)
#define I2C_FLAG_GENCALL                ((uint32_t)0x00100000)
#define I2C_FLAG_TRA                    ((uint32_t)0x00040000)
#define I2C_FLAG_BUSY                   ((uint32_t)0x00020000)
#define I2C_FLAG_MSL                    ((uint32_t)0x00010000)

/** 
  * @brief  SR1 register flags  
  */

#define I2C_FLAG_SMBALERT               ((uint32_t)0x10008000)
#define I2C_FLAG_TIMEOUT                ((uint32_t)0x10004000)
#define I2C_FLAG_PECERR                 ((uint32_t)0x10001000)
#define I2C_FLAG_OVR                    ((uint32_t)0x10000800)
#define I2C_FLAG_AF                     ((uint32_t)0x10000400)
#define I2C_FLAG_ARLO                   ((uint32_t)0x10000200)
#define I2C_FLAG_BERR                   ((uint32_t)0x10000100)
#define I2C_FLAG_TXE                    ((uint32_t)0x10000080)
#define I2C_FLAG_RXNE                   ((uint32_t)0x10000040)
#define I2C_FLAG_STOPF                  ((uint32_t)0x10000010)
#define I2C_FLAG_ADD10                  ((uint32_t)0x10000008)
#define I2C_FLAG_BTF                    ((uint32_t)0x10000004)
#define I2C_FLAG_ADDR                   ((uint32_t)0x10000002)
#define I2C_FLAG_SB                     ((uint32_t)0x10000001)

#define IS_I2C_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0x20FF) == 0x00) && ((FLAG) != (uint16_t)0x00))

#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \
                               ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \
                               ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \
                               ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) || \
                               ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) || \
                               ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) || \
                               ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) || \
                               ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) || \
                               ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \
                               ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \
                               ((FLAG) == I2C_FLAG_SB))
/**
  * @}
  */

/** @defgroup I2C_Events 
  * @{
  */

/**
 ===============================================================================
               I2C Master Events (Events grouped in order of communication)
 ===============================================================================
 */

/** 
  * @brief  Communication start
  * 
  * After sending the START condition (I2C_GenerateSTART() function) the master 
  * has to wait for this event. It means that the Start condition has been correctly 
  * released on the I2C bus (the bus is free, no other devices is communicating).
  * 
  */
/* --EV5 */
#define  I2C_EVENT_MASTER_MODE_SELECT                      ((uint32_t)0x00030001)  /* BUSY, MSL and SB flag */

/** 
  * @brief  Address Acknowledge
  * 
  * After checking on EV5 (start condition correctly released on the bus), the 
  * master sends the address of the slave(s) with which it will communicate 
  * (I2C_Send7bitAddress() function, it also determines the direction of the communication: 
  * Master transmitter or Receiver). Then the master has to wait that a slave acknowledges 
  * his address. If an acknowledge is sent on the bus, one of the following events will 
  * be set:
  * 
  *  1) In case of Master Receiver (7-bit addressing): the I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED 
  *     event is set.
  *  
  *  2) In case of Master Transmitter (7-bit addressing): the I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED 
  *     is set
  *  
  *  3) In case of 10-Bit addressing mode, the master (just after generating the START 
  *  and checking on EV5) has to send the header of 10-bit addressing mode (I2C_SendData() 
  *  function). Then master should wait on EV9. It means that the 10-bit addressing 
  *  header has been correctly sent on the bus. Then master should send the second part of 
  *  the 10-bit address (LSB) using the function I2C_Send7bitAddress(). Then master 
  *  should wait for event EV6. 
  *     
  */

/* --EV6 */
#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((uint32_t)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((uint32_t)0x00030002)  /* BUSY, MSL and ADDR flags */
/* --EV9 */
#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((uint32_t)0x00030008)  /* BUSY, MSL and ADD10 flags */

/** 
  * @brief Communication events
  * 
  * If a communication is established (START condition generated and slave address 
  * acknowledged) then the master has to check on one of the following events for 
  * communication procedures:
  *  
  * 1) Master Receiver mode: The master has to wait on the event EV7 then to read 
  *    the data received from the slave (I2C_ReceiveData() function).
  * 
  * 2) Master Transmitter mode: The master has to send data (I2C_SendData() 
  *    function) then to wait on event EV8 or EV8_2.
  *    These two events are similar: 
  *     - EV8 means that the data has been written in the data register and is 
  *       being shifted out.
  *     - EV8_2 means that the data has been physically shifted out and output 
  *       on the bus.
  *     In most cases, using EV8 is sufficient for the application.
  *     Using EV8_2 leads to a slower communication but ensure more reliable test.
  *     EV8_2 is also more suitable than EV8 for testing on the last data transmission 
  *     (before Stop condition generation).
  *     
  *  @note In case the  user software does not guarantee that this event EV7 is 
  *        managed before the current byte end of transfer, then user may check on EV7 
  *        and BTF flag at the same time (ie. (I2C_EVENT_MASTER_BYTE_RECEIVED | I2C_FLAG_BTF)).
  *        In this case the communication may be slower.
  * 
  */

/* Master RECEIVER mode -----------------------------*/ 
/* --EV7 */
#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((uint32_t)0x00030040)  /* BUSY, MSL and RXNE flags */

/* Master TRANSMITTER mode --------------------------*/
/* --EV8 */
#define I2C_EVENT_MASTER_BYTE_TRANSMITTING                 ((uint32_t)0x00070080) /* TRA, BUSY, MSL, TXE flags */
/* --EV8_2 */
#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((uint32_t)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */


/**
 ===============================================================================
               I2C Slave Events (Events grouped in order of communication)
 ===============================================================================
 */


/** 
  * @brief  Communication start events
  * 
  * Wait on one of these events at the start of the communication. It means that 
  * the I2C peripheral detected a Start condition on the bus (generated by master 
  * device) followed by the peripheral address. The peripheral generates an ACK 
  * condition on the bus (if the acknowledge feature is enabled through function 
  * I2C_AcknowledgeConfig()) and the events listed above are set :
  *  
  * 1) In normal case (only one address managed by the slave), when the address 
  *   sent by the master matches the own address of the peripheral (configured by 
  *   I2C_OwnAddress1 field) the I2C_EVENT_SLAVE_XXX_ADDRESS_MATCHED event is set 
  *   (where XXX could be TRANSMITTER or RECEIVER).
  *    
  * 2) In case the address sent by the master matches the second address of the 
  *   peripheral (configured by the function I2C_OwnAddress2Config() and enabled 
  *   by the function I2C_DualAddressCmd()) the events I2C_EVENT_SLAVE_XXX_SECONDADDRESS_MATCHED 
  *   (where XXX could be TRANSMITTER or RECEIVER) are set.
  *   
  * 3) In case the address sent by the master is General Call (address 0x00) and 
  *   if the General Call is enabled for the peripheral (using function I2C_GeneralCallCmd()) 
  *   the following event is set I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED.   
  * 
  */

/* --EV1  (all the events below are variants of EV1) */   
/* 1) Case of One Single Address managed by the slave */
#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((uint32_t)0x00020002) /* BUSY and ADDR flags */
#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((uint32_t)0x00060082) /* TRA, BUSY, TXE and ADDR flags */

/* 2) Case of Dual address managed by the slave */
#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((uint32_t)0x00820000)  /* DUALF and BUSY flags */
#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((uint32_t)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */

/* 3) Case of General Call enabled for the slave */
#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((uint32_t)0x00120000)  /* GENCALL and BUSY flags */

/** 
  * @brief  Communication events
  * 
  * Wait on one of these events when EV1 has already been checked and: 
  * 
  * - Slave RECEIVER mode:
  *     - EV2: When the application is expecting a data byte to be received. 
  *     - EV4: When the application is expecting the end of the communication: master 
  *       sends a stop condition and data transmission is stopped.
  *    
  * - Slave Transmitter mode:
  *    - EV3: When a byte has been transmitted by the slave and the application is expecting 
  *      the end of the byte transmission. The two events I2C_EVENT_SLAVE_BYTE_TRANSMITTED and
  *      I2C_EVENT_SLAVE_BYTE_TRANSMITTING are similar. The second one can optionally be 
  *      used when the user software doesn't guarantee the EV3 is managed before the
  *      current byte end of transfer.
  *    - EV3_2: When the master sends a NACK in order to tell slave that data transmission 
  *      shall end (before sending the STOP condition). In this case slave has to stop sending 
  *      data bytes and expect a Stop condition on the bus.
  *      
  *  @note In case the  user software does not guarantee that the event EV2 is 
  *        managed before the current byte end of transfer, then user may check on EV2 
  *        and BTF flag at the same time (ie. (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_BTF)).
  *        In this case the communication may be slower.
  *
  */

/* Slave RECEIVER mode --------------------------*/ 
/* --EV2 */
#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((uint32_t)0x00020040)  /* BUSY and RXNE flags */
/* --EV4  */
#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((uint32_t)0x00000010)  /* STOPF flag */

/* Slave TRANSMITTER mode -----------------------*/
/* --EV3 */
#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((uint32_t)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTING                 ((uint32_t)0x00060080)  /* TRA, BUSY and TXE flags */
/* --EV3_2 */
#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((uint32_t)0x00000400)  /* AF flag */

/*
 ===============================================================================
                          End of Events Description
 ===============================================================================
 */

#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
                             ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \
                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) || \
                             ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \
                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \
                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) || \
                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) || \
                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \
                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) || \
                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) || \
                             ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \
                             ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \
                             ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \
                             ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
                             ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTING) || \
                             ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \
                             ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
/**
  * @}
  */

/** @defgroup I2C_own_address1 
  * @{
  */

#define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) <= 0x3FF)
/**
  * @}
  */

/** @defgroup I2C_clock_speed 
  * @{
  */

#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) >= 0x1) && ((SPEED) <= 400000))
/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/*  Function used to set the I2C configuration to the default reset state *****/
void I2C_DeInit(I2C_TypeDef* I2Cx);

/* Initialization and Configuration functions *********************************/
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_DigitalFilterConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DigitalFilter);
void I2C_AnalogFilterCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction);
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, uint8_t Address);
void I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, uint16_t I2C_DutyCycle);
void I2C_NACKPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_NACKPosition);
void I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, uint16_t I2C_SMBusAlert);
void I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);

/* Data transfers functions ***************************************************/ 
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data);
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx);

/* PEC management functions ***************************************************/ 
void I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_PECPositionConfig(I2C_TypeDef* I2Cx, uint16_t I2C_PECPosition);
void I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
uint8_t I2C_GetPEC(I2C_TypeDef* I2Cx);

/* DMA transfers management functions *****************************************/
void I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
void I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);

/* Interrupts, events and flags management functions **************************/
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register);
void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState);

/* 
 ===============================================================================
                          I2C State Monitoring Functions
 ===============================================================================
  This I2C driver provides three different ways for I2C state monitoring
  depending on the application requirements and constraints:
         
   
     1. Basic state monitoring (Using I2C_CheckEvent() function)
     -----------------------------------------------------------
        It compares the status registers (SR1 and SR2) content to a given event
        (can be the combination of one or more flags).
        It returns SUCCESS if the current status includes the given flags 
        and returns ERROR if one or more flags are missing in the current status.

          - When to use
             - This function is suitable for most applications as well as for startup 
               activity since the events are fully described in the product reference 
               manual (RM0090).
             - It is also suitable for users who need to define their own events.

          - Limitations
             - If an error occurs (ie. error flags are set besides to the monitored 
               flags), the I2C_CheckEvent() function may return SUCCESS despite 
               the communication hold or corrupted real state. 
               In this case, it is advised to use error interrupts to monitor 
               the error events and handle them in the interrupt IRQ handler.
         
     Note 
         For error management, it is advised to use the following functions:
           - I2C_ITConfig() to configure and enable the error interrupts (I2C_IT_ERR).
           - I2Cx_ER_IRQHandler() which is called when the error interrupt occurs.
             Where x is the peripheral instance (I2C1, I2C2 ...)
           - I2C_GetFlagStatus() or I2C_GetITStatus()  to be called into the 
             I2Cx_ER_IRQHandler() function in order to determine which error occurred.
           - I2C_ClearFlag() or I2C_ClearITPendingBit() and/or I2C_SoftwareResetCmd() 
             and/or I2C_GenerateStop() in order to clear the error flag and source 
             and return to correct  communication status.
             
 
     2. Advanced state monitoring (Using the function I2C_GetLastEvent())
     -------------------------------------------------------------------- 
        Using the function I2C_GetLastEvent() which returns the image of both status 
        registers in a single word (uint32_t) (Status Register 2 value is shifted left 
        by 16 bits and concatenated to Status Register 1).

          - When to use
             - This function is suitable for the same applications above but it 
               allows to overcome the mentioned limitation of I2C_GetFlagStatus() 
               function.
             - The returned value could be compared to events already defined in 
               this file or to custom values defined by user.
               This function is suitable when multiple flags are monitored at the 
               same time.
             - At the opposite of I2C_CheckEvent() function, this function allows 
               user to choose when an event is accepted (when all events flags are 
               set and no other flags are set or just when the needed flags are set 
               like I2C_CheckEvent() function.

          - Limitations
             - User may need to define his own events.
             - Same remark concerning the error management is applicable for this 
               function if user decides to check only regular communication flags 
               (and ignores error flags).
      
 
     3. Flag-based state monitoring (Using the function I2C_GetFlagStatus())
     -----------------------------------------------------------------------
     
      Using the function I2C_GetFlagStatus() which simply returns the status of 
      one single flag (ie. I2C_FLAG_RXNE ...). 

          - When to use
             - This function could be used for specific applications or in debug 
               phase.
             - It is suitable when only one flag checking is needed (most I2C 
               events are monitored through multiple flags).
          - Limitations: 
             - When calling this function, the Status register is accessed. 
               Some flags are cleared when the status register is accessed. 
               So checking the status of one Flag, may clear other ones.
             - Function may need to be called twice or more in order to monitor 
               one single event.           
 */

/*
 ===============================================================================
                          1. Basic state monitoring
 ===============================================================================
 */
ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT);
/*
 ===============================================================================
                          2. Advanced state monitoring
 ===============================================================================
 */
uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx);
/*
 ===============================================================================
                          3. Flag-based state monitoring
 ===============================================================================
 */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);


void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG);
ITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, uint32_t I2C_IT);
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT);

#ifdef __cplusplus
}
#endif

#endif /*__STM32F4xx_I2C_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_i2c.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_rcc.h
/**
  ******************************************************************************
  * @file    stm32f4xx_rcc.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the RCC firmware library.  
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_RCC_H
#define __STM32F4xx_RCC_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup RCC
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
typedef struct
{
  uint32_t SYSCLK_Frequency; /*!<  SYSCLK clock frequency expressed in Hz */
  uint32_t HCLK_Frequency;   /*!<  HCLK clock frequency expressed in Hz   */
  uint32_t PCLK1_Frequency;  /*!<  PCLK1 clock frequency expressed in Hz  */
  uint32_t PCLK2_Frequency;  /*!<  PCLK2 clock frequency expressed in Hz  */
}RCC_ClocksTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup RCC_Exported_Constants
  * @{
  */
  
/** @defgroup RCC_HSE_configuration 
  * @{
  */
#define RCC_HSE_OFF                      ((uint8_t)0x00)
#define RCC_HSE_ON                       ((uint8_t)0x01)
#define RCC_HSE_Bypass                   ((uint8_t)0x05)
#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
                         ((HSE) == RCC_HSE_Bypass))
/**
  * @}
  */ 

/** @defgroup RCC_LSE_Dual_Mode_Selection
  * @{
  */
#define RCC_LSE_LOWPOWER_MODE           ((uint8_t)0x00)
#define RCC_LSE_HIGHDRIVE_MODE          ((uint8_t)0x01)
#define IS_RCC_LSE_MODE(MODE)           (((MODE) == RCC_LSE_LOWPOWER_MODE) || \
                                         ((MODE) == RCC_LSE_HIGHDRIVE_MODE))
/**
  * @}
  */

/** @defgroup RCC_PLL_Clock_Source 
  * @{
  */
#define RCC_PLLSource_HSI                ((uint32_t)0x00000000)
#define RCC_PLLSource_HSE                ((uint32_t)0x00400000)
#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI) || \
                                   ((SOURCE) == RCC_PLLSource_HSE))
#define IS_RCC_PLLM_VALUE(VALUE) ((VALUE) <= 63)
#define IS_RCC_PLLN_VALUE(VALUE) ((192 <= (VALUE)) && ((VALUE) <= 432))
#define IS_RCC_PLLP_VALUE(VALUE) (((VALUE) == 2) || ((VALUE) == 4) || ((VALUE) == 6) || ((VALUE) == 8))
#define IS_RCC_PLLQ_VALUE(VALUE) ((4 <= (VALUE)) && ((VALUE) <= 15))
 
#define IS_RCC_PLLI2SN_VALUE(VALUE) ((192 <= (VALUE)) && ((VALUE) <= 432))
#define IS_RCC_PLLI2SR_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 7))  
#define IS_RCC_PLLI2SM_VALUE(VALUE) ((VALUE) <= 63)  

#define IS_RCC_PLLI2SQ_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 15))
#define IS_RCC_PLLSAIN_VALUE(VALUE) ((192 <= (VALUE)) && ((VALUE) <= 432))
#define IS_RCC_PLLSAIQ_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 15))
#define IS_RCC_PLLSAIR_VALUE(VALUE) ((2 <= (VALUE)) && ((VALUE) <= 7))  

#define IS_RCC_PLLSAI_DIVQ_VALUE(VALUE) ((1 <= (VALUE)) && ((VALUE) <= 32))
#define IS_RCC_PLLI2S_DIVQ_VALUE(VALUE) ((1 <= (VALUE)) && ((VALUE) <= 32))

#define RCC_PLLSAIDivR_Div2                ((uint32_t)0x00000000)
#define RCC_PLLSAIDivR_Div4                ((uint32_t)0x00010000)
#define RCC_PLLSAIDivR_Div8                ((uint32_t)0x00020000)
#define RCC_PLLSAIDivR_Div16               ((uint32_t)0x00030000)
#define IS_RCC_PLLSAI_DIVR_VALUE(VALUE) (((VALUE) == RCC_PLLSAIDivR_Div2) ||\
                                        ((VALUE) == RCC_PLLSAIDivR_Div4)  ||\
                                        ((VALUE) == RCC_PLLSAIDivR_Div8)  ||\
                                        ((VALUE) == RCC_PLLSAIDivR_Div16))
 
/**
  * @}
  */ 
  
/** @defgroup RCC_System_Clock_Source 
  * @{
  */
#define RCC_SYSCLKSource_HSI             ((uint32_t)0x00000000)
#define RCC_SYSCLKSource_HSE             ((uint32_t)0x00000001)
#define RCC_SYSCLKSource_PLLCLK          ((uint32_t)0x00000002)
#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
/**
  * @}
  */ 
  
/** @defgroup RCC_AHB_Clock_Source
  * @{
  */
#define RCC_SYSCLK_Div1                  ((uint32_t)0x00000000)
#define RCC_SYSCLK_Div2                  ((uint32_t)0x00000080)
#define RCC_SYSCLK_Div4                  ((uint32_t)0x00000090)
#define RCC_SYSCLK_Div8                  ((uint32_t)0x000000A0)
#define RCC_SYSCLK_Div16                 ((uint32_t)0x000000B0)
#define RCC_SYSCLK_Div64                 ((uint32_t)0x000000C0)
#define RCC_SYSCLK_Div128                ((uint32_t)0x000000D0)
#define RCC_SYSCLK_Div256                ((uint32_t)0x000000E0)
#define RCC_SYSCLK_Div512                ((uint32_t)0x000000F0)
#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
                           ((HCLK) == RCC_SYSCLK_Div512))
/**
  * @}
  */ 
  
/** @defgroup RCC_APB1_APB2_Clock_Source
  * @{
  */
#define RCC_HCLK_Div1                    ((uint32_t)0x00000000)
#define RCC_HCLK_Div2                    ((uint32_t)0x00001000)
#define RCC_HCLK_Div4                    ((uint32_t)0x00001400)
#define RCC_HCLK_Div8                    ((uint32_t)0x00001800)
#define RCC_HCLK_Div16                   ((uint32_t)0x00001C00)
#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
                           ((PCLK) == RCC_HCLK_Div16))
/**
  * @}
  */ 
  
/** @defgroup RCC_Interrupt_Source 
  * @{
  */
#define RCC_IT_LSIRDY                    ((uint8_t)0x01)
#define RCC_IT_LSERDY                    ((uint8_t)0x02)
#define RCC_IT_HSIRDY                    ((uint8_t)0x04)
#define RCC_IT_HSERDY                    ((uint8_t)0x08)
#define RCC_IT_PLLRDY                    ((uint8_t)0x10)
#define RCC_IT_PLLI2SRDY                 ((uint8_t)0x20) 
#define RCC_IT_PLLSAIRDY                 ((uint8_t)0x40)
#define RCC_IT_CSS                       ((uint8_t)0x80)

#define IS_RCC_IT(IT) ((((IT) & (uint8_t)0x80) == 0x00) && ((IT) != 0x00))
#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS) || \
                           ((IT) == RCC_IT_PLLSAIRDY) || ((IT) == RCC_IT_PLLI2SRDY))
#define IS_RCC_CLEAR_IT(IT)((IT) != 0x00)

/**
  * @}
  */ 
  
/** @defgroup RCC_LSE_Configuration 
  * @{
  */
#define RCC_LSE_OFF                      ((uint8_t)0x00)
#define RCC_LSE_ON                       ((uint8_t)0x01)
#define RCC_LSE_Bypass                   ((uint8_t)0x04)
#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
                         ((LSE) == RCC_LSE_Bypass))
/**
  * @}
  */ 
  
/** @defgroup RCC_RTC_Clock_Source
  * @{
  */
#define RCC_RTCCLKSource_LSE             ((uint32_t)0x00000100)
#define RCC_RTCCLKSource_LSI             ((uint32_t)0x00000200)
#define RCC_RTCCLKSource_HSE_Div2        ((uint32_t)0x00020300)
#define RCC_RTCCLKSource_HSE_Div3        ((uint32_t)0x00030300)
#define RCC_RTCCLKSource_HSE_Div4        ((uint32_t)0x00040300)
#define RCC_RTCCLKSource_HSE_Div5        ((uint32_t)0x00050300)
#define RCC_RTCCLKSource_HSE_Div6        ((uint32_t)0x00060300)
#define RCC_RTCCLKSource_HSE_Div7        ((uint32_t)0x00070300)
#define RCC_RTCCLKSource_HSE_Div8        ((uint32_t)0x00080300)
#define RCC_RTCCLKSource_HSE_Div9        ((uint32_t)0x00090300)
#define RCC_RTCCLKSource_HSE_Div10       ((uint32_t)0x000A0300)
#define RCC_RTCCLKSource_HSE_Div11       ((uint32_t)0x000B0300)
#define RCC_RTCCLKSource_HSE_Div12       ((uint32_t)0x000C0300)
#define RCC_RTCCLKSource_HSE_Div13       ((uint32_t)0x000D0300)
#define RCC_RTCCLKSource_HSE_Div14       ((uint32_t)0x000E0300)
#define RCC_RTCCLKSource_HSE_Div15       ((uint32_t)0x000F0300)
#define RCC_RTCCLKSource_HSE_Div16       ((uint32_t)0x00100300)
#define RCC_RTCCLKSource_HSE_Div17       ((uint32_t)0x00110300)
#define RCC_RTCCLKSource_HSE_Div18       ((uint32_t)0x00120300)
#define RCC_RTCCLKSource_HSE_Div19       ((uint32_t)0x00130300)
#define RCC_RTCCLKSource_HSE_Div20       ((uint32_t)0x00140300)
#define RCC_RTCCLKSource_HSE_Div21       ((uint32_t)0x00150300)
#define RCC_RTCCLKSource_HSE_Div22       ((uint32_t)0x00160300)
#define RCC_RTCCLKSource_HSE_Div23       ((uint32_t)0x00170300)
#define RCC_RTCCLKSource_HSE_Div24       ((uint32_t)0x00180300)
#define RCC_RTCCLKSource_HSE_Div25       ((uint32_t)0x00190300)
#define RCC_RTCCLKSource_HSE_Div26       ((uint32_t)0x001A0300)
#define RCC_RTCCLKSource_HSE_Div27       ((uint32_t)0x001B0300)
#define RCC_RTCCLKSource_HSE_Div28       ((uint32_t)0x001C0300)
#define RCC_RTCCLKSource_HSE_Div29       ((uint32_t)0x001D0300)
#define RCC_RTCCLKSource_HSE_Div30       ((uint32_t)0x001E0300)
#define RCC_RTCCLKSource_HSE_Div31       ((uint32_t)0x001F0300)
#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div2) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div3) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div4) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div5) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div6) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div7) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div8) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div9) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div10) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div11) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div12) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div13) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div14) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div15) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div16) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div17) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div18) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div19) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div20) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div21) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div22) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div23) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div24) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div25) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div26) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div27) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div28) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div29) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div30) || \
                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div31))
/**
  * @}
  */ 
  
/** @defgroup RCC_I2S_Clock_Source
  * @{
  */
#define RCC_I2S2CLKSource_PLLI2S             ((uint8_t)0x00)
#define RCC_I2S2CLKSource_Ext                ((uint8_t)0x01)

#define IS_RCC_I2SCLK_SOURCE(SOURCE) (((SOURCE) == RCC_I2S2CLKSource_PLLI2S) || ((SOURCE) == RCC_I2S2CLKSource_Ext))                                
/**
  * @}
  */ 

/** @defgroup RCC_SAI_BlockA_Clock_Source
  * @{
  */
#define RCC_SAIACLKSource_PLLSAI             ((uint32_t)0x00000000)
#define RCC_SAIACLKSource_PLLI2S             ((uint32_t)0x00100000)
#define RCC_SAIACLKSource_Ext                ((uint32_t)0x00200000)

#define IS_RCC_SAIACLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIACLKSource_PLLI2S) ||\
                                       ((SOURCE) == RCC_SAIACLKSource_PLLSAI) ||\
                                       ((SOURCE) == RCC_SAIACLKSource_Ext))
/**
  * @}
  */ 

/** @defgroup RCC_SAI_BlockB_Clock_Source
  * @{
  */
#define RCC_SAIBCLKSource_PLLSAI             ((uint32_t)0x00000000)
#define RCC_SAIBCLKSource_PLLI2S             ((uint32_t)0x00400000)
#define RCC_SAIBCLKSource_Ext                ((uint32_t)0x00800000)

#define IS_RCC_SAIBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SAIBCLKSource_PLLI2S) ||\
                                       ((SOURCE) == RCC_SAIBCLKSource_PLLSAI) ||\
                                       ((SOURCE) == RCC_SAIBCLKSource_Ext))
/**
  * @}
  */ 

/** @defgroup RCC_TIM_PRescaler_Selection
  * @{
  */
#define RCC_TIMPrescDesactivated             ((uint8_t)0x00)
#define RCC_TIMPrescActivated                ((uint8_t)0x01)

#define IS_RCC_TIMCLK_PRESCALER(VALUE) (((VALUE) == RCC_TIMPrescDesactivated) || ((VALUE) == RCC_TIMPrescActivated))
/**
  * @}
  */
  
/** @defgroup RCC_AHB1_Peripherals 
  * @{
  */ 
#define RCC_AHB1Periph_GPIOA             ((uint32_t)0x00000001)
#define RCC_AHB1Periph_GPIOB             ((uint32_t)0x00000002)
#define RCC_AHB1Periph_GPIOC             ((uint32_t)0x00000004)
#define RCC_AHB1Periph_GPIOD             ((uint32_t)0x00000008)
#define RCC_AHB1Periph_GPIOE             ((uint32_t)0x00000010)
#define RCC_AHB1Periph_GPIOF             ((uint32_t)0x00000020)
#define RCC_AHB1Periph_GPIOG             ((uint32_t)0x00000040)
#define RCC_AHB1Periph_GPIOH             ((uint32_t)0x00000080)
#define RCC_AHB1Periph_GPIOI             ((uint32_t)0x00000100) 
#define RCC_AHB1Periph_GPIOJ             ((uint32_t)0x00000200)
#define RCC_AHB1Periph_GPIOK             ((uint32_t)0x00000400)
#define RCC_AHB1Periph_CRC               ((uint32_t)0x00001000)
#define RCC_AHB1Periph_FLITF             ((uint32_t)0x00008000)
#define RCC_AHB1Periph_SRAM1             ((uint32_t)0x00010000)
#define RCC_AHB1Periph_SRAM2             ((uint32_t)0x00020000)
#define RCC_AHB1Periph_BKPSRAM           ((uint32_t)0x00040000)
#define RCC_AHB1Periph_SRAM3             ((uint32_t)0x00080000)
#define RCC_AHB1Periph_CCMDATARAMEN      ((uint32_t)0x00100000)
#define RCC_AHB1Periph_DMA1              ((uint32_t)0x00200000)
#define RCC_AHB1Periph_DMA2              ((uint32_t)0x00400000)
#define RCC_AHB1Periph_DMA2D             ((uint32_t)0x00800000)
#define RCC_AHB1Periph_ETH_MAC           ((uint32_t)0x02000000)
#define RCC_AHB1Periph_ETH_MAC_Tx        ((uint32_t)0x04000000)
#define RCC_AHB1Periph_ETH_MAC_Rx        ((uint32_t)0x08000000)
#define RCC_AHB1Periph_ETH_MAC_PTP       ((uint32_t)0x10000000)
#define RCC_AHB1Periph_OTG_HS            ((uint32_t)0x20000000)
#define RCC_AHB1Periph_OTG_HS_ULPI       ((uint32_t)0x40000000)

#define IS_RCC_AHB1_CLOCK_PERIPH(PERIPH) ((((PERIPH) & 0x810BE800) == 0x00) && ((PERIPH) != 0x00))
#define IS_RCC_AHB1_RESET_PERIPH(PERIPH) ((((PERIPH) & 0xDD1FE800) == 0x00) && ((PERIPH) != 0x00))
#define IS_RCC_AHB1_LPMODE_PERIPH(PERIPH) ((((PERIPH) & 0x81106800) == 0x00) && ((PERIPH) != 0x00))

/**
  * @}
  */ 
  
/** @defgroup RCC_AHB2_Peripherals 
  * @{
  */  
#define RCC_AHB2Periph_DCMI              ((uint32_t)0x00000001)
#define RCC_AHB2Periph_CRYP              ((uint32_t)0x00000010)
#define RCC_AHB2Periph_HASH              ((uint32_t)0x00000020)
#define RCC_AHB2Periph_RNG               ((uint32_t)0x00000040)
#define RCC_AHB2Periph_OTG_FS            ((uint32_t)0x00000080)
#define IS_RCC_AHB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFF0E) == 0x00) && ((PERIPH) != 0x00))
/**
  * @}
  */ 
  
/** @defgroup RCC_AHB3_Peripherals 
  * @{
  */ 
#if defined (STM32F40_41xxx)
#define RCC_AHB3Periph_FSMC                ((uint32_t)0x00000001)
#endif /* STM32F40_41xxx */

#if defined (STM32F427_437xx) || defined (STM32F429_439xx) 
#define RCC_AHB3Periph_FMC                ((uint32_t)0x00000001)
#endif /* STM32F427_437xx ||  STM32F429_439xx */

#define IS_RCC_AHB3_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFFFE) == 0x00) && ((PERIPH) != 0x00))
/**
  * @}
  */ 
  
/** @defgroup RCC_APB1_Peripherals 
  * @{
  */ 
#define RCC_APB1Periph_TIM2              ((uint32_t)0x00000001)
#define RCC_APB1Periph_TIM3              ((uint32_t)0x00000002)
#define RCC_APB1Periph_TIM4              ((uint32_t)0x00000004)
#define RCC_APB1Periph_TIM5              ((uint32_t)0x00000008)
#define RCC_APB1Periph_TIM6              ((uint32_t)0x00000010)
#define RCC_APB1Periph_TIM7              ((uint32_t)0x00000020)
#define RCC_APB1Periph_TIM12             ((uint32_t)0x00000040)
#define RCC_APB1Periph_TIM13             ((uint32_t)0x00000080)
#define RCC_APB1Periph_TIM14             ((uint32_t)0x00000100)
#define RCC_APB1Periph_WWDG              ((uint32_t)0x00000800)
#define RCC_APB1Periph_SPI2              ((uint32_t)0x00004000)
#define RCC_APB1Periph_SPI3              ((uint32_t)0x00008000)
#define RCC_APB1Periph_USART2            ((uint32_t)0x00020000)
#define RCC_APB1Periph_USART3            ((uint32_t)0x00040000)
#define RCC_APB1Periph_UART4             ((uint32_t)0x00080000)
#define RCC_APB1Periph_UART5             ((uint32_t)0x00100000)
#define RCC_APB1Periph_I2C1              ((uint32_t)0x00200000)
#define RCC_APB1Periph_I2C2              ((uint32_t)0x00400000)
#define RCC_APB1Periph_I2C3              ((uint32_t)0x00800000)
#define RCC_APB1Periph_CAN1              ((uint32_t)0x02000000)
#define RCC_APB1Periph_CAN2              ((uint32_t)0x04000000)
#define RCC_APB1Periph_PWR               ((uint32_t)0x10000000)
#define RCC_APB1Periph_DAC               ((uint32_t)0x20000000)
#define RCC_APB1Periph_UART7             ((uint32_t)0x40000000)
#define RCC_APB1Periph_UART8             ((uint32_t)0x80000000)
#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0x09013600) == 0x00) && ((PERIPH) != 0x00))
/**
  * @}
  */ 
  
/** @defgroup RCC_APB2_Peripherals 
  * @{
  */ 
#define RCC_APB2Periph_TIM1              ((uint32_t)0x00000001)
#define RCC_APB2Periph_TIM8              ((uint32_t)0x00000002)
#define RCC_APB2Periph_USART1            ((uint32_t)0x00000010)
#define RCC_APB2Periph_USART6            ((uint32_t)0x00000020)
#define RCC_APB2Periph_ADC               ((uint32_t)0x00000100)
#define RCC_APB2Periph_ADC1              ((uint32_t)0x00000100)
#define RCC_APB2Periph_ADC2              ((uint32_t)0x00000200)
#define RCC_APB2Periph_ADC3              ((uint32_t)0x00000400)
#define RCC_APB2Periph_SDIO              ((uint32_t)0x00000800)
#define RCC_APB2Periph_SPI1              ((uint32_t)0x00001000)
#define RCC_APB2Periph_SPI4              ((uint32_t)0x00002000)
#define RCC_APB2Periph_SYSCFG            ((uint32_t)0x00004000)
#define RCC_APB2Periph_TIM9              ((uint32_t)0x00010000)
#define RCC_APB2Periph_TIM10             ((uint32_t)0x00020000)
#define RCC_APB2Periph_TIM11             ((uint32_t)0x00040000)
#define RCC_APB2Periph_SPI5              ((uint32_t)0x00100000)
#define RCC_APB2Periph_SPI6              ((uint32_t)0x00200000)
#define RCC_APB2Periph_SAI1              ((uint32_t)0x00400000)
#define RCC_APB2Periph_LTDC              ((uint32_t)0x04000000)

#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFB8880CC) == 0x00) && ((PERIPH) != 0x00))
#define IS_RCC_APB2_RESET_PERIPH(PERIPH) ((((PERIPH) & 0xFB8886CC) == 0x00) && ((PERIPH) != 0x00))

/**
  * @}
  */ 
  
/** @defgroup RCC_MCO1_Clock_Source_Prescaler
  * @{
  */
#define RCC_MCO1Source_HSI               ((uint32_t)0x00000000)
#define RCC_MCO1Source_LSE               ((uint32_t)0x00200000)
#define RCC_MCO1Source_HSE               ((uint32_t)0x00400000)
#define RCC_MCO1Source_PLLCLK            ((uint32_t)0x00600000)
#define RCC_MCO1Div_1                    ((uint32_t)0x00000000)
#define RCC_MCO1Div_2                    ((uint32_t)0x04000000)
#define RCC_MCO1Div_3                    ((uint32_t)0x05000000)
#define RCC_MCO1Div_4                    ((uint32_t)0x06000000)
#define RCC_MCO1Div_5                    ((uint32_t)0x07000000)
#define IS_RCC_MCO1SOURCE(SOURCE) (((SOURCE) == RCC_MCO1Source_HSI) || ((SOURCE) == RCC_MCO1Source_LSE) || \
                                   ((SOURCE) == RCC_MCO1Source_HSE) || ((SOURCE) == RCC_MCO1Source_PLLCLK))
                                   
#define IS_RCC_MCO1DIV(DIV) (((DIV) == RCC_MCO1Div_1) || ((DIV) == RCC_MCO1Div_2) || \
                             ((DIV) == RCC_MCO1Div_3) || ((DIV) == RCC_MCO1Div_4) || \
                             ((DIV) == RCC_MCO1Div_5)) 
/**
  * @}
  */ 
  
/** @defgroup RCC_MCO2_Clock_Source_Prescaler
  * @{
  */
#define RCC_MCO2Source_SYSCLK            ((uint32_t)0x00000000)
#define RCC_MCO2Source_PLLI2SCLK         ((uint32_t)0x40000000)
#define RCC_MCO2Source_HSE               ((uint32_t)0x80000000)
#define RCC_MCO2Source_PLLCLK            ((uint32_t)0xC0000000)
#define RCC_MCO2Div_1                    ((uint32_t)0x00000000)
#define RCC_MCO2Div_2                    ((uint32_t)0x20000000)
#define RCC_MCO2Div_3                    ((uint32_t)0x28000000)
#define RCC_MCO2Div_4                    ((uint32_t)0x30000000)
#define RCC_MCO2Div_5                    ((uint32_t)0x38000000)
#define IS_RCC_MCO2SOURCE(SOURCE) (((SOURCE) == RCC_MCO2Source_SYSCLK) || ((SOURCE) == RCC_MCO2Source_PLLI2SCLK)|| \
                                   ((SOURCE) == RCC_MCO2Source_HSE) || ((SOURCE) == RCC_MCO2Source_PLLCLK))
                                   
#define IS_RCC_MCO2DIV(DIV) (((DIV) == RCC_MCO2Div_1) || ((DIV) == RCC_MCO2Div_2) || \
                             ((DIV) == RCC_MCO2Div_3) || ((DIV) == RCC_MCO2Div_4) || \
                             ((DIV) == RCC_MCO2Div_5))                             
/**
  * @}
  */ 
  
/** @defgroup RCC_Flag 
  * @{
  */
#define RCC_FLAG_HSIRDY                  ((uint8_t)0x21)
#define RCC_FLAG_HSERDY                  ((uint8_t)0x31)
#define RCC_FLAG_PLLRDY                  ((uint8_t)0x39)
#define RCC_FLAG_PLLI2SRDY               ((uint8_t)0x3B)
#define RCC_FLAG_PLLSAIRDY               ((uint8_t)0x3D)
#define RCC_FLAG_LSERDY                  ((uint8_t)0x41)
#define RCC_FLAG_LSIRDY                  ((uint8_t)0x61)
#define RCC_FLAG_BORRST                  ((uint8_t)0x79)
#define RCC_FLAG_PINRST                  ((uint8_t)0x7A)
#define RCC_FLAG_PORRST                  ((uint8_t)0x7B)
#define RCC_FLAG_SFTRST                  ((uint8_t)0x7C)
#define RCC_FLAG_IWDGRST                 ((uint8_t)0x7D)
#define RCC_FLAG_WWDGRST                 ((uint8_t)0x7E)
#define RCC_FLAG_LPWRRST                 ((uint8_t)0x7F)

#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY)   || ((FLAG) == RCC_FLAG_HSERDY) || \
                           ((FLAG) == RCC_FLAG_PLLRDY)   || ((FLAG) == RCC_FLAG_LSERDY) || \
                           ((FLAG) == RCC_FLAG_LSIRDY)   || ((FLAG) == RCC_FLAG_BORRST) || \
                           ((FLAG) == RCC_FLAG_PINRST)   || ((FLAG) == RCC_FLAG_PORRST) || \
                           ((FLAG) == RCC_FLAG_SFTRST)   || ((FLAG) == RCC_FLAG_IWDGRST)|| \
                           ((FLAG) == RCC_FLAG_WWDGRST)  || ((FLAG) == RCC_FLAG_LPWRRST)|| \
                           ((FLAG) == RCC_FLAG_PLLI2SRDY)|| ((FLAG) == RCC_FLAG_PLLSAIRDY))

#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
/**
  * @}
  */ 

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/* Function used to set the RCC clock configuration to the default reset state */
void RCC_DeInit(void);

/* Internal/external clocks, PLL, CSS and MCO configuration functions *********/
void        RCC_HSEConfig(uint8_t RCC_HSE);
ErrorStatus RCC_WaitForHSEStartUp(void);
void        RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue);
void        RCC_HSICmd(FunctionalState NewState);
void        RCC_LSEConfig(uint8_t RCC_LSE);
void        RCC_LSICmd(FunctionalState NewState);
void        RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ);
void        RCC_PLLCmd(FunctionalState NewState);

#if defined (STM32F40_41xxx) || defined (STM32F401xx)
void        RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR);
#elif defined (STM32F411xE)
void        RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR, uint32_t PLLI2SM);
#elif defined (STM32F427_437xx) || defined (STM32F429_439xx)
void        RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SQ, uint32_t PLLI2SR);
#else
#endif /* STM32F40_41xxx || STM32F401xx */

void        RCC_PLLI2SCmd(FunctionalState NewState);
void        RCC_PLLSAIConfig(uint32_t PLLSAIN, uint32_t PLLSAIQ, uint32_t PLLSAIR);
void        RCC_PLLSAICmd(FunctionalState NewState);
void        RCC_ClockSecuritySystemCmd(FunctionalState NewState);
void        RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div);
void        RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div);

/* System, AHB and APB busses clocks configuration functions ******************/
void        RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource);
uint8_t     RCC_GetSYSCLKSource(void);
void        RCC_HCLKConfig(uint32_t RCC_SYSCLK);
void        RCC_PCLK1Config(uint32_t RCC_HCLK);
void        RCC_PCLK2Config(uint32_t RCC_HCLK);
void        RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);

/* Peripheral clocks configuration functions **********************************/
void        RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource);
void        RCC_RTCCLKCmd(FunctionalState NewState);
void        RCC_BackupResetCmd(FunctionalState NewState);
void        RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource); 
void        RCC_SAIPLLI2SClkDivConfig(uint32_t RCC_PLLI2SDivQ);
void        RCC_SAIPLLSAIClkDivConfig(uint32_t RCC_PLLSAIDivQ);
void        RCC_SAIBlockACLKConfig(uint32_t RCC_SAIBlockACLKSource);
void        RCC_SAIBlockBCLKConfig(uint32_t RCC_SAIBlockBCLKSource);
void        RCC_LTDCCLKDivConfig(uint32_t RCC_PLLSAIDivR);
void        RCC_TIMCLKPresConfig(uint32_t RCC_TIMCLKPrescaler);

void        RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
void        RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState);
void        RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState);
void        RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
void        RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);

void        RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
void        RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState);
void        RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState);
void        RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
void        RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);

void        RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState);
void        RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState);
void        RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState);
void        RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState);
void        RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);

void        RCC_LSEModeConfig(uint8_t Mode);

/* Interrupts and flags management functions **********************************/
void        RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState);
FlagStatus  RCC_GetFlagStatus(uint8_t RCC_FLAG);
void        RCC_ClearFlag(void);
ITStatus    RCC_GetITStatus(uint8_t RCC_IT);
void        RCC_ClearITPendingBit(uint8_t RCC_IT);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_RCC_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_rcc.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_dma.h
/**
  ******************************************************************************
  * @file    stm32f4xx_dma.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the DMA firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************  
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_DMA_H
#define __STM32F4xx_DMA_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup DMA
  * @{
  */

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief  DMA Init structure definition
  */

typedef struct
{
  uint32_t DMA_Channel;            /*!< Specifies the channel used for the specified stream. 
                                        This parameter can be a value of @ref DMA_channel */
 
  uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Streamx. */

  uint32_t DMA_Memory0BaseAddr;    /*!< Specifies the memory 0 base address for DMAy Streamx. 
                                        This memory is the default memory used when double buffer mode is
                                        not enabled. */

  uint32_t DMA_DIR;                /*!< Specifies if the data will be transferred from memory to peripheral, 
                                        from memory to memory or from peripheral to memory.
                                        This parameter can be a value of @ref DMA_data_transfer_direction */

  uint32_t DMA_BufferSize;         /*!< Specifies the buffer size, in data unit, of the specified Stream. 
                                        The data unit is equal to the configuration set in DMA_PeripheralDataSize
                                        or DMA_MemoryDataSize members depending in the transfer direction. */

  uint32_t DMA_PeripheralInc;      /*!< Specifies whether the Peripheral address register should be incremented or not.
                                        This parameter can be a value of @ref DMA_peripheral_incremented_mode */

  uint32_t DMA_MemoryInc;          /*!< Specifies whether the memory address register should be incremented or not.
                                        This parameter can be a value of @ref DMA_memory_incremented_mode */

  uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width.
                                        This parameter can be a value of @ref DMA_peripheral_data_size */

  uint32_t DMA_MemoryDataSize;     /*!< Specifies the Memory data width.
                                        This parameter can be a value of @ref DMA_memory_data_size */

  uint32_t DMA_Mode;               /*!< Specifies the operation mode of the DMAy Streamx.
                                        This parameter can be a value of @ref DMA_circular_normal_mode
                                        @note The circular buffer mode cannot be used if the memory-to-memory
                                              data transfer is configured on the selected Stream */

  uint32_t DMA_Priority;           /*!< Specifies the software priority for the DMAy Streamx.
                                        This parameter can be a value of @ref DMA_priority_level */

  uint32_t DMA_FIFOMode;          /*!< Specifies if the FIFO mode or Direct mode will be used for the specified Stream.
                                        This parameter can be a value of @ref DMA_fifo_direct_mode
                                        @note The Direct mode (FIFO mode disabled) cannot be used if the 
                                               memory-to-memory data transfer is configured on the selected Stream */

  uint32_t DMA_FIFOThreshold;      /*!< Specifies the FIFO threshold level.
                                        This parameter can be a value of @ref DMA_fifo_threshold_level */

  uint32_t DMA_MemoryBurst;        /*!< Specifies the Burst transfer configuration for the memory transfers. 
                                        It specifies the amount of data to be transferred in a single non interruptable 
                                        transaction. This parameter can be a value of @ref DMA_memory_burst 
                                        @note The burst mode is possible only if the address Increment mode is enabled. */

  uint32_t DMA_PeripheralBurst;    /*!< Specifies the Burst transfer configuration for the peripheral transfers. 
                                        It specifies the amount of data to be transferred in a single non interruptable 
                                        transaction. This parameter can be a value of @ref DMA_peripheral_burst
                                        @note The burst mode is possible only if the address Increment mode is enabled. */  
}DMA_InitTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup DMA_Exported_Constants
  * @{
  */

#define IS_DMA_ALL_PERIPH(PERIPH) (((PERIPH) == DMA1_Stream0) || \
                                   ((PERIPH) == DMA1_Stream1) || \
                                   ((PERIPH) == DMA1_Stream2) || \
                                   ((PERIPH) == DMA1_Stream3) || \
                                   ((PERIPH) == DMA1_Stream4) || \
                                   ((PERIPH) == DMA1_Stream5) || \
                                   ((PERIPH) == DMA1_Stream6) || \
                                   ((PERIPH) == DMA1_Stream7) || \
                                   ((PERIPH) == DMA2_Stream0) || \
                                   ((PERIPH) == DMA2_Stream1) || \
                                   ((PERIPH) == DMA2_Stream2) || \
                                   ((PERIPH) == DMA2_Stream3) || \
                                   ((PERIPH) == DMA2_Stream4) || \
                                   ((PERIPH) == DMA2_Stream5) || \
                                   ((PERIPH) == DMA2_Stream6) || \
                                   ((PERIPH) == DMA2_Stream7))

#define IS_DMA_ALL_CONTROLLER(CONTROLLER) (((CONTROLLER) == DMA1) || \
                                           ((CONTROLLER) == DMA2))

/** @defgroup DMA_channel 
  * @{
  */ 
#define DMA_Channel_0                     ((uint32_t)0x00000000)
#define DMA_Channel_1                     ((uint32_t)0x02000000)
#define DMA_Channel_2                     ((uint32_t)0x04000000)
#define DMA_Channel_3                     ((uint32_t)0x06000000)
#define DMA_Channel_4                     ((uint32_t)0x08000000)
#define DMA_Channel_5                     ((uint32_t)0x0A000000)
#define DMA_Channel_6                     ((uint32_t)0x0C000000)
#define DMA_Channel_7                     ((uint32_t)0x0E000000)

#define IS_DMA_CHANNEL(CHANNEL) (((CHANNEL) == DMA_Channel_0) || \
                                 ((CHANNEL) == DMA_Channel_1) || \
                                 ((CHANNEL) == DMA_Channel_2) || \
                                 ((CHANNEL) == DMA_Channel_3) || \
                                 ((CHANNEL) == DMA_Channel_4) || \
                                 ((CHANNEL) == DMA_Channel_5) || \
                                 ((CHANNEL) == DMA_Channel_6) || \
                                 ((CHANNEL) == DMA_Channel_7))
/**
  * @}
  */ 


/** @defgroup DMA_data_transfer_direction 
  * @{
  */ 
#define DMA_DIR_PeripheralToMemory        ((uint32_t)0x00000000)
#define DMA_DIR_MemoryToPeripheral        ((uint32_t)0x00000040) 
#define DMA_DIR_MemoryToMemory            ((uint32_t)0x00000080)

#define IS_DMA_DIRECTION(DIRECTION) (((DIRECTION) == DMA_DIR_PeripheralToMemory ) || \
                                     ((DIRECTION) == DMA_DIR_MemoryToPeripheral)  || \
                                     ((DIRECTION) == DMA_DIR_MemoryToMemory)) 
/**
  * @}
  */ 


/** @defgroup DMA_data_buffer_size 
  * @{
  */ 
#define IS_DMA_BUFFER_SIZE(SIZE) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))
/**
  * @}
  */ 


/** @defgroup DMA_peripheral_incremented_mode 
  * @{
  */ 
#define DMA_PeripheralInc_Enable          ((uint32_t)0x00000200)
#define DMA_PeripheralInc_Disable         ((uint32_t)0x00000000)

#define IS_DMA_PERIPHERAL_INC_STATE(STATE) (((STATE) == DMA_PeripheralInc_Enable) || \
                                            ((STATE) == DMA_PeripheralInc_Disable))
/**
  * @}
  */ 


/** @defgroup DMA_memory_incremented_mode 
  * @{
  */ 
#define DMA_MemoryInc_Enable              ((uint32_t)0x00000400)
#define DMA_MemoryInc_Disable             ((uint32_t)0x00000000)

#define IS_DMA_MEMORY_INC_STATE(STATE) (((STATE) == DMA_MemoryInc_Enable) || \
                                        ((STATE) == DMA_MemoryInc_Disable))
/**
  * @}
  */ 


/** @defgroup DMA_peripheral_data_size 
  * @{
  */ 
#define DMA_PeripheralDataSize_Byte       ((uint32_t)0x00000000) 
#define DMA_PeripheralDataSize_HalfWord   ((uint32_t)0x00000800) 
#define DMA_PeripheralDataSize_Word       ((uint32_t)0x00001000)

#define IS_DMA_PERIPHERAL_DATA_SIZE(SIZE) (((SIZE) == DMA_PeripheralDataSize_Byte)  || \
                                           ((SIZE) == DMA_PeripheralDataSize_HalfWord) || \
                                           ((SIZE) == DMA_PeripheralDataSize_Word))
/**
  * @}
  */ 


/** @defgroup DMA_memory_data_size 
  * @{
  */ 
#define DMA_MemoryDataSize_Byte           ((uint32_t)0x00000000) 
#define DMA_MemoryDataSize_HalfWord       ((uint32_t)0x00002000) 
#define DMA_MemoryDataSize_Word           ((uint32_t)0x00004000)

#define IS_DMA_MEMORY_DATA_SIZE(SIZE) (((SIZE) == DMA_MemoryDataSize_Byte)  || \
                                       ((SIZE) == DMA_MemoryDataSize_HalfWord) || \
                                       ((SIZE) == DMA_MemoryDataSize_Word ))
/**
  * @}
  */ 


/** @defgroup DMA_circular_normal_mode 
  * @{
  */ 
#define DMA_Mode_Normal                   ((uint32_t)0x00000000) 
#define DMA_Mode_Circular                 ((uint32_t)0x00000100)

#define IS_DMA_MODE(MODE) (((MODE) == DMA_Mode_Normal ) || \
                           ((MODE) == DMA_Mode_Circular)) 
/**
  * @}
  */ 


/** @defgroup DMA_priority_level 
  * @{
  */ 
#define DMA_Priority_Low                  ((uint32_t)0x00000000)
#define DMA_Priority_Medium               ((uint32_t)0x00010000) 
#define DMA_Priority_High                 ((uint32_t)0x00020000)
#define DMA_Priority_VeryHigh             ((uint32_t)0x00030000)

#define IS_DMA_PRIORITY(PRIORITY) (((PRIORITY) == DMA_Priority_Low )   || \
                                   ((PRIORITY) == DMA_Priority_Medium) || \
                                   ((PRIORITY) == DMA_Priority_High)   || \
                                   ((PRIORITY) == DMA_Priority_VeryHigh)) 
/**
  * @}
  */ 


/** @defgroup DMA_fifo_direct_mode 
  * @{
  */ 
#define DMA_FIFOMode_Disable              ((uint32_t)0x00000000) 
#define DMA_FIFOMode_Enable               ((uint32_t)0x00000004)

#define IS_DMA_FIFO_MODE_STATE(STATE) (((STATE) == DMA_FIFOMode_Disable ) || \
                                       ((STATE) == DMA_FIFOMode_Enable)) 
/**
  * @}
  */ 


/** @defgroup DMA_fifo_threshold_level 
  * @{
  */ 
#define DMA_FIFOThreshold_1QuarterFull    ((uint32_t)0x00000000)
#define DMA_FIFOThreshold_HalfFull        ((uint32_t)0x00000001) 
#define DMA_FIFOThreshold_3QuartersFull   ((uint32_t)0x00000002)
#define DMA_FIFOThreshold_Full            ((uint32_t)0x00000003)

#define IS_DMA_FIFO_THRESHOLD(THRESHOLD) (((THRESHOLD) == DMA_FIFOThreshold_1QuarterFull ) || \
                                          ((THRESHOLD) == DMA_FIFOThreshold_HalfFull)      || \
                                          ((THRESHOLD) == DMA_FIFOThreshold_3QuartersFull) || \
                                          ((THRESHOLD) == DMA_FIFOThreshold_Full)) 
/**
  * @}
  */ 


/** @defgroup DMA_memory_burst 
  * @{
  */ 
#define DMA_MemoryBurst_Single            ((uint32_t)0x00000000)
#define DMA_MemoryBurst_INC4              ((uint32_t)0x00800000)  
#define DMA_MemoryBurst_INC8              ((uint32_t)0x01000000)
#define DMA_MemoryBurst_INC16             ((uint32_t)0x01800000)

#define IS_DMA_MEMORY_BURST(BURST) (((BURST) == DMA_MemoryBurst_Single) || \
                                    ((BURST) == DMA_MemoryBurst_INC4)  || \
                                    ((BURST) == DMA_MemoryBurst_INC8)  || \
                                    ((BURST) == DMA_MemoryBurst_INC16))
/**
  * @}
  */ 


/** @defgroup DMA_peripheral_burst 
  * @{
  */ 
#define DMA_PeripheralBurst_Single        ((uint32_t)0x00000000)
#define DMA_PeripheralBurst_INC4          ((uint32_t)0x00200000)  
#define DMA_PeripheralBurst_INC8          ((uint32_t)0x00400000)
#define DMA_PeripheralBurst_INC16         ((uint32_t)0x00600000)

#define IS_DMA_PERIPHERAL_BURST(BURST) (((BURST) == DMA_PeripheralBurst_Single) || \
                                        ((BURST) == DMA_PeripheralBurst_INC4)  || \
                                        ((BURST) == DMA_PeripheralBurst_INC8)  || \
                                        ((BURST) == DMA_PeripheralBurst_INC16))
/**
  * @}
  */ 


/** @defgroup DMA_fifo_status_level 
  * @{
  */
#define DMA_FIFOStatus_Less1QuarterFull   ((uint32_t)0x00000000 << 3)
#define DMA_FIFOStatus_1QuarterFull       ((uint32_t)0x00000001 << 3)
#define DMA_FIFOStatus_HalfFull           ((uint32_t)0x00000002 << 3) 
#define DMA_FIFOStatus_3QuartersFull      ((uint32_t)0x00000003 << 3)
#define DMA_FIFOStatus_Empty              ((uint32_t)0x00000004 << 3)
#define DMA_FIFOStatus_Full               ((uint32_t)0x00000005 << 3)

#define IS_DMA_FIFO_STATUS(STATUS) (((STATUS) == DMA_FIFOStatus_Less1QuarterFull ) || \
                                    ((STATUS) == DMA_FIFOStatus_HalfFull)          || \
                                    ((STATUS) == DMA_FIFOStatus_1QuarterFull)      || \
                                    ((STATUS) == DMA_FIFOStatus_3QuartersFull)     || \
                                    ((STATUS) == DMA_FIFOStatus_Full)              || \
                                    ((STATUS) == DMA_FIFOStatus_Empty)) 
/**
  * @}
  */ 

/** @defgroup DMA_flags_definition 
  * @{
  */
#define DMA_FLAG_FEIF0                    ((uint32_t)0x10800001)
#define DMA_FLAG_DMEIF0                   ((uint32_t)0x10800004)
#define DMA_FLAG_TEIF0                    ((uint32_t)0x10000008)
#define DMA_FLAG_HTIF0                    ((uint32_t)0x10000010)
#define DMA_FLAG_TCIF0                    ((uint32_t)0x10000020)
#define DMA_FLAG_FEIF1                    ((uint32_t)0x10000040)
#define DMA_FLAG_DMEIF1                   ((uint32_t)0x10000100)
#define DMA_FLAG_TEIF1                    ((uint32_t)0x10000200)
#define DMA_FLAG_HTIF1                    ((uint32_t)0x10000400)
#define DMA_FLAG_TCIF1                    ((uint32_t)0x10000800)
#define DMA_FLAG_FEIF2                    ((uint32_t)0x10010000)
#define DMA_FLAG_DMEIF2                   ((uint32_t)0x10040000)
#define DMA_FLAG_TEIF2                    ((uint32_t)0x10080000)
#define DMA_FLAG_HTIF2                    ((uint32_t)0x10100000)
#define DMA_FLAG_TCIF2                    ((uint32_t)0x10200000)
#define DMA_FLAG_FEIF3                    ((uint32_t)0x10400000)
#define DMA_FLAG_DMEIF3                   ((uint32_t)0x11000000)
#define DMA_FLAG_TEIF3                    ((uint32_t)0x12000000)
#define DMA_FLAG_HTIF3                    ((uint32_t)0x14000000)
#define DMA_FLAG_TCIF3                    ((uint32_t)0x18000000)
#define DMA_FLAG_FEIF4                    ((uint32_t)0x20000001)
#define DMA_FLAG_DMEIF4                   ((uint32_t)0x20000004)
#define DMA_FLAG_TEIF4                    ((uint32_t)0x20000008)
#define DMA_FLAG_HTIF4                    ((uint32_t)0x20000010)
#define DMA_FLAG_TCIF4                    ((uint32_t)0x20000020)
#define DMA_FLAG_FEIF5                    ((uint32_t)0x20000040)
#define DMA_FLAG_DMEIF5                   ((uint32_t)0x20000100)
#define DMA_FLAG_TEIF5                    ((uint32_t)0x20000200)
#define DMA_FLAG_HTIF5                    ((uint32_t)0x20000400)
#define DMA_FLAG_TCIF5                    ((uint32_t)0x20000800)
#define DMA_FLAG_FEIF6                    ((uint32_t)0x20010000)
#define DMA_FLAG_DMEIF6                   ((uint32_t)0x20040000)
#define DMA_FLAG_TEIF6                    ((uint32_t)0x20080000)
#define DMA_FLAG_HTIF6                    ((uint32_t)0x20100000)
#define DMA_FLAG_TCIF6                    ((uint32_t)0x20200000)
#define DMA_FLAG_FEIF7                    ((uint32_t)0x20400000)
#define DMA_FLAG_DMEIF7                   ((uint32_t)0x21000000)
#define DMA_FLAG_TEIF7                    ((uint32_t)0x22000000)
#define DMA_FLAG_HTIF7                    ((uint32_t)0x24000000)
#define DMA_FLAG_TCIF7                    ((uint32_t)0x28000000)

#define IS_DMA_CLEAR_FLAG(FLAG) ((((FLAG) & 0x30000000) != 0x30000000) && (((FLAG) & 0x30000000) != 0) && \
                                 (((FLAG) & 0xC002F082) == 0x00) && ((FLAG) != 0x00))

#define IS_DMA_GET_FLAG(FLAG) (((FLAG) == DMA_FLAG_TCIF0)  || ((FLAG) == DMA_FLAG_HTIF0)  || \
                               ((FLAG) == DMA_FLAG_TEIF0)  || ((FLAG) == DMA_FLAG_DMEIF0) || \
                               ((FLAG) == DMA_FLAG_FEIF0)  || ((FLAG) == DMA_FLAG_TCIF1)  || \
                               ((FLAG) == DMA_FLAG_HTIF1)  || ((FLAG) == DMA_FLAG_TEIF1)  || \
                               ((FLAG) == DMA_FLAG_DMEIF1) || ((FLAG) == DMA_FLAG_FEIF1)  || \
                               ((FLAG) == DMA_FLAG_TCIF2)  || ((FLAG) == DMA_FLAG_HTIF2)  || \
                               ((FLAG) == DMA_FLAG_TEIF2)  || ((FLAG) == DMA_FLAG_DMEIF2) || \
                               ((FLAG) == DMA_FLAG_FEIF2)  || ((FLAG) == DMA_FLAG_TCIF3)  || \
                               ((FLAG) == DMA_FLAG_HTIF3)  || ((FLAG) == DMA_FLAG_TEIF3)  || \
                               ((FLAG) == DMA_FLAG_DMEIF3) || ((FLAG) == DMA_FLAG_FEIF3)  || \
                               ((FLAG) == DMA_FLAG_TCIF4)  || ((FLAG) == DMA_FLAG_HTIF4)  || \
                               ((FLAG) == DMA_FLAG_TEIF4)  || ((FLAG) == DMA_FLAG_DMEIF4) || \
                               ((FLAG) == DMA_FLAG_FEIF4)  || ((FLAG) == DMA_FLAG_TCIF5)  || \
                               ((FLAG) == DMA_FLAG_HTIF5)  || ((FLAG) == DMA_FLAG_TEIF5)  || \
                               ((FLAG) == DMA_FLAG_DMEIF5) || ((FLAG) == DMA_FLAG_FEIF5)  || \
                               ((FLAG) == DMA_FLAG_TCIF6)  || ((FLAG) == DMA_FLAG_HTIF6)  || \
                               ((FLAG) == DMA_FLAG_TEIF6)  || ((FLAG) == DMA_FLAG_DMEIF6) || \
                               ((FLAG) == DMA_FLAG_FEIF6)  || ((FLAG) == DMA_FLAG_TCIF7)  || \
                               ((FLAG) == DMA_FLAG_HTIF7)  || ((FLAG) == DMA_FLAG_TEIF7)  || \
                               ((FLAG) == DMA_FLAG_DMEIF7) || ((FLAG) == DMA_FLAG_FEIF7))
/**
  * @}
  */ 


/** @defgroup DMA_interrupt_enable_definitions 
  * @{
  */ 
#define DMA_IT_TC                         ((uint32_t)0x00000010)
#define DMA_IT_HT                         ((uint32_t)0x00000008)
#define DMA_IT_TE                         ((uint32_t)0x00000004)
#define DMA_IT_DME                        ((uint32_t)0x00000002)
#define DMA_IT_FE                         ((uint32_t)0x00000080)

#define IS_DMA_CONFIG_IT(IT) ((((IT) & 0xFFFFFF61) == 0x00) && ((IT) != 0x00))
/**
  * @}
  */ 


/** @defgroup DMA_interrupts_definitions 
  * @{
  */ 
#define DMA_IT_FEIF0                      ((uint32_t)0x90000001)
#define DMA_IT_DMEIF0                     ((uint32_t)0x10001004)
#define DMA_IT_TEIF0                      ((uint32_t)0x10002008)
#define DMA_IT_HTIF0                      ((uint32_t)0x10004010)
#define DMA_IT_TCIF0                      ((uint32_t)0x10008020)
#define DMA_IT_FEIF1                      ((uint32_t)0x90000040)
#define DMA_IT_DMEIF1                     ((uint32_t)0x10001100)
#define DMA_IT_TEIF1                      ((uint32_t)0x10002200)
#define DMA_IT_HTIF1                      ((uint32_t)0x10004400)
#define DMA_IT_TCIF1                      ((uint32_t)0x10008800)
#define DMA_IT_FEIF2                      ((uint32_t)0x90010000)
#define DMA_IT_DMEIF2                     ((uint32_t)0x10041000)
#define DMA_IT_TEIF2                      ((uint32_t)0x10082000)
#define DMA_IT_HTIF2                      ((uint32_t)0x10104000)
#define DMA_IT_TCIF2                      ((uint32_t)0x10208000)
#define DMA_IT_FEIF3                      ((uint32_t)0x90400000)
#define DMA_IT_DMEIF3                     ((uint32_t)0x11001000)
#define DMA_IT_TEIF3                      ((uint32_t)0x12002000)
#define DMA_IT_HTIF3                      ((uint32_t)0x14004000)
#define DMA_IT_TCIF3                      ((uint32_t)0x18008000)
#define DMA_IT_FEIF4                      ((uint32_t)0xA0000001)
#define DMA_IT_DMEIF4                     ((uint32_t)0x20001004)
#define DMA_IT_TEIF4                      ((uint32_t)0x20002008)
#define DMA_IT_HTIF4                      ((uint32_t)0x20004010)
#define DMA_IT_TCIF4                      ((uint32_t)0x20008020)
#define DMA_IT_FEIF5                      ((uint32_t)0xA0000040)
#define DMA_IT_DMEIF5                     ((uint32_t)0x20001100)
#define DMA_IT_TEIF5                      ((uint32_t)0x20002200)
#define DMA_IT_HTIF5                      ((uint32_t)0x20004400)
#define DMA_IT_TCIF5                      ((uint32_t)0x20008800)
#define DMA_IT_FEIF6                      ((uint32_t)0xA0010000)
#define DMA_IT_DMEIF6                     ((uint32_t)0x20041000)
#define DMA_IT_TEIF6                      ((uint32_t)0x20082000)
#define DMA_IT_HTIF6                      ((uint32_t)0x20104000)
#define DMA_IT_TCIF6                      ((uint32_t)0x20208000)
#define DMA_IT_FEIF7                      ((uint32_t)0xA0400000)
#define DMA_IT_DMEIF7                     ((uint32_t)0x21001000)
#define DMA_IT_TEIF7                      ((uint32_t)0x22002000)
#define DMA_IT_HTIF7                      ((uint32_t)0x24004000)
#define DMA_IT_TCIF7                      ((uint32_t)0x28008000)

#define IS_DMA_CLEAR_IT(IT) ((((IT) & 0x30000000) != 0x30000000) && \
                             (((IT) & 0x30000000) != 0) && ((IT) != 0x00) && \
                             (((IT) & 0x40820082) == 0x00))

#define IS_DMA_GET_IT(IT) (((IT) == DMA_IT_TCIF0) || ((IT) == DMA_IT_HTIF0)  || \
                           ((IT) == DMA_IT_TEIF0) || ((IT) == DMA_IT_DMEIF0) || \
                           ((IT) == DMA_IT_FEIF0) || ((IT) == DMA_IT_TCIF1)  || \
                           ((IT) == DMA_IT_HTIF1) || ((IT) == DMA_IT_TEIF1)  || \
                           ((IT) == DMA_IT_DMEIF1)|| ((IT) == DMA_IT_FEIF1)  || \
                           ((IT) == DMA_IT_TCIF2) || ((IT) == DMA_IT_HTIF2)  || \
                           ((IT) == DMA_IT_TEIF2) || ((IT) == DMA_IT_DMEIF2) || \
                           ((IT) == DMA_IT_FEIF2) || ((IT) == DMA_IT_TCIF3)  || \
                           ((IT) == DMA_IT_HTIF3) || ((IT) == DMA_IT_TEIF3)  || \
                           ((IT) == DMA_IT_DMEIF3)|| ((IT) == DMA_IT_FEIF3)  || \
                           ((IT) == DMA_IT_TCIF4) || ((IT) == DMA_IT_HTIF4)  || \
                           ((IT) == DMA_IT_TEIF4) || ((IT) == DMA_IT_DMEIF4) || \
                           ((IT) == DMA_IT_FEIF4) || ((IT) == DMA_IT_TCIF5)  || \
                           ((IT) == DMA_IT_HTIF5) || ((IT) == DMA_IT_TEIF5)  || \
                           ((IT) == DMA_IT_DMEIF5)|| ((IT) == DMA_IT_FEIF5)  || \
                           ((IT) == DMA_IT_TCIF6) || ((IT) == DMA_IT_HTIF6)  || \
                           ((IT) == DMA_IT_TEIF6) || ((IT) == DMA_IT_DMEIF6) || \
                           ((IT) == DMA_IT_FEIF6) || ((IT) == DMA_IT_TCIF7)  || \
                           ((IT) == DMA_IT_HTIF7) || ((IT) == DMA_IT_TEIF7)  || \
                           ((IT) == DMA_IT_DMEIF7)|| ((IT) == DMA_IT_FEIF7))
/**
  * @}
  */ 


/** @defgroup DMA_peripheral_increment_offset 
  * @{
  */ 
#define DMA_PINCOS_Psize                  ((uint32_t)0x00000000)
#define DMA_PINCOS_WordAligned            ((uint32_t)0x00008000)

#define IS_DMA_PINCOS_SIZE(SIZE) (((SIZE) == DMA_PINCOS_Psize) || \
                                  ((SIZE) == DMA_PINCOS_WordAligned))
/**
  * @}
  */ 


/** @defgroup DMA_flow_controller_definitions 
  * @{
  */ 
#define DMA_FlowCtrl_Memory               ((uint32_t)0x00000000)
#define DMA_FlowCtrl_Peripheral           ((uint32_t)0x00000020)

#define IS_DMA_FLOW_CTRL(CTRL) (((CTRL) == DMA_FlowCtrl_Memory) || \
                                ((CTRL) == DMA_FlowCtrl_Peripheral))
/**
  * @}
  */ 


/** @defgroup DMA_memory_targets_definitions 
  * @{
  */ 
#define DMA_Memory_0                      ((uint32_t)0x00000000)
#define DMA_Memory_1                      ((uint32_t)0x00080000)

#define IS_DMA_CURRENT_MEM(MEM) (((MEM) == DMA_Memory_0) || ((MEM) == DMA_Memory_1))
/**
  * @}
  */ 

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/*  Function used to set the DMA configuration to the default reset state *****/ 
void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx);

/* Initialization and Configuration functions *********************************/
void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct);
void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct);
void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);

/* Optional Configuration functions *******************************************/
void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos);
void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl);

/* Data Counter functions *****************************************************/
void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter);
uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx);

/* Double Buffer mode functions ***********************************************/
void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
                                uint32_t DMA_CurrentMemory);
void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
                            uint32_t DMA_MemoryTarget);
uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx);

/* Interrupts and flags management functions **********************************/
FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx);
uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx);
FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState);
ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);

#ifdef __cplusplus
}
#endif

#endif /*__STM32F4xx_DMA_H */

/**
  * @}
  */

/**
  * @}
  */


/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_dma.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_sdio.h
/**
  ******************************************************************************
  * @file    stm32f4xx_sdio.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the SDIO firmware
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_SDIO_H
#define __STM32F4xx_SDIO_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup SDIO
  * @{
  */

/* Exported types ------------------------------------------------------------*/

typedef struct
{
  uint32_t SDIO_ClockEdge;            /*!< Specifies the clock transition on which the bit capture is made.
                                           This parameter can be a value of @ref SDIO_Clock_Edge */

  uint32_t SDIO_ClockBypass;          /*!< Specifies whether the SDIO Clock divider bypass is
                                           enabled or disabled.
                                           This parameter can be a value of @ref SDIO_Clock_Bypass */

  uint32_t SDIO_ClockPowerSave;       /*!< Specifies whether SDIO Clock output is enabled or
                                           disabled when the bus is idle.
                                           This parameter can be a value of @ref SDIO_Clock_Power_Save */

  uint32_t SDIO_BusWide;              /*!< Specifies the SDIO bus width.
                                           This parameter can be a value of @ref SDIO_Bus_Wide */

  uint32_t SDIO_HardwareFlowControl;  /*!< Specifies whether the SDIO hardware flow control is enabled or disabled.
                                           This parameter can be a value of @ref SDIO_Hardware_Flow_Control */

  uint8_t SDIO_ClockDiv;              /*!< Specifies the clock frequency of the SDIO controller.
                                           This parameter can be a value between 0x00 and 0xFF. */
                                           
} SDIO_InitTypeDef;

typedef struct
{
  uint32_t SDIO_Argument;  /*!< Specifies the SDIO command argument which is sent
                                to a card as part of a command message. If a command
                                contains an argument, it must be loaded into this register
                                before writing the command to the command register */

  uint32_t SDIO_CmdIndex;  /*!< Specifies the SDIO command index. It must be lower than 0x40. */

  uint32_t SDIO_Response;  /*!< Specifies the SDIO response type.
                                This parameter can be a value of @ref SDIO_Response_Type */

  uint32_t SDIO_Wait;      /*!< Specifies whether SDIO wait for interrupt request is enabled or disabled.
                                This parameter can be a value of @ref SDIO_Wait_Interrupt_State */

  uint32_t SDIO_CPSM;      /*!< Specifies whether SDIO Command path state machine (CPSM)
                                is enabled or disabled.
                                This parameter can be a value of @ref SDIO_CPSM_State */
} SDIO_CmdInitTypeDef;

typedef struct
{
  uint32_t SDIO_DataTimeOut;    /*!< Specifies the data timeout period in card bus clock periods. */

  uint32_t SDIO_DataLength;     /*!< Specifies the number of data bytes to be transferred. */
 
  uint32_t SDIO_DataBlockSize;  /*!< Specifies the data block size for block transfer.
                                     This parameter can be a value of @ref SDIO_Data_Block_Size */
 
  uint32_t SDIO_TransferDir;    /*!< Specifies the data transfer direction, whether the transfer
                                     is a read or write.
                                     This parameter can be a value of @ref SDIO_Transfer_Direction */
 
  uint32_t SDIO_TransferMode;   /*!< Specifies whether data transfer is in stream or block mode.
                                     This parameter can be a value of @ref SDIO_Transfer_Type */
 
  uint32_t SDIO_DPSM;           /*!< Specifies whether SDIO Data path state machine (DPSM)
                                     is enabled or disabled.
                                     This parameter can be a value of @ref SDIO_DPSM_State */
} SDIO_DataInitTypeDef;


/* Exported constants --------------------------------------------------------*/

/** @defgroup SDIO_Exported_Constants
  * @{
  */

/** @defgroup SDIO_Clock_Edge 
  * @{
  */

#define SDIO_ClockEdge_Rising               ((uint32_t)0x00000000)
#define SDIO_ClockEdge_Falling              ((uint32_t)0x00002000)
#define IS_SDIO_CLOCK_EDGE(EDGE) (((EDGE) == SDIO_ClockEdge_Rising) || \
                                  ((EDGE) == SDIO_ClockEdge_Falling))
/**
  * @}
  */

/** @defgroup SDIO_Clock_Bypass 
  * @{
  */

#define SDIO_ClockBypass_Disable             ((uint32_t)0x00000000)
#define SDIO_ClockBypass_Enable              ((uint32_t)0x00000400)    
#define IS_SDIO_CLOCK_BYPASS(BYPASS) (((BYPASS) == SDIO_ClockBypass_Disable) || \
                                     ((BYPASS) == SDIO_ClockBypass_Enable))
/**
  * @}
  */ 

/** @defgroup SDIO_Clock_Power_Save 
  * @{
  */

#define SDIO_ClockPowerSave_Disable         ((uint32_t)0x00000000)
#define SDIO_ClockPowerSave_Enable          ((uint32_t)0x00000200) 
#define IS_SDIO_CLOCK_POWER_SAVE(SAVE) (((SAVE) == SDIO_ClockPowerSave_Disable) || \
                                        ((SAVE) == SDIO_ClockPowerSave_Enable))
/**
  * @}
  */

/** @defgroup SDIO_Bus_Wide 
  * @{
  */

#define SDIO_BusWide_1b                     ((uint32_t)0x00000000)
#define SDIO_BusWide_4b                     ((uint32_t)0x00000800)
#define SDIO_BusWide_8b                     ((uint32_t)0x00001000)
#define IS_SDIO_BUS_WIDE(WIDE) (((WIDE) == SDIO_BusWide_1b) || ((WIDE) == SDIO_BusWide_4b) || \
                                ((WIDE) == SDIO_BusWide_8b))

/**
  * @}
  */

/** @defgroup SDIO_Hardware_Flow_Control 
  * @{
  */

#define SDIO_HardwareFlowControl_Disable    ((uint32_t)0x00000000)
#define SDIO_HardwareFlowControl_Enable     ((uint32_t)0x00004000)
#define IS_SDIO_HARDWARE_FLOW_CONTROL(CONTROL) (((CONTROL) == SDIO_HardwareFlowControl_Disable) || \
                                                ((CONTROL) == SDIO_HardwareFlowControl_Enable))
/**
  * @}
  */

/** @defgroup SDIO_Power_State 
  * @{
  */

#define SDIO_PowerState_OFF                 ((uint32_t)0x00000000)
#define SDIO_PowerState_ON                  ((uint32_t)0x00000003)
#define IS_SDIO_POWER_STATE(STATE) (((STATE) == SDIO_PowerState_OFF) || ((STATE) == SDIO_PowerState_ON))
/**
  * @}
  */ 


/** @defgroup SDIO_Interrupt_sources
  * @{
  */

#define SDIO_IT_CCRCFAIL                    ((uint32_t)0x00000001)
#define SDIO_IT_DCRCFAIL                    ((uint32_t)0x00000002)
#define SDIO_IT_CTIMEOUT                    ((uint32_t)0x00000004)
#define SDIO_IT_DTIMEOUT                    ((uint32_t)0x00000008)
#define SDIO_IT_TXUNDERR                    ((uint32_t)0x00000010)
#define SDIO_IT_RXOVERR                     ((uint32_t)0x00000020)
#define SDIO_IT_CMDREND                     ((uint32_t)0x00000040)
#define SDIO_IT_CMDSENT                     ((uint32_t)0x00000080)
#define SDIO_IT_DATAEND                     ((uint32_t)0x00000100)
#define SDIO_IT_STBITERR                    ((uint32_t)0x00000200)
#define SDIO_IT_DBCKEND                     ((uint32_t)0x00000400)
#define SDIO_IT_CMDACT                      ((uint32_t)0x00000800)
#define SDIO_IT_TXACT                       ((uint32_t)0x00001000)
#define SDIO_IT_RXACT                       ((uint32_t)0x00002000)
#define SDIO_IT_TXFIFOHE                    ((uint32_t)0x00004000)
#define SDIO_IT_RXFIFOHF                    ((uint32_t)0x00008000)
#define SDIO_IT_TXFIFOF                     ((uint32_t)0x00010000)
#define SDIO_IT_RXFIFOF                     ((uint32_t)0x00020000)
#define SDIO_IT_TXFIFOE                     ((uint32_t)0x00040000)
#define SDIO_IT_RXFIFOE                     ((uint32_t)0x00080000)
#define SDIO_IT_TXDAVL                      ((uint32_t)0x00100000)
#define SDIO_IT_RXDAVL                      ((uint32_t)0x00200000)
#define SDIO_IT_SDIOIT                      ((uint32_t)0x00400000)
#define SDIO_IT_CEATAEND                    ((uint32_t)0x00800000)
#define IS_SDIO_IT(IT) ((((IT) & (uint32_t)0xFF000000) == 0x00) && ((IT) != (uint32_t)0x00))
/**
  * @}
  */ 

/** @defgroup SDIO_Command_Index
  * @{
  */

#define IS_SDIO_CMD_INDEX(INDEX)            ((INDEX) < 0x40)
/**
  * @}
  */

/** @defgroup SDIO_Response_Type
  * @{
  */

#define SDIO_Response_No                    ((uint32_t)0x00000000)
#define SDIO_Response_Short                 ((uint32_t)0x00000040)
#define SDIO_Response_Long                  ((uint32_t)0x000000C0)
#define IS_SDIO_RESPONSE(RESPONSE) (((RESPONSE) == SDIO_Response_No) || \
                                    ((RESPONSE) == SDIO_Response_Short) || \
                                    ((RESPONSE) == SDIO_Response_Long))
/**
  * @}
  */

/** @defgroup SDIO_Wait_Interrupt_State
  * @{
  */

#define SDIO_Wait_No                        ((uint32_t)0x00000000) /*!< SDIO No Wait, TimeOut is enabled */
#define SDIO_Wait_IT                        ((uint32_t)0x00000100) /*!< SDIO Wait Interrupt Request */
#define SDIO_Wait_Pend                      ((uint32_t)0x00000200) /*!< SDIO Wait End of transfer */
#define IS_SDIO_WAIT(WAIT) (((WAIT) == SDIO_Wait_No) || ((WAIT) == SDIO_Wait_IT) || \
                            ((WAIT) == SDIO_Wait_Pend))
/**
  * @}
  */

/** @defgroup SDIO_CPSM_State
  * @{
  */

#define SDIO_CPSM_Disable                    ((uint32_t)0x00000000)
#define SDIO_CPSM_Enable                     ((uint32_t)0x00000400)
#define IS_SDIO_CPSM(CPSM) (((CPSM) == SDIO_CPSM_Enable) || ((CPSM) == SDIO_CPSM_Disable))
/**
  * @}
  */ 

/** @defgroup SDIO_Response_Registers
  * @{
  */

#define SDIO_RESP1                          ((uint32_t)0x00000000)
#define SDIO_RESP2                          ((uint32_t)0x00000004)
#define SDIO_RESP3                          ((uint32_t)0x00000008)
#define SDIO_RESP4                          ((uint32_t)0x0000000C)
#define IS_SDIO_RESP(RESP) (((RESP) == SDIO_RESP1) || ((RESP) == SDIO_RESP2) || \
                            ((RESP) == SDIO_RESP3) || ((RESP) == SDIO_RESP4))
/**
  * @}
  */

/** @defgroup SDIO_Data_Length 
  * @{
  */

#define IS_SDIO_DATA_LENGTH(LENGTH) ((LENGTH) <= 0x01FFFFFF)
/**
  * @}
  */

/** @defgroup SDIO_Data_Block_Size 
  * @{
  */

#define SDIO_DataBlockSize_1b               ((uint32_t)0x00000000)
#define SDIO_DataBlockSize_2b               ((uint32_t)0x00000010)
#define SDIO_DataBlockSize_4b               ((uint32_t)0x00000020)
#define SDIO_DataBlockSize_8b               ((uint32_t)0x00000030)
#define SDIO_DataBlockSize_16b              ((uint32_t)0x00000040)
#define SDIO_DataBlockSize_32b              ((uint32_t)0x00000050)
#define SDIO_DataBlockSize_64b              ((uint32_t)0x00000060)
#define SDIO_DataBlockSize_128b             ((uint32_t)0x00000070)
#define SDIO_DataBlockSize_256b             ((uint32_t)0x00000080)
#define SDIO_DataBlockSize_512b             ((uint32_t)0x00000090)
#define SDIO_DataBlockSize_1024b            ((uint32_t)0x000000A0)
#define SDIO_DataBlockSize_2048b            ((uint32_t)0x000000B0)
#define SDIO_DataBlockSize_4096b            ((uint32_t)0x000000C0)
#define SDIO_DataBlockSize_8192b            ((uint32_t)0x000000D0)
#define SDIO_DataBlockSize_16384b           ((uint32_t)0x000000E0)
#define IS_SDIO_BLOCK_SIZE(SIZE) (((SIZE) == SDIO_DataBlockSize_1b) || \
                                  ((SIZE) == SDIO_DataBlockSize_2b) || \
                                  ((SIZE) == SDIO_DataBlockSize_4b) || \
                                  ((SIZE) == SDIO_DataBlockSize_8b) || \
                                  ((SIZE) == SDIO_DataBlockSize_16b) || \
                                  ((SIZE) == SDIO_DataBlockSize_32b) || \
                                  ((SIZE) == SDIO_DataBlockSize_64b) || \
                                  ((SIZE) == SDIO_DataBlockSize_128b) || \
                                  ((SIZE) == SDIO_DataBlockSize_256b) || \
                                  ((SIZE) == SDIO_DataBlockSize_512b) || \
                                  ((SIZE) == SDIO_DataBlockSize_1024b) || \
                                  ((SIZE) == SDIO_DataBlockSize_2048b) || \
                                  ((SIZE) == SDIO_DataBlockSize_4096b) || \
                                  ((SIZE) == SDIO_DataBlockSize_8192b) || \
                                  ((SIZE) == SDIO_DataBlockSize_16384b)) 
/**
  * @}
  */

/** @defgroup SDIO_Transfer_Direction 
  * @{
  */

#define SDIO_TransferDir_ToCard             ((uint32_t)0x00000000)
#define SDIO_TransferDir_ToSDIO             ((uint32_t)0x00000002)
#define IS_SDIO_TRANSFER_DIR(DIR) (((DIR) == SDIO_TransferDir_ToCard) || \
                                   ((DIR) == SDIO_TransferDir_ToSDIO))
/**
  * @}
  */

/** @defgroup SDIO_Transfer_Type 
  * @{
  */

#define SDIO_TransferMode_Block             ((uint32_t)0x00000000)
#define SDIO_TransferMode_Stream            ((uint32_t)0x00000004)
#define IS_SDIO_TRANSFER_MODE(MODE) (((MODE) == SDIO_TransferMode_Stream) || \
                                     ((MODE) == SDIO_TransferMode_Block))
/**
  * @}
  */

/** @defgroup SDIO_DPSM_State 
  * @{
  */

#define SDIO_DPSM_Disable                    ((uint32_t)0x00000000)
#define SDIO_DPSM_Enable                     ((uint32_t)0x00000001)
#define IS_SDIO_DPSM(DPSM) (((DPSM) == SDIO_DPSM_Enable) || ((DPSM) == SDIO_DPSM_Disable))
/**
  * @}
  */

/** @defgroup SDIO_Flags 
  * @{
  */

#define SDIO_FLAG_CCRCFAIL                  ((uint32_t)0x00000001)
#define SDIO_FLAG_DCRCFAIL                  ((uint32_t)0x00000002)
#define SDIO_FLAG_CTIMEOUT                  ((uint32_t)0x00000004)
#define SDIO_FLAG_DTIMEOUT                  ((uint32_t)0x00000008)
#define SDIO_FLAG_TXUNDERR                  ((uint32_t)0x00000010)
#define SDIO_FLAG_RXOVERR                   ((uint32_t)0x00000020)
#define SDIO_FLAG_CMDREND                   ((uint32_t)0x00000040)
#define SDIO_FLAG_CMDSENT                   ((uint32_t)0x00000080)
#define SDIO_FLAG_DATAEND                   ((uint32_t)0x00000100)
#define SDIO_FLAG_STBITERR                  ((uint32_t)0x00000200)
#define SDIO_FLAG_DBCKEND                   ((uint32_t)0x00000400)
#define SDIO_FLAG_CMDACT                    ((uint32_t)0x00000800)
#define SDIO_FLAG_TXACT                     ((uint32_t)0x00001000)
#define SDIO_FLAG_RXACT                     ((uint32_t)0x00002000)
#define SDIO_FLAG_TXFIFOHE                  ((uint32_t)0x00004000)
#define SDIO_FLAG_RXFIFOHF                  ((uint32_t)0x00008000)
#define SDIO_FLAG_TXFIFOF                   ((uint32_t)0x00010000)
#define SDIO_FLAG_RXFIFOF                   ((uint32_t)0x00020000)
#define SDIO_FLAG_TXFIFOE                   ((uint32_t)0x00040000)
#define SDIO_FLAG_RXFIFOE                   ((uint32_t)0x00080000)
#define SDIO_FLAG_TXDAVL                    ((uint32_t)0x00100000)
#define SDIO_FLAG_RXDAVL                    ((uint32_t)0x00200000)
#define SDIO_FLAG_SDIOIT                    ((uint32_t)0x00400000)
#define SDIO_FLAG_CEATAEND                  ((uint32_t)0x00800000)
#define IS_SDIO_FLAG(FLAG) (((FLAG)  == SDIO_FLAG_CCRCFAIL) || \
                            ((FLAG)  == SDIO_FLAG_DCRCFAIL) || \
                            ((FLAG)  == SDIO_FLAG_CTIMEOUT) || \
                            ((FLAG)  == SDIO_FLAG_DTIMEOUT) || \
                            ((FLAG)  == SDIO_FLAG_TXUNDERR) || \
                            ((FLAG)  == SDIO_FLAG_RXOVERR) || \
                            ((FLAG)  == SDIO_FLAG_CMDREND) || \
                            ((FLAG)  == SDIO_FLAG_CMDSENT) || \
                            ((FLAG)  == SDIO_FLAG_DATAEND) || \
                            ((FLAG)  == SDIO_FLAG_STBITERR) || \
                            ((FLAG)  == SDIO_FLAG_DBCKEND) || \
                            ((FLAG)  == SDIO_FLAG_CMDACT) || \
                            ((FLAG)  == SDIO_FLAG_TXACT) || \
                            ((FLAG)  == SDIO_FLAG_RXACT) || \
                            ((FLAG)  == SDIO_FLAG_TXFIFOHE) || \
                            ((FLAG)  == SDIO_FLAG_RXFIFOHF) || \
                            ((FLAG)  == SDIO_FLAG_TXFIFOF) || \
                            ((FLAG)  == SDIO_FLAG_RXFIFOF) || \
                            ((FLAG)  == SDIO_FLAG_TXFIFOE) || \
                            ((FLAG)  == SDIO_FLAG_RXFIFOE) || \
                            ((FLAG)  == SDIO_FLAG_TXDAVL) || \
                            ((FLAG)  == SDIO_FLAG_RXDAVL) || \
                            ((FLAG)  == SDIO_FLAG_SDIOIT) || \
                            ((FLAG)  == SDIO_FLAG_CEATAEND))

#define IS_SDIO_CLEAR_FLAG(FLAG) ((((FLAG) & (uint32_t)0xFF3FF800) == 0x00) && ((FLAG) != (uint32_t)0x00))

#define IS_SDIO_GET_IT(IT) (((IT)  == SDIO_IT_CCRCFAIL) || \
                            ((IT)  == SDIO_IT_DCRCFAIL) || \
                            ((IT)  == SDIO_IT_CTIMEOUT) || \
                            ((IT)  == SDIO_IT_DTIMEOUT) || \
                            ((IT)  == SDIO_IT_TXUNDERR) || \
                            ((IT)  == SDIO_IT_RXOVERR) || \
                            ((IT)  == SDIO_IT_CMDREND) || \
                            ((IT)  == SDIO_IT_CMDSENT) || \
                            ((IT)  == SDIO_IT_DATAEND) || \
                            ((IT)  == SDIO_IT_STBITERR) || \
                            ((IT)  == SDIO_IT_DBCKEND) || \
                            ((IT)  == SDIO_IT_CMDACT) || \
                            ((IT)  == SDIO_IT_TXACT) || \
                            ((IT)  == SDIO_IT_RXACT) || \
                            ((IT)  == SDIO_IT_TXFIFOHE) || \
                            ((IT)  == SDIO_IT_RXFIFOHF) || \
                            ((IT)  == SDIO_IT_TXFIFOF) || \
                            ((IT)  == SDIO_IT_RXFIFOF) || \
                            ((IT)  == SDIO_IT_TXFIFOE) || \
                            ((IT)  == SDIO_IT_RXFIFOE) || \
                            ((IT)  == SDIO_IT_TXDAVL) || \
                            ((IT)  == SDIO_IT_RXDAVL) || \
                            ((IT)  == SDIO_IT_SDIOIT) || \
                            ((IT)  == SDIO_IT_CEATAEND))

#define IS_SDIO_CLEAR_IT(IT) ((((IT) & (uint32_t)0xFF3FF800) == 0x00) && ((IT) != (uint32_t)0x00))

/**
  * @}
  */

/** @defgroup SDIO_Read_Wait_Mode 
  * @{
  */

#define SDIO_ReadWaitMode_DATA2             ((uint32_t)0x00000000)
#define SDIO_ReadWaitMode_CLK               ((uint32_t)0x00000001)
#define IS_SDIO_READWAIT_MODE(MODE) (((MODE) == SDIO_ReadWaitMode_CLK) || \
                                     ((MODE) == SDIO_ReadWaitMode_DATA2))
/**
  * @}
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/
/*  Function used to set the SDIO configuration to the default reset state ****/
void SDIO_DeInit(void);

/* Initialization and Configuration functions *********************************/
void SDIO_Init(SDIO_InitTypeDef* SDIO_InitStruct);
void SDIO_StructInit(SDIO_InitTypeDef* SDIO_InitStruct);
void SDIO_ClockCmd(FunctionalState NewState);
void SDIO_SetPowerState(uint32_t SDIO_PowerState);
uint32_t SDIO_GetPowerState(void);

/* Command path state machine (CPSM) management functions *********************/
void SDIO_SendCommand(SDIO_CmdInitTypeDef *SDIO_CmdInitStruct);
void SDIO_CmdStructInit(SDIO_CmdInitTypeDef* SDIO_CmdInitStruct);
uint8_t SDIO_GetCommandResponse(void);
uint32_t SDIO_GetResponse(uint32_t SDIO_RESP);

/* Data path state machine (DPSM) management functions ************************/
void SDIO_DataConfig(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
void SDIO_DataStructInit(SDIO_DataInitTypeDef* SDIO_DataInitStruct);
uint32_t SDIO_GetDataCounter(void);
uint32_t SDIO_ReadData(void);
void SDIO_WriteData(uint32_t Data);
uint32_t SDIO_GetFIFOCount(void);

/* SDIO IO Cards mode management functions ************************************/
void SDIO_StartSDIOReadWait(FunctionalState NewState);
void SDIO_StopSDIOReadWait(FunctionalState NewState);
void SDIO_SetSDIOReadWaitMode(uint32_t SDIO_ReadWaitMode);
void SDIO_SetSDIOOperation(FunctionalState NewState);
void SDIO_SendSDIOSuspendCmd(FunctionalState NewState);

/* CE-ATA mode management functions *******************************************/
void SDIO_CommandCompletionCmd(FunctionalState NewState);
void SDIO_CEATAITCmd(FunctionalState NewState);
void SDIO_SendCEATACmd(FunctionalState NewState);

/* DMA transfers management functions *****************************************/
void SDIO_DMACmd(FunctionalState NewState);

/* Interrupts and flags management functions **********************************/
void SDIO_ITConfig(uint32_t SDIO_IT, FunctionalState NewState);
FlagStatus SDIO_GetFlagStatus(uint32_t SDIO_FLAG);
void SDIO_ClearFlag(uint32_t SDIO_FLAG);
ITStatus SDIO_GetITStatus(uint32_t SDIO_IT);
void SDIO_ClearITPendingBit(uint32_t SDIO_IT);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_SDIO_H */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_sdio.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_rng.h
/**
  ******************************************************************************
  * @file    stm32f4xx_rng.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the Random 
  *          Number Generator(RNG) firmware library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_RNG_H
#define __STM32F4xx_RNG_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup RNG
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/ 

/** @defgroup RNG_Exported_Constants
  * @{
  */
  
/** @defgroup RNG_flags_definition  
  * @{
  */ 
#define RNG_FLAG_DRDY               ((uint8_t)0x0001) /*!< Data ready */
#define RNG_FLAG_CECS               ((uint8_t)0x0002) /*!< Clock error current status */
#define RNG_FLAG_SECS               ((uint8_t)0x0004) /*!< Seed error current status */

#define IS_RNG_GET_FLAG(RNG_FLAG) (((RNG_FLAG) == RNG_FLAG_DRDY) || \
                                   ((RNG_FLAG) == RNG_FLAG_CECS) || \
                                   ((RNG_FLAG) == RNG_FLAG_SECS))
#define IS_RNG_CLEAR_FLAG(RNG_FLAG) (((RNG_FLAG) == RNG_FLAG_CECS) || \
                                    ((RNG_FLAG) == RNG_FLAG_SECS))
/**
  * @}
  */ 

/** @defgroup RNG_interrupts_definition   
  * @{
  */  
#define RNG_IT_CEI                  ((uint8_t)0x20) /*!< Clock error interrupt */
#define RNG_IT_SEI                  ((uint8_t)0x40) /*!< Seed error interrupt */

#define IS_RNG_IT(IT) ((((IT) & (uint8_t)0x9F) == 0x00) && ((IT) != 0x00))
#define IS_RNG_GET_IT(RNG_IT) (((RNG_IT) == RNG_IT_CEI) || ((RNG_IT) == RNG_IT_SEI))
/**
  * @}
  */ 

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/*  Function used to set the RNG configuration to the default reset state *****/ 
void RNG_DeInit(void);

/* Configuration function *****************************************************/
void RNG_Cmd(FunctionalState NewState);

/* Get 32 bit Random number function ******************************************/
uint32_t RNG_GetRandomNumber(void);

/* Interrupts and flags management functions **********************************/
void RNG_ITConfig(FunctionalState NewState);
FlagStatus RNG_GetFlagStatus(uint8_t RNG_FLAG);
void RNG_ClearFlag(uint8_t RNG_FLAG);
ITStatus RNG_GetITStatus(uint8_t RNG_IT);
void RNG_ClearITPendingBit(uint8_t RNG_IT);

#ifdef __cplusplus
}
#endif

#endif /*__STM32F4xx_RNG_H */

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_rng.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_crc.h
/**
  ******************************************************************************
  * @file    stm32f4xx_crc.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the CRC firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_CRC_H
#define __STM32F4xx_CRC_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup CRC
  * @{
  */

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/

/** @defgroup CRC_Exported_Constants
  * @{
  */

/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/  

void CRC_ResetDR(void);
uint32_t CRC_CalcCRC(uint32_t Data);
uint32_t CRC_CalcBlockCRC(uint32_t pBuffer[], uint32_t BufferLength);
uint32_t CRC_GetCRC(void);
void CRC_SetIDRegister(uint8_t IDValue);
uint8_t CRC_GetIDRegister(void);

#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_CRC_H */

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_crc.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_dma2d.h
/**
  ******************************************************************************
  * @file    stm32f4xx_dma2d.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the DMA2D firmware 
  *          library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#pragma once

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

#if defined(STM32PLUS_F4_HAS_DMA2D)

/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup DMA2D
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
 
/** 
  * @brief  DMA2D Init structure definition  
  */

typedef struct
{
  uint32_t DMA2D_Mode;                           /*!< configures the DMA2D transfer mode.
                                                 This parameter can be one value of @ref DMA2D_MODE */
  
  uint32_t DMA2D_CMode;                          /*!< configures the color format of the output image.
                                                 This parameter can be one value of @ref DMA2D_CMODE */

  uint32_t DMA2D_OutputBlue;                     /*!< configures the blue value of the output image. 
                                                 This parameter must range:
                                                 - from 0x00 to 0xFF if ARGB8888 color mode is slected
                                                 - from 0x00 to 0xFF if RGB888 color mode is slected
                                                 - from 0x00 to 0x1F if RGB565 color mode is slected
                                                 - from 0x00 to 0x1F if ARGB1555 color mode is slected
                                                 - from 0x00 to 0x0F if ARGB4444 color mode is slected  */

  uint32_t DMA2D_OutputGreen;                    /*!< configures the green value of the output image. 
                                                 This parameter must range:
                                                 - from 0x00 to 0xFF if ARGB8888 color mode is slected
                                                 - from 0x00 to 0xFF if RGB888 color mode is slected
                                                 - from 0x00 to 0x2F if RGB565 color mode is slected
                                                 - from 0x00 to 0x1F if ARGB1555 color mode is slected
                                                 - from 0x00 to 0x0F if ARGB4444 color mode is slected  */
            
  uint32_t DMA2D_OutputRed;                      /*!< configures the red value of the output image. 
                                                 This parameter must range:
                                                 - from 0x00 to 0xFF if ARGB8888 color mode is slected
                                                 - from 0x00 to 0xFF if RGB888 color mode is slected
                                                 - from 0x00 to 0x1F if RGB565 color mode is slected
                                                 - from 0x00 to 0x1F if ARGB1555 color mode is slected
                                                 - from 0x00 to 0x0F if ARGB4444 color mode is slected  */
  
  uint32_t DMA2D_OutputAlpha;                    /*!< configures the alpha channel of the output color. 
                                                 This parameter must range:
                                                 - from 0x00 to 0xFF if ARGB8888 color mode is slected
                                                 - from 0x00 to 0x01 if ARGB1555 color mode is slected
                                                 - from 0x00 to 0x0F if ARGB4444 color mode is slected  */

  uint32_t DMA2D_OutputMemoryAdd;                /*!< Specifies the memory address. This parameter 
                                                 must be range from 0x00000000 to 0xFFFFFFFF. */

  uint32_t DMA2D_OutputOffset;                   /*!< Specifies the Offset value. This parameter must be range from
                                                 0x0000 to 0x3FFF. */

  uint32_t DMA2D_NumberOfLine;                   /*!< Configures the number of line of the area to be transfered.
                                                 This parameter must range from 0x0000 to 0xFFFF */
            
  uint32_t DMA2D_PixelPerLine;                   /*!< Configures the number pixel per line of the area to be transfered.
                                                 This parameter must range from 0x0000 to 0x3FFF */
} DMA2D_InitTypeDef;



typedef struct
{
  uint32_t DMA2D_FGMA;                           /*!< configures the DMA2D foreground memory address.
                                                 This parameter must be range from 0x00000000 to 0xFFFFFFFF. */
  
  uint32_t DMA2D_FGO;                            /*!< configures the DMA2D foreground offset.
                                                 This parameter must be range from 0x0000 to 0x3FFF. */

  uint32_t DMA2D_FGCM;                           /*!< configures the DMA2D foreground color mode . 
                                                 This parameter can be one value of @ref DMA2D_FGCM */

  uint32_t DMA2D_FG_CLUT_CM;                     /*!< configures the DMA2D foreground CLUT color mode. 
                                                 This parameter can be one value of @ref DMA2D_FG_CLUT_CM */
            
  uint32_t DMA2D_FG_CLUT_SIZE;                   /*!< configures the DMA2D foreground CLUT size. 
                                                 This parameter must range from 0x00 to 0xFF. */
  
  uint32_t DMA2D_FGPFC_ALPHA_MODE;               /*!< configures the DMA2D foreground alpha mode. 
                                                 This parameter can be one value of @ref DMA2D_FGPFC_ALPHA_MODE */

  uint32_t DMA2D_FGPFC_ALPHA_VALUE;              /*!< Specifies the DMA2D foreground alpha value 
                                                 must be range from 0x00 to 0xFF. */

  uint32_t DMA2D_FGC_BLUE;                       /*!< Specifies the DMA2D foreground blue value 
                                                 must be range from 0x00 to 0xFF. */

  uint32_t DMA2D_FGC_GREEN;                      /*!< Specifies the DMA2D foreground green value 
                                                 must be range from 0x00 to 0xFF. */

  uint32_t DMA2D_FGC_RED;                        /*!< Specifies the DMA2D foreground red value 
                                                 must be range from 0x00 to 0xFF. */
            
  uint32_t DMA2D_FGCMAR;                         /*!< Configures the DMA2D foreground CLUT memory address.
                                                 This parameter must range from 0x00000000 to 0xFFFFFFFF. */
} DMA2D_FG_InitTypeDef;


typedef struct
{
  uint32_t DMA2D_BGMA;                           /*!< configures the DMA2D background memory address.
                                                 This parameter must be range from 0x00000000 to 0xFFFFFFFF. */
  
  uint32_t DMA2D_BGO;                            /*!< configures the DMA2D background offset.
                                                 This parameter must be range from 0x0000 to 0x3FFF. */

  uint32_t DMA2D_BGCM;                           /*!< configures the DMA2D background color mode . 
                                                 This parameter can be one value of @ref DMA2D_FGCM */

  uint32_t DMA2D_BG_CLUT_CM;                     /*!< configures the DMA2D background CLUT color mode. 
                                                 This parameter can be one value of @ref DMA2D_FG_CLUT_CM */
            
  uint32_t DMA2D_BG_CLUT_SIZE;                   /*!< configures the DMA2D background CLUT size. 
                                                 This parameter must range from 0x00 to 0xFF. */
  
  uint32_t DMA2D_BGPFC_ALPHA_MODE;               /*!< configures the DMA2D background alpha mode. 
                                                 This parameter can be one value of @ref DMA2D_FGPFC_ALPHA_MODE */

  uint32_t DMA2D_BGPFC_ALPHA_VALUE;              /*!< Specifies the DMA2D background alpha value 
                                                 must be range from 0x00 to 0xFF. */

  uint32_t DMA2D_BGC_BLUE;                       /*!< Specifies the DMA2D background blue value 
                                                 must be range from 0x00 to 0xFF. */

  uint32_t DMA2D_BGC_GREEN;                      /*!< Specifies the DMA2D background green value 
                                                 must be range from 0x00 to 0xFF. */

  uint32_t DMA2D_BGC_RED;                        /*!< Specifies the DMA2D background red value 
                                                 must be range from 0x00 to 0xFF. */
            
  uint32_t DMA2D_BGCMAR;                         /*!< Configures the DMA2D background CLUT memory address.
                                                 This parameter must range from 0x00000000 to 0xFFFFFFFF. */
} DMA2D_BG_InitTypeDef;



/* Exported constants --------------------------------------------------------*/

/** @defgroup DMA2D_Exported_Constants
  * @{
  */  

/** @defgroup DMA2D_MODE 
  * @{
  */


#define DMA2D_M2M                            ((uint32_t)0x00000000)
#define DMA2D_M2M_PFC                        ((uint32_t)0x00010000)
#define DMA2D_M2M_BLEND                      ((uint32_t)0x00020000)
#define DMA2D_R2M                            ((uint32_t)0x00030000)

#define IS_DMA2D_MODE(MODE) (((MODE) == DMA2D_M2M) || ((MODE) == DMA2D_M2M_PFC) || \
                             ((MODE) == DMA2D_M2M_BLEND) || ((MODE) == DMA2D_R2M))


/**
  * @}
  */  

/** @defgroup DMA2D_CMODE 
  * @{
  */
#define DMA2D_ARGB8888                       ((uint32_t)0x00000000)
#define DMA2D_RGB888                         ((uint32_t)0x00000001)
#define DMA2D_RGB565                         ((uint32_t)0x00000002)
#define DMA2D_ARGB1555                       ((uint32_t)0x00000003)
#define DMA2D_ARGB4444                       ((uint32_t)0x00000004)

#define IS_DMA2D_CMODE(MODE_ARGB) (((MODE_ARGB) == DMA2D_ARGB8888) || ((MODE_ARGB) == DMA2D_RGB888) || \
                                   ((MODE_ARGB) == DMA2D_RGB565) || ((MODE_ARGB) == DMA2D_ARGB1555) || \
                                   ((MODE_ARGB) == DMA2D_ARGB4444))


/**
  * @}
  */  

/** @defgroup DMA2D_OUTPUT_COLOR 
  * @{
  */
#define DMA2D_Output_Color                 ((uint32_t)0x000000FF)

#define IS_DMA2D_OGREEN(OGREEN) ((OGREEN) <= DMA2D_Output_Color)
#define IS_DMA2D_ORED(ORED)     ((ORED) <= DMA2D_Output_Color)
#define IS_DMA2D_OBLUE(OBLUE)   ((OBLUE) <= DMA2D_Output_Color)
#define IS_DMA2D_OALPHA(OALPHA) ((OALPHA) <= DMA2D_Output_Color)

/**
  * @}
  */  

/** @defgroup DMA2D_OUTPUT_OFFSET 
  * @{
  */
#define DMA2D_OUTPUT_OFFSET      ((uint32_t)0x00003FFF)

#define IS_DMA2D_OUTPUT_OFFSET(OOFFSET) ((OOFFSET) <= DMA2D_OUTPUT_OFFSET)


/**
  * @}
  */  

/** @defgroup DMA2D_SIZE 
  * @{
  */

#define DMA2D_pixel          ((uint32_t)0x00003FFF)
#define DMA2D_Line           ((uint32_t)0x0000FFFF)

#define IS_DMA2D_LINE(LINE)  ((LINE) <= DMA2D_Line)
#define IS_DMA2D_PIXEL(PIXEL) ((PIXEL) <= DMA2D_pixel)


/**
  * @}
  */  

/** @defgroup DMA2D_OFFSET
  * @{
  */
#define OFFSET               ((uint32_t)0x00003FFF)

#define IS_DMA2D_FGO(FGO)  ((FGO) <= OFFSET)

#define IS_DMA2D_BGO(BGO)  ((BGO) <= OFFSET) 

/**
  * @}
  */  


/** @defgroup DMA2D_FGCM
  * @{
  */

#define CM_ARGB8888        ((uint32_t)0x00000000)
#define CM_RGB888          ((uint32_t)0x00000001)
#define CM_RGB565          ((uint32_t)0x00000002)
#define CM_ARGB1555        ((uint32_t)0x00000003)
#define CM_ARGB4444        ((uint32_t)0x00000004)
#define CM_L8              ((uint32_t)0x00000005)
#define CM_AL44            ((uint32_t)0x00000006)
#define CM_AL88            ((uint32_t)0x00000007)
#define CM_L4              ((uint32_t)0x00000008)
#define CM_A8              ((uint32_t)0x00000009)
#define CM_A4              ((uint32_t)0x0000000A)

#define IS_DMA2D_FGCM(FGCM) (((FGCM) == CM_ARGB8888) || ((FGCM) == CM_RGB888) || \
                             ((FGCM) == CM_RGB565) || ((FGCM) == CM_ARGB1555) || \
                             ((FGCM) == CM_ARGB4444) || ((FGCM) == CM_L8) || \
                             ((FGCM) == CM_AL44) || ((FGCM) == CM_AL88) || \
                             ((FGCM) == CM_L4) || ((FGCM) == CM_A8) || \
                             ((FGCM) == CM_A4))

#define IS_DMA2D_BGCM(BGCM) (((BGCM) == CM_ARGB8888) || ((BGCM) == CM_RGB888) || \
                             ((BGCM) == CM_RGB565) || ((BGCM) == CM_ARGB1555) || \
                             ((BGCM) == CM_ARGB4444) || ((BGCM) == CM_L8) || \
                             ((BGCM) == CM_AL44) || ((BGCM) == CM_AL88) || \
                             ((BGCM) == CM_L4) || ((BGCM) == CM_A8) || \
                             ((BGCM) == CM_A4))

/**
  * @}
  */

/** @defgroup DMA2D_FG_CLUT_CM
  * @{
  */

#define CLUT_CM_ARGB8888        ((uint32_t)0x00000000)
#define CLUT_CM_RGB888          ((uint32_t)0x00000001)

#define IS_DMA2D_FG_CLUT_CM(FG_CLUT_CM) (((FG_CLUT_CM) == CLUT_CM_ARGB8888) || ((FG_CLUT_CM) == CLUT_CM_RGB888))

#define IS_DMA2D_BG_CLUT_CM(BG_CLUT_CM) (((BG_CLUT_CM) == CLUT_CM_ARGB8888) || ((BG_CLUT_CM) == CLUT_CM_RGB888))

/**
  * @}
  */

/** @defgroup DMA2D_FG_COLOR_VALUE
  * @{
  */

#define COLOR_VALUE             ((uint32_t)0x000000FF)

#define IS_DMA2D_FG_CLUT_SIZE(FG_CLUT_SIZE) ((FG_CLUT_SIZE) <= COLOR_VALUE)

#define IS_DMA2D_FG_ALPHA_VALUE(FG_ALPHA_VALUE) ((FG_ALPHA_VALUE) <= COLOR_VALUE)
#define IS_DMA2D_FGC_BLUE(FGC_BLUE) ((FGC_BLUE) <= COLOR_VALUE)
#define IS_DMA2D_FGC_GREEN(FGC_GREEN) ((FGC_GREEN) <= COLOR_VALUE)
#define IS_DMA2D_FGC_RED(FGC_RED) ((FGC_RED) <= COLOR_VALUE)

#define IS_DMA2D_BG_CLUT_SIZE(BG_CLUT_SIZE) ((BG_CLUT_SIZE) <= COLOR_VALUE)

#define IS_DMA2D_BG_ALPHA_VALUE(BG_ALPHA_VALUE) ((BG_ALPHA_VALUE) <= COLOR_VALUE)
#define IS_DMA2D_BGC_BLUE(BGC_BLUE) ((BGC_BLUE) <= COLOR_VALUE)
#define IS_DMA2D_BGC_GREEN(BGC_GREEN) ((BGC_GREEN) <= COLOR_VALUE)
#define IS_DMA2D_BGC_RED(BGC_RED) ((BGC_RED) <= COLOR_VALUE)

/**
  * @}
  */

/** DMA2D_FGPFC_ALPHA_MODE
  * @{
  */

#define NO_MODIF_ALPHA_VALUE       ((uint32_t)0x00000000)
#define REPLACE_ALPHA_VALUE        ((uint32_t)0x00000001)
#define COMBINE_ALPHA_VALUE        ((uint32_t)0x00000002)

#define IS_DMA2D_FG_ALPHA_MODE(FG_ALPHA_MODE) (((FG_ALPHA_MODE) ==  NO_MODIF_ALPHA_VALUE) || \
                                              ((FG_ALPHA_MODE) == REPLACE_ALPHA_VALUE) || \
                                              ((FG_ALPHA_MODE) == COMBINE_ALPHA_VALUE))

#define IS_DMA2D_BG_ALPHA_MODE(BG_ALPHA_MODE) (((BG_ALPHA_MODE) ==  NO_MODIF_ALPHA_VALUE) || \
                                              ((BG_ALPHA_MODE) == REPLACE_ALPHA_VALUE) || \
                                              ((BG_ALPHA_MODE) == COMBINE_ALPHA_VALUE))

/**
  * @}
  */

/** @defgroup DMA2D_Interrupts 
  * @{
  */

#define DMA2D_IT_CE                      DMA2D_CR_CEIE
#define DMA2D_IT_CTC                     DMA2D_CR_CTCIE
#define DMA2D_IT_CAE                     DMA2D_CR_CAEIE
#define DMA2D_IT_TW                      DMA2D_CR_TWIE
#define DMA2D_IT_TC                      DMA2D_CR_TCIE
#define DMA2D_IT_TE                      DMA2D_CR_TEIE

#define IS_DMA2D_IT(IT) (((IT) == DMA2D_IT_CTC) || ((IT) == DMA2D_IT_CAE) || \
                        ((IT) == DMA2D_IT_TW) || ((IT) == DMA2D_IT_TC) || \
                        ((IT) == DMA2D_IT_TE) || ((IT) == DMA2D_IT_CE))

/**
  * @}
  */
      
/** @defgroup DMA2D_Flag 
  * @{
  */

#define DMA2D_FLAG_CE                      DMA2D_ISR_CEIF
#define DMA2D_FLAG_CTC                     DMA2D_ISR_CTCIF
#define DMA2D_FLAG_CAE                     DMA2D_ISR_CAEIF
#define DMA2D_FLAG_TW                      DMA2D_ISR_TWIF
#define DMA2D_FLAG_TC                      DMA2D_ISR_TCIF
#define DMA2D_FLAG_TE                      DMA2D_ISR_TEIF


#define IS_DMA2D_GET_FLAG(FLAG) (((FLAG) == DMA2D_FLAG_CTC) || ((FLAG) == DMA2D_FLAG_CAE) || \
                                ((FLAG) == DMA2D_FLAG_TW) || ((FLAG) == DMA2D_FLAG_TC) || \
                                ((FLAG) == DMA2D_FLAG_TE) || ((FLAG) == DMA2D_FLAG_CE)) 


/**
  * @}
  */
      
/** @defgroup DMA2D_DeadTime 
  * @{
  */

#define DEADTIME                  ((uint32_t)0x000000FF)
  
#define IS_DMA2D_DEAD_TIME(DEAD_TIME) ((DEAD_TIME) <= DEADTIME)


#define LINE_WATERMARK            DMA2D_LWR_LW

#define IS_DMA2D_LineWatermark(LineWatermark) ((LineWatermark) <= LINE_WATERMARK)

/**
  * @}
  */
  
/**
  * @}
  */

/* Exported macro ------------------------------------------------------------*/
/* Exported functions ------------------------------------------------------- */

/*  Function used to set the DMA2D configuration to the default reset state *****/
void DMA2D_DeInit(void);

/* Initialization and Configuration functions *********************************/
void DMA2D_Init(DMA2D_InitTypeDef* DMA2D_InitStruct);
void DMA2D_StructInit(DMA2D_InitTypeDef* DMA2D_InitStruct);
void DMA2D_StartTransfer(void);
void DMA2D_AbortTransfer(void);
void DMA2D_Suspend(FunctionalState NewState);
void DMA2D_FGConfig(DMA2D_FG_InitTypeDef* DMA2D_FG_InitStruct);
void DMA2D_FG_StructInit(DMA2D_FG_InitTypeDef* DMA2D_FG_InitStruct);
void DMA2D_BGConfig(DMA2D_BG_InitTypeDef* DMA2D_BG_InitStruct);
void DMA2D_BG_StructInit(DMA2D_BG_InitTypeDef* DMA2D_BG_InitStruct);
void DMA2D_FGStart(FunctionalState NewState);
void DMA2D_BGStart(FunctionalState NewState);
void DMA2D_DeadTimeConfig(uint32_t DMA2D_DeadTime, FunctionalState NewState);
void DMA2D_LineWatermarkConfig(uint32_t DMA2D_LWatermarkConfig);

/* Interrupts and flags management functions **********************************/
void DMA2D_ITConfig(uint32_t DMA2D_IT, FunctionalState NewState);
FlagStatus DMA2D_GetFlagStatus(uint32_t DMA2D_FLAG);
void DMA2D_ClearFlag(uint32_t DMA2D_FLAG);
ITStatus DMA2D_GetITStatus(uint32_t DMA2D_IT);
void DMA2D_ClearITPendingBit(uint32_t DMA2D_IT);

#endif

#ifdef __cplusplus
}
#endif

/**
  * @}
  */

/**
  * @}
  */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_dma2d.h
// START FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_dcmi.h
/**
  ******************************************************************************
  * @file    stm32f4xx_dcmi.h
  * @author  MCD Application Team
  * @version V1.4.0
  * @date    04-August-2014
  * @brief   This file contains all the functions prototypes for the DCMI firmware library.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#pragma once

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

#if defined(STM32PLUS_F4_HAS_DCMI)


/** @addtogroup STM32F4xx_StdPeriph_Driver
  * @{
  */

/** @addtogroup DCMI
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
/** 
  * @brief   DCMI Init structure definition  
  */ 
typedef struct
{
  uint16_t DCMI_CaptureMode;      /*!< Specifies the Capture Mode: Continuous or Snapshot.
                                       This parameter can be a value of @ref DCMI_Capture_Mode */

  uint16_t DCMI_SynchroMode;      /*!< Specifies the Synchronization Mode: Hardware or Embedded.
                                       This parameter can be a value of @ref DCMI_Synchronization_Mode */

  uint16_t DCMI_PCKPolarity;      /*!< Specifies the Pixel clock polarity: Falling or Rising.
                                       This parameter can be a value of @ref DCMI_PIXCK_Polarity */

  uint16_t DCMI_VSPolarity;       /*!< Specifies the Vertical synchronization polarity: High or Low.
                                       This parameter can be a value of @ref DCMI_VSYNC_Polarity */

  uint16_t DCMI_HSPolarity;       /*!< Specifies the Horizontal synchronization polarity: High or Low.
                                       This parameter can be a value of @ref DCMI_HSYNC_Polarity */

  uint16_t DCMI_CaptureRate;      /*!< Specifies the frequency of frame capture: All, 1/2 or 1/4.
                                       This parameter can be a value of @ref DCMI_Capture_Rate */

  uint16_t DCMI_ExtendedDataMode; /*!< Specifies the data width: 8-bit, 10-bit, 12-bit or 14-bit.
                                       This parameter can be a value of @ref DCMI_Extended_Data_Mode */
} DCMI_InitTypeDef;

/** 
  * @brief   DCMI CROP Init structure definition  
  */ 
typedef struct
{
  uint16_t DCMI_VerticalStartLine;      /*!< Specifies the Vertical start line count from which the image capture
                                             will start. This parameter can be a value between 0x00 and 0x1FFF */

  uint16_t DCMI_HorizontalOffsetCount;  /*!< Specifies the number of pixel clocks to count before starting a capture.
                                             This parameter can be a value between 0x00 and 0x3FFF */

  uint16_t DCMI_VerticalLineCount;      /*!< Specifies the number of lines to be captured from the starting point.
                                             This parameter can be a value between 0x00 and 0x3FFF */

  uint16_t DCMI_CaptureCount;           /*!< Specifies the number of pixel clocks to be captured from the starting
                                             point on the same line.
                                             This parameter can be a value between 0x00 and 0x3FFF */
} DCMI_CROPInitTypeDef;

/** 
  * @brief   DCMI Embedded Synchronisation CODE Init structure definition  
  */ 
typedef struct
{
  uint8_t DCMI_FrameStartCode; /*!< Specifies the code of the frame start delimiter. */
  uint8_t DCMI_LineStartCode;  /*!< Specifies the code of the line start delimiter. */
  uint8_t DCMI_LineEndCode;    /*!< Specifies the code of the line end delimiter. */
  uint8_t DCMI_FrameEndCode;   /*!< Specifies the code of the frame end delimiter. */
} DCMI_CodesInitTypeDef;

/* Exported constants --------------------------------------------------------*/

/** @defgroup DCMI_Exported_Constants
  * @{
  */

/** @defgroup DCMI_Capture_Mode 
  * @{
  */ 
#define DCMI_CaptureMode_Continuous    ((uint16_t)0x0000) /*!< The received data are transferred continuously 
                                                               into the destination memory through the DMA */
#define DCMI_CaptureMode_SnapShot      ((uint16_t)0x0002) /*!< Once activated, the interface waits for the start of 
                                                               frame and then transfers a single frame through the DMA */
#define IS_DCMI_CAPTURE_MODE(MODE)(((MODE) == DCMI_CaptureMode_Continuous) || \
                                   ((MODE) == DCMI_CaptureMode_SnapShot))
/**
  * @}
  */ 


/** @defgroup DCMI_Synchronization_Mode
  * @{
  */ 
#define DCMI_SynchroMode_Hardware    ((uint16_t)0x0000) /*!< Hardware synchronization data capture (frame/line start/stop)
                                                             is synchronized with the HSYNC/VSYNC signals */
#define DCMI_SynchroMode_Embedded    ((uint16_t)0x0010) /*!< Embedded synchronization data capture is synchronized with 
                                                             synchronization codes embedded in the data flow */
#define IS_DCMI_SYNCHRO(MODE)(((MODE) == DCMI_SynchroMode_Hardware) || \
                              ((MODE) == DCMI_SynchroMode_Embedded))
/**
  * @}
  */ 


/** @defgroup DCMI_PIXCK_Polarity 
  * @{
  */ 
#define DCMI_PCKPolarity_Falling    ((uint16_t)0x0000) /*!< Pixel clock active on Falling edge */
#define DCMI_PCKPolarity_Rising     ((uint16_t)0x0020) /*!< Pixel clock active on Rising edge */
#define IS_DCMI_PCKPOLARITY(POLARITY)(((POLARITY) == DCMI_PCKPolarity_Falling) || \
                                      ((POLARITY) == DCMI_PCKPolarity_Rising))
/**
  * @}
  */ 


/** @defgroup DCMI_VSYNC_Polarity 
  * @{
  */ 
#define DCMI_VSPolarity_Low     ((uint16_t)0x0000) /*!< Vertical synchronization active Low */
#define DCMI_VSPolarity_High    ((uint16_t)0x0080) /*!< Vertical synchronization active High */
#define IS_DCMI_VSPOLARITY(POLARITY)(((POLARITY) == DCMI_VSPolarity_Low) || \
                                     ((POLARITY) == DCMI_VSPolarity_High))
/**
  * @}
  */ 


/** @defgroup DCMI_HSYNC_Polarity 
  * @{
  */ 
#define DCMI_HSPolarity_Low     ((uint16_t)0x0000) /*!< Horizontal synchronization active Low */
#define DCMI_HSPolarity_High    ((uint16_t)0x0040) /*!< Horizontal synchronization active High */
#define IS_DCMI_HSPOLARITY(POLARITY)(((POLARITY) == DCMI_HSPolarity_Low) || \
                                     ((POLARITY) == DCMI_HSPolarity_High))
/**
  * @}
  */ 


/** @defgroup DCMI_Capture_Rate 
  * @{
  */ 
#define DCMI_CaptureRate_All_Frame     ((uint16_t)0x0000) /*!< All frames are captured */
#define DCMI_CaptureRate_1of2_Frame    ((uint16_t)0x0100) /*!< Every alternate frame captured */
#define DCMI_CaptureRate_1of4_Frame    ((uint16_t)0x0200) /*!< One frame in 4 frames captured */
#define IS_DCMI_CAPTURE_RATE(RATE) (((RATE) == DCMI_CaptureRate_All_Frame) || \
                                    ((RATE) == DCMI_CaptureRate_1of2_Frame) ||\
                                    ((RATE) == DCMI_CaptureRate_1of4_Frame))
/**
  * @}
  */ 


/** @defgroup DCMI_Extended_Data_Mode 
  * @{
  */ 
#define DCMI_ExtendedDataMode_8b     ((uint16_t)0x0000) /*!< Interface captures 8-bit data on every pixel clock */
#define DCMI_ExtendedDataMode_10b    ((uint16_t)0x0400) /*!< Interface captures 10-bit data on every pixel clock */
#define DCMI_ExtendedDataMode_12b    ((uint16_t)0x0800) /*!< Interface captures 12-bit data on every pixel clock */
#define DCMI_ExtendedDataMode_14b    ((uint16_t)0x0C00) /*!< Interface captures 14-bit data on every pixel clock */
#define IS_DCMI_EXTENDED_DATA(DATA)(((DATA) == DCMI_ExtendedDataMode_8b) || \
                                    ((DATA) == DCMI_ExtendedDataMode_10b) ||\
                                    ((DATA) == DCMI_ExtendedDataMode_12b) ||\
                                    ((DATA) == DCMI_ExtendedDataMode_14b))
/**
  * @}
  */ 


/** @defgroup DCMI_interrupt_sources 
  * @{
  */ 
#define DCMI_IT_FRAME    ((uint16_t)0x0001)
#define DCMI_IT_OVF      ((uint16_t)0x0002)
#define DCMI_IT_ERR      ((uint16_t)0x0004)
#define DCMI_IT_VSYNC    ((uint16_t)0x0008)
#define DCMI_IT_LINE     ((uint16_t)0x0010)
#define IS_DCMI_CONFIG_IT(IT) ((((IT) & (uint16_t)0xFFE0) == 0x0000) && ((IT) != 0x0000))
#define IS_DCMI_GET_IT(IT) (((IT) == DCMI_IT_FRAME) || \
                            ((IT) == DCMI_IT_OVF) || \
                            ((IT) == DCMI_IT_ERR) || \
                            ((IT) == DCMI_IT_VSYNC) || \
                            ((IT) == DCMI_IT_LINE))
/**
  * @}
  */ 


/** @defgroup DCMI_Flags 
  * @{
  */ 
/** 
  * @brief   DCMI SR register  
  */ 
#define DCMI_FLAG_HSYNC     ((uint16_t)0x2001)
#define DCMI_FLAG_VSYNC     ((uint16_t)0x2002)
#define DCMI_FLAG_FNE       ((uint16_t)0x2004)
/** 
  * @brief   DCMI RISR register  
  */ 
#define DCMI_FLAG_FRAMERI    ((uint16_t)0x0001)
#define DCMI_FLAG_OVFRI      ((uint16_t)0x0002)
#define DCMI_FLAG_ERRRI      ((uint16_t)0x0004)
#define DCMI_FLAG_VSYNCRI    ((uint16_t)0x0008)
#define DCMI_FLAG_LINERI     ((uint16_t)0x0010)
/** 
  * @brief   DCMI MISR register  
  */ 
#define DCMI_FLAG_FRAMEMI    ((uint16_t)0x1001)
#define DCMI_FLAG_OVFMI      ((uint16_t)0x1002)
#define DCMI_FLAG_ERRMI      ((uint16_t)0x1004)
#define DCMI_FLAG_VSYNCMI    ((uint16_t)0x1008)
#define DCMI_FLAG_LINEMI     ((uint16_t)0x1010)
#define IS_DCMI_GET_FLAG(FLAG) (((FLAG) == DCMI_FLAG_HSYNC) || \
                                ((FLAG) == DCMI_FLAG_VSYNC) || \
                                ((FLAG) == DCMI_FLAG_FNE) || \
                                ((FLAG) == DCMI_FLAG_FRAMERI) || \
                                ((FLAG) == DCMI_FLAG_OVFRI) || \
                                ((FLAG) == DCMI_FLAG_ERRRI) || \
                                ((FLAG) == DCMI_FLAG_VSYNCRI) || \
                                ((FLAG) == DCMI_FLAG_LINERI) || \
                                ((FLAG) == DCMI_FLAG_FRAMEMI) || \
                                ((FLAG) == DCMI_FLAG_OVFMI) || \
                                ((FLAG) == DCMI_FLAG_ERRMI) || \
                                ((FLAG) == DCMI_FLAG_VSYNCMI) || \
                                ((FLAG) == DCMI_FLAG_LINEMI))
                                
#define IS_DCMI_CLEAR_FLAG(FLAG) ((((FLAG) & (uint16_t)0xFFE0) == 0x0000) && ((FLAG) != 0x0000))
/**
  * @}
  */ 

/**
  * @}
  */ 

/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/ 

/*  Function used to set the DCMI configuration to the default reset state ****/ 
void DCMI_DeInit(void);

/* Initialization and Configuration functions *********************************/
void DCMI_Init(DCMI_InitTypeDef* DCMI_InitStruct);
void DCMI_StructInit(DCMI_InitTypeDef* DCMI_InitStruct);
void DCMI_CROPConfig(DCMI_CROPInitTypeDef* DCMI_CROPInitStruct);
void DCMI_CROPCmd(FunctionalState NewState);
void DCMI_SetEmbeddedSynchroCodes(DCMI_CodesInitTypeDef* DCMI_CodesInitStruct);
void DCMI_JPEGCmd(FunctionalState NewState);

/* Image capture functions ****************************************************/
void DCMI_Cmd(FunctionalState NewState);
void DCMI_CaptureCmd(FunctionalState NewState);
uint32_t DCMI_ReadData(void);

/* Interrupts and flags management functions **********************************/
void DCMI_ITConfig(uint16_t DCMI_IT, FunctionalState NewState);
FlagStatus DCMI_GetFlagStatus(uint16_t DCMI_FLAG);
void DCMI_ClearFlag(uint16_t DCMI_FLAG);
ITStatus DCMI_GetITStatus(uint16_t DCMI_IT);
void DCMI_ClearITPendingBit(uint16_t DCMI_IT);

#endif


#ifdef __cplusplus
}
#endif

/**
  * @}
  */ 

/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

// END FILE: ../lib/fwlib/f4/stdperiph/inc/stm32f4xx_dcmi.h
// START FILE: ../lib/usblib/device/core/inc/usbd_ioreq.h
/**
  ******************************************************************************
  * @file    usbd_ioreq.h
  * @author  MCD Application Team
  * @version V2.2.0
  * @date    13-June-2014
  * @brief   header file for the usbd_ioreq.c file
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/

#ifndef __USBD_IOREQ_H_
#define __USBD_IOREQ_H_

/* Includes ------------------------------------------------------------------*/
#include  "usbd_def.h"
#include  "usbd_core.h"

/** @addtogroup STM32_USB_DEVICE_LIBRARY
  * @{
  */
  
/** @defgroup USBD_IOREQ
  * @brief header file for the usbd_ioreq.c file
  * @{
  */ 

/** @defgroup USBD_IOREQ_Exported_Defines
  * @{
  */ 
/**
  * @}
  */ 


/** @defgroup USBD_IOREQ_Exported_Types
  * @{
  */


/**
  * @}
  */ 



/** @defgroup USBD_IOREQ_Exported_Macros
  * @{
  */ 

/**
  * @}
  */ 

/** @defgroup USBD_IOREQ_Exported_Variables
  * @{
  */ 

/**
  * @}
  */ 

/** @defgroup USBD_IOREQ_Exported_FunctionsPrototype
  * @{
  */ 

USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *buf,
                               uint16_t len);

USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len);

USBD_StatusTypeDef USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,                                 
                               uint16_t len);

USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                              uint8_t *pbuf,                                          
                              uint16_t len);

USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev);

USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev);

uint16_t  USBD_GetRxCount (USBD_HandleTypeDef  *pdev , 
                           uint8_t epnum);

/**
  * @}
  */ 

#endif /* __USBD_IOREQ_H_ */

/**
  * @}
  */ 

/**
* @}
*/ 
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/usblib/device/core/inc/usbd_ioreq.h
// START FILE: ../lib/usblib/device/core/inc/usbd_core.h
/**
  ******************************************************************************
  * @file    usbd_core.h
  * @author  MCD Application Team
  * @version V2.2.0
  * @date    13-June-2014
  * @brief   Header file for usbd_core.c
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __USBD_CORE_H
#define __USBD_CORE_H

/* Includes ------------------------------------------------------------------*/
#include "usbd_conf.h"
#include "usbd_def.h"
#include "usbd_ioreq.h"
#include "usbd_ctlreq.h"

/** @defgroup USBD_CORE_Exported_Variables
  * @{
  */ 
#define USBD_SOF          USBD_LL_SOF
/**
  * @}
  */ 

/** @defgroup USBD_CORE_Exported_FunctionsPrototype
  * @{
  */ 
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id);
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev);
USBD_StatusTypeDef USBD_Start  (USBD_HandleTypeDef *pdev);
USBD_StatusTypeDef USBD_Stop   (USBD_HandleTypeDef *pdev);
USBD_StatusTypeDef USBD_RegisterClass(USBD_HandleTypeDef *pdev, stm32plus::usb::UsbEventSource *eventSource);

USBD_StatusTypeDef USBD_RunTestMode (USBD_HandleTypeDef  *pdev); 
USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx);
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx);

USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup);
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata);
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata);

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev);
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed);
USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev);
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev);

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev);
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum);
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev, uint8_t epnum);

USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev);
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev);

/* USBD Low Level Driver */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev);
USBD_StatusTypeDef  USBD_LL_DeInit (USBD_HandleTypeDef *pdev);
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev);
USBD_StatusTypeDef  USBD_LL_Stop (USBD_HandleTypeDef *pdev);
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps);

USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr);   
USBD_StatusTypeDef  USBD_LL_FlushEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr);   
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr);   
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr);   
uint8_t             USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr);   
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr);   
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size);

USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,                                      
                                           uint8_t  *pbuf,
                                           uint16_t  size);

uint32_t USBD_LL_GetRxDataSize  (USBD_HandleTypeDef *pdev, uint8_t  ep_addr);  
void  USBD_LL_Delay (uint32_t Delay);

/**
  * @}
  */ 

#endif /* __USBD_CORE_H */

/**
  * @}
  */ 

/**
* @}
*/ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/



// END FILE: ../lib/usblib/device/core/inc/usbd_core.h
// START FILE: ../lib/usblib/device/core/inc/usbd_conf.h
/**
  ******************************************************************************
  * @file    usbd_conf_template.h
  * @author  MCD Application Team
  * @version V2.2.0
  * @date    13-June-2014
  * @brief   USB device low level driver configuration
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __USBD_CONF__H__
#define __USBD_CONF__H__

#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* Includes ------------------------------------------------------------------*/

/** @addtogroup STM32_USB_DEVICE_LIBRARY
  * @{
  */
  
/** @defgroup USBD_CONF
  * @brief USB device low level driver configuration file
  * @{
  */ 

/** @defgroup USBD_CONF_Exported_Defines
  * @{
  */ 

#define USBD_MAX_NUM_INTERFACES               1
#define USBD_MAX_NUM_CONFIGURATION            1
#define USBD_MAX_STR_DESC_SIZ                 0x100
#define USBD_SUPPORT_USER_STRING              0 
#define USBD_SELF_POWERED                     1
#define USBD_DEBUG_LEVEL                      0

/* MSC Class Config */
#define MSC_MEDIA_PACKET                       8192   

/* CDC Class Config */
#define USBD_CDC_INTERVAL                      2000  

 /* DFU Class Config */
#define USBD_DFU_MAX_ITF_NUM                   1
#define USBD_DFU_XFERS_IZE                     1024

 /* AUDIO Class Config */
#define USBD_AUDIO_FREQ                       22100 

/** @defgroup USBD_Exported_Macros
  * @{
  */ 

 /* Memory management macros */   
#define USBD_malloc               malloc
#define USBD_free                 free
#define USBD_memset               memset
#define USBD_memcpy               memcpy
    
 /* DEBUG macros */  

  
#if (USBD_DEBUG_LEVEL > 0)
#define  USBD_UsrLog(...)   printf(__VA_ARGS__);\
                            printf("\n");
#else
#define USBD_UsrLog(...)   
#endif 
                            
                            
#if (USBD_DEBUG_LEVEL > 1)

#define  USBD_ErrLog(...)   printf("ERROR: ") ;\
                            printf(__VA_ARGS__);\
                            printf("\n");
#else
#define USBD_ErrLog(...)   
#endif 
                            
                            
#if (USBD_DEBUG_LEVEL > 2)                         
#define  USBD_DbgLog(...)   printf("DEBUG : ") ;\
                            printf(__VA_ARGS__);\
                            printf("\n");
#else
#define USBD_DbgLog(...)                         
#endif
                            
/**
  * @}
  */ 
 
    
    
/**
  * @}
  */ 


/** @defgroup USBD_CONF_Exported_Types
  * @{
  */ 
/**
  * @}
  */ 


/** @defgroup USBD_CONF_Exported_Macros
  * @{
  */ 
/**
  * @}
  */ 

/** @defgroup USBD_CONF_Exported_Variables
  * @{
  */ 
/**
  * @}
  */ 

/** @defgroup USBD_CONF_Exported_FunctionsPrototype
  * @{
  */ 
/**
  * @}
  */ 


#endif //__USBD_CONF__H__


/**
  * @}
  */ 

/**
  * @}
  */ 
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

// END FILE: ../lib/usblib/device/core/inc/usbd_conf.h
// START FILE: ../lib/usblib/device/core/inc/usbd_ctlreq.h
/**
  ******************************************************************************
  * @file    usbd_req.h
  * @author  MCD Application Team
  * @version V2.2.0
  * @date    13-June-2014
  * @brief   header file for the usbd_req.c file
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/

#ifndef __USB_REQUEST_H_
#define __USB_REQUEST_H_

/* Includes ------------------------------------------------------------------*/
#include  "usbd_def.h"


/** @addtogroup STM32_USB_DEVICE_LIBRARY
  * @{
  */
  
/** @defgroup USBD_REQ
  * @brief header file for the usbd_ioreq.c file
  * @{
  */ 

/** @defgroup USBD_REQ_Exported_Defines
  * @{
  */ 
/**
  * @}
  */ 


/** @defgroup USBD_REQ_Exported_Types
  * @{
  */
/**
  * @}
  */ 



/** @defgroup USBD_REQ_Exported_Macros
  * @{
  */ 
/**
  * @}
  */ 

/** @defgroup USBD_REQ_Exported_Variables
  * @{
  */ 
/**
  * @}
  */ 

/** @defgroup USBD_REQ_Exported_FunctionsPrototype
  * @{
  */ 

USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef  *pdev, USBD_SetupReqTypedef  *req);
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef  *pdev, USBD_SetupReqTypedef  *req);
USBD_StatusTypeDef  USBD_StdEPReq  (USBD_HandleTypeDef  *pdev, USBD_SetupReqTypedef  *req);


void USBD_CtlError  (USBD_HandleTypeDef  *pdev, USBD_SetupReqTypedef *req);

void USBD_ParseSetupRequest (USBD_SetupReqTypedef *req, uint8_t *pdata);

void USBD_GetString         (uint8_t *desc, uint8_t *unicode, uint16_t *len);
/**
  * @}
  */ 

#endif /* __USB_REQUEST_H_ */

/**
  * @}
  */ 

/**
* @}
*/ 


/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/usblib/device/core/inc/usbd_ctlreq.h
// START FILE: ../lib/usblib/device/core/inc/usbd_def.h
/**
  ******************************************************************************
  * @file    usbd_def.h
  * @author  MCD Application Team
  * @version V2.2.0
  * @date    13-June-2014
  * @brief   general defines for the usb device library 
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/

#ifndef __USBD_DEF_H
#define __USBD_DEF_H

/* Includes ------------------------------------------------------------------*/
#include "usbd_conf.h"

/** @addtogroup STM32_USBD_DEVICE_LIBRARY
  * @{
  */
  
/** @defgroup USB_DEF
  * @brief general defines for the usb device library file
  * @{
  */ 

/** @defgroup USB_DEF_Exported_Defines
  * @{
  */ 

#ifndef NULL
#define NULL ((void *)0)
#endif


#define  USB_LEN_DEV_QUALIFIER_DESC                     0x0A
#define  USB_LEN_DEV_DESC                               0x12
#define  USB_LEN_CFG_DESC                               0x09
#define  USB_LEN_IF_DESC                                0x09
#define  USB_LEN_EP_DESC                                0x07
#define  USB_LEN_OTG_DESC                               0x03
#define  USB_LEN_LANGID_STR_DESC                        0x04
#define  USB_LEN_OTHER_SPEED_DESC_SIZ                   0x09

#define  USBD_IDX_LANGID_STR                            0x00 
#define  USBD_IDX_MFC_STR                               0x01 
#define  USBD_IDX_PRODUCT_STR                           0x02
#define  USBD_IDX_SERIAL_STR                            0x03 
#define  USBD_IDX_CONFIG_STR                            0x04 
#define  USBD_IDX_INTERFACE_STR                         0x05 

#define  USB_REQ_TYPE_STANDARD                          0x00
#define  USB_REQ_TYPE_CLASS                             0x20
#define  USB_REQ_TYPE_VENDOR                            0x40
#define  USB_REQ_TYPE_MASK                              0x60

#define  USB_REQ_RECIPIENT_DEVICE                       0x00
#define  USB_REQ_RECIPIENT_INTERFACE                    0x01
#define  USB_REQ_RECIPIENT_ENDPOINT                     0x02
#define  USB_REQ_RECIPIENT_MASK                         0x03

#define  USB_REQ_GET_STATUS                             0x00
#define  USB_REQ_CLEAR_FEATURE                          0x01
#define  USB_REQ_SET_FEATURE                            0x03
#define  USB_REQ_SET_ADDRESS                            0x05
#define  USB_REQ_GET_DESCRIPTOR                         0x06
#define  USB_REQ_SET_DESCRIPTOR                         0x07
#define  USB_REQ_GET_CONFIGURATION                      0x08
#define  USB_REQ_SET_CONFIGURATION                      0x09
#define  USB_REQ_GET_INTERFACE                          0x0A
#define  USB_REQ_SET_INTERFACE                          0x0B
#define  USB_REQ_SYNCH_FRAME                            0x0C

#define  USB_DESC_TYPE_DEVICE                              1
#define  USB_DESC_TYPE_CONFIGURATION                       2
#define  USB_DESC_TYPE_STRING                              3
#define  USB_DESC_TYPE_INTERFACE                           4
#define  USB_DESC_TYPE_ENDPOINT                            5
#define  USB_DESC_TYPE_DEVICE_QUALIFIER                    6
#define  USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION           7


#define USB_CONFIG_REMOTE_WAKEUP                           2
#define USB_CONFIG_SELF_POWERED                            1

#define USB_FEATURE_EP_HALT                                0
#define USB_FEATURE_REMOTE_WAKEUP                          1
#define USB_FEATURE_TEST_MODE                              2


#define USB_HS_MAX_PACKET_SIZE                            512
#define USB_FS_MAX_PACKET_SIZE                            64
#define USB_MAX_EP0_SIZE                                  64

/*  Device Status */
#define USBD_STATE_DEFAULT                                1
#define USBD_STATE_ADDRESSED                              2
#define USBD_STATE_CONFIGURED                             3
#define USBD_STATE_SUSPENDED                              4


/*  EP0 State */    
#define USBD_EP0_IDLE                                     0
#define USBD_EP0_SETUP                                    1
#define USBD_EP0_DATA_IN                                  2
#define USBD_EP0_DATA_OUT                                 3
#define USBD_EP0_STATUS_IN                                4
#define USBD_EP0_STATUS_OUT                               5
#define USBD_EP0_STALL                                    6    

#define USBD_EP_TYPE_CTRL                                 0
#define USBD_EP_TYPE_ISOC                                 1
#define USBD_EP_TYPE_BULK                                 2
#define USBD_EP_TYPE_INTR                                 3


/**
  * @}
  */ 


/** @defgroup USBD_DEF_Exported_TypesDefinitions
  * @{
  */

typedef  struct  usb_setup_req 
{
    
    uint8_t   bmRequest;                      
    uint8_t   bRequest;                           
    uint16_t  wValue;                             
    uint16_t  wIndex;                             
    uint16_t  wLength;                            
}USBD_SetupReqTypedef;

struct _USBD_HandleTypeDef;
    
typedef struct _Device_cb
{
  uint8_t  (*Init)             (struct _USBD_HandleTypeDef *pdev , uint8_t cfgidx);
  uint8_t  (*DeInit)           (struct _USBD_HandleTypeDef *pdev , uint8_t cfgidx);
 /* Control Endpoints*/
  uint8_t  (*Setup)            (struct _USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req);  
  uint8_t  (*EP0_TxSent)       (struct _USBD_HandleTypeDef *pdev );    
  uint8_t  (*EP0_RxReady)      (struct _USBD_HandleTypeDef *pdev );  
  /* Class Specific Endpoints*/
  uint8_t  (*DataIn)           (struct _USBD_HandleTypeDef *pdev , uint8_t epnum);   
  uint8_t  (*DataOut)          (struct _USBD_HandleTypeDef *pdev , uint8_t epnum); 
  uint8_t  (*SOF)              (struct _USBD_HandleTypeDef *pdev); 
  uint8_t  (*IsoINIncomplete)  (struct _USBD_HandleTypeDef *pdev , uint8_t epnum); 
  uint8_t  (*IsoOUTIncomplete) (struct _USBD_HandleTypeDef *pdev , uint8_t epnum);   

  uint8_t  *(*GetHSConfigDescriptor)(uint16_t *length); 
  uint8_t  *(*GetFSConfigDescriptor)(uint16_t *length);   
  uint8_t  *(*GetOtherSpeedConfigDescriptor)(uint16_t *length);
  uint8_t  *(*GetDeviceQualifierDescriptor)(uint16_t *length);
#if (USBD_SUPPORT_USER_STRING == 1)
  uint8_t  *(*GetUsrStrDescriptor)(struct _USBD_HandleTypeDef *pdev ,uint8_t index,  uint16_t *length);   
#endif  
  
} USBD_ClassTypeDef;

/* Following USB Device Speed */
typedef enum 
{
  USBD_SPEED_HIGH  = 0,
  USBD_SPEED_FULL  = 1,
  USBD_SPEED_LOW   = 2,  
}USBD_SpeedTypeDef;

/* Following USB Device status */
typedef enum {
  USBD_OK   = 0,
  USBD_BUSY,
  USBD_FAIL,
}USBD_StatusTypeDef;

/* USB Device descriptors structure */
typedef struct
{
  uint8_t  *(*GetDeviceDescriptor)( USBD_SpeedTypeDef speed , uint16_t *length);  
  uint8_t  *(*GetLangIDStrDescriptor)( USBD_SpeedTypeDef speed , uint16_t *length); 
  uint8_t  *(*GetManufacturerStrDescriptor)( USBD_SpeedTypeDef speed , uint16_t *length);  
  uint8_t  *(*GetProductStrDescriptor)( USBD_SpeedTypeDef speed , uint16_t *length);  
  uint8_t  *(*GetSerialStrDescriptor)( USBD_SpeedTypeDef speed , uint16_t *length);  
  uint8_t  *(*GetConfigurationStrDescriptor)( USBD_SpeedTypeDef speed , uint16_t *length);  
  uint8_t  *(*GetInterfaceStrDescriptor)( USBD_SpeedTypeDef speed , uint16_t *length);   
} USBD_DescriptorsTypeDef;

/* USB Device handle structure */
typedef struct
{ 
  uint32_t                status;
  uint32_t                total_length;    
  uint32_t                rem_length; 
  uint32_t                maxpacket;   
} USBD_EndpointTypeDef;

/* USB Device handle structure */
typedef struct _USBD_HandleTypeDef
{
  uint8_t                 id;
  uint32_t                dev_config;
  uint32_t                dev_default_config;
  uint32_t                dev_config_status; 
  USBD_SpeedTypeDef       dev_speed; 
  USBD_EndpointTypeDef    ep_in[15];
  USBD_EndpointTypeDef    ep_out[15];  
  uint32_t                ep0_state;  
  uint32_t                ep0_data_len;     
  uint8_t                 dev_state;
  uint8_t                 dev_old_state;
  uint8_t                 dev_address;
  uint8_t                 dev_connection_status;  
  uint8_t                 dev_test_mode;
  uint32_t                dev_remote_wakeup;

  USBD_SetupReqTypedef    request;
  USBD_DescriptorsTypeDef *pDesc;
  stm32plus::usb::UsbEventSource *pEventSource;
  void                    *pClassData;  
  void                    *pUserData;    
  void                    *pData;    
} USBD_HandleTypeDef;

/**
  * @}
  */ 



/** @defgroup USBD_DEF_Exported_Macros
  * @{
  */ 
#define  SWAPBYTE(addr)        (((uint16_t)(*((uint8_t *)(addr)))) + \
                               (((uint16_t)(*(((uint8_t *)(addr)) + 1))) << 8))

#define LOBYTE(x)  ((uint8_t)(x & 0x00FF))
#define HIBYTE(x)  ((uint8_t)((x & 0xFF00) >>8))
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))


#if  defined ( __GNUC__ )
  #ifndef __weak
    #define __weak   __attribute__((weak))
  #endif /* __weak */
  #ifndef __packed
    #define __packed __attribute__((__packed__))
  #endif /* __packed */
#endif /* __GNUC__ */


/* In HS mode and when the DMA is used, all variables and data structures dealing
   with the DMA during the transaction process should be 4-bytes aligned */    

#if defined   (__GNUC__)        /* GNU Compiler */
  #define __ALIGN_END    __attribute__ ((aligned (4)))
  #define __ALIGN_BEGIN         
#else                           
  #define __ALIGN_END
  #if defined   (__CC_ARM)      /* ARM Compiler */
    #define __ALIGN_BEGIN    __align(4)  
  #elif defined (__ICCARM__)    /* IAR Compiler */
    #define __ALIGN_BEGIN 
  #elif defined  (__TASKING__)  /* TASKING Compiler */
    #define __ALIGN_BEGIN    __align(4) 
  #endif /* __CC_ARM */  
#endif /* __GNUC__ */ 
  

/**
  * @}
  */ 

/** @defgroup USBD_DEF_Exported_Variables
  * @{
  */ 

/**
  * @}
  */ 

/** @defgroup USBD_DEF_Exported_FunctionsPrototype
  * @{
  */ 

/**
  * @}
  */ 

#endif /* __USBD_DEF_H */

/**
  * @}
  */ 

/**
* @}
*/ 
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/usblib/device/core/inc/usbd_def.h
// START FILE: ../lib/usblib/device/core/src/usbd_ctlreq.cpp
/**
  ******************************************************************************
  * @file    usbd_req.c
  * @author  MCD Application Team
  * @version V2.2.0
  * @date    13-June-2014 
  * @brief   This file provides the standard USB requests following chapter 9.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Includes ------------------------------------------------------------------*/
#include "config/stm32plus.h"
#include "config/event.h"
#include "usb/f4/UsbEventDescriptor.h"
#include "usb/f4/UsbErrorEvent.h"
#include "usb/f4/UsbEventSource.h"
#include "usblib/device/core/inc/usbd_ctlreq.h"
#include "usblib/device/core/inc/usbd_ioreq.h"
#include "usb/f4/device/events/class/DeviceClassSdkSetupEvent.h"
#include "usb/f4/device/events/class/DeviceClassSdkGetConfigurationDescriptorEvent.h"
#include "usb/f4/device/DescriptorHeader.h"
#include "usb/f4/device/DeviceQualifierDescriptor.h"
#include "usb/f4/device/events/class/DeviceClassSdkGetDeviceQualifierDescriptorEvent.h"


/** @addtogroup STM32_USBD_STATE_DEVICE_LIBRARY
  * @{
  */


/** @defgroup USBD_REQ 
  * @brief USB standard requests module
  * @{
  */ 

/** @defgroup USBD_REQ_Private_TypesDefinitions
  * @{
  */ 
/**
  * @}
  */ 


/** @defgroup USBD_REQ_Private_Defines
  * @{
  */ 

/**
  * @}
  */ 


/** @defgroup USBD_REQ_Private_Macros
  * @{
  */ 
/**
  * @}
  */ 


/** @defgroup USBD_REQ_Private_Variables
  * @{
  */ 
/**
  * @}
  */ 


/** @defgroup USBD_REQ_Private_FunctionPrototypes
  * @{
  */ 
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
                               USBD_SetupReqTypedef *req);

static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req);

static void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req);

static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req);

static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req);

static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req);

static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req);

static uint8_t USBD_GetLen(uint8_t *buf);

/**
  * @}
  */ 


/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 


/**
* @brief  USBD_StdDevReq
*         Handle standard usb device requests
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
  {
  case USB_REQ_GET_DESCRIPTOR: 
    
    USBD_GetDescriptor (pdev, req) ;
    break;
    
  case USB_REQ_SET_ADDRESS:                      
    USBD_SetAddress(pdev, req);
    break;
    
  case USB_REQ_SET_CONFIGURATION:                    
    USBD_SetConfig (pdev , req);
    break;
    
  case USB_REQ_GET_CONFIGURATION:                 
    USBD_GetConfig (pdev , req);
    break;
    
  case USB_REQ_GET_STATUS:                                  
    USBD_GetStatus (pdev , req);
    break;
    
    
  case USB_REQ_SET_FEATURE:   
    USBD_SetFeature (pdev , req);    
    break;
    
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
    break;
  }
  
  return ret;
}

/**
* @brief  USBD_StdItfReq
*         Handle standard usb interface requests
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
  {
  case USBD_STATE_CONFIGURED:
    
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
    {
      pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkSetupEvent(*req));
      
      if((req->wLength == 0)&& (ret == USBD_OK))
      {
         USBD_CtlSendStatus(pdev);
      }
    } 
    else 
    {                                               
       USBD_CtlError(pdev , req);
    }
    break;
    
  default:
     USBD_CtlError(pdev , req);
    break;
  }
  return USBD_OK;
}

/**
* @brief  USBD_StdEPReq
*         Handle standard usb endpoint requests
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
  
  switch (req->bRequest) 
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
      {
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
        { 
          USBD_LL_StallEP(pdev , ep_addr);
          
        }
      }
      pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkSetupEvent(*req));
      USBD_CtlSendStatus(pdev);
      
      break;
      
    default:                         
      USBD_CtlError(pdev , req);
      break;    
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
      {
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
      {
        if ((ep_addr & 0x7F) != 0x00) 
        {        
          USBD_LL_ClearStallEP(pdev , ep_addr);
          pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkSetupEvent(*req));
        }
        USBD_CtlSendStatus(pdev);
      }
      break;
      
    default:                         
      USBD_CtlError(pdev , req);
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr & 0x7F) != 0x00) 
      {
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
      {
        pep->status = 0x0001;     
      }
      else
      {
        pep->status = 0x0000;  
      }
      
      USBD_CtlSendData (pdev,
                        (uint8_t *)&pep->status,
                        2);
      break;
      
    default:                         
      USBD_CtlError(pdev , req);
      break;
    }
    break;
    
  default:
    break;
  }
  return ret;
}
/**
* @brief  USBD_GetDescriptor
*         Handle Get Descriptor requests
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
                               USBD_SetupReqTypedef *req)
{
  uint16_t len;
  uint8_t *pbuf;
  
    
  switch (req->wValue >> 8)
  {
  case USB_DESC_TYPE_DEVICE:
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
    {
      stm32plus::usb::DeviceClassSdkGetConfigurationDescriptorEvent event(
          stm32plus::usb::DeviceClassSdkGetConfigurationDescriptorEvent::Type::HIGH_SPEED);

      pdev->pEventSource->UsbEventSender.raiseEvent(event);

      pbuf=event.descriptor;
      len=event.length;

      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    else
    {
      stm32plus::usb::DeviceClassSdkGetConfigurationDescriptorEvent event(
          stm32plus::usb::DeviceClassSdkGetConfigurationDescriptorEvent::Type::FULL_SPEED);

      pdev->pEventSource->UsbEventSender.raiseEvent(event);

      pbuf=event.descriptor;
      len=event.length;

      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
    {
    case USBD_IDX_LANGID_STR:
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
      break;
      
    default:
#if (USBD_SUPPORT_USER_STRING == 1)
      pbuf = pdev->pClass->GetUsrStrDescriptor(pdev, (req->wValue) , &len);
      break;
#else      
       USBD_CtlError(pdev , req);
      return;
#endif   
    }
    break;
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
    {
      stm32plus::usb::DeviceClassSdkGetDeviceQualifierDescriptorEvent event;
      pdev->pEventSource->UsbEventSender.raiseEvent(event);

      pbuf = (uint8_t *)event.descriptor;
      len = event.length;
      break;
    }
    else
    {
      USBD_CtlError(pdev , req);
      return;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
    {
      stm32plus::usb::DeviceClassSdkGetConfigurationDescriptorEvent event(
          stm32plus::usb::DeviceClassSdkGetConfigurationDescriptorEvent::Type::OTHER_SPEED);

      pdev->pEventSource->UsbEventSender.raiseEvent(event);

      pbuf=event.descriptor;
      len=event.length;

      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
      break; 
    }
    else
    {
      USBD_CtlError(pdev , req);
      return;
    }

  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
  {
    
    len = MIN(len , req->wLength);
    
    USBD_CtlSendData (pdev, 
                      pbuf,
                      len);
  }
  
}

/**
* @brief  USBD_SetAddress
*         Set device address
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev_address = dev_addr;
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
      USBD_CtlSendStatus(pdev);                         
      
      if (dev_addr != 0) 
      {
        pdev->dev_state  = USBD_STATE_ADDRESSED;
      } 
      else 
      {
        pdev->dev_state  = USBD_STATE_DEFAULT; 
      }
    }
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
  } 
}

/**
* @brief  USBD_SetConfig
*         Handle Set device configuration request
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
  
  static uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
        pdev->dev_state = USBD_STATE_CONFIGURED;
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
        {
          USBD_CtlError(pdev , req);  
          return;
        }
        USBD_CtlSendStatus(pdev);
      }
      else 
      {
         USBD_CtlSendStatus(pdev);
      }
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
        pdev->dev_config = cfgidx;          
        USBD_ClrClassConfig(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
        
      } 
      else  if (cfgidx != pdev->dev_config) 
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
        {
          USBD_CtlError(pdev , req);  
          return;
        }
        USBD_CtlSendStatus(pdev);
      }
      else
      {
        USBD_CtlSendStatus(pdev);
      }
      break;
      
    default:					
       USBD_CtlError(pdev , req);                     
      break;
    }
  }
}

/**
* @brief  USBD_GetConfig
*         Handle Get device configuration request
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{

  if (req->wLength != 1) 
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
      USBD_CtlSendData (pdev, 
                        (uint8_t *)&pdev->dev_default_config,
                        1);
      break;
      
    case USBD_STATE_CONFIGURED:   
      
      USBD_CtlSendData (pdev, 
                        (uint8_t *)&pdev->dev_config,
                        1);
      break;
      
    default:
       USBD_CtlError(pdev , req);
      break;
    }
  }
}

/**
* @brief  USBD_GetStatus
*         Handle Get Status request
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
  
    
  switch (pdev->dev_state) 
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) 
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
    }
    
    USBD_CtlSendData (pdev, 
                      (uint8_t *)& pdev->dev_config_status,
                      2);
    break;
    
  default :
    USBD_CtlError(pdev , req);                        
    break;
  }
}


/**
* @brief  USBD_SetFeature
*         Handle Set device feature request
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev_remote_wakeup = 1;  
    pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkSetupEvent(*req));
    USBD_CtlSendStatus(pdev);
  }

}


/**
* @brief  USBD_ClrFeature
*         Handle clear device feature request
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
static void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
  switch (pdev->dev_state)
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev_remote_wakeup = 0; 
      pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkSetupEvent(*req));
      USBD_CtlSendStatus(pdev);
    }
    break;
    
  default :
     USBD_CtlError(pdev , req);
    break;
  }
}

/**
* @brief  USBD_ParseSetupRequest 
*         Copy buffer into setup structure
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
  req->bRequest      = *(uint8_t *)  (pdata +  1);
  req->wValue        = SWAPBYTE      (pdata +  2);
  req->wIndex        = SWAPBYTE      (pdata +  4);
  req->wLength       = SWAPBYTE      (pdata +  6);

}

/**
* @brief  USBD_CtlError 
*         Handle USB low level Error
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
                    USBD_SetupReqTypedef *req __attribute__((unused)))
{
  USBD_LL_StallEP(pdev , 0x80);
  USBD_LL_StallEP(pdev , 0);
}


/**
  * @brief  USBD_GetString
  *         Convert Ascii string into unicode one
  * @param  desc : descriptor buffer
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
  uint8_t idx = 0;
  
  if (desc != NULL) 
  {
    *len =  USBD_GetLen(desc) * 2 + 2;    
    unicode[idx++] = *len;
    unicode[idx++] =  USB_DESC_TYPE_STRING;
    
    while (*desc != '\0') 
    {
      unicode[idx++] = *desc++;
      unicode[idx++] =  0x00;
    }
  } 
}

/**
  * @brief  USBD_GetLen
  *         return the string length
   * @param  buf : pointer to the ascii string buffer
  * @retval string length
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
    {
        len++;
        buf++;
    }

    return len;
}
/**
  * @}
  */ 


/**
  * @}
  */ 


/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/usblib/device/core/src/usbd_ctlreq.cpp
// START FILE: ../lib/usblib/device/core/src/usbd_ioreq.cpp
/**
  ******************************************************************************
  * @file    usbd_ioreq.c
  * @author  MCD Application Team
  * @version V2.2.0
  * @date    13-June-2014
  * @brief   This file provides the IO requests APIs for control endpoints.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Includes ------------------------------------------------------------------*/
#include "config/stm32plus.h"
#include "config/event.h"
#include "usb/f4/UsbEventDescriptor.h"
#include "usb/f4/UsbErrorEvent.h"
#include "usb/f4/UsbEventSource.h"
#include "usblib/device/core/inc/usbd_ioreq.h"

/** @addtogroup STM32_USB_DEVICE_LIBRARY
  * @{
  */


/** @defgroup USBD_IOREQ 
  * @brief control I/O requests module
  * @{
  */ 

/** @defgroup USBD_IOREQ_Private_TypesDefinitions
  * @{
  */ 
/**
  * @}
  */ 


/** @defgroup USBD_IOREQ_Private_Defines
  * @{
  */ 

/**
  * @}
  */ 


/** @defgroup USBD_IOREQ_Private_Macros
  * @{
  */ 
/**
  * @}
  */ 


/** @defgroup USBD_IOREQ_Private_Variables
  * @{
  */ 

/**
  * @}
  */ 


/** @defgroup USBD_IOREQ_Private_FunctionPrototypes
  * @{
  */ 
/**
  * @}
  */ 


/** @defgroup USBD_IOREQ_Private_Functions
  * @{
  */ 

/**
* @brief  USBD_CtlSendData
*         send data on the ctl pipe
* @param  pdev: device instance
* @param  buff: pointer to data buffer
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
  pdev->ep_in[0].total_length = len;
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
  
  return USBD_OK;
}

/**
* @brief  USBD_CtlContinueSendData
*         continue sending data on the ctl pipe
* @param  pdev: device instance
* @param  buff: pointer to data buffer
* @param  len: length of data to be sent
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
  
  return USBD_OK;
}

/**
* @brief  USBD_CtlPrepareRx
*         receive data on the ctl pipe
* @param  pdev: device instance
* @param  buff: pointer to data buffer
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
  pdev->ep_out[0].total_length = len;
  pdev->ep_out[0].rem_length   = len;
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
                          0,
                          pbuf,
                         len);
  
  return USBD_OK;
}

/**
* @brief  USBD_CtlContinueRx
*         continue receive data on the ctl pipe
* @param  pdev: device instance
* @param  buff: pointer to data buffer
* @param  len: length of data to be received
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{

  USBD_LL_PrepareReceive (pdev,
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
/**
* @brief  USBD_CtlSendStatus
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
  
  return USBD_OK;
}

/**
* @brief  USBD_CtlReceiveStatus
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}


/**
* @brief  USBD_GetRxCount
*         returns the received data length
* @param  pdev: device instance
* @param  ep_addr: endpoint address
* @retval Rx Data blength
*/
uint16_t  USBD_GetRxCount (USBD_HandleTypeDef  *pdev , uint8_t ep_addr)
{
  return USBD_LL_GetRxDataSize(pdev, ep_addr);
}

/**
  * @}
  */ 


/**
  * @}
  */ 


/**
  * @}
  */ 

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/usblib/device/core/src/usbd_ioreq.cpp
// START FILE: ../lib/usblib/device/core/src/usbd_core.cpp
/**
  ******************************************************************************
  * @file    usbd_core.c
  * @author  MCD Application Team
  * @version V2.2.0
  * @date    13-June-2014
  * @brief   This file provides all the USBD core functions.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software 
  * distributed under the License is distributed on an "AS IS" BASIS, 
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */ 

/* Includes ------------------------------------------------------------------*/
#include "config/stm32plus.h"
#include "config/event.h"
#include "usb/f4/UsbEventDescriptor.h"
#include "usb/f4/UsbErrorEvent.h"
#include "usb/f4/UsbEventSource.h"
#include "usblib/device/core/inc/usbd_core.h"
#include "usb/f4/device/events/class/DeviceClassSdkInitEvent.h"
#include "usb/f4/device/events/class/DeviceClassSdkDeInitEvent.h"
#include "usb/f4/device/events/class/DeviceClassSdkEp0ReadyEvent.h"
#include "usb/f4/device/events/class/DeviceClassSdkEp0TxSentEvent.h"
#include "usb/f4/device/events/class/DeviceClassSdkDataInEvent.h"
#include "usb/f4/device/events/class/DeviceClassSdkDataOutEvent.h"
#include "usb/f4/device/events/class/DeviceClassSdkSofEvent.h"


/**
* @brief  USBD_Init
*         Initailizes the device stack and load the class driver
* @param  pdev: device instance
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pEventSource)
    pdev->pEventSource = NULL;
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
  {
    pdev->pDesc = pdesc;
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  pdev->id = id;
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
  
  return USBD_OK; 
}

/**
* @brief  USBD_DeInit 
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  
  /* Free Class Resources */
  pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkDeInitEvent(pdev->dev_config));
  
    /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
  
  /* Initialize low level driver */
  USBD_LL_DeInit(pdev);
  
  return USBD_OK;
}


/**
  * @brief  USBD_RegisterClass 
  *         Link class driver to Device Core.
  * @param  pDevice : Device Handle
  * @param  pEventSource: Pointer to event source
  * @retval USBD Status
  */

USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, stm32plus::usb::UsbEventSource *eventSource)
{
  pdev->pEventSource=eventSource;
  return USBD_OK;
}


/**
  * @brief  USBD_Start 
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
  
  return USBD_OK;  
}

/**
  * @brief  USBD_Stop 
  *         Stop the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Stop   (USBD_HandleTypeDef *pdev)
{
  /* Free Class Resources */
  pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkDeInitEvent(pdev->dev_config));

  /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
  
  return USBD_OK;  
}

/**
* @brief  USBD_RunTestMode 
*         Launch test mode process
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_RunTestMode (USBD_HandleTypeDef  *pdev __attribute__((unused)))
{
  return USBD_OK;
}


/**
* @brief  USBD_SetClassConfig 
*        Configure device and start the interface
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  if(pdev->pEventSource)
  {
    // send init event

    stm32plus::usb::DeviceClassSdkInitEvent event(cfgidx);
    pdev->pEventSource->UsbEventSender.raiseEvent(event);

    return event.status;
  }
  else
    return USBD_FAIL;
}

/**
* @brief  USBD_ClrClassConfig 
*         Clear current configuration
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  /* Clear configuration  and Deinitialize the Class process*/
  pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkDeInitEvent(cfgidx));
  return USBD_OK;
}


/**
* @brief  USBD_SetupStage 
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{

  USBD_ParseSetupRequest(&pdev->request, psetup);
  
  pdev->ep0_state = USBD_EP0_SETUP;
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
    break;
  }  
  return USBD_OK;  
}

/**
* @brief  USBD_DataOutStage 
*         Handle data OUT stage
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
       
        USBD_CtlContinueRx (pdev, 
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
      }
      else
      {
        if(pdev->dev_state == USBD_STATE_CONFIGURED)
          pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkEp0ReadyEvent());

        USBD_CtlSendStatus(pdev);
      }
    }
  }
  else if(pdev->dev_state == USBD_STATE_CONFIGURED)
    pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkDataOutEvent(epnum));

  return USBD_OK;
}

/**
* @brief  USBD_DataInStage 
*         Handle data in stage
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
    {
      if(pep->rem_length > pep->maxpacket)
      {
        pep->rem_length -=  pep->maxpacket;
        
        USBD_CtlContinueSendData (pdev, 
                                  pdata, 
                                  pep->rem_length);
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((pep->total_length % pep->maxpacket == 0) &&
           (pep->total_length >= pep->maxpacket) &&
             (pep->total_length < pdev->ep0_data_len ))
        {
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
          pdev->ep0_data_len = 0;
        }
        else
        {
          if(pdev->dev_state == USBD_STATE_CONFIGURED)
            pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkEp0TxSentEvent());

          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
    if (pdev->dev_test_mode == 1)
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
    }
  }
  else if(pdev->dev_state == USBD_STATE_CONFIGURED)
    pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkDataInEvent(epnum));

  return USBD_OK;
}

/**
* @brief  USBD_LL_Reset 
*         Handle Reset event
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
              0x80,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call usr call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
  
  if (pdev->pEventSource)
    pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkDeInitEvent(pdev->dev_config));
 
  
  return USBD_OK;
}




/**
* @brief  USBD_LL_Reset 
*         Handle Reset event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
  return USBD_OK;
}

/**
* @brief  USBD_Suspend 
*         Handle Suspend event
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
  pdev->dev_state  = USBD_STATE_SUSPENDED;
  return USBD_OK;
}

/**
* @brief  USBD_Resume 
*         Handle Resume event
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
  return USBD_OK;
}

/**
* @brief  USBD_SOF 
*         Handle SOF event
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
  if(pdev->dev_state == USBD_STATE_CONFIGURED && pdev->pEventSource)
    pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkSofEvent());

  return USBD_OK;
}

/**
* @brief  USBD_IsoINIncomplete 
*         Handle iso in incomplete event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoINIncomplete(USBD_HandleTypeDef  *pdev __attribute__((unused)),
                                           uint8_t epnum __attribute__((unused)))
{
  return USBD_OK;
}

/**
* @brief  USBD_IsoOUTIncomplete 
*         Handle iso out incomplete event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_IsoOUTIncomplete(USBD_HandleTypeDef  *pdev __attribute__((unused)),
                                            uint8_t epnum __attribute__((unused)))
{
  return USBD_OK;
}

/**
* @brief  USBD_DevConnected 
*         Handle device connection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevConnected(USBD_HandleTypeDef  *pdev __attribute__((unused)))
{
  return USBD_OK;
}

/**
* @brief  USBD_DevDisconnected 
*         Handle device disconnection event
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DevDisconnected(USBD_HandleTypeDef  *pdev)
{
  /* Free Class Resources */
  pdev->dev_state = USBD_STATE_DEFAULT;
  pdev->pEventSource->UsbEventSender.raiseEvent(stm32plus::usb::DeviceClassSdkDeInitEvent(pdev->dev_config));
   
  return USBD_OK;
}
// END FILE: ../lib/usblib/device/core/src/usbd_core.cpp
// START FILE: ../lib/usblib/hal/inc/stm32f4xx_hal_pcd.h
/**
  ******************************************************************************
  * @file    stm32f4xx_hal_pcd.h
  * @author  MCD Application Team
  * @version V1.1.0
  * @date    19-June-2014
  * @brief   Header file of PCD HAL module.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_HAL_PCD_H
#define __STM32F4xx_HAL_PCD_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "usblib/hal/inc/stm32f4xx_ll_usb.h"
   
/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */

/** @addtogroup PCD
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/ 

   /** 
  * @brief  PCD State structures definition  
  */  
typedef enum 
{
  HAL_PCD_STATE_RESET   = 0x00,
  HAL_PCD_STATE_READY   = 0x01,
  HAL_PCD_STATE_ERROR   = 0x02,
  HAL_PCD_STATE_BUSY    = 0x03,
  HAL_PCD_STATE_TIMEOUT = 0x04
} PCD_StateTypeDef;


typedef USB_OTG_GlobalTypeDef  PCD_TypeDef;
typedef USB_OTG_CfgTypeDef     PCD_InitTypeDef;
typedef USB_OTG_EPTypeDef      PCD_EPTypeDef ;                          

/** 
  * @brief  PCD Handle Structure definition  
  */ 
typedef struct
{
  PCD_TypeDef             *Instance;   /*!< Register base address              */ 
  PCD_InitTypeDef         Init;       /*!< PCD required parameters            */
  PCD_EPTypeDef           IN_ep[15];  /*!< IN endpoint parameters             */
  PCD_EPTypeDef           OUT_ep[15]; /*!< OUT endpoint parameters            */ 
  HAL_LockTypeDef         Lock;       /*!< PCD peripheral status              */
  __IO PCD_StateTypeDef   State;      /*!< PCD communication state            */
  uint32_t                Setup[12];  /*!< Setup packet buffer                */
  void                    *pData;      /*!< Pointer to upper stack Handler     */    
  
} PCD_HandleTypeDef;
  
/* Exported constants --------------------------------------------------------*/
/** @defgroup PCD_Exported_Constants
  * @{
  */

/** @defgroup PCD_Speed
  * @{
  */
#define PCD_SPEED_HIGH               0
#define PCD_SPEED_HIGH_IN_FULL       1
#define PCD_SPEED_FULL               2
/**
  * @}
  */
  
  /** @defgroup PCD_PHY_Module
  * @{
  */
#define PCD_PHY_ULPI                 1
#define PCD_PHY_EMBEDDED             2
/**
  * @}
  */
  
/** @defgroup PCD_Instance_definition 
  * @{
  */ 
#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx) || defined(STM32F417xx) || defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx) || defined(STM32F439xx)
 #define IS_PCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS) || \
                                        ((INSTANCE) == USB_OTG_HS))
#elif defined(STM32F401xC) || defined(STM32F401xE) || defined(STM32F411xE)
 #define IS_PCD_ALL_INSTANCE(INSTANCE) (((INSTANCE) == USB_OTG_FS))
#endif

/**
  * @}
  */

/**
  * @}
  */ 
  
/* Exported macro ------------------------------------------------------------*/

/** @defgroup PCD_Interrupt_Clock
 *  @brief macros to handle interrupts and specific clock configurations
 * @{
 */
#define __HAL_PCD_ENABLE(__HANDLE__)                   USB_EnableGlobalInt ((__HANDLE__)->Instance)
#define __HAL_PCD_DISABLE(__HANDLE__)                  USB_DisableGlobalInt ((__HANDLE__)->Instance)
   
#define __HAL_PCD_GET_FLAG(__HANDLE__, __INTERRUPT__)      ((USB_ReadInterrupts((__HANDLE__)->Instance) & (__INTERRUPT__)) == (__INTERRUPT__))
#define __HAL_PCD_CLEAR_FLAG(__HANDLE__, __INTERRUPT__)    (((__HANDLE__)->Instance->GINTSTS) = (__INTERRUPT__))
#define __HAL_PCD_IS_INVALID_INTERRUPT(__HANDLE__)         (USB_ReadInterrupts((__HANDLE__)->Instance) == 0)


#define __HAL_PCD_UNGATE_PHYCLOCK(__HANDLE__)             *(__IO uint32_t *)((uint32_t)((__HANDLE__)->Instance) + USB_OTG_PCGCCTL_BASE) &= \
                                                       ~(USB_OTG_PCGCCTL_STOPCLK)


#define __HAL_PCD_GATE_PHYCLOCK(__HANDLE__)               *(__IO uint32_t *)((uint32_t)((__HANDLE__)->Instance) + USB_OTG_PCGCCTL_BASE) |= USB_OTG_PCGCCTL_STOPCLK
                                                      
#define __HAL_PCD_IS_PHY_SUSPENDED(__HANDLE__)            ((*(__IO uint32_t *)((uint32_t)((__HANDLE__)->Instance) + USB_OTG_PCGCCTL_BASE))&0x10)
                                                         
#define USB_FS_EXTI_TRIGGER_RISING_EDGE      ((uint32_t)0x08) 
#define USB_FS_EXTI_TRIGGER_FALLING_EDGE     ((uint32_t)0x0C) 
#define USB_FS_EXTI_TRIGGER_BOTH_EDGE        ((uint32_t)0x10) 

#define USB_HS_EXTI_TRIGGER_RISING_EDGE      ((uint32_t)0x08) 
#define USB_HS_EXTI_TRIGGER_FALLING_EDGE     ((uint32_t)0x0C) 
#define USB_HS_EXTI_TRIGGER_BOTH_EDGE        ((uint32_t)0x10) 


#define USB_HS_EXTI_LINE_WAKEUP              ((uint32_t)0x00100000)  /*!< External interrupt line 20 Connected to the USB HS EXTI Line */
#define USB_FS_EXTI_LINE_WAKEUP              ((uint32_t)0x00040000)  /*!< External interrupt line 18 Connected to the USB FS EXTI Line */



#define __HAL_USB_HS_EXTI_ENABLE_IT()    EXTI->IMR |= (USB_HS_EXTI_LINE_WAKEUP)
#define __HAL_USB_HS_EXTI_DISABLE_IT()   EXTI->IMR &= ~(USB_HS_EXTI_LINE_WAKEUP)
#define __HAL_USB_HS_EXTI_GET_FLAG()     EXTI->PR & (USB_HS_EXTI_LINE_WAKEUP)
#define __HAL_USB_HS_EXTI_CLEAR_FLAG()   EXTI->PR = (USB_HS_EXTI_LINE_WAKEUP)

#define __HAL_USB_HS_EXTI_SET_RISING_EGDE_TRIGGER() EXTI->FTSR &= ~(USB_HS_EXTI_LINE_WAKEUP);\
                                                    EXTI->RTSR |= USB_HS_EXTI_LINE_WAKEUP

                                                      
#define __HAL_USB_HS_EXTI_SET_FALLING_EGDE_TRIGGER()  EXTI->FTSR |= (USB_HS_EXTI_LINE_WAKEUP);\
                                                      EXTI->RTSR &= ~(USB_HS_EXTI_LINE_WAKEUP)


#define __HAL_USB_HS_EXTI_SET_FALLINGRISING_TRIGGER()   EXTI->RTSR &= ~(USB_HS_EXTI_LINE_WAKEUP);\
                                                        EXTI->FTSR &= ~(USB_HS_EXTI_LINE_WAKEUP;)\
                                                        EXTI->RTSR |= USB_HS_EXTI_LINE_WAKEUP;\
                                                        EXTI->FTSR |= USB_HS_EXTI_LINE_WAKEUP

#define __HAL_USB_HS_EXTI_GENERATE_SWIT()             (EXTI->SWIER |= USB_FS_EXTI_LINE_WAKEUP) 
                                                          
                                                          
#define __HAL_USB_FS_EXTI_ENABLE_IT()    EXTI->IMR |= USB_FS_EXTI_LINE_WAKEUP
#define __HAL_USB_FS_EXTI_DISABLE_IT()   EXTI->IMR &= ~(USB_FS_EXTI_LINE_WAKEUP)
#define __HAL_USB_FS_EXTI_GET_FLAG()     EXTI->PR & (USB_FS_EXTI_LINE_WAKEUP)
#define __HAL_USB_FS_EXTI_CLEAR_FLAG()   EXTI->PR = USB_FS_EXTI_LINE_WAKEUP

#define __HAL_USB_FS_EXTI_SET_RISING_EGDE_TRIGGER() EXTI->FTSR &= ~(USB_FS_EXTI_LINE_WAKEUP);\
                                                    EXTI->RTSR |= USB_FS_EXTI_LINE_WAKEUP

                                                      
#define __HAL_USB_FS_EXTI_SET_FALLING_EGDE_TRIGGER()  EXTI->FTSR |= (USB_FS_EXTI_LINE_WAKEUP);\
                                                      EXTI->RTSR &= ~(USB_FS_EXTI_LINE_WAKEUP)


#define __HAL_USB_FS_EXTI_SET_FALLINGRISING_TRIGGER()  EXTI->RTSR &= ~(USB_FS_EXTI_LINE_WAKEUP);\
                                                       EXTI->FTSR &= ~(USB_FS_EXTI_LINE_WAKEUP);\
                                                       EXTI->RTSR |= USB_FS_EXTI_LINE_WAKEUP;\
                                                       EXTI->FTSR |= USB_FS_EXTI_LINE_WAKEUP 
                                                         
#define __HAL_USB_FS_EXTI_GENERATE_SWIT()             (EXTI->SWIER |= USB_FS_EXTI_LINE_WAKEUP)                                                          

/**
  * @}
  */

/* Include PCD HAL Extension module */
#include "stm32f4xx_hal_pcd_ex.h"

/* Exported functions --------------------------------------------------------*/

/* Initialization/de-initialization functions  **********************************/
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd);
HAL_StatusTypeDef HAL_PCD_DeInit (PCD_HandleTypeDef *hpcd);
void HAL_PCD_MspInit(PCD_HandleTypeDef *hpcd);
void HAL_PCD_MspDeInit(PCD_HandleTypeDef *hpcd);

/* I/O operation functions  *****************************************************/
 /* Non-Blocking mode: Interrupt */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd);
HAL_StatusTypeDef HAL_PCD_Stop(PCD_HandleTypeDef *hpcd);
void HAL_PCD_IRQHandler(PCD_HandleTypeDef *hpcd);

void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum);
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum);
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd);
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd);
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd);
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd);
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd);
void HAL_PCD_ISOOUTIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum);
void HAL_PCD_ISOINIncompleteCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum);
void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd);
void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd);

/* Peripheral Control functions  ************************************************/
HAL_StatusTypeDef HAL_PCD_DevConnect(PCD_HandleTypeDef *hpcd);
HAL_StatusTypeDef HAL_PCD_DevDisconnect(PCD_HandleTypeDef *hpcd);
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address);
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type);
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr);
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len);
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len);
uint16_t          HAL_PCD_EP_GetRxCount(PCD_HandleTypeDef *hpcd, uint8_t ep_addr);
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr);
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr);
HAL_StatusTypeDef HAL_PCD_EP_Flush(PCD_HandleTypeDef *hpcd, uint8_t ep_addr);
HAL_StatusTypeDef HAL_PCD_ActiveRemoteWakeup(PCD_HandleTypeDef *hpcd);
HAL_StatusTypeDef HAL_PCD_DeActiveRemoteWakeup(PCD_HandleTypeDef *hpcd);

/* Create an alias to keep compatibility with the old name */ 
#define HAL_PCD_SetTxFiFo    HAL_PCDEx_SetTxFiFo
#define HAL_PCD_SetRxFiFo    HAL_PCDEx_SetRxFiFo

/* Peripheral State functions  **************************************************/
PCD_StateTypeDef HAL_PCD_GetState(PCD_HandleTypeDef *hpcd);

/**
  * @}
  */ 

/**
  * @}
  */ 

#ifdef __cplusplus
}
#endif


#endif /* __STM32F4xx_HAL_PCD_H */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/usblib/hal/inc/stm32f4xx_hal_pcd.h
// START FILE: ../lib/usblib/hal/inc/stm32f4xx_hal.h
/**
  ******************************************************************************
  * @file    stm32f4xx_hal.h
  * @author  MCD Application Team
  * @version V1.1.0
  * @date    19-June-2014
  * @brief   This file contains all the functions prototypes for the HAL 
  *          module driver.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_HAL_H
#define __STM32F4xx_HAL_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "usblib/hal/inc/stm32f4xx_hal_def.h"
#include "usblib/hal/inc/stm32f4xx_hal_conf.h"

/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */

/** @addtogroup HAL
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/
/* Exported constants --------------------------------------------------------*/
/* Exported macro ------------------------------------------------------------*/

/** @brief  Freeze/Unfreeze Peripherals in Debug mode 
  */
#define __HAL_FREEZE_TIM2_DBGMCU()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM2_STOP))
#define __HAL_FREEZE_TIM3_DBGMCU()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM3_STOP))
#define __HAL_FREEZE_TIM4_DBGMCU()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM4_STOP))
#define __HAL_FREEZE_TIM5_DBGMCU()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM5_STOP))
#define __HAL_FREEZE_TIM6_DBGMCU()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM6_STOP))
#define __HAL_FREEZE_TIM7_DBGMCU()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM7_STOP))
#define __HAL_FREEZE_TIM12_DBGMCU()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM12_STOP))
#define __HAL_FREEZE_TIM13_DBGMCU()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM13_STOP))
#define __HAL_FREEZE_TIM14_DBGMCU()          (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_TIM14_STOP))
#define __HAL_FREEZE_RTC_DBGMCU()            (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_RTC_STOP))
#define __HAL_FREEZE_WWDG_DBGMCU()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_WWDG_STOP))
#define __HAL_FREEZE_IWDG_DBGMCU()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_IWDG_STOP))
#define __HAL_FREEZE_I2C1_TIMEOUT_DBGMCU()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
#define __HAL_FREEZE_I2C2_TIMEOUT_DBGMCU()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))
#define __HAL_FREEZE_I2C3_TIMEOUT_DBGMCU()   (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))
#define __HAL_FREEZE_CAN1_DBGMCU()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN1_STOP))
#define __HAL_FREEZE_CAN2_DBGMCU()           (DBGMCU->APB1FZ |= (DBGMCU_APB1_FZ_DBG_CAN2_STOP))
#define __HAL_FREEZE_TIM1_DBGMCU()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM1_STOP))
#define __HAL_FREEZE_TIM8_DBGMCU()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM8_STOP))
#define __HAL_FREEZE_TIM9_DBGMCU()           (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM9_STOP))
#define __HAL_FREEZE_TIM10_DBGMCU()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM10_STOP))
#define __HAL_FREEZE_TIM11_DBGMCU()          (DBGMCU->APB2FZ |= (DBGMCU_APB2_FZ_DBG_TIM11_STOP))

#define __HAL_UNFREEZE_TIM2_DBGMCU()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM2_STOP))
#define __HAL_UNFREEZE_TIM3_DBGMCU()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM3_STOP))
#define __HAL_UNFREEZE_TIM4_DBGMCU()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM4_STOP))
#define __HAL_UNFREEZE_TIM5_DBGMCU()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM5_STOP))
#define __HAL_UNFREEZE_TIM6_DBGMCU()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM6_STOP))
#define __HAL_UNFREEZE_TIM7_DBGMCU()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM7_STOP))
#define __HAL_UNFREEZE_TIM12_DBGMCU()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM12_STOP))
#define __HAL_UNFREEZE_TIM13_DBGMCU()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM13_STOP))
#define __HAL_UNFREEZE_TIM14_DBGMCU()          (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_TIM14_STOP))
#define __HAL_UNFREEZE_RTC_DBGMCU()            (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_RTC_STOP))
#define __HAL_UNFREEZE_WWDG_DBGMCU()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_WWDG_STOP))
#define __HAL_UNFREEZE_IWDG_DBGMCU()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_IWDG_STOP))
#define __HAL_UNFREEZE_I2C1_TIMEOUT_DBGMCU()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT))
#define __HAL_UNFREEZE_I2C2_TIMEOUT_DBGMCU()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT))
#define __HAL_UNFREEZE_I2C3_TIMEOUT_DBGMCU()   (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT))
#define __HAL_UNFREEZE_CAN1_DBGMCU()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN1_STOP))
#define __HAL_UNFREEZE_CAN2_DBGMCU()           (DBGMCU->APB1FZ &= ~(DBGMCU_APB1_FZ_DBG_CAN2_STOP))
#define __HAL_UNFREEZE_TIM1_DBGMCU()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM1_STOP))
#define __HAL_UNFREEZE_TIM8_DBGMCU()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM8_STOP))
#define __HAL_UNFREEZE_TIM9_DBGMCU()           (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM9_STOP))
#define __HAL_UNFREEZE_TIM10_DBGMCU()          (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM10_STOP))
#define __HAL_UNFREEZE_TIM11_DBGMCU()          (DBGMCU->APB2FZ &= ~(DBGMCU_APB2_FZ_DBG_TIM11_STOP))

/** @brief  Main Flash memory mapped at 0x00000000
  */
#define __HAL_REMAPMEMORY_FLASH()             (SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE))

/** @brief  System Flash memory mapped at 0x00000000
  */
#define __HAL_REMAPMEMORY_SYSTEMFLASH()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
                                                  SYSCFG->MEMRMP |= SYSCFG_MEMRMP_MEM_MODE_0;\
                                                 }while(0);

/** @brief  Embedded SRAM mapped at 0x00000000
  */
#define __HAL_REMAPMEMORY_SRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
                                           SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_0 | SYSCFG_MEMRMP_MEM_MODE_1);\
                                          }while(0);

#if defined(STM32F405xx) || defined(STM32F415xx) || defined(STM32F407xx)|| defined(STM32F417xx)
/** @brief  FSMC Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
  */
#define __HAL_REMAPMEMORY_FSMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
                                           SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);\
                                          }while(0);
#endif /* STM32F405xx || STM32F415xx || STM32F407xx || STM32F417xx */

#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx) 
/** @brief  FMC Bank1 (NOR/PSRAM 1 and 2) mapped at 0x00000000
  */
#define __HAL_REMAPMEMORY_FMC()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
                                          SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_1);\
                                         }while(0);

/** @brief  FMC/SDRAM Bank 1 and 2 mapped at 0x00000000
  */
#define __HAL_REMAPMEMORY_FMC_SDRAM()       do {SYSCFG->MEMRMP &= ~(SYSCFG_MEMRMP_MEM_MODE);\
                                                SYSCFG->MEMRMP |= (SYSCFG_MEMRMP_MEM_MODE_2);\
                                               }while(0);
#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */ 

/* Exported functions --------------------------------------------------------*/

/* Initialization and de-initialization functions  ******************************/
HAL_StatusTypeDef HAL_Init(void);
HAL_StatusTypeDef HAL_DeInit(void);
void HAL_MspInit(void);
void HAL_MspDeInit(void);
HAL_StatusTypeDef HAL_InitTick (uint32_t TickPriority);

/* Peripheral Control functions  ************************************************/
void HAL_IncTick(void);
void HAL_Delay(__IO uint32_t Delay);
uint32_t HAL_GetTick(void);
void HAL_SuspendTick(void);
void HAL_ResumeTick(void);
uint32_t HAL_GetHalVersion(void);
uint32_t HAL_GetREVID(void);
uint32_t HAL_GetDEVID(void);
void HAL_EnableDBGSleepMode(void);
void HAL_DisableDBGSleepMode(void);
void HAL_EnableDBGStopMode(void);
void HAL_DisableDBGStopMode(void);
void HAL_EnableDBGStandbyMode(void);
void HAL_DisableDBGStandbyMode(void);
void HAL_EnableCompensationCell(void);
void HAL_DisableCompensationCell(void);
#if defined(STM32F427xx) || defined(STM32F437xx) || defined(STM32F429xx)|| defined(STM32F439xx)
void HAL_EnableMemorySwappingBank(void);
void HAL_DisableMemorySwappingBank(void);
#endif /* STM32F427xx || STM32F437xx || STM32F429xx || STM32F439xx */ 


/**
  * @}
  */ 

/**
  * @}
  */ 
  
#ifdef __cplusplus
}
#endif

#endif /* __STM32F4xx_HAL_H */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/usblib/hal/inc/stm32f4xx_hal.h
// START FILE: ../lib/usblib/hal/inc/stm32f4xx_hal_conf.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#define HAL_PCD_MODULE_ENABLED
// END FILE: ../lib/usblib/hal/inc/stm32f4xx_hal_conf.h
// START FILE: ../lib/usblib/hal/inc/stm32f4xx_hal_def.h
/**
  ******************************************************************************
  * @file    stm32f4xx_hal_def.h
  * @author  MCD Application Team
  * @version V1.1.0
  * @date    19-June-2014
  * @brief   This file contains HAL common defines, enumeration, macros and 
  *          structures definitions. 
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_HAL_DEF
#define __STM32F4xx_HAL_DEF

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "fwlib/f4/cmsis/Device/ST/STM32F4xx/Include/stm32f4xx.h"

/* Exported types ------------------------------------------------------------*/

/** 
  * @brief  HAL Status structures definition  
  */  
typedef enum 
{
  HAL_OK       = 0x00,
  HAL_ERROR    = 0x01,
  HAL_BUSY     = 0x02,
  HAL_TIMEOUT  = 0x03
} HAL_StatusTypeDef;

/** 
  * @brief  HAL Lock structures definition  
  */
typedef enum 
{
  HAL_UNLOCKED = 0x00,
  HAL_LOCKED   = 0x01  
} HAL_LockTypeDef;

/* Exported macro ------------------------------------------------------------*/
#ifndef NULL
  #define NULL      (void *) 0
#endif

#define HAL_MAX_DELAY      0xFFFFFFFF

#define HAL_IS_BIT_SET(REG, BIT)         (((REG) & (BIT)) != RESET)
#define HAL_IS_BIT_CLR(REG, BIT)         (((REG) & (BIT)) == RESET)

#define __HAL_LINKDMA(__HANDLE__, __PPP_DMA_FIELD__, __DMA_HANDLE__)               \
                        do{                                                      \
                              (__HANDLE__)->__PPP_DMA_FIELD__ = &(__DMA_HANDLE__); \
                              (__DMA_HANDLE__).Parent = (__HANDLE__);             \
                          } while(0)

/** @brief Reset the Handle's State field.
  * @param __HANDLE__: specifies the Peripheral Handle.
  * @note  This macro can be used for the following purpose: 
  *          - When the Handle is declared as local variable; before passing it as parameter
  *            to HAL_PPP_Init() for the first time, it is mandatory to use this macro 
  *            to set to 0 the Handle's "State" field.
  *            Otherwise, "State" field may have any random value and the first time the function 
  *            HAL_PPP_Init() is called, the low level hardware initialization will be missed
  *            (i.e. HAL_PPP_MspInit() will not be executed).
  *          - When there is a need to reconfigure the low level hardware: instead of calling
  *            HAL_PPP_DeInit() then HAL_PPP_Init(), user can make a call to this macro then HAL_PPP_Init().
  *            In this later function, when the Handle's "State" field is set to 0, it will execute the function
  *            HAL_PPP_MspInit() which will reconfigure the low level hardware.
  * @retval None
  */
#define __HAL_RESET_HANDLE_STATE(__HANDLE__) ((__HANDLE__)->State = 0)

#if (USE_RTOS == 1)
  /* Reserved for future use */
  #error USE_RTOS should be 0 in the current HAL release
#else
  #define __HAL_LOCK(__HANDLE__)                                           \
                                do{                                        \
                                    if((__HANDLE__)->Lock == HAL_LOCKED)   \
                                    {                                      \
                                       return HAL_BUSY;                    \
                                    }                                      \
                                    else                                   \
                                    {                                      \
                                       (__HANDLE__)->Lock = HAL_LOCKED;    \
                                    }                                      \
                                  }while (0)

  #define __HAL_UNLOCK(__HANDLE__)                                          \
                                  do{                                       \
                                      (__HANDLE__)->Lock = HAL_UNLOCKED;    \
                                    }while (0)
#endif /* USE_RTOS */

#if  defined ( __GNUC__ )
  #ifndef __weak
    #define __weak   __attribute__((weak))
  #endif /* __weak */
  #ifndef __packed
    #define __packed __attribute__((__packed__))
  #endif /* __packed */
#endif /* __GNUC__ */


/* Macro to get variable aligned on 4-bytes, for __ICCARM__ the directive "#pragma data_alignment=4" must be used instead */
#if defined   (__GNUC__)        /* GNU Compiler */
  #ifndef __ALIGN_END
    #define __ALIGN_END    __attribute__ ((aligned (4)))
  #endif /* __ALIGN_END */
  #ifndef __ALIGN_BEGIN  
    #define __ALIGN_BEGIN
  #endif /* __ALIGN_BEGIN */
#else
  #ifndef __ALIGN_END
    #define __ALIGN_END
  #endif /* __ALIGN_END */
  #ifndef __ALIGN_BEGIN      
    #if defined   (__CC_ARM)      /* ARM Compiler */
      #define __ALIGN_BEGIN    __align(4)  
    #elif defined (__ICCARM__)    /* IAR Compiler */
      #define __ALIGN_BEGIN 
    #endif /* __CC_ARM */
  #endif /* __ALIGN_BEGIN */
#endif /* __GNUC__ */


/** 
  * @brief  __RAM_FUNC definition
  */ 
#if defined ( __CC_ARM   )
/* ARM Compiler
   ------------
   RAM functions are defined using the toolchain options. 
   Functions that are executed in RAM should reside in a separate source module.
   Using the 'Options for File' dialog you can simply change the 'Code / Const' 
   area of a module to a memory space in physical RAM.
   Available memory areas are declared in the 'Target' tab of the 'Options for Target'
   dialog. 
*/
#define __RAM_FUNC HAL_StatusTypeDef 

#elif defined ( __ICCARM__ )
/* ICCARM Compiler
   ---------------
   RAM functions are defined using a specific toolchain keyword "__ramfunc". 
*/
#define __RAM_FUNC __ramfunc HAL_StatusTypeDef

#elif defined   (  __GNUC__  )
/* GNU Compiler
   ------------
  RAM functions are defined using a specific toolchain attribute 
   "__attribute__((section(".RamFunc")))".
*/
#define __RAM_FUNC HAL_StatusTypeDef  __attribute__((section(".RamFunc")))

#endif


#ifdef __cplusplus
}
#endif

#endif /* ___STM32F4xx_HAL_DEF */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/usblib/hal/inc/stm32f4xx_hal_def.h
// START FILE: ../lib/usblib/hal/inc/stm32f4xx_hal_pcd_ex.h
/**
  ******************************************************************************
  * @file    stm32f4xx_hal_pcd_ex.h
  * @author  MCD Application Team
  * @version V1.1.0
  * @date    19-June-2014
  * @brief   Header file of PCD HAL module.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_HAL_PCD_EX_H
#define __STM32F4xx_HAL_PCD_EX_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "usblib/hal/inc/stm32f4xx_hal_def.h"
   
/** @addtogroup STM32F4xx_HAL_Driver
  * @{
  */

/** @addtogroup PCDEx
  * @{
  */

/* Exported functions --------------------------------------------------------*/

/* Peripheral Extended functions  *********************************************/
HAL_StatusTypeDef HAL_PCDEx_SetTxFiFo(PCD_HandleTypeDef *hpcd, uint8_t fifo, uint16_t size);
HAL_StatusTypeDef HAL_PCDEx_SetRxFiFo(PCD_HandleTypeDef *hpcd, uint16_t size);

/**
  * @}
  */ 

/**
  * @}
  */ 

#ifdef __cplusplus
}
#endif


#endif /* __STM32F4xx_HAL_PCD_EX_H */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/usblib/hal/inc/stm32f4xx_hal_pcd_ex.h
// START FILE: ../lib/usblib/hal/inc/stm32f4xx_ll_usb.h
/**
  ******************************************************************************
  * @file    stm32f4xx_ll_usb.h
  * @author  MCD Application Team
  * @version V1.1.0
  * @date    19-June-2014
  * @brief   Header file of USB Core HAL module.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT(c) 2014 STMicroelectronics</center></h2>
  *
  * Redistribution and use in source and binary forms, with or without modification,
  * are permitted provided that the following conditions are met:
  *   1. Redistributions of source code must retain the above copyright notice,
  *      this list of conditions and the following disclaimer.
  *   2. Redistributions in binary form must reproduce the above copyright notice,
  *      this list of conditions and the following disclaimer in the documentation
  *      and/or other materials provided with the distribution.
  *   3. Neither the name of STMicroelectronics nor the names of its contributors
  *      may be used to endorse or promote products derived from this software
  *      without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  *
  ******************************************************************************
  */ 

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __STM32F4xx_LL_USB_H
#define __STM32F4xx_LL_USB_H

#ifdef __cplusplus
 extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include "usblib/hal/inc/stm32f4xx_hal_def.h"

/** @addtogroup STM32F4xx_HAL
  * @{
  */

/** @addtogroup USB_Core
  * @{
  */ 

/* Exported types ------------------------------------------------------------*/ 

/** 
  * @brief  USB Mode definition  
  */  
typedef enum 
{
   USB_OTG_DEVICE_MODE  = 0,
   USB_OTG_HOST_MODE    = 1,
   USB_OTG_DRD_MODE     = 2
   
}USB_OTG_ModeTypeDef;

/** 
  * @brief  URB States definition  
  */ 
typedef enum {
  URB_IDLE = 0,
  URB_DONE,
  URB_NOTREADY,
  URB_NYET,
  URB_ERROR,
  URB_STALL
    
}USB_OTG_URBStateTypeDef;

/** 
  * @brief  Host channel States  definition  
  */ 
typedef enum {
  HC_IDLE = 0,
  HC_XFRC,
  HC_HALTED,
  HC_NAK,
  HC_NYET,
  HC_STALL,
  HC_XACTERR,  
  HC_BBLERR,   
  HC_DATATGLERR
    
}USB_OTG_HCStateTypeDef;

/** 
  * @brief  PCD Initialization Structure definition  
  */
typedef struct
{
  uint32_t dev_endpoints;        /*!< Device Endpoints number.
                                      This parameter depends on the used USB core.   
                                      This parameter must be a number between Min_Data = 1 and Max_Data = 15 */    
  
  uint32_t Host_channels;        /*!< Host Channels number.
                                      This parameter Depends on the used USB core.   
                                      This parameter must be a number between Min_Data = 1 and Max_Data = 15 */       

  uint32_t speed;                /*!< USB Core speed.
                                      This parameter can be any value of @ref USB_Core_Speed_                */        
                               
  uint32_t dma_enable;           /*!< Enable or disable of the USB embedded DMA.                             */            

  uint32_t ep0_mps;              /*!< Set the Endpoint 0 Max Packet size. 
                                      This parameter can be any value of @ref USB_EP0_MPS_                   */              
                       
  uint32_t phy_itface;           /*!< Select the used PHY interface.
                                      This parameter can be any value of @ref USB_Core_PHY_                  */ 
                                
  uint32_t Sof_enable;           /*!< Enable or disable the output of the SOF signal.                        */     
                               
  uint32_t low_power_enable;     /*!< Enable or disable the low power mode.                                  */     
                          
  uint32_t vbus_sensing_enable;  /*!< Enable or disable the VBUS Sensing feature.                            */ 

  uint32_t use_dedicated_ep1;    /*!< Enable or disable the use of the dedicated EP1 interrupt.              */      
  
  uint32_t use_external_vbus;    /*!< Enable or disable the use of the external VBUS.                        */   
  
}USB_OTG_CfgTypeDef;

typedef struct
{
  uint8_t   num;            /*!< Endpoint number
                                This parameter must be a number between Min_Data = 1 and Max_Data = 15    */ 
                                
  uint8_t   is_in;          /*!< Endpoint direction
                                This parameter must be a number between Min_Data = 0 and Max_Data = 1     */ 
  
  uint8_t   is_stall;       /*!< Endpoint stall condition
                                This parameter must be a number between Min_Data = 0 and Max_Data = 1     */ 
  
  uint8_t   type;           /*!< Endpoint type
                                 This parameter can be any value of @ref USB_EP_Type_                     */ 
                                
  uint8_t   data_pid_start; /*!< Initial data PID
                                This parameter must be a number between Min_Data = 0 and Max_Data = 1     */
                                
  uint8_t   even_odd_frame; /*!< IFrame parity
                                 This parameter must be a number between Min_Data = 0 and Max_Data = 1    */
                                
  uint16_t  tx_fifo_num;    /*!< Transmission FIFO number
                                 This parameter must be a number between Min_Data = 1 and Max_Data = 15   */
                                
  uint32_t  maxpacket;      /*!< Endpoint Max packet size
                                 This parameter must be a number between Min_Data = 0 and Max_Data = 64KB */

  uint8_t   *xfer_buff;     /*!< Pointer to transfer buffer                                               */
                                
  uint32_t  dma_addr;       /*!< 32 bits aligned transfer buffer address                                  */
  
  uint32_t  xfer_len;       /*!< Current transfer length                                                  */
  
  uint32_t  xfer_count;     /*!< Partial transfer length in case of multi packet transfer                 */

}USB_OTG_EPTypeDef;

typedef struct
{
  uint8_t   dev_addr ;     /*!< USB device address.
                                This parameter must be a number between Min_Data = 1 and Max_Data = 255    */ 

  uint8_t   ch_num;        /*!< Host channel number.
                                This parameter must be a number between Min_Data = 1 and Max_Data = 15     */ 
                                
  uint8_t   ep_num;        /*!< Endpoint number.
                                This parameter must be a number between Min_Data = 1 and Max_Data = 15     */ 
                                
  uint8_t   ep_is_in;      /*!< Endpoint direction
                                This parameter must be a number between Min_Data = 0 and Max_Data = 1      */ 
                                
  uint8_t   speed;         /*!< USB Host speed.
                                This parameter can be any value of @ref USB_Core_Speed_                    */
                                
  uint8_t   do_ping;       /*!< Enable or disable the use of the PING protocol for HS mode.                */
  
  uint8_t   process_ping;  /*!< Execute the PING protocol for HS mode.                                     */

  uint8_t   ep_type;       /*!< Endpoint Type.
                                This parameter can be any value of @ref USB_EP_Type_                       */
                                
  uint16_t  max_packet;    /*!< Endpoint Max packet size.
                                This parameter must be a number between Min_Data = 0 and Max_Data = 64KB   */
                                
  uint8_t   data_pid;      /*!< Initial data PID.
                                This parameter must be a number between Min_Data = 0 and Max_Data = 1      */
                                
  uint8_t   *xfer_buff;    /*!< Pointer to transfer buffer.                                                */
  
  uint32_t  xfer_len;      /*!< Current transfer length.                                                   */
  
  uint32_t  xfer_count;    /*!< Partial transfer length in case of multi packet transfer.                  */
  
  uint8_t   toggle_in;     /*!< IN transfer current toggle flag.
                                This parameter must be a number between Min_Data = 0 and Max_Data = 1      */
                                
  uint8_t   toggle_out;    /*!< OUT transfer current toggle flag
                                This parameter must be a number between Min_Data = 0 and Max_Data = 1      */
  
  uint32_t  dma_addr;      /*!< 32 bits aligned transfer buffer address.                                   */
  
  uint32_t  ErrCnt;        /*!< Host channel error count.*/
  
  USB_OTG_URBStateTypeDef  urb_state;  /*!< URB state. 
                                           This parameter can be any value of @ref USB_OTG_URBStateTypeDef */ 
  
  USB_OTG_HCStateTypeDef   state;     /*!< Host Channel state. 
                                           This parameter can be any value of @ref USB_OTG_HCStateTypeDef  */ 
                                             
}USB_OTG_HCTypeDef;
  
/* Exported constants --------------------------------------------------------*/

/** @defgroup PCD_Exported_Constants
  * @{
  */

/** @defgroup USB_Core_Mode_
  * @{
  */
#define USB_OTG_MODE_DEVICE                    0
#define USB_OTG_MODE_HOST                      1
#define USB_OTG_MODE_DRD                       2
/**
  * @}
  */

/** @defgroup USB_Core_Speed_
  * @{
  */  
#define USB_OTG_SPEED_HIGH                     0
#define USB_OTG_SPEED_HIGH_IN_FULL             1
#define USB_OTG_SPEED_LOW                      2  
#define USB_OTG_SPEED_FULL                     3
/**
  * @}
  */
  
/** @defgroup USB_Core_PHY_
  * @{
  */   
#define USB_OTG_ULPI_PHY                       1
#define USB_OTG_EMBEDDED_PHY                   2
/**
  * @}
  */
  
/** @defgroup USB_Core_MPS_
  * @{
  */
#define USB_OTG_HS_MAX_PACKET_SIZE           512
#define USB_OTG_FS_MAX_PACKET_SIZE           64
#define USB_OTG_MAX_EP0_SIZE                 64
/**
  * @}
  */

/** @defgroup USB_Core_Phy_Frequency_
  * @{
  */
#define DSTS_ENUMSPD_HS_PHY_30MHZ_OR_60MHZ     (0 << 1)
#define DSTS_ENUMSPD_FS_PHY_30MHZ_OR_60MHZ     (1 << 1)
#define DSTS_ENUMSPD_LS_PHY_6MHZ               (2 << 1)
#define DSTS_ENUMSPD_FS_PHY_48MHZ              (3 << 1)
/**
  * @}
  */
  
/** @defgroup USB_CORE_Frame_Interval_
  * @{
  */  
#define DCFG_FRAME_INTERVAL_80                 0
#define DCFG_FRAME_INTERVAL_85                 1
#define DCFG_FRAME_INTERVAL_90                 2
#define DCFG_FRAME_INTERVAL_95                 3
/**
  * @}
  */

/** @defgroup USB_EP0_MPS_
  * @{
  */
#define DEP0CTL_MPS_64                         0
#define DEP0CTL_MPS_32                         1
#define DEP0CTL_MPS_16                         2
#define DEP0CTL_MPS_8                          3
/**
  * @}
  */

/** @defgroup USB_EP_Speed_
  * @{
  */
#define EP_SPEED_LOW                           0
#define EP_SPEED_FULL                          1
#define EP_SPEED_HIGH                          2
/**
  * @}
  */

/** @defgroup USB_EP_Type_
  * @{
  */
#define EP_TYPE_CTRL                           0
#define EP_TYPE_ISOC                           1
#define EP_TYPE_BULK                           2
#define EP_TYPE_INTR                           3
#define EP_TYPE_MSK                            3
/**
  * @}
  */

/** @defgroup USB_STS_Defines_
  * @{
  */
#define STS_GOUT_NAK                           1
#define STS_DATA_UPDT                          2
#define STS_XFER_COMP                          3
#define STS_SETUP_COMP                         4
#define STS_SETUP_UPDT                         6
/**
  * @}
  */

/** @defgroup HCFG_SPEED_Defines_
  * @{
  */  
#define HCFG_30_60_MHZ                         0
#define HCFG_48_MHZ                            1
#define HCFG_6_MHZ                             2
/**
  * @}
  */
    
/** @defgroup HPRT0_PRTSPD_SPEED_Defines_
  * @{
  */    
#define HPRT0_PRTSPD_HIGH_SPEED                0
#define HPRT0_PRTSPD_FULL_SPEED                1
#define HPRT0_PRTSPD_LOW_SPEED                 2
/**
  * @}
  */  
   
#define HCCHAR_CTRL                            0
#define HCCHAR_ISOC                            1
#define HCCHAR_BULK                            2
#define HCCHAR_INTR                            3
       
#define HC_PID_DATA0                           0
#define HC_PID_DATA2                           1
#define HC_PID_DATA1                           2
#define HC_PID_SETUP                           3

#define GRXSTS_PKTSTS_IN                       2
#define GRXSTS_PKTSTS_IN_XFER_COMP             3
#define GRXSTS_PKTSTS_DATA_TOGGLE_ERR          5
#define GRXSTS_PKTSTS_CH_HALTED                7
    
#define USBx_PCGCCTL    *(__IO uint32_t *)((uint32_t)USBx + USB_OTG_PCGCCTL_BASE)
#define USBx_HPRT0      *(__IO uint32_t *)((uint32_t)USBx + USB_OTG_HOST_PORT_BASE)

#define USBx_DEVICE     ((USB_OTG_DeviceTypeDef *)((uint32_t )USBx + USB_OTG_DEVICE_BASE)) 
#define USBx_INEP(i)    ((USB_OTG_INEndpointTypeDef *)((uint32_t)USBx + USB_OTG_IN_ENDPOINT_BASE + (i)*USB_OTG_EP_REG_SIZE))        
#define USBx_OUTEP(i)   ((USB_OTG_OUTEndpointTypeDef *)((uint32_t)USBx + USB_OTG_OUT_ENDPOINT_BASE + (i)*USB_OTG_EP_REG_SIZE))        
#define USBx_DFIFO(i)   *(__IO uint32_t *)((uint32_t)USBx + USB_OTG_FIFO_BASE + (i) * USB_OTG_FIFO_SIZE)

#define USBx_HOST       ((USB_OTG_HostTypeDef *)((uint32_t )USBx + USB_OTG_HOST_BASE))  
#define USBx_HC(i)      ((USB_OTG_HostChannelTypeDef *)((uint32_t)USBx + USB_OTG_HOST_CHANNEL_BASE + (i)*USB_OTG_HOST_CHANNEL_SIZE))

/* Exported macro ------------------------------------------------------------*/
#define USB_MASK_INTERRUPT(__INSTANCE__, __INTERRUPT__)     ((__INSTANCE__)->GINTMSK &= ~(__INTERRUPT__))
#define USB_UNMASK_INTERRUPT(__INSTANCE__, __INTERRUPT__)   ((__INSTANCE__)->GINTMSK |= (__INTERRUPT__))
    
#define CLEAR_IN_EP_INTR(__EPNUM__, __INTERRUPT__)          (USBx_INEP(__EPNUM__)->DIEPINT = (__INTERRUPT__))
#define CLEAR_OUT_EP_INTR(__EPNUM__, __INTERRUPT__)         (USBx_OUTEP(__EPNUM__)->DOEPINT = (__INTERRUPT__))  

/* Exported functions --------------------------------------------------------*/
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef Init);
HAL_StatusTypeDef USB_DevInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef Init);
HAL_StatusTypeDef USB_EnableGlobalInt(USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx , USB_OTG_ModeTypeDef mode);
HAL_StatusTypeDef USB_SetDevSpeed(USB_OTG_GlobalTypeDef *USBx , uint8_t speed);
HAL_StatusTypeDef USB_FlushRxFifo (USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_FlushTxFifo (USB_OTG_GlobalTypeDef *USBx, uint32_t num );
HAL_StatusTypeDef USB_ActivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep);
HAL_StatusTypeDef USB_DeactivateEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep);
HAL_StatusTypeDef USB_ActivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep);
HAL_StatusTypeDef USB_DeactivateDedicatedEndpoint(USB_OTG_GlobalTypeDef *USBx, USB_OTG_EPTypeDef *ep);
HAL_StatusTypeDef USB_EPStartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma);
HAL_StatusTypeDef USB_EP0StartXfer(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep, uint8_t dma);
HAL_StatusTypeDef USB_WritePacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *src, uint8_t ch_ep_num, uint16_t len, uint8_t dma);
void *            USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len);
HAL_StatusTypeDef USB_EPSetStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep);
HAL_StatusTypeDef USB_EPClearStall(USB_OTG_GlobalTypeDef *USBx , USB_OTG_EPTypeDef *ep);
HAL_StatusTypeDef USB_SetDevAddress (USB_OTG_GlobalTypeDef *USBx, uint8_t address);
HAL_StatusTypeDef USB_DevConnect (USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_DevDisconnect (USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_StopDevice(USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_ActivateSetup (USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_EP0_OutStart(USB_OTG_GlobalTypeDef *USBx, uint8_t dma, uint8_t *psetup);
uint8_t           USB_GetDevSpeed(USB_OTG_GlobalTypeDef *USBx);
uint32_t          USB_GetMode(USB_OTG_GlobalTypeDef *USBx);
uint32_t          USB_ReadInterrupts (USB_OTG_GlobalTypeDef *USBx);
uint32_t          USB_ReadDevAllOutEpInterrupt (USB_OTG_GlobalTypeDef *USBx);
uint32_t          USB_ReadDevOutEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum);
uint32_t          USB_ReadDevAllInEpInterrupt (USB_OTG_GlobalTypeDef *USBx);
uint32_t          USB_ReadDevInEPInterrupt (USB_OTG_GlobalTypeDef *USBx , uint8_t epnum);
void              USB_ClearInterrupts (USB_OTG_GlobalTypeDef *USBx, uint32_t interrupt);

HAL_StatusTypeDef USB_HostInit (USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg);
HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx , uint8_t freq);
HAL_StatusTypeDef USB_ResetPort(USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_DriveVbus (USB_OTG_GlobalTypeDef *USBx, uint8_t state);
uint32_t          USB_GetHostSpeed (USB_OTG_GlobalTypeDef *USBx);
uint32_t          USB_GetCurrentFrame (USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_HC_Init(USB_OTG_GlobalTypeDef *USBx,  
                                  uint8_t ch_num,
                                  uint8_t epnum,
                                  uint8_t dev_address,
                                  uint8_t speed,
                                  uint8_t ep_type,
                                  uint16_t mps);
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma);
uint32_t          USB_HC_ReadInterrupt (USB_OTG_GlobalTypeDef *USBx);
HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx , uint8_t hc_num);
HAL_StatusTypeDef USB_DoPing(USB_OTG_GlobalTypeDef *USBx , uint8_t ch_num);
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx);

/**
  * @}
  */ 

/**
  * @}
  */
  
#ifdef __cplusplus
}
#endif


#endif /* __STM32F4xx_LL_USB_H */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
// END FILE: ../lib/usblib/hal/inc/stm32f4xx_ll_usb.h
// START FILE: ../lib/src/string/StringUtil.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/string.h"


namespace stm32plus {

  namespace StringUtil {

    /**
     * Convert input values to lower case hex (like bin2hex).
     * @param buffer The input values
     * @param bufferSize How many bytes to convert
     * @param output Where to store output. Requires 2x bufferSize bytes available.
     */

    void toHex(const void *buffer,uint32_t bufferSize,char *output) {

      const char *ptr;
      static const char *hexSet="0123456789abcdef";

      ptr=reinterpret_cast<const char *>(buffer);
      while(bufferSize--) {

        *output++=hexSet[(*ptr & 0xf0) >> 4];
        *output++=hexSet[*ptr & 0xf];
        ptr++;
      }
    }


    /*
     * itoa - not present in standard libraries
     */

    char* itoa(int value,char* result,int base) {

      char* ptr=result,*ptr1=result,tmp_char;
      int tmp_value;

      do {
        tmp_value=value;
        value/=base;
        *ptr++="zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"[35+(tmp_value-value*base)];
      } while(value);

      // Apply negative sign

      if(tmp_value<0)
        *ptr++='-';

      *ptr--='\0';

      while(ptr1<ptr) {
        tmp_char=*ptr;
        *ptr--=*ptr1;
        *ptr1++=tmp_char;
      }
      return result;
    }


    /*
     * modp_uitoa10 (from stringencoders library)
     */

    uint32_t modp_uitoa10(uint32_t value,char *str) {

      char *wstr=str;
      uint32_t size;

      // Conversion. Number is reversed.

      do *wstr++ = (char)(48 + (value % 10)); while (value /= 10);
      *wstr='\0';

      // andy's mod: reverse the string in place. this is probably optimal.

      size=wstr-str;
      wstr--;

      while(str<wstr) {

        *str^=*wstr;
        *wstr^=*str;
        *str^=*wstr;

        wstr--;
        str++;
      }

      return size;
    }


    /*
     * Derived from http://code.google.com/p/stringencoders/source/browse/trunk/src/modp_numtoa.c
     * "string encoders: A collection of high performance c-string transformations".
     *
     * The following license applies:
     *
     * MODP_B64 - High performance base64 encoder/decoder
     * http://code.google.com/p/stringencoders/
     *
     * Copyright (c) 2005, 2006, 2007  Nick Galbreath -- nickg [at] modp [dot] com
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *   Redistributions of source code must retain the above copyright
     *   notice, this list of conditions and the following disclaimer.
     *
     *   Redistributions in binary form must reproduce the above copyright
     *   notice, this list of conditions and the following disclaimer in the
     *   documentation and/or other materials provided with the distribution.
     *
     *   Neither the name of the modp.com nor the names of its
     *   contributors may be used to endorse or promote products derived from
     *   this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     *
     * This is the standard "new" BSD license:
     * http://www.opensource.org/licenses/bsd-license.php
     */

    uint16_t modp_dtoa(double value,int8_t prec,char *str) {

      static const double pow10[] = { 1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000 };
      uint16_t length;

      if(!(value==value)) {

        str[0]='n';
        str[1]='a';
        str[2]='n';
        str[3]='\0';
        return 3;
      }

      int8_t count;
      double diff=0.0;
      char *wstr=str;

    // we'll work in positive values and deal with the negative sign issue later

      bool neg=false;

      if(value<0) {
        neg=true;
        value=-value;
      }

      uint32_t whole=(uint32_t)value;
      double tmp=(value-whole)*pow10[prec];
      uint32_t frac=(uint32_t)(tmp);

      diff=tmp-frac;

      if(diff>0.5) {

        ++frac;

        // handle rollover, e.g.  case 0.99 with prec 1 is 1.0

        if(frac>=pow10[prec]) {
          frac=0;
          ++whole;
        }

      } else if(diff==0.5 && ((frac==0) || (frac & 1))) {

        // if halfway, round up if odd, OR if last digit is 0.  That last part is strange

        ++frac;
      }

      if(prec==0) {

        diff=value-whole;

        if(diff>0.5) {
        // greater than 0.5, round up, e.g. 1.6 -> 2

          ++whole;

        } else if(diff==0.5 && (whole & 1)) {

          // exactly 0.5 and ODD, then round up
          // 1.5 -> 2, but 2.5 -> 2 */

          ++whole;
        }

      } else if(frac) {

        count=prec;

        // now do fractional part, as an unsigned number
        // we know it is not 0 but we can have leading zeros, these should be removed

        while(!(frac % 10)) {
          --count;
          frac/=10;
        }

      // now do fractional part, as an unsigned number

        do {
          --count;
          *wstr++=(char)(48 + (frac % 10));
        } while(frac/=10);

        // add extra 0s

        while(count-- > 0)
          *wstr++='0';

        // add decimal

        *wstr++='.';
      }

      // do whole part. Take care of sign conversion. Number is reversed.

      do {
        *wstr++=(char)(48 + (whole % 10));
      } while(whole/=10);

      if(neg)
        *wstr++='-';

      *wstr='\0';
      length=wstr-str;

      // andy's mod: reverse the string in place. this is probably optimal.

      wstr--;

      while(str<wstr) {

        *str^=*wstr;
        *wstr^=*str;
        *str^=*wstr;

        wstr--;
        str++;
      }

      return length;
    }
  }
}
// END FILE: ../lib/src/string/StringUtil.cpp
// START FILE: ../lib/src/string/TokenisedString.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/string.h"


namespace stm32plus {

  /**
   * Constructor.
   * @param[in] original The original string. This string is not modified.
   * @param[in] separators The token separators.
   */

  TokenisedString::TokenisedString(const char *original,const char *separators) {

    char *ptr,*current;
    int i;

  // count tokens

    _numTokens=0;
    _first=0;
    _last=-1;
    _tokens=nullptr;

    if(original==nullptr)
      return;

    ptr=strdup(original);
    current=strtok(ptr,separators);

    while(current!=nullptr) {
      _numTokens++;
      current=strtok(nullptr,separators);
    }
    free(ptr);

  // anything?

    if(_numTokens==0)
      return;

  // allocate

    _tokens=new char *[_numTokens];

  // parse again

    ptr=strdup(original);
    current=strtok(ptr,separators);
    i=0;

    while(current!=nullptr) {
      _tokens[i++]=strdup(current);
      current=strtok(nullptr,separators);
    }
    free(ptr);

    _last=_numTokens-1;
  }


  /**
   * Destructor. Free memory used by tokens.
   */

  TokenisedString::~TokenisedString() {

    int i;

    if(_numTokens>0) {
      for(i=0;i<_numTokens;i++)
        free(_tokens[i]);

      delete [] _tokens;
    }
  }

  /**
   * Get the number of tokens, taking into account the range if set.
   * @return The number of tokens.
   */

  int TokenisedString::getNumTokens() const {
    return (_last-_first)+1;
  }


  /**
   * Get a token, taking into account the range if set.
   * @param[in] pos The token index to get.
   * @return An internal pointer to the token.
   */

  const char *TokenisedString::operator[](int pos) const {
    return _tokens[_first+pos];
  }


  /**
   * Return the last entry.
   * @return The last token.
   */

  const char *TokenisedString::last() const {
    return _tokens[_last];
  }


  /**
   * Limit the range of tokens returned so that the caller can only see a subset of all the tokens.
   * @param[in] first The first token in the range.
   * @param[in] last The last token in the range.
   */

  void TokenisedString::setRange(int first,int last) {
    _first=first;
    _last=last;
  }


  /**
   * Clear the range parameters.
   */

  void TokenisedString::resetRange() {
    _first=0;
    _last=_numTokens-1;
  }
}
// END FILE: ../lib/src/string/TokenisedString.cpp
// START FILE: ../lib/src/stream/ByteArrayOutputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/stream.h"


namespace stm32plus {

  /**
   * Constructor.
   * @param[in] initialSize The size to allocate.
   * @param[in] resizeAmount The amount to increase allocation by when new space needed
   */

  ByteArrayOutputStream::ByteArrayOutputStream(uint32_t initialSize,uint32_t resizeAmount)
    : _memblock(initialSize) {

    _currentUsage=0;
    _initialSize=initialSize;
    _resizeAmount=resizeAmount;
  }


  /**
   * Clear the stream back to zero size
   */

  void ByteArrayOutputStream::clear() {
    _memblock.reset(_initialSize);
    _currentUsage=0;
  }

  /**
   * get the current size of the data written to the stream.
   * @return The current byte size actually used
   */

  uint32_t ByteArrayOutputStream::getSize() const {
    return _currentUsage;
  }


  /**
   * get a pointer to the internal buffer containing the data written to the stream.
   * This buffer is owned by the stream and should not be free'd by you. Modifications
   * to the data in this buffer directly affect the data in the stream.
   * @return A pointer to the internal buffer
   */

  uint8_t* ByteArrayOutputStream::getBuffer() const {
    return _memblock.getData();
  }


  /**
   * write a byte to the buffer
   */

  bool ByteArrayOutputStream::write(uint8_t c) {
    return write(&c,1);
  }


  /*
   * Write a buffer to the stream
   */

  bool ByteArrayOutputStream::write(const void *buffer,uint32_t size) {

    uint32_t newSize;

    if(_currentUsage+size>_memblock.getSize()) {

      // more space needed: reallocate to the required amount plus margin

      newSize=_currentUsage+size+_resizeAmount;
      _memblock.reallocate(newSize);
    }

    memcpy(_memblock.getData()+_currentUsage,buffer,size);
    _currentUsage+=size;

    return true;
  }


  /*
   * Can't close
   */

  bool ByteArrayOutputStream::close() {
    return true;
  }


  /*
   * Can't flush
   */

  bool ByteArrayOutputStream::flush() {
    return true;
  }
}

// END FILE: ../lib/src/stream/ByteArrayOutputStream.cpp
// START FILE: ../lib/src/stream/CircularBufferInputOutputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/stream.h"


namespace stm32plus {

  /**
   * Read a single byte, returned in the low 8 bits of the return value.
   * @return E_END_OF_STREAM (actually -1) or the data byte in the low 8 bits.
   */

  int16_t CircularBufferInputOutputStream::read() {

    uint8_t value;

    if(_readPtr == _writePtr)
      return E_END_OF_STREAM; // EOF

    value=*_readPtr++;

    if(_readPtr >= _buffer + _bufferSize)
      _readPtr=_buffer;

    return value;
  }

  /**
   * Read multiple.
   * @param[in,out] buffer Where to place the data.
   * @param[in] size The amount to try and read.
   * @param[out] actuallyRead The number of bytes read without error.
   * @return false if it failed, or the end of stream is reached. In the case of the end of stream actuallyRead will
   *    hold the number of bytes that were read before the end of stream was hit.
   */

  bool CircularBufferInputOutputStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

    actuallyRead=0;
    int16_t value;
    uint8_t *ptr;

    ptr=static_cast<uint8_t *> (buffer);

    // read until EOF or got all

    while(size-- && (value=read()) != E_END_OF_STREAM) {
      *ptr++=value;
      actuallyRead++;
    }

    return true;
  }

  /*
   * Skip forward
   */

  bool CircularBufferInputOutputStream::skip(uint32_t howMuch) {

    uint32_t available;

    // get the amount available to read

    if(_writePtr >= _readPtr)
      available=_writePtr - _readPtr;
    else
      available=_bufferSize - (_readPtr - _writePtr);

    // check range

    if(howMuch > available)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_BUFFERED_IOSTREAM,E_INVALID_SEEK_SIZE);

    _readPtr+=howMuch;

    if(_readPtr >= _buffer + _bufferSize)
      _readPtr=_buffer + (_readPtr - _buffer + _bufferSize);

    return true;
  }

  /**
   * Check if can read without error.
   * @return true if there is data to read.
   */

  bool CircularBufferInputOutputStream::available() {
    return _readPtr != _writePtr;
  }

  /**
   * Write a byte.
   * @param[in] c The byte to write.
   * @return false and E_BUFFER_FULL if the buffer has no space available for writing.
   */

  bool CircularBufferInputOutputStream::write(uint8_t c) {

    if(_readPtr == _writePtr && _wrappedWrite)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_BUFFERED_IOSTREAM,E_BUFFER_FULL);

    *_writePtr++=c;

    if(_writePtr == _buffer + _bufferSize) {
      _writePtr=_buffer;
      _wrappedWrite=true;
    }

    return true;
  }

  /**
   * Write many bytes.
   * @param[in] buffer The buffer of data to write.
   * @param[in] size The amount of bytes in the buffer.
   * @return false and E_BUFFER_FULL if the buffer has no space available for writing. In this case no data is written.
   */

  bool CircularBufferInputOutputStream::write(const void *buffer,uint32_t size) {

    uint32_t available;
    const uint8_t *ptr;

    // get the amount available to write

    if(_readPtr == _writePtr)
      available=_wrappedWrite ? 0 : _bufferSize;
    else if(_readPtr > _writePtr)
      available=_readPtr - _writePtr;
    else
      available=_bufferSize - (_writePtr - _readPtr);

    if(size > available)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_BUFFERED_IOSTREAM,E_BUFFER_FULL);

    // do the write

    ptr=static_cast<const uint8_t *> (buffer);
    while(size--)
      write(*ptr++);

    return true;
  }
}
// END FILE: ../lib/src/stream/CircularBufferInputOutputStream.cpp
// START FILE: ../lib/src/stream/OutputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/stream.h"


namespace stm32plus {

  /**
   * Write a signed byte to the stream.
   * @param[in] c The byte to write.
   * @return A self reference to allow chaining of the operator.
   */

  OutputStream& OutputStream::operator<<(int8_t c) {
    return opWrite(&c,sizeof(c));
  }

  /**
   * Write a signed 16-bit integer to the stream.
   * @param[in] c The 16-bit integer to write.
   * @return A self reference to allow chaining of the operator.
   */

  OutputStream& OutputStream::operator<<(int16_t c) {
    return opWrite(&c,sizeof(c));
  }

  /**
   * Write a signed 32-bit integer to the stream.
   * @param[in] c The 32-bit integer to write.
   * @return A self reference to allow chaining of the operator.
   */

  OutputStream& OutputStream::operator<<(int32_t c) {
    return opWrite(&c,sizeof(c));
  }

  /**
   * Write an unsigned byte to the stream.
   * @param[in] c The byte to write.
   * @return A self reference to allow chaining of the operator.
   */

  OutputStream& OutputStream::operator<<(uint8_t c) {
    return opWrite(&c,sizeof(c));
  }

  /**
   * Write an unsigned 16-bit integer to the stream.
   * @param[in] c The 16-bit integer to write.
   * @return A self reference to allow chaining of the operator.
   */

  OutputStream& OutputStream::operator<<(uint16_t c) {
    return opWrite(&c,sizeof(c));
  }

  /**
   * Write an unsigned 32-bit integer to the stream.
   * @param[in] c The 32-bit integer to write.
   * @return A self reference to allow chaining of the operator.
   */

  OutputStream& OutputStream::operator<<(uint32_t c) {
    return opWrite(&c,sizeof(c));
  }

  /*
   * Write some data for one of the operators
   */

  OutputStream& OutputStream::opWrite(void *buffer,uint32_t bufferSize) {
    write(buffer,bufferSize);
    return *this;
  }


  /**
   * Write a 'C' style nul-terminated string
   * @param string The string
   * @return A self reference to allow chaining of the operator.
   */

  OutputStream& OutputStream::operator<<(const char *string) {
    write(string,strlen(string));
    return *this;
  }
}
// END FILE: ../lib/src/stream/OutputStream.cpp
// START FILE: ../lib/src/stream/ConnectedInputOutputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/stream.h"


namespace stm32plus {

  /**
   * Constructor.
   * @param[in] is The input stream where data comes from.
   * @param[in] os The output stream where data goes to.
   */

  ConnectedInputOutputStream::ConnectedInputOutputStream(InputStream& is,OutputStream& os) :
    _inputStream(is), _outputStream(os) {
  }

  /**
   * Read/write while there is data. This method will continually read the input stream and write the data
   * to the output stream until the end of the input stream is reached.
   * @return false if an error occurred during the read/write operation.
   */

  bool ConnectedInputOutputStream::readWrite() {

    int16_t c;

    while((c=_inputStream.read()) > 0)
      if(!_outputStream.write(c))
        return false;

    _outputStream.flush();

    return c == InputStream::E_END_OF_STREAM ? true : false;
  }


  /**
   * Read/write up to the size specified by the user. Up to size_ bytes are read from the input stream
   * and written to the output stream. In the event of an error or end-of-stream actuallyWritten_ will
   * hold the number of bytes received.
   * @param[in] size_ The maximum amount of data to to read and write.
   * @param[out] actuallyWritten_ The amount of data written which may be less than size_.
   * @return false if it failed.
   */

  bool ConnectedInputOutputStream::readWrite(uint32_t size,uint32_t& actuallyWritten) {

    char buffer[32];
    uint32_t actuallyRead,count;

    actuallyWritten=0;

    while(size!=0) {

    // read some data

      count=size<sizeof(buffer) ? size : sizeof(buffer);

      if(!_inputStream.read(buffer,count,actuallyRead))
        return false;

    // write it

      if(actuallyRead!=0) {

        if(!_outputStream.write(buffer,actuallyRead))
          return false;

        actuallyWritten+=actuallyRead;
        size-=actuallyRead;

        _outputStream.flush();
      }
    }

    return true;
  }
}
// END FILE: ../lib/src/stream/ConnectedInputOutputStream.cpp
// START FILE: ../lib/src/stream/LzgDecompressionInputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/stream.h"


static const uint8_t LZG_LENGTH_DECODE_LUT[32]= { 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,35,48,72,128 };


namespace stm32plus {


  /**
   * Constructor. Initiates the decompression.
   * The error provider should be checked to ensure that nothing went wrong
   * while setting up the decompressor
   *
   * @param input The source of compressed bytes
   * @param compressedSize the number of bytes of compressed data
   */

  LzgDecompressionStream::LzgDecompressionStream(InputStream& input,uint32_t compressedSize)
    : _input(input),
      _compressedSize(compressedSize) {

    int i;

    // no error yet

    errorProvider.clear();

    // initialize the output byte buffer

    _compressedDataAvailable=_compressedSize;
    _historyCopyDataAvailable=0;

    _dst=_circbuf;
    _dstEnd=_circbuf+sizeof(_circbuf);

    // skip header information

    if(!input.skip(16))
      return;

    // Get marker symbols from the input stream

    _input >> _marker1;
    _input >> _marker2;
    _input >> _marker3;
    _input >> _marker4;

    _compressedDataAvailable-=20;           // the header and 4 markers

    // Initialize marker symbol LUT

    for(i=0;i<256;++i)
      _isMarkerSymbolLUT[i]=0;

    _isMarkerSymbolLUT[_marker1]=1;
    _isMarkerSymbolLUT[_marker2]=1;
    _isMarkerSymbolLUT[_marker3]=1;
    _isMarkerSymbolLUT[_marker4]=1;
  }


  /*
   * Read a byte from the stream, or return EOF or an error
   */

  int16_t LzgDecompressionStream::read() {

    uint8_t nextByte;

    // check for end of stream

    if(_historyCopyDataAvailable==0 && _compressedDataAvailable==0)
      return E_END_OF_STREAM;

    // return the next byte

    if(readNextUncompressedByte(nextByte))
      return nextByte;

    return false;
  }


  bool LzgDecompressionStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

    uint8_t *ptr;

    ptr=static_cast<uint8_t *>(buffer);
    actuallyRead=0;

    while(size-- && available()) {

      if(!readNextUncompressedByte(*ptr++))
        return false;

      actuallyRead++;
    }

    return true;
  }


  /*
   * Can't close, and can't go wrong either
   */

  bool LzgDecompressionStream::close() {
    return true;
  }


  /*
   * Can't skip
   */

  bool LzgDecompressionStream::skip(uint32_t howMuch __attribute__((unused))) {
    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_LZG_DECOMPRESSION_STREAM,E_OPERATION_NOT_SUPPORTED);
  }


  /*
   * Return true if there is data available
   */

  bool LzgDecompressionStream::available() {
    return _compressedDataAvailable>0 || _historyCopyDataAvailable>0;
  }


  /*
   * Cannot reset because we can't guarantee that the compressed data
   * started at the beginning of the input stream
   */

  bool LzgDecompressionStream::reset() {
    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_LZG_DECOMPRESSION_STREAM,E_OPERATION_NOT_SUPPORTED);
  }


  /*
   * Read the next uncompressed byte from the stream
   */

  bool LzgDecompressionStream::readNextUncompressedByte(uint8_t& nextByte) {

    uint8_t symbol,b,b2;
    uint16_t offset,length;

    // if we're in mid-copy from the history window, take the next byte from there

    if(_historyCopyDataAvailable>0) {
      nextByte=getByteFromHistoryCopy();
      return true;
    }

    // get the next symbol

    if(!nextByteFromStream(symbol))
      return false;

    // Marker symbol?

    if(!_isMarkerSymbolLUT[symbol]) {

      // Literal copy

      nextByte=symbol;

      *_dst++=symbol;
      if(_dst==_dstEnd)
        _dst=_circbuf;
    } else {

      if(!nextByteFromStream(b))
        return false;

      if(b) {

        // Decode offset / length parameters

        if(symbol == _marker1) {

          // distant copy is not supported on the STM32 due to lack of SRAM)

          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_LZG_DECOMPRESSION_STREAM,E_UNSUPPORTED_COMPRESSED_DATA);

        } else if(symbol == _marker2) {

          // Medium copy

          length=LZG_LENGTH_DECODE_LUT[b & 0x1f];

          if(!nextByteFromStream(b2))
            return false;

          offset=(((uint16_t)(b & 0xe0)) << 3) | b2;
          offset+=8;
        } else if(symbol == _marker3) {

          // Short copy

          length=(b >> 6) + 3;
          offset=(b & 0x3f) + 8;
        } else {

          // Near copy (including RLE)

          length=LZG_LENGTH_DECODE_LUT[b & 0x1f];
          offset=(b >> 5) + 1;
        }

        // Copy corresponding data from history window

        if(offset<=static_cast<uint16_t>(_dst-_circbuf))
          _historyCopyPosition=_dst-offset;
        else
          _historyCopyPosition=_dstEnd-(offset-(uint16_t)(_dst-_circbuf));

        _historyCopyDataAvailable=length;

        nextByte=getByteFromHistoryCopy();

      } else {

        // single occurance of a marker symbol

        nextByte=symbol;

        *_dst++=symbol;
        if(_dst==_dstEnd)
          _dst=_circbuf;
      }
    }

    return true;
  }


  /*
   * Get next byte from input stream
   */

  bool LzgDecompressionStream::nextByteFromStream(uint8_t& nextByte) {

    int16_t value;

    // must have a byte to read

    if(_compressedSize==0)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_LZG_DECOMPRESSION_STREAM,E_END_OF_STREAM);

    // read next byte

    if((value=_input.read())<0)
      return false;

    // return it

    nextByte=value;
    _compressedSize--;

    return true;
  }


  /*
   * Get one byte from the available data in this history window.
   * Data must be available!
   */

  uint8_t LzgDecompressionStream::getByteFromHistoryCopy() {

    uint8_t retval;

    // get the next value from the copy position, copy back to the circular buffer

    retval=*_historyCopyPosition++;
    *_dst++=retval;

    // copy position and source pointer are both in the circular buffer and must be updated

    if(_dst==_dstEnd)
      _dst=_circbuf;

    if(_historyCopyPosition==_dstEnd)
      _historyCopyPosition=_circbuf;

    // that's one less byte available for next time

    _historyCopyDataAvailable--;

    return retval;
  }
}
// END FILE: ../lib/src/stream/LzgDecompressionInputStream.cpp
// START FILE: ../lib/src/stream/LinearBufferInputOutputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"
#include "config/stream.h"


namespace stm32plus {


  /**
   * Constructor
   * @param buffer
   * @param size
   */

  LinearBufferInputOutputStream::LinearBufferInputOutputStream(void *buffer,uint32_t size)
    : BufferedInputOutputStream(buffer,size) {
  }


  /**
   * Constructor with initial size
   * @param initialSize
   */

  LinearBufferInputOutputStream::LinearBufferInputOutputStream(uint32_t initialSize)
    : BufferedInputOutputStream(initialSize) {
  }


  /**
   * Read a single byte unless we're at the end of the stream
   * @return E_END_OF_STREAM (actually -1) or the data byte in the low 8 bits.
   */

  int16_t LinearBufferInputOutputStream::read() {

    if(_readPtr==_buffer+_bufferSize)
      return E_END_OF_STREAM;

    return *_readPtr++;
  }


  /**
   * Read a block of data from the buffer. Always succeeds but will return actuallyRead=0 at end of stream
   *
   * @param[in] buffer Where to read the data out to.
   * @param[in] size The maximum size to read.
   * @param[out] actuallyRead The actual size read.
   * @return Always true
   */

  bool LinearBufferInputOutputStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

    uint32_t available;

    if((available=_bufferSize-(_readPtr-_buffer))<size)
      actuallyRead=available;
    else
      actuallyRead=size;

    if(actuallyRead>0) {

      memcpy(buffer,(void *)_readPtr,actuallyRead);
      _readPtr+=actuallyRead;
    }

    return true;
  }


  /**
   * Skip forward (read pointer)
   * @param[in] howMuch How far to skip
   * @return false if would be past end of stream
   */

  bool LinearBufferInputOutputStream::skip(uint32_t howMuch) {

    uint32_t available;

    if((available=_bufferSize-(_readPtr-_buffer))<howMuch)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_BUFFERED_IOSTREAM,E_INVALID_SEEK_SIZE);

    _readPtr+=howMuch;
    return true;
  }


  /**
   * Return true if at least one byte can be read without error
   * @return true if a byte can be read
   */

  bool LinearBufferInputOutputStream::available() {
    return _bufferSize-(_readPtr-_buffer)>0;
  }


  /**
   * Reset the input stream pointer.
   * @return Always true.
   */

  bool LinearBufferInputOutputStream::reset() {
    _readPtr=_buffer;
    return true;
  }


  /**
   * Reset the output pointer.
   */

  void LinearBufferInputOutputStream::resetOutput() {
    _writePtr=_buffer;
  }


  /**
   * Write a byte to the output pointer
   * @param[in] c The byte to write.
   * @return false if out of space
   */

  bool LinearBufferInputOutputStream::write(uint8_t c) {

    if(_writePtr==_buffer+_bufferSize)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_BUFFERED_IOSTREAM,E_BUFFER_FULL);

    *_writePtr++=c;
    return true;
  }


  /**
   * Write a block of bytes. There must be space for it all
   * @param[in] buffer Where to write from.
   * @param[in] size The number of bytes to write
   */

  bool LinearBufferInputOutputStream::write(const void *buffer,uint32_t size) {

    // check for space

    if(_bufferSize-(_writePtr-_buffer)<size)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_BUFFERED_IOSTREAM,E_BUFFER_FULL);

    // write the data

    memcpy((void *)_writePtr,buffer,size);
    _writePtr+=size;

    return true;
  }
}
// END FILE: ../lib/src/stream/LinearBufferInputOutputStream.cpp
// START FILE: ../lib/src/stream/InputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/stream.h"


namespace stm32plus {

  /**
   * Read a single byte using the stream input operator syntax.
   * @param[out] c_ Reference to the byte to hold the result.
   * @return A self reference to allow chaining of the operator.
   */

  InputStream& InputStream::operator>>(int8_t& c_) {
    return opRead(&c_,sizeof(c_));
  }

  /**
   * Read a 16-bit integer using the stream input operator syntax.
   * @param[out] c_ Reference to the integer to hold the result.
   * @return A self reference to allow chaining of the operator.
   */

  InputStream& InputStream::operator>>(int16_t& c_) {
    return opRead(&c_,sizeof(c_));
  }

  /**
   * Read a 32-bit integer using the stream input operator syntax.
   * @param[out] c_ Reference to the integer to hold the result.
   * @return A self reference to allow chaining of the operator.
   */

  InputStream& InputStream::operator>>(int32_t& c_) {
    return opRead(&c_,sizeof(c_));
  }

  /**
   * Read a single unsigned byte using the stream input operator syntax.
   * @param[out] c_ Reference to the byte to hold the result.
   * @return A self reference to allow chaining of the operator.
   */

  InputStream& InputStream::operator>>(uint8_t& c_) {
    return opRead(&c_,sizeof(c_));
  }

  /**
   * Read a single unsigned 16-bit integer using the stream input operator syntax.
   * @param[out] c_ Reference to the integer to hold the result.
   * @return A self reference to allow chaining of the operator.
   */

  InputStream& InputStream::operator>>(uint16_t& c_) {
    return opRead(&c_,sizeof(c_));
  }

  /**
   * Read a single unsigned 32-bit integer using the stream input operator syntax.
   * @param[out] c_ Reference to the integer to hold the result.
   * @return A self reference to allow chaining of the operator.
   */

  InputStream& InputStream::operator>>(uint32_t& c_) {
    return opRead(&c_,sizeof(c_));
  }


  /*
   * Read some data for one of the operators
   */

  InputStream& InputStream::opRead(void *buffer_,uint32_t bufferSize_) {
    uint32_t actuallyRead;

    read(buffer_,bufferSize_,actuallyRead);
    return *this;
  }
}
// END FILE: ../lib/src/stream/InputStream.cpp
// START FILE: ../lib/src/error/ErrorProvider.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "error/ErrorProvider.h"

namespace stm32plus {

  ErrorProvider errorProvider;
}
// END FILE: ../lib/src/error/ErrorProvider.cpp
// START FILE: ../lib/src/timer/f4/Timer8_12_13_14InterruptHandlers.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"

#if defined(STM32PLUS_F4)


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> TimerInterruptFeatureEnabler<8>::FPTR TimerInterruptFeatureEnabler<8>::_forceLinkage=nullptr;
template<> TimerInterruptFeatureEnabler<12>::FPTR TimerInterruptFeatureEnabler<12>::_forceLinkage=nullptr;
template<> TimerInterruptFeatureEnabler<13>::FPTR TimerInterruptFeatureEnabler<13>::_forceLinkage=nullptr;
template<> TimerInterruptFeatureEnabler<14>::FPTR TimerInterruptFeatureEnabler<14>::_forceLinkage=nullptr;


extern "C" {

  /**
   * TIM8_BRK and TIM12 share the same vector.
   * TIM12 can have CC1, CC2, Update, Trigger
   */

#if defined(USE_TIM8_BRK_INTERRUPT) || defined(USE_TIM12_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM8_BRK_TIM12_IRQHandler() {

    if(TIM_GetITStatus(TIM8,TIM_IT_Break)!=RESET) {
      TimerInterruptFeature<8>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_BREAK,8);
      TIM_ClearITPendingBit(TIM8,TIM_IT_Break);
    }
    else if(TIM_GetITStatus(TIM12,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<12>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,12);
      TIM_ClearITPendingBit(TIM12,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM12,TIM_IT_CC2)!=RESET) {
      TimerInterruptFeature<12>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE2,12);
      TIM_ClearITPendingBit(TIM12,TIM_IT_CC2);
    }
    else if(TIM_GetITStatus(TIM12,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<12>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,12);
      TIM_ClearITPendingBit(TIM12,TIM_IT_Update);
    }
    else if(TIM_GetITStatus(TIM12,TIM_IT_Trigger)!=RESET) {
      TimerInterruptFeature<12>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_TRIGGER,12);
      TIM_ClearITPendingBit(TIM12,TIM_IT_Trigger);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

  /**
   * TIM8_UP and TIM13 share the same vector.
   * TIM13 can have CC1, Update
   */

#if defined(USE_TIM8_UP_INTERRUPT) || defined(USE_TIM13_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM8_UP_TIM13_IRQHandler() {

    if(TIM_GetITStatus(TIM8,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<8>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,8);
      TIM_ClearITPendingBit(TIM8,TIM_IT_Update);
    }
    else if(TIM_GetITStatus(TIM13,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<13>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,13);
      TIM_ClearITPendingBit(TIM13,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM13,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<13>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,13);
      TIM_ClearITPendingBit(TIM13,TIM_IT_Update);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

  /**
   * TIM8_TRG_COM and TIM14 share the same vector.
   * TIM14 can have CC1, Update
   */

#if defined(USE_TIM8_TRG_COM_INTERRUPT) || defined(USE_TIM14_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM8_TRG_COM_TIM14_IRQHandler() {

    if(TIM_GetITStatus(TIM8,TIM_IT_Trigger)!=RESET) {
      TimerInterruptFeature<8>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_TRIGGER,8);
      TIM_ClearITPendingBit(TIM8,TIM_IT_Trigger);
    }
    else if(TIM_GetITStatus(TIM8,TIM_IT_COM)!=RESET) {
      TimerInterruptFeature<8>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COM,8);
      TIM_ClearITPendingBit(TIM8,TIM_IT_COM);
    }
    else if(TIM_GetITStatus(TIM14,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<14>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,14);
      TIM_ClearITPendingBit(TIM14,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM14,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<14>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,14);
      TIM_ClearITPendingBit(TIM14,TIM_IT_Update);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

  /**
   * TIM8_CC interrupt handler
   */

#if defined(USE_TIM8_CC_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM8_CC_IRQHandler() {

    if(TIM_GetITStatus(TIM8,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<8>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,8);
      TIM_ClearITPendingBit(TIM8,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM8,TIM_IT_CC2)!=RESET) {
      TimerInterruptFeature<8>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE2,8);
      TIM_ClearITPendingBit(TIM8,TIM_IT_CC2);
    }
    else if(TIM_GetITStatus(TIM8,TIM_IT_CC3)!=RESET) {
      TimerInterruptFeature<8>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE3,8);
      TIM_ClearITPendingBit(TIM8,TIM_IT_CC3);
    }
    else if(TIM_GetITStatus(TIM8,TIM_IT_CC3)!=RESET) {
      TimerInterruptFeature<8>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE3,8);
      TIM_ClearITPendingBit(TIM8,TIM_IT_CC3);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif
} // extern "C"

#endif
// END FILE: ../lib/src/timer/f4/Timer8_12_13_14InterruptHandlers.cpp
// START FILE: ../lib/src/timer/f4/Timer4InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"


#if defined(STM32PLUS_F4)

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> TimerInterruptFeatureEnabler<4>::FPTR TimerInterruptFeatureEnabler<4>::_forceLinkage=nullptr;


extern "C" {

  /**
   * TIM4 interrupt handler
   * TIM4 can have CC1..4, Update, Trigger
   */

#if defined(USE_TIM4_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM4_IRQHandler() {

    if(TIM_GetITStatus(TIM4,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<4>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,4);
      TIM_ClearITPendingBit(TIM4,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM4,TIM_IT_CC2)!=RESET) {
      TimerInterruptFeature<4>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE2,4);
      TIM_ClearITPendingBit(TIM4,TIM_IT_CC2);
    }
    else if(TIM_GetITStatus(TIM4,TIM_IT_CC3)!=RESET) {
      TimerInterruptFeature<4>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE3,4);
      TIM_ClearITPendingBit(TIM4,TIM_IT_CC3);
    }
    else if(TIM_GetITStatus(TIM4,TIM_IT_CC4)!=RESET) {
      TimerInterruptFeature<4>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE4,4);
      TIM_ClearITPendingBit(TIM4,TIM_IT_CC4);
    }
    else if(TIM_GetITStatus(TIM4,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<4>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,4);
      TIM_ClearITPendingBit(TIM4,TIM_IT_Update);
    }
    else if(TIM_GetITStatus(TIM4,TIM_IT_Trigger)!=RESET) {
      TimerInterruptFeature<4>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_TRIGGER,4);
      TIM_ClearITPendingBit(TIM4,TIM_IT_Trigger);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

} // extern "C"


#endif
// END FILE: ../lib/src/timer/f4/Timer4InterruptHandler.cpp
// START FILE: ../lib/src/timer/f4/Timer7InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"


#if defined(STM32PLUS_F4)

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> TimerInterruptFeatureEnabler<7>::FPTR TimerInterruptFeatureEnabler<7>::_forceLinkage=nullptr;


extern "C" {

  /**
   * TIM7 interrupt handler
   * TIM7 can have Update
   */

#if defined(USE_TIM7_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM7_IRQHandler() {

    if(TIM_GetITStatus(TIM7,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<7>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,7);
      TIM_ClearITPendingBit(TIM7,TIM_IT_Update);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

} // extern "C"


#endif
// END FILE: ../lib/src/timer/f4/Timer7InterruptHandler.cpp
// START FILE: ../lib/src/timer/f4/Timer5InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"

#if defined(STM32PLUS_F4)


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> TimerInterruptFeatureEnabler<5>::FPTR TimerInterruptFeatureEnabler<5>::_forceLinkage=nullptr;


extern "C" {

  /**
   * TIM5 interrupt handler
   * TIM5 can have CC1..4, Update, Trigger
   */

#if defined(USE_TIM5_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM5_IRQHandler() {

    if(TIM_GetITStatus(TIM5,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<5>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,5);
      TIM_ClearITPendingBit(TIM5,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM5,TIM_IT_CC2)!=RESET) {
      TimerInterruptFeature<5>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE2,5);
      TIM_ClearITPendingBit(TIM5,TIM_IT_CC2);
    }
    else if(TIM_GetITStatus(TIM5,TIM_IT_CC3)!=RESET) {
      TimerInterruptFeature<5>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE3,5);
      TIM_ClearITPendingBit(TIM5,TIM_IT_CC3);
    }
    else if(TIM_GetITStatus(TIM5,TIM_IT_CC4)!=RESET) {
      TimerInterruptFeature<5>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE4,5);
      TIM_ClearITPendingBit(TIM5,TIM_IT_CC4);
    }
    else if(TIM_GetITStatus(TIM5,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<5>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,5);
      TIM_ClearITPendingBit(TIM5,TIM_IT_Update);
    }
    else if(TIM_GetITStatus(TIM5,TIM_IT_Trigger)!=RESET) {
      TimerInterruptFeature<5>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_TRIGGER,5);
      TIM_ClearITPendingBit(TIM5,TIM_IT_Trigger);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

} // extern "C"

#endif
// END FILE: ../lib/src/timer/f4/Timer5InterruptHandler.cpp
// START FILE: ../lib/src/timer/f4/Timer6InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"


#if defined(STM32PLUS_F4)

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> TimerInterruptFeatureEnabler<6>::FPTR TimerInterruptFeatureEnabler<6>::_forceLinkage=nullptr;


extern "C" {

  /**
   * TIM6 interrupt handler
   * TIM6 can have Update
   */

#if defined(USE_TIM6_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM6_DAC_IRQHandler() {

    if(TIM_GetITStatus(TIM6,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<6>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,6);
      TIM_ClearITPendingBit(TIM6,TIM_IT_Update);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

} // extern "C"

#endif
// END FILE: ../lib/src/timer/f4/Timer6InterruptHandler.cpp
// START FILE: ../lib/src/timer/f4/Timer1_9_10_11InterruptHandlers.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"


#if defined(STM32PLUS_F4)


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> TimerInterruptFeatureEnabler<1>::FPTR TimerInterruptFeatureEnabler<1>::_forceLinkage=nullptr;
template<> TimerInterruptFeatureEnabler<9>::FPTR TimerInterruptFeatureEnabler<9>::_forceLinkage=nullptr;
template<> TimerInterruptFeatureEnabler<10>::FPTR TimerInterruptFeatureEnabler<10>::_forceLinkage=nullptr;


extern "C" {

#if defined(USE_TIM1_UP_INTERRUPT) || defined(USE_TIM10_INTERRUPT)

  /**
   * TIM1_UP and TIM10 share the same vector.
   * TIM10 can have CC1, Update
   */

  void __attribute__ ((interrupt("IRQ"))) TIM1_UP_TIM10_IRQHandler() {

    if(TIM_GetITStatus(TIM1,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<1>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,1);
      TIM_ClearITPendingBit(TIM1,TIM_IT_Update);
    }
    else if(TIM_GetITStatus(TIM10,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<10>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,10);
      TIM_ClearITPendingBit(TIM10,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM10,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<10>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,10);
      TIM_ClearITPendingBit(TIM10,TIM_IT_Update);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

  /**
   * TIM1_BRK and TIM9 share the same vector.
   * TIM9 can have CC1, CC2, Update, Trigger
   */

#if defined(USE_TIM1_BRK_INTERRUPT) || defined(USE_TIM9_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM1_BRK_TIM9_IRQHandler() {

    if(TIM_GetITStatus(TIM1,TIM_IT_Break)!=RESET) {
      TimerInterruptFeature<1>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_BREAK,1);
      TIM_ClearITPendingBit(TIM1,TIM_IT_Break);
    }
    else if(TIM_GetITStatus(TIM9,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<9>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,9);
      TIM_ClearITPendingBit(TIM9,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM9,TIM_IT_CC2)!=RESET) {
      TimerInterruptFeature<9>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE2,9);
      TIM_ClearITPendingBit(TIM9,TIM_IT_CC2);
    }
    else if(TIM_GetITStatus(TIM9,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<9>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,9);
      TIM_ClearITPendingBit(TIM9,TIM_IT_Update);
    }
    else if(TIM_GetITStatus(TIM9,TIM_IT_Trigger)!=RESET) {
      TimerInterruptFeature<9>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_TRIGGER,9);
      TIM_ClearITPendingBit(TIM9,TIM_IT_Trigger);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

  /**
   * TIM1_TRG_COM and TIM11 share the same vector.
   * TIM11 can have CC1, Update
   */

#if defined(USE_TIM1_TRG_COM_INTERRUPT) || defined(USE_TIM11_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM1_TRG_COM_TIM11_IRQHandler() {

    if(TIM_GetITStatus(TIM1,TIM_IT_Trigger)!=RESET) {
      TimerInterruptFeature<1>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_TRIGGER,1);
      TIM_ClearITPendingBit(TIM1,TIM_IT_Trigger);
    }
    else if(TIM_GetITStatus(TIM1,TIM_IT_COM)!=RESET) {
      TimerInterruptFeature<1>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COM,1);
      TIM_ClearITPendingBit(TIM1,TIM_IT_COM);
    }
    else if(TIM_GetITStatus(TIM11,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<11>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,11);
      TIM_ClearITPendingBit(TIM11,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM11,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<11>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,11);
      TIM_ClearITPendingBit(TIM11,TIM_IT_Update);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

  /**
   * TIM1_CC interrupt handler
   */

#if defined(USE_TIM1_CC_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM1_CC_IRQHandler() {

    if(TIM_GetITStatus(TIM1,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<1>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,1);
      TIM_ClearITPendingBit(TIM1,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM1,TIM_IT_CC2)!=RESET) {
      TimerInterruptFeature<1>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE2,1);
      TIM_ClearITPendingBit(TIM1,TIM_IT_CC2);
    }
    else if(TIM_GetITStatus(TIM1,TIM_IT_CC3)!=RESET) {
      TimerInterruptFeature<1>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE3,1);
      TIM_ClearITPendingBit(TIM1,TIM_IT_CC3);
    }
    else if(TIM_GetITStatus(TIM1,TIM_IT_CC4)!=RESET) {
      TimerInterruptFeature<1>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE4,1);
      TIM_ClearITPendingBit(TIM1,TIM_IT_CC4);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

} // extern "C"

#endif
// END FILE: ../lib/src/timer/f4/Timer1_9_10_11InterruptHandlers.cpp
// START FILE: ../lib/src/timer/Timer2InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> TimerInterruptFeatureEnabler<2>::FPTR TimerInterruptFeatureEnabler<2>::_forceLinkage=nullptr;


extern "C" {

  /**
   * TIM2 interrupt handler
   * TIM2 can have CC1..4, Update, Trigger
   */

#if defined(USE_TIM2_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM2_IRQHandler() {

    if(TIM_GetITStatus(TIM2,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<2>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,2);
      TIM_ClearITPendingBit(TIM2,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM2,TIM_IT_CC2)!=RESET) {
      TimerInterruptFeature<2>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE2,2);
      TIM_ClearITPendingBit(TIM2,TIM_IT_CC2);
    }
    else if(TIM_GetITStatus(TIM2,TIM_IT_CC3)!=RESET) {
      TimerInterruptFeature<2>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE3,2);
      TIM_ClearITPendingBit(TIM2,TIM_IT_CC3);
    }
    else if(TIM_GetITStatus(TIM2,TIM_IT_CC4)!=RESET) {
      TimerInterruptFeature<2>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE4,2);
      TIM_ClearITPendingBit(TIM2,TIM_IT_CC4);
    }
    else if(TIM_GetITStatus(TIM2,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<2>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,2);
      TIM_ClearITPendingBit(TIM2,TIM_IT_Update);
    }
    else if(TIM_GetITStatus(TIM2,TIM_IT_Trigger)!=RESET) {
      TimerInterruptFeature<2>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_TRIGGER,2);
      TIM_ClearITPendingBit(TIM2,TIM_IT_Trigger);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif


} // extern "C"
// END FILE: ../lib/src/timer/Timer2InterruptHandler.cpp
// START FILE: ../lib/src/timer/Timer3InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> TimerInterruptFeatureEnabler<3>::FPTR TimerInterruptFeatureEnabler<3>::_forceLinkage=nullptr;


extern "C" {

  /**
   * TIM3 interrupt handler
   * TIM3 can have CC1..4, Update, Trigger
   */

#if defined(USE_TIM3_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) TIM3_IRQHandler() {

    if(TIM_GetITStatus(TIM3,TIM_IT_CC1)!=RESET) {
      TimerInterruptFeature<3>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE1,3);
      TIM_ClearITPendingBit(TIM3,TIM_IT_CC1);
    }
    else if(TIM_GetITStatus(TIM3,TIM_IT_CC2)!=RESET) {
      TimerInterruptFeature<3>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE2,3);
      TIM_ClearITPendingBit(TIM3,TIM_IT_CC2);
    }
    else if(TIM_GetITStatus(TIM3,TIM_IT_CC3)!=RESET) {
      TimerInterruptFeature<3>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE3,3);
      TIM_ClearITPendingBit(TIM3,TIM_IT_CC3);
    }
    else if(TIM_GetITStatus(TIM3,TIM_IT_CC4)!=RESET) {
      TimerInterruptFeature<3>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_COMPARE4,3);
      TIM_ClearITPendingBit(TIM3,TIM_IT_CC4);
    }
    else if(TIM_GetITStatus(TIM3,TIM_IT_Update)!=RESET) {
      TimerInterruptFeature<3>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_UPDATE,3);
      TIM_ClearITPendingBit(TIM3,TIM_IT_Update);
    }
    else if(TIM_GetITStatus(TIM3,TIM_IT_Trigger)!=RESET) {
      TimerInterruptFeature<3>::_timerInstance->TimerInterruptEventSender.raiseEvent(TimerEventType::EVENT_TRIGGER,3);
      TIM_ClearITPendingBit(TIM3,TIM_IT_Trigger);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif

} // extern "C"
// END FILE: ../lib/src/timer/Timer3InterruptHandler.cpp
// START FILE: ../lib/src/net/network/ip/features/IpPacketReassemblerFeature.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4_HAS_MAC) || defined(STM32PLUS_F1_CL_E)

#include "config/net.h"


namespace stm32plus {
  namespace net {


    /**
     * Initialise the class
     * @param params The IP parameters class that holds the limits
     * @param utilityObjects The network utilities
     * @return true;
     */

    bool IpPacketReassemblerFeature::initialise(const Parameters& params,NetworkUtilityObjects& utilityObjects) {

      // save variables

      _params=params;
      _totalFragmentSize=0;
      _inFlightPacketCount=0;
      _utilityObjects=&utilityObjects;

      // subscribe to ticks for the expiry

      utilityObjects.subscribeIntervalTicks(
          _params.ip_fragmentExpiryIntervalCheckSeconds,
          NetworkIntervalTicker::TickIntervalSlotType::bind(this,&IpPacketReassemblerFeature::expireOldEntries)
        );

      return true;
    }


    /**
     * Startup (does nothing)
     */

    bool IpPacketReassemblerFeature::startup() {
      return true;
    }


    /**
     * Destructor, free all
     */

    IpPacketReassemblerFeature::~IpPacketReassemblerFeature() {

      // ensure we cannot be interrupted here

      IrqSuspend suspender;

      // clear the list

      while(!_frags.empty()) {
        delete _frags.front();
        _frags.pop_front();
      }
    }


    /**
     * Handle a packet fragment from the Ip class
     * @param[in] packet The packet fragment class
     * @param[out] fp points to the FragmentedPacket class that we're operating on
     * @return true if it worked
     */

    bool IpPacketReassemblerFeature::ip_handleFragment(const IpPacket& packet,IpFragmentedPacket*& fp) {

      // ensure we cannot be interrupted

      IrqSuspend suspend;
      return internalHandleFragment(packet,fp);
    }


    /*
     * Handle the reassembly under the protection of the critical section
     */

    bool IpPacketReassemblerFeature::internalHandleFragment(const IpPacket& packet,IpFragmentedPacket*& fp) {

      uint16_t offset,extendedLength,extra;
      IpFragmentedPacket::PacketId pid;

      // get the packet identifier. the combination of id, source address,
      // destination address and protocol identify a packet on the network

      pid.identification=packet.getIdentifier();
      pid.sourceAddress=packet.header->ip_sourceAddress;
      pid.destinationAddress=packet.header->ip_destinationAddress;
      pid.protocol=packet.header->ip_hdr_protocol;

      // find the existing fragment or create a new one

      if((fp=findFragment(pid))==nullptr)
        if(!createNewFragment(pid,fp))
          return false;

      // update the expiry time

      fp->expiryTime=_utilityObjects->getRtc().getTick()+_params.ip_fragmentExpirySeconds;

      // get the fragment offset

      offset=packet.getFragmentOffset();
      extendedLength=offset+packet.payloadLength;

      // if the memory buffer holding the packet being assembled is too small
      // then increase it

      if(extendedLength>fp->packetLength) {

        // can we handle it based on the max packet length restriction

        if(extendedLength>_params.ip_maxPacketLength) {
          ip_freePacket(fp);
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_IP_PACKET_REASSEMBLER,E_PACKET_TOO_BIG);
        }

        // can we handle it based on the overal memory usage cap

        if(_totalFragmentSize-fp->packetLength+extendedLength>_params.ip_maxFragmentedPacketMemoryUsage) {
          ip_freePacket(fp);
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_IP_PACKET_REASSEMBLER,E_MEMORY_LIMIT_EXCEEDED);
        }

        // if this is not the last fragment then we allocate an extra 8 bytes on the end for
        // the hole descriptor that will inevitably be required to describe the packet fragment
        // that must eventually land there.

        extra=packet.isLastFragment() ? 0 : 8;

        // increase the size of the fragment

        if((fp->packet=reinterpret_cast<uint8_t *>(realloc(fp->packet,extendedLength+extra)))==nullptr) {
          ip_freePacket(fp);
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_IP_PACKET_REASSEMBLER,E_OUT_OF_MEMORY);
        }

        // update the new total size (take off the old known size and add back on the new known size)

        _totalFragmentSize=_totalFragmentSize-fp->packetLength+extendedLength;

        // set the new fragment length

        fp->packetLength=extendedLength;
      }

      // deal with the hole list

      fp->handleHoleList(packet);

      // copy in the new fragment and return. the caller will check for nullptr in fp->firstHole
      // to indicate that the fragment is complete

      memcpy(&fp->packet[offset],packet.payload,packet.payloadLength);
      return true;
    }


    /**
     * Expire old entries that have timed out. Always called on the RTC tick IRQ handler. Never
     * call this on non-IRQ code because the critical section won't work.
     * @param nitd Network interval data
     */

    void IpPacketReassemblerFeature::expireOldEntries(NetworkIntervalTickData& nitd) {

      // ensure any higher priority IRQs can't come along and pre-empt us

      IrqSuspend suspender;

      // check each entry and delete if expired

      for(auto it=_frags.begin();it!=_frags.end();) {

        if(nitd.timeNow>(*it)->expiryTime) {

          _totalFragmentSize-=(*it)->packetLength;
          _inFlightPacketCount--;

          delete *it;
          it=_frags.erase(it);
        }
        else
          it++;
      }
    }


    /**
     * Free a packet and take it out of the linked list and update
     * all statuses
     * @param fp The packet to free
     */

    void IpPacketReassemblerFeature::ip_freePacket(IpFragmentedPacket *packetToFree) {

      // ensure we cannot be interrupted

      IrqSuspend suspender;

      // find and free the packet

      for(auto it=_frags.begin();it!=_frags.end();it++) {
        if(*it==packetToFree) {
          _frags.erase(it);
          break;
        }
      }

      // free the data, update counts

      _totalFragmentSize-=packetToFree->packetLength;
      _inFlightPacketCount--;

      // free packet structure

      delete packetToFree;
    }


    /**
     * Find a fragmented packet in the list of in-progress fragments
     * @param pid the id of the packet to find
     * @return the fragments so far or nullptr
     */

    IpFragmentedPacket *IpPacketReassemblerFeature::findFragment(const IpFragmentedPacket::PacketId& pid) const {

      for(auto it=_frags.begin();it!=_frags.end();it++)
        if((*it)->identifier==pid)
          return *it;

      return nullptr;
    }


    /**
     * Create a new fragment, add to the list and return the FragmentedPacket structure
     * @param pid The packet id
     * @param[out] fp The new FragmentedPacket structure
     * @return true if it works, false if a limit is exceeded
     */

    bool IpPacketReassemblerFeature::createNewFragment(IpFragmentedPacket::PacketId pid,IpFragmentedPacket *&fp) {

      // check for the maximum fragmented packets

      if(_frags.size()==_params.ip_maxInProgressFragmentedPackets)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_IP_PACKET_REASSEMBLER,E_TOO_MANY_FRAGMENTED_PACKETS);

      // create the new entry (expiry time is not set here)

      fp=new IpFragmentedPacket(pid);

      // link it in at the front

      _frags.push_front(fp);

      // update the inflight count and memory usage

      _inFlightPacketCount++;
      _totalFragmentSize+=fp->packetLength;

      return true;
    }
  }
}


#endif
// END FILE: ../lib/src/net/network/ip/features/IpPacketReassemblerFeature.cpp
// START FILE: ../lib/src/net/network/ip/features/IpPacketFragmentFeature.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"

#if defined(STM32PLUS_F4_HAS_MAC) || defined(STM32PLUS_F1_CL_E)

#include "config/net.h"


namespace stm32plus {
  namespace net {


    /**
     * Create an IPv4 fragment collection from the input buffer.
     * @param inputBuffer[in] The input buffer to fragment
     * @param outputBuffers[out] The collection of output buffers. This should be free'd
     *   using free() when the buffers have been accepted by the link layer. Do NOT
     *   use operator delete[] because that would destroy the objects whose ownership
     *   has been transferred to the link layer.
     * @param outputBufferCount[out] The number of net buffers in the output
     * @param mtu The max MTU size for the link layer (excluding its own headers)
     * @param linkHeaderSize The size of the headers for the link layer
     * @param protocol The IP protocol in this packet
     * @param myIpAddress this IP address
     * @param destinationIpAddress the target address
     * @return true if it worked. false if it failed.
     */

    bool IpPacketFragmentFeature::ip_createFragments(
                                    IpProtocol protocol,
                                    const IpAddress& myIpAddress,
                                    const IpAddress& destinationIpAddress,
                                    uint16_t mtu,
                                    uint16_t linkHeaderSize,
                                    NetBuffer *inputBuffer,
                                    NetBuffer **&outputBuffers,
                                    uint16_t& outputBufferCount) {

      uint16_t i;

      _mtu=mtu;
      _linkHeaderSize=linkHeaderSize;

      // MTU - IP_HEADER_SIZE must be a multiple of 8 bytes. reduce it to the
      // nearest multiple if it's not

      _mtu=((_mtu-IpPacketHeader::getNoOptionsHeaderSize()) & ~7)+IpPacketHeader::getNoOptionsHeaderSize();

      // start with a new ID (first = 1)

      _identification++;

      // The STM32 MAC cannot do checksum offload for fragmented packets so we offer the option
      // to do it in software for UDP packets.

      if(_params.ip_checksumOnLargeUdpPackets && protocol==IpProtocol::UDP)
        InternetChecksum::calculate(myIpAddress,destinationIpAddress,*inputBuffer);

      // work out how many fragments we need. we fragment the internal buffer and the
      // user buffer separately resulting in one more fragment than is strictly
      // necessary in some cases

      outputBufferCount=fragmentsRequired(inputBuffer->getSizeFromWritePointerToEnd())
                       +fragmentsRequired(inputBuffer->getUserBufferSize());

      // allocate for the output buffers

      outputBuffers=reinterpret_cast<NetBuffer **>(malloc(sizeof(NetBuffer)*outputBufferCount));
      if(outputBuffers==nullptr)
        return false;

      memset(outputBuffers,0,sizeof(NetBuffer *)*outputBufferCount);

      // attempt to do the fragmentation

      if(internalCreateFragments(inputBuffer,outputBuffers))
        return true;

      // failed, clean up any memory allocated and return failure

      for(i=0;i<outputBufferCount;i++)
        if(outputBuffers[i])
          delete outputBuffers[i];

      free(outputBuffers);
      outputBuffers=nullptr;

      return false;
    }


    /*
     * Create fragments, internal function. buffers and count are set up.
     */

    bool IpPacketFragmentFeature::internalCreateFragments(NetBuffer *inputBuffer,NetBuffer **&outputBuffers) {

      uint16_t offset;

      // first fragment the internal buffer - there will at least
      // be a header in here from the upper layers

      offset=0;

      if(!createFragmentsFrom(inputBuffer,
                              inputBuffer->getWritePointer(),
                              inputBuffer->getSizeFromWritePointerToEnd(),
                              outputBuffers,
                              0,
                              inputBuffer->getUserBufferSize()==0,
                              offset))
        return false;

      // if there's no user data then that's it

      if(inputBuffer->getUserBufferSize()==0)
        return true;

      // finally fragment the user data

      return createFragmentsFrom(inputBuffer,
                                 inputBuffer->getUserBuffer(),
                                 inputBuffer->getUserBufferSize(),
                                 outputBuffers,
                                 fragmentsRequired(inputBuffer->getSizeFromWritePointerToEnd()),
                                 true,
                                 offset);
    }


    /**
     * Create a run of fragmented packets from this data
     * @param inputBuffer The netbuffer containing the data to fragment
     * @param sourceData The source data to fragment
     * @param sourceDataSize The size of sourceData in bytes
     * @param isInternalBufferData true if this data is coming from the internal buffer
     * @param outputBuffers Where to store the netbuffers containing the fragments
     * @param firstOutputBuffer The index of the first netbuffer to store the fragments in
     * @param lastFragmentIsHere true if the last fragment in this packet is in this data
     * @return true if it worked. false means out of memory.
     */

    bool IpPacketFragmentFeature::createFragmentsFrom(NetBuffer *inputBuffer,
                                                       const void *sourceData,
                                                       uint16_t sourceDataSize,
                                                       NetBuffer **outputBuffers,
                                                       uint16_t firstOutputBuffer,
                                                       bool lastFragmentIsHere,
                                                       uint16_t& offset) {

      NetBuffer *nb;
      uint16_t fragmentSize,flags;
      const uint8_t *ptr;

      ptr=reinterpret_cast<const uint8_t *>(sourceData);

      while(sourceDataSize) {

        // calculate sizes

        fragmentSize=sourceDataSize<_mtu-IpPacketHeader::getNoOptionsHeaderSize() ?
                      sourceDataSize :
                      _mtu-IpPacketHeader::getNoOptionsHeaderSize();

        // create a new netbuffer for the fragment

        nb=new NetBuffer(_linkHeaderSize+IpPacketHeader::getNoOptionsHeaderSize(),  // needs IP and link layer headers
                         0,
                         ptr,                                 // fragment data starts here
                         fragmentSize);                       // size of this fragment

        // more fragments flag if this is not the last in the run

        if(lastFragmentIsHere && fragmentSize==sourceDataSize) {

          // this is the last

          flags=0;
          nb->setReference(inputBuffer);
        }
        else
          flags=MORE_FRAGMENTS;

        // insert the IP fragment header

        IpPacketHeader *header=reinterpret_cast<IpPacketHeader *>(nb->moveWritePointerBack(IpPacketHeader::getNoOptionsHeaderSize()));

        // set up only the parts that are unique to the fragmenter

        header->ip_hdr_length=NetUtil::htons(IpPacketHeader::getNoOptionsHeaderSize()+fragmentSize);
        header->ip_hdr_identification=_identification;
        header->ip_hdr_flagsAndOffset=NetUtil::htons((offset/8) | flags);

        // store the netbuffer in the array

        outputBuffers[firstOutputBuffer++]=nb;

        // update pointers

        ptr+=fragmentSize;
        sourceDataSize-=fragmentSize;
        offset+=fragmentSize;
      }

      return true;
    }


    /**
     * Calculate the number of fragments required to send 'size' bytes with an
     * @param mtu The max MTU size of the link layer
     * @param size The number of bytes to send
     * @return The number of fragments required
     */

    uint32_t IpPacketFragmentFeature::fragmentsRequired(uint16_t size) {
      return size/(_mtu-IpPacketHeader::getNoOptionsHeaderSize())+(size % (_mtu-IpPacketHeader::getNoOptionsHeaderSize()) ? 1 : 0);
    }
  }
}


#endif
// END FILE: ../lib/src/net/network/ip/features/IpPacketFragmentFeature.cpp
// START FILE: ../lib/src/net/network/ip/InternetChecksum.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4_HAS_MAC) || defined(STM32PLUS_F1_CL_E)

#include "config/net.h"


namespace stm32plus {
  namespace net {


    /**
     * Calculate the checksum for a UDP packet
     * @param sourceAddress Our IP address
     * @param destinationAddress The destination IP address
     * @param protocol The internet protocol - which must be UDP for this overload
     * @param nb The netbuffer containing the UDP packet including the header
     */

    void InternetChecksum::calculate(const IpAddress& sourceAddress,const IpAddress& destinationAddress,NetBuffer& nb) {

      PseudoHeader ph;
      uint32_t sum,bufferSize;
      uint16_t temp;
      UdpDatagram *datagram;
      const uint8_t *ptr;

      // the internal buffer is always there and always has the UDP header

      datagram=reinterpret_cast<UdpDatagram *>(nb.getWritePointer());

      // set up the pseudo-header

      ph.sourceAddress=sourceAddress;
      ph.destinationAddress=destinationAddress;
      ph.zero=0;
      ph.protocol=IpProtocol::UDP;
      ph.length=datagram->udp_length;

      // sum the pseudo-header

      sum=0;
      sumit(&ph,sizeof(PseudoHeader),sum);

      // sum the internal buffer - the UDP API guarantees that there will be an internal buffer

      ptr=static_cast<uint8_t *>(nb.getWritePointer());
      bufferSize=nb.getSizeFromWritePointerToEnd();

      sumit(ptr,bufferSize & ~1,sum);

      // if there's one left, get it

      if((bufferSize & 1)!=0) {

        if(nb.getUserBufferSize()) {

          temp=ptr[bufferSize-1];

          ptr=static_cast<const uint8_t *>(nb.getUserBuffer());
          temp=(temp << 8) | *ptr++;

          bufferSize=nb.getUserBufferSize()-1;
          sumit(&temp,2,sum);
        }
      }
      else {
        if(nb.getUserBufferSize()) {
          ptr=static_cast<const uint8_t *>(nb.getUserBuffer());
          bufferSize=nb.getUserBufferSize();
        }
      }

      // if there's a user buffer, sum it

      if(nb.getUserBufferSize())
        sumit(ptr,bufferSize & ~1,sum);

      // take care of any left over byte

      if((bufferSize & 1)!=0)
        sum+=ptr[bufferSize-1];

      while(sum >> 16)
        sum=(sum & 0xFFFF)+(sum >> 16);

      // insert the complement into the datagram checksum

      datagram->udp_checksum=~sum;
    }


    /**
     * Sum up a buffer up to the last even byte
     * @param vptr buffer address
     * @param length length in bytes
     * @param[in,out] sum The running total
     */

    void InternetChecksum::sumit(const void *vptr,uint16_t length,uint32_t& sum) {

      const uint16_t *ptr;

      ptr=reinterpret_cast<const uint16_t *>(vptr);
      length>>=1;

      while(length--) {

        sum+=*ptr++;

        if(sum & 0x80000000)    // if high order bit set, fold
          sum=(sum & 0xFFFF) + (sum >> 16);
      }
    }
  }
}

#endif
// END FILE: ../lib/src/net/network/ip/InternetChecksum.cpp
// START FILE: ../lib/src/net/datalink/mac/MacBase.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"

#if defined(STM32PLUS_F4_HAS_MAC) || defined(STM32PLUS_F1_CL_E)

#include "config/net.h"


// Global pointer for last received frame infos

extern "C" ETH_DMA_Rx_Frame_infos *DMA_RX_FRAME_infos;


namespace stm32plus {
  namespace net {


    /**
     * Startup the class
     * @return true if it worked
     */

    bool MacBase::startup() {

      // announce our MAC address to everyone

      this->NetworkNotificationEventSender.raiseEvent(MacAddressAnnouncementEvent(_params.mac_address));
      return true;
    }


    /**
     * Initialise
     * @param params parameters structure
     * @return true
     */

    bool MacBase::initialise(const Parameters& params) {

      ETH_DMADESCTypeDef *txdesc;
      int i;

      // save parameters

      _params=params;

      // subscribe to send and notify events

      this->NetworkSendEventSender.insertSubscriber(NetworkSendEventSourceSlot::bind(this,&MacBase::onSend));

      // set our MAC address

      ETH_MACAddressConfig(ETH_MAC_Address0,const_cast<uint8_t *>(params.mac_address.macAddress));

      // initialise the receive descriptor chain

      _receiveDmaDescriptors.reset(new ETH_DMADESCTypeDef[params.mac_receiveBufferCount]);
      _receiveBuffers.reset(new uint8_t[params.mac_receiveBufferCount][ETH_MAX_PACKET_SIZE]);
      ETH_DMARxDescChainInit(&_receiveDmaDescriptors[0],&_receiveBuffers[0][0],params.mac_receiveBufferCount);

      // enable interrupts on all the receive buffers

      for(i=0;i<params.mac_receiveBufferCount;i++)
        ETH_DMARxDescReceiveITConfig(&_receiveDmaDescriptors[i],ENABLE);

      // initialise the transmit descriptor ring

      _transmitDmaDescriptors.reset(new ETH_DMADESCTypeDef[params.mac_transmitBufferCount]);
      _transmitNetBuffers.reset(new NetBuffer *[params.mac_transmitBufferCount]);
      txdesc=_transmitDmaDescriptors.get();

      // initialise the transmit ring buffer. the DMA descriptors are in contiguous memory blocks
      // and we make full use of the ability to transmit up to 2 blocks per descriptor

      for(i=0;i<params.mac_transmitBufferCount;i++) {

        txdesc->Status=ETH_DMATxDesc_IC;        // interrupt on complete
        txdesc->Buffer1Addr=0;                  // not yet, nothing to send
        txdesc->Buffer2NextDescAddr=0;          // not yet, nothing to send

        if(i==params.mac_transmitBufferCount-1)
          txdesc->Status|=ETH_DMATxDesc_TER;    // end of ring

        // clear out the NetBuffer pointer associated with this entry

        _transmitNetBuffers[i]=nullptr;

        // advance to next buffer

        txdesc++;
      }

      // set the base table address

      ETH->DMATDLAR=reinterpret_cast<uint32_t>(_transmitDmaDescriptors.get());

      // this is the next one to consider sending

      _transmitBufferIndex=0;
      return true;
    }


    /**
     * Handle the receive DMA interrupt. Set up an EthernetFrame structure and notify observers. If an
     * error occurred, notify of the error
     */

    void MacBase::handleReceiveInterrupt() {

      FrameTypeDef frame;

      // loop over received frames

      for(frame=ETH_Get_Received_Frame_interrupt(_params.mac_receiveBufferCount);frame.buffer;frame=ETH_Get_Received_Frame_interrupt(_params.mac_receiveBufferCount))
        processReceivedFrame(frame);
    }


    /**
     * Fully process a received frame
     * @param frame The frame definition to process
     */

    void MacBase::processReceivedFrame(const FrameTypeDef& frame) {

      volatile ETH_DMADESCTypeDef *DMARxNextDesc;
      uint32_t i,context;
      EthernetFrame ef;

      // check for errors (_ES is the OR of all error flags into one bit)

      if((frame.descriptor->Status & ETH_DMARxDesc_ES)!=0) {

        // an error has occurred

        switch(frame.descriptor->Status & (ETH_DMARxDesc_CE | ETH_DMARxDesc_RE | ETH_DMARxDesc_RWT | ETH_DMARxDesc_LC | ETH_DMARxDesc_IPV4HCE | ETH_DMARxDesc_OE | ETH_DMARxDesc_DE)) {

          case ETH_DMARxDesc_CE:
            context=E_CRC;
            break;

          case ETH_DMARxDesc_RE:
            context=E_RECEIVE;
            break;

          case ETH_DMARxDesc_RWT:
            context=E_WATCHDOG;
            break;

          case ETH_DMARxDesc_LC:
            context=E_LATE_COLLISION;
            break;

          case ETH_DMARxDesc_IPV4HCE:
            context=E_IP_HEADER_CHECKSUM;
            break;

          case ETH_DMARxDesc_OE:
            context=E_OVERFLOW;
            break;

          case ETH_DMARxDesc_DE:
            context=E_TRUNCATED;
            break;

          default:
            context=E_UNSPECIFIED;
            break;
        }

        // notify the observers of the error

        this->setError(ErrorProvider::ERROR_PROVIDER_NET_MAC,context);
      }
      else {

#if defined(USE_ENHANCED_DMA_DESCRIPTORS)

        if((frame.descriptor->Status & (ETH_DMARxDesc_LS | ETH_DMARxDesc_MAMPCE))==(ETH_DMARxDesc_LS | ETH_DMARxDesc_MAMPCE)) {

          // extended info is available, check for errors in RDES4

          if((frame.descriptor->ExtendedStatus & (ETH_DMAPTPRxDesc_IPPE | ETH_DMAPTPRxDesc_IPHE))!=0) {

            // set the error code

            if((frame.descriptor->ExtendedStatus & ETH_DMAPTPRxDesc_IPPE)!=0)
              context=E_PAYLOAD;
            else
              context=E_HEADER;

            // notify observers of the error (PE = payload, HE= header)

            this->setError(ErrorProvider::ERROR_PROVIDER_NET_MAC,context);
          }
          else {

            // set the various frame detection flags

            if((frame.descriptor->ExtendedStatus & ETH_DMAPTPRxDesc_IPV4PR)!=0)
              ef.flags|=EthernetFrame::FLAG_IP;
            else if((frame.descriptor->ExtendedStatus & ETH_DMAPTPRxDesc_IPV6PR)!=0)
              ef.flags|=EthernetFrame::FLAG_IP6;

            if((frame.descriptor->ExtendedStatus & ETH_DMAPTPRxDesc_IPPT_UDP)!=0)
              ef.flags|=EthernetFrame::FLAG_UDP;
            else if((frame.descriptor->ExtendedStatus & ETH_DMAPTPRxDesc_IPPT_TCP)!=0)
              ef.flags|=EthernetFrame::FLAG_TCP;
            else if((frame.descriptor->ExtendedStatus & ETH_DMAPTPRxDesc_IPPT_ICMP)!=0)
              ef.flags|=EthernetFrame::FLAG_ICMP;

            // extended frame with possible flags received

            if(setupEthernetFrame(frame,ef))
              NetworkReceiveEventSender.raiseEvent(DatalinkFrameEvent(ef));
          }
        }
        else {

          // basic frame with no extended info received OK

          if(setupEthernetFrame(frame,ef))
            NetworkReceiveEventSender.raiseEvent(DatalinkFrameEvent(ef));
        }
#else
        // basic frame with no extended info received OK

        if(setupEthernetFrame(frame,ef))
          NetworkReceiveEventSender.raiseEvent(DatalinkFrameEvent(ef));
#endif
      }

      // release descriptors to DMA
      // check if received frame with multiple DMA buffer segments

      if(DMA_RX_FRAME_infos->Seg_Count>1)
        DMARxNextDesc=DMA_RX_FRAME_infos->FS_Rx_Desc;
      else
        DMARxNextDesc=frame.descriptor;

      // set Own bit in Rx descriptors: gives the buffers back to DMA

      for(i=0;i<DMA_RX_FRAME_infos->Seg_Count;i++) {
        DMARxNextDesc->Status=ETH_DMARxDesc_OWN;
        DMARxNextDesc=(ETH_DMADESCTypeDef *)(DMARxNextDesc->Buffer2NextDescAddr);
      }

      // clear Segment_Count

      DMA_RX_FRAME_infos->Seg_Count=0;

      // When Rx Buffer unavailable flag is set: clear it and resume reception

      if((ETH->DMASR & ETH_DMASR_RBUS)!=(uint32_t)RESET) {

        // clear RBUS ETHERNET DMA flag

        ETH->DMASR=ETH_DMASR_RBUS;

        // Resume DMA reception

        ETH->DMARPDR=0;
      }
    }


    /**
     * Set up the EthernetFrame structure
     * @param fd The incoming frame definition
     * @param ef The extended EthernetFrame structure to fill in
     * @param true if it worked.
     */

    bool MacBase::setupEthernetFrame(const FrameTypeDef& fd,EthernetFrame& ef) const {

      EthernetFrameData *efd;

      efd=reinterpret_cast<EthernetFrameData *>(fd.buffer);

      // source and dest are mandatory

      ef.destinationMac=&efd->eth_destinationAddress;
      ef.sourceMac=&efd->eth_sourceAddress;
      ef.frameSource=DatalinkFrame::FrameSource::ETHERNET_FRAME;

      // qtag is optional and supported

      if(efd->eth_etherType==0x0081) {        // big-endian comparison for 0x8100

        EthernetTaggedFrameData *eftd;

        // get the protocol, which might be a length if 802.3 not v2.

        eftd=reinterpret_cast<EthernetTaggedFrameData *>(fd.buffer);
        ef.protocol=NetUtil::ntohs(eftd->eth_etherType);

        if(ef.protocol<0x0600) {

          EthernetTaggedSnapFrameData *etsfd;

          // this is an 802.3 frame with a qtag. if the D-S-C bytes indicate a SNAP frame then
          // we can handle it

          etsfd=reinterpret_cast<EthernetTaggedSnapFrameData *>(fd.buffer);

          if(etsfd->eth_dsap==0xaa && etsfd->eth_ssap==0xaa && etsfd->eth_control==0x03) {

            // set up the values from the SNAP frame with qtag

            ef.protocol=NetUtil::ntohs(etsfd->eth_etherType);
            ef.payload=etsfd->eth_data;
            ef.payloadLength=fd.length-offsetof(EthernetTaggedSnapFrameData,eth_data);
          }
          else
            return this->setError(ErrorProvider::ERROR_PROVIDER_NET_MAC,E_UNSUPPORTED_802_3_FRAME_FORMAT);
        }
        else {

          // it's a tagged ethernet v2 frame

          ef.payload=eftd->eth_data;
          ef.payloadLength=fd.length-offsetof(EthernetTaggedFrameData,eth_data);
        }
      }
      else {

        // no tag, get the protocol - which might be a length if this is a SNAP frame

        ef.protocol=NetUtil::ntohs(efd->eth_etherType);

        if(ef.protocol<0x0600) {

          EthernetSnapFrameData *esfd;

          // this is an 802.3 frame. if the D-S-C bytes indicate a SNAP frame then
          // we can handle it

          esfd=reinterpret_cast<EthernetSnapFrameData *>(fd.buffer);

          if(esfd->eth_dsap==0xaa && esfd->eth_ssap==0xaa && esfd->eth_control==0x03) {

            // set up the values from the SNAP frame with no qtag

            ef.protocol=NetUtil::ntohs(esfd->eth_etherType);
            ef.payload=esfd->eth_data;
            ef.payloadLength=fd.length-offsetof(EthernetSnapFrameData,eth_data);
          }
          else
            return this->setError(ErrorProvider::ERROR_PROVIDER_NET_MAC,E_UNSUPPORTED_802_3_FRAME_FORMAT);
        }
        else {

          // it's an ethernet v2 frame which we can handle

          ef.payload=efd->eth_data;
          ef.payloadLength=fd.length-offsetof(EthernetTaggedFrameData,eth_data);
        }
      }

      // it's OK

      return true;
    }


    /**
     * Send a frame over the ethernet. This high level method validates the net buffer
     * and tries to call the frame sender. If the MAC is busy and we are not in an IRQ context
     * then we'll retry sending for a configurable number of milliseconds.
     *
     * @param ned The event containing the data for the request
     */

    void MacBase::onSend(NetEventDescriptor& ned) {

      // must be an ethernet send request

      if(ned.eventType!=NetEventDescriptor::NetEventType::ETHERNET_TRANSMIT_REQUEST)
        return;

      EthernetTransmitRequestEvent& event=static_cast<EthernetTransmitRequestEvent&>(ned);
      EthernetFrameData *efd;

      // we cannot transmit data out of flash memory because the flash banks are
      // not connected to the Ethernet DMA bus on the STM32. More's the pity.

      uint32_t ub=reinterpret_cast<uint32_t>(event.networkBuffer->getUserBuffer());

      if(ub && IS_FLASH_ADDRESS(ub)) {
        delete event.networkBuffer;
        this->setError(ErrorProvider::ERROR_PROVIDER_NET_MAC,E_NO_FLASH_DATA);
        return;
      }

      // the NetBuffer needs to get an ethernet header

      efd=reinterpret_cast<EthernetFrameData *>(event.networkBuffer->moveWritePointerBack(getDatalinkTransmitHeaderSize()));

      efd->eth_destinationAddress=event.macAddress;
      efd->eth_sourceAddress=_params.mac_address;
      efd->eth_etherType=NetUtil::htons(static_cast<uint16_t>(event.etherType));

      uint32_t now=MillisecondTimer::millis();

      while(!sendBuffer(event.networkBuffer)) {

        if(errorProvider.isLastError(ErrorProvider::ERROR_PROVIDER_NET_MAC,E_BUSY)) {

          // DMA still has our TX descriptor. If we're not running in an IRQ context then we
          // can wait to see if it frees up

          if(Nvic::isAnyIrqActive()) {
            delete event.networkBuffer;
            return;
          }

          if(MillisecondTimer::hasTimedOut(now,_params.mac_txWaitMillis)) {
            delete event.networkBuffer;
            return;
          }
        }
        else {
          delete event.networkBuffer;
          return;         // other error
        }
      }

      // it was sent and the net buffer will be deleted when the TX interrupt is processed

      event.succeeded=true;
    }


    /**
     * Send the content of a NetBuffer via DMA. One NetBuffer contains exactly one frame which may be
     * in one or two buffers. When two buffers are used typically the first buffer contain all the
     * metadata in the form of headers and the second buffer is the user data to send.
     *
     * @param nb The buffer to send.
     * @return true if it worked
     */

    bool MacBase::sendBuffer(NetBuffer *nb) {

      // ensure we cannot be interrupted either by an IRQ if we are normal flow
      // or by a higher priority interrupt if we are an IRQ

      IrqSuspend suspender;

      // find the next buffer owned by the CPU with NetBuffer == nullptr (TDES0 OWN bit = 0)
      // it's important to consider NetBuffer == nullptr to avoid a race condition with the
      // IRQ handler that cleans up the NetBuffer

      ETH_DMADESCTypeDef& txdesc(_transmitDmaDescriptors[_transmitBufferIndex]);

      if((txdesc.Status & ETH_DMATxDesc_OWN)!=0 || _transmitNetBuffers[_transmitBufferIndex]!=nullptr)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_MAC,E_BUSY);

      // clear out the buffer1 and buffer2 size bits in TDES1

      txdesc.ControlBufferSize&=~(ETH_DMATxDesc_TBS2 | ETH_DMATxDesc_TBS1);

      // set up buffer1

      txdesc.Buffer1Addr=reinterpret_cast<uint32_t>(nb->getInternalBuffer());
      txdesc.ControlBufferSize|=nb->getInternalBufferSize();

      if(nb->getUserBufferSize()>0) {

        // there are two buffers, headers go out first followed by the user buffer
        // check that we will not exceed the MTU

        if(nb->getUserBufferSize()+nb->getInternalBufferSize()>_params.mac_mtu)
          return this->setError(ErrorProvider::ERROR_PROVIDER_NET_MAC,E_TOO_BIG);

        // set up buffer2

        txdesc.Buffer2NextDescAddr=reinterpret_cast<uint32_t>(nb->getUserBuffer());
        txdesc.ControlBufferSize|=nb->getUserBufferSize() <<  16;
      }
      else if(nb->getInternalBufferSize()>_params.mac_mtu)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_MAC,E_TOO_BIG);

      // this is the first and the last frame and DMA owns it now. OWN must be set before
      // the netbuffer pointer is inserted to avoid a race condition with the cleanup
      // code in the transmit interrupt handler.

      txdesc.Status&=~(ETH_DMATxDesc_ChecksumIPV4Header | ETH_DMATxDesc_ChecksumTCPUDPICMPFull | ETH_DMATxDesc_ChecksumByPass);

      if(nb->getChecksumRequest()==DatalinkChecksum::IP_HEADER)
        txdesc.Status|=ETH_DMATxDesc_ChecksumIPV4Header;
      else if(nb->getChecksumRequest()==DatalinkChecksum::IP_HEADER_AND_PROTOCOL)
        txdesc.Status|=ETH_DMATxDesc_ChecksumTCPUDPICMPFull;
      else
        txdesc.Status|=ETH_DMATxDesc_ChecksumByPass;

      txdesc.Status|=ETH_DMATxDesc_LS | ETH_DMATxDesc_FS | ETH_DMATxDesc_OWN;

      // set up the NetBuffer pointer in the transmit buffers array

      _transmitNetBuffers[_transmitBufferIndex]=nb;

      // move to the next, or back to the first

      if(_transmitBufferIndex==_params.mac_transmitBufferCount-1)
        _transmitBufferIndex=0;
      else
        _transmitBufferIndex++;

      // trigger DMA to poll for transmit buffers

      if((ETH->DMASR & ETH_DMASR_TBUS)!=0) {
        ETH->DMASR=ETH_DMASR_TBUS;
        ETH->DMATPDR=0;               // poll demand register
      }

      // done

      return true;
    }


    /**
     * A frame has been transmitted, release memory used by the NetBuffer
     * that held the memory
     */

    void MacBase::handleTransmitInterrupt() {

      uint16_t i;
      ETH_DMADESCTypeDef *txbuf;
      NetBuffer *nb;

      // loop over the small number of tx buffers

      txbuf=_transmitDmaDescriptors.get();
      for(i=0;i<_params.mac_transmitBufferCount;i++) {

        // if the CPU owns the descriptor and a buffer is present then it's finished
        // free the buffer and clear it out

        if((txbuf->Status & ETH_DMATxDesc_OWN)==0 && _transmitNetBuffers[i]!=nullptr) {

          // send a notification that a NetBuffer is being cleaned up. This can be used by
          // the receiver to synchronise frame send requests with the frame actually being
          // transmitted

          nb=_transmitNetBuffers[i];
          this->NetworkNotificationEventSender.raiseEvent(DatalinkFrameSentEvent(*nb));

          // if this is the last in a sequence of fragmented packets then there will be a referenced
          // netbuffer that is serving to hold the jumbo packet's memory in scope while the fragments
          // got tx'd. now that's done we're safe to delete it and we must also notify it upwards
          // because that's the buffer that anything waiting on will recognise.

          if(nb->getReference())
            this->NetworkNotificationEventSender.raiseEvent(DatalinkFrameSentEvent(*(nb->getReference())));

          // clean up the buffer

          delete _transmitNetBuffers[i];
          _transmitNetBuffers[i]=nullptr;
        }
      }
    }


    /**
     * Handle an error interrupt from the DMA
     * @param dmaStatus The DMA status register with the interrupt flags in it
     */

    void MacBase::handleErrorInterrupt(uint32_t dmaStatus) {

      int context;

      if((dmaStatus & ETH_DMA_FLAG_TPS)!=0)
        context=E_TRANSMIT_PROCESS_STOPPED;
      else if((dmaStatus & ETH_DMA_FLAG_TJT)!=0)
        context=E_TRANSMIT_JABBER_TIMEOUT;
      else if((dmaStatus & ETH_DMA_FLAG_RO)!=0)
        context=E_RECEIVE_OVERFLOW;
      else if((dmaStatus & ETH_DMA_FLAG_TU)!=0)
        context=E_TRANSMIT_UNDERFLOW;
      else if((dmaStatus & ETH_DMA_FLAG_RBU)!=0)
        context=E_RECEIVE_BUFFER_UNAVAILABLE;
      else if((dmaStatus & ETH_DMA_FLAG_RPS)!=0)
        context=E_RECEIVE_PROCESS_STOPPED;
      else if((dmaStatus & ETH_DMA_FLAG_RWT)!=0)
        context=E_RECEIVE_WATCHDOG_TIMEOUT;
      else if((dmaStatus & ETH_DMA_FLAG_FBE)!=0)
        context=E_FATAL_BUS_ERROR;
      else
        context=E_UNSPECIFIED;

      this->setError(ErrorProvider::ERROR_PROVIDER_NET_MAC,context);
    }
  }
}


#endif
// END FILE: ../lib/src/net/datalink/mac/MacBase.cpp
// START FILE: ../lib/src/net/datalink/mac/interrupts/EthernetInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4_HAS_MAC) || defined(STM32PLUS_F1_CL_E)

#include "config/net.h"


using namespace stm32plus::net;


/**
 * Static instance pointer back into the mac class
 */

MacBase *MacBase::_instance=NULL;


extern "C" {

  /**
   * Ethernet IRQ handler
   */

  void __attribute__ ((interrupt("IRQ"))) ETH_IRQHandler(void) {

    // receive interrupt

    if(ETH_GetDMAFlagStatus(ETH_DMA_FLAG_R)==SET) {

      // clear the interrupt flags before servicing the interrupt. This will prevent a race condition
      // where an interrupt is raised in the short period between us finishing processing and then
      // clearing the interrupt flag before returning. The drawback is that we may receive an interrupt
      // for an already-processed frame which we will detect and return quickly with no harm done.

      ETH_DMAClearITPendingBit(ETH_DMA_IT_R | ETH_DMA_IT_NIS);      // NIS = normal interrupt summary
      MacBase::_instance->handleReceiveInterrupt();
    }

    // transmit interrupt

    if(ETH_GetDMAFlagStatus(ETH_DMA_FLAG_T)==SET) {

      // clear the interrupt flags and process the interrupt. Again this may result in an an
      // un-necessary, harmless interrupt as we avoid the race condition that would occur because
      // we cannot atomically finish processing and clear the interrupt flag.

      ETH_DMAClearITPendingBit(ETH_DMA_IT_T | ETH_DMA_IT_NIS);      // NIS = normal interrupt summary
      MacBase::_instance->handleTransmitInterrupt();
    }

    if(ETH_GetDMAFlagStatus(ETH_DMA_FLAG_AIS)==SET) {   // AIS = abnormal interrupt summary

      MacBase::_instance->handleErrorInterrupt(ETH->DMASR);

      // clear the interrupt flags

      ETH_DMAClearITPendingBit(
          ETH_DMA_IT_AIS | ETH_DMA_IT_TPS | ETH_DMA_IT_TJT | ETH_DMA_IT_RO | ETH_DMA_IT_TU |
          ETH_DMA_IT_RBU | ETH_DMA_IT_RPS | ETH_DMA_IT_RWT | ETH_DMA_IT_ET | ETH_DMA_IT_FBE);
    }

    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}


#endif
// END FILE: ../lib/src/net/datalink/mac/interrupts/EthernetInterruptHandler.cpp
// START FILE: ../lib/src/net/transport/tcp/TcpConnection.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4_HAS_MAC) || defined(STM32PLUS_F1_CL_E)

#include "config/net.h"


namespace stm32plus {
  namespace net {


    /**
     * Constructor when creating a connection from an incoming connection to a TcpServer. This is IRQ code.
     * @param networkUtilityObjects utility objects
     * @param tcpEvents TCP events
     * @param segmentEvent The event that triggered the server
     * @param segmentSizeLimit The MSS limit for this server
     * @param additionalHeaderSize Number of bytes required for lower layer headers
     */

    bool TcpConnection::initialise(NetworkUtilityObjects& networkUtilityObjects,
                                   TcpEvents& tcpEvents,
                                   TcpSegmentEvent& segmentEvent,
                                   uint16_t segmentSizeLimit,
                                   uint16_t additionalHeaderSize) {

      const TcpOptionMaximumSegmentSize *mss;

      // remember parameters

      _networkUtilityObjects=&networkUtilityObjects;
      _tcpEvents=&tcpEvents;
      _segmentSizeLimit=segmentSizeLimit;
      _additionalHeaderSize=additionalHeaderSize;
      _lastZeroWindowPollTime=0;

      // create the receive buffer

      _receiveBuffer=new TcpReceiveBuffer(_params.tcp_receiveBufferSize);

      // set up the class

      initialise(segmentEvent.ipPacket.header->ip_sourceAddress,
                 segmentEvent.sourcePort,
                 segmentEvent.destinationPort);

      // pull out the state variables from the remote side

      _state.rxWindow.receiveNext=NetUtil::ntohl(segmentEvent.tcpHeader.tcp_sequenceNumber);
      _state.txWindow.sendWindow=NetUtil::ntohs(segmentEvent.tcpHeader.tcp_windowSize);

      // find the MSS option

      if((mss=segmentEvent.tcpHeader.findOption<TcpOptionMaximumSegmentSize>())==nullptr)
        _remoteMss=536;                 // default from the RFC
      else
        _remoteMss=NetUtil::ntohs(mss->tcp_optionMss);

      // this is an incoming client connection to our server. we need to send a SYN-ACK

      _state.localPortIsEphemeral=false;
      _state.changeState(*_networkUtilityObjects,TcpState::SYN_RCVD);

      return sendSynAck();
    }


    /**
     * Constructor when creating a client for an outgoing connection to a server.
     * @param networkUtilityObjects utility objects
     * @param tcpEvents TCP events
     * @param segmentSizeLimit The MSS limit for this server
     * @param additionalHeaderSize Number of bytes required for lower layer headers
     */

    bool TcpConnection::initialise(NetworkUtilityObjects& networkUtilityObjects,
                                   TcpEvents& tcpEvents,
                                   const IpAddress& remoteAddress,
                                   uint16_t localPort,
                                   uint16_t remotePort,
                                   uint16_t segmentSizeLimit,
                                   uint16_t additionalHeaderSize) {

      // remember parameters

      _networkUtilityObjects=&networkUtilityObjects;
      _tcpEvents=&tcpEvents;
      _segmentSizeLimit=segmentSizeLimit;
      _additionalHeaderSize=additionalHeaderSize;
      _lastZeroWindowPollTime=0;

      // create the receive buffer

      _receiveBuffer=new TcpReceiveBuffer(_params.tcp_receiveBufferSize);

      // set up the class

      initialise(remoteAddress,remotePort,localPort);

      // no state variables from the remote side yet

      _state.rxWindow.receiveNext=0;
      _state.txWindow.sendWindow=0;

      // this is an incoming client connection to our server. we need to send a SYN-ACK

      _state.localPortIsEphemeral=true;
      _state.changeState(*_networkUtilityObjects,TcpState::SYN_SENT);

      return sendSyn();
    }


    /**
     * Destructor
     */

    TcpConnection::~TcpConnection() {

      // unsubscribe from notification events

      _networkUtilityObjects->NetworkNotificationEventSender.removeSubscriber(NetworkNotificationEventSourceSlot::bind(this,&TcpConnection::onNotification));

      // unsubscribe from receive events

      _tcpEvents->TcpReceiveEventSender.removeSubscriber(TcpReceiveEventSourceSlot::bind(this,&TcpConnection::onReceive));

      // notify that we've been released. depending on our state, the connection may be moved into the
      // closing handler

      _networkUtilityObjects->NetworkNotificationEventSender.raiseEvent(TcpConnectionReleasedEvent(*this));

      // delete the receive buffer

      delete _receiveBuffer;
    }


    /**
     * Initialise the class members and subscriptions
     * @param remoteAddress IP address of the remote end
     * @param remotePort The remote port
     * @param localPort The local port
     */

    void TcpConnection::initialise(const IpAddress& remoteAddress,uint16_t remotePort,uint16_t localPort) {

      _state.changeState(*_networkUtilityObjects,TcpState::CLOSED);
      _state.additionalHeaderSize=_additionalHeaderSize;

      _state.localPort=localPort;
      _state.remotePort=remotePort;
      _state.remoteAddress=remoteAddress;

      // the receive window is not currently closed

      _receiveWindowIsClosed=false;

      // set the last active time to now

      _lastActiveTime=MillisecondTimer::millis();

      // generate a random initial sequence number. Yes this is wrong according to the host requirements RFC but we're
      // not in a position to maintain a continuously incrementing 4us timer. OK to cast off the volatile here.

      _networkUtilityObjects->nextRandom(const_cast<uint32_t&>(_state.txWindow.sendNext));
      _state.txWindow.sendNext&=0x7FFFFFFF;

      _state.txWindow.sendUnacknowledged=_state.txWindow.sendNext;
      _state.rxWindow.receiveWindow=_receiveBuffer->availableToWrite();

      // subscribe to notification events

      _networkUtilityObjects->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&TcpConnection::onNotification));

      // subscribe to segment receive events

      _tcpEvents->TcpReceiveEventSender.insertSubscriber(TcpReceiveEventSourceSlot::bind(this,&TcpConnection::onReceive));
    }


    /**
     * Callback from our subscription to notification events
     * @param ned The event descriptor
     */

    void TcpConnection::onNotification(NetEventDescriptor& ned) {

      if(ned.eventType==NetEventDescriptor::NetEventType::TCP_FIND_CONNECTION)
        handleFindConnectionEvent(static_cast<TcpFindConnectionNotificationEvent&>(ned));
    }


    /**
     * Segment received event. This is IRQ code.
     * @param event The event
     */

    void TcpConnection::onReceive(TcpSegmentEvent& event) {

      // must be for this connection

      if(event.ipPacket.header->ip_sourceAddress!=_state.remoteAddress ||
         _state.localPort!=event.destinationPort ||
         _state.remotePort!=event.sourcePort)
        return;

      // it's for us, so it's considered handled even if we drop it

      event.handled=true;

      // see what we've been sent

      if(event.tcpHeader.hasRst())
        handleIncomingRst();
      else {

        // check for SYN-ACK

        if(event.tcpHeader.hasSyn() && event.tcpHeader.hasAck())
          handleIncomingSynAck(event.tcpHeader);
        else {

          if(event.tcpHeader.hasAck())
            handleIncomingAck(event.tcpHeader,event.payloadLength!=0);

          if(event.payloadLength>0)
            handleIncomingData(event);

          if(event.tcpHeader.hasFin())
            handleIncomingFin(event);
        }

        // store the latest sender window size - it can change on any incoming segment

        _state.txWindow.sendWindow=NetUtil::ntohs(event.tcpHeader.tcp_windowSize);
      }
    }


    /**
     * Handle a FIN (remote close) coming from the other side.
     * Change the state to CLOSE_WAIT and send a notification.
     *
     * This is IRQ code
     */

    void TcpConnection::handleIncomingFin(TcpSegmentEvent& event) {

      uint32_t rxnext;

      // the sequence number must be in order. if the segments have got out of order on
      // the network then there could be data to come before this FIN

      rxnext=NetUtil::ntohl(event.tcpHeader.tcp_sequenceNumber);
      if(rxnext!=_state.rxWindow.receiveNext)
        return;

      // change our state

      _state.changeState(*_networkUtilityObjects,TcpState::CLOSE_WAIT);

      // ACK the FIN so the connection is now half-closed

      _state.rxWindow.receiveNext++;
      _state.sendAck(*_networkUtilityObjects,sillyWindowAvoidance());

      // notify

      TcpConnectionClosedEventSender.raiseEvent(TcpConnectionClosedEvent(*this));
    }


    /**
     * Handle some incoming data from the remote end. This is IRQ code.
     * @param event The segment event
     */

    void TcpConnection::handleIncomingData(const TcpSegmentEvent& event) {

      uint32_t rxnext;

      // we've become active

      _lastActiveTime=MillisecondTimer::millis();

      // we can only handle sequential data. if the sequence number on the incoming packet is
      // not what we expect then we drop the segment because an earlier segment has either got
      // lost or been overtaken on the network. the sender will have to resend.

      rxnext=NetUtil::ntohl(event.tcpHeader.tcp_sequenceNumber);

      if(rxnext==_state.rxWindow.receiveNext) {

        // the data size cannot be greater than the write space available in the buffer. If it
        // is then the sender is most likely probing a zero window that we have advertised.

        if(event.payloadLength<=_receiveBuffer->availableToWrite()) {

          // write the data into the buffer

          _receiveBuffer->write(event.payload,event.payloadLength);

          // update our variables

          _state.rxWindow.receiveNext+=event.payloadLength;
          _state.rxWindow.receiveWindow=_receiveBuffer->availableToWrite();
        }
      }

      // ack the current state

      _state.sendAck(*_networkUtilityObjects,sillyWindowAvoidance());

      // notify if there is some data to read

      if(_receiveBuffer->availableToRead()>0)
        TcpConnectionDataReadyEventSender.raiseEvent(TcpConnectionDataReadyEvent(*this));
    }


    /**
     * Handle an incoming ACK. We can handle any ACK that moves sendUnacknowledged forward. We are trusting
     * the remote not to ACK data that it hasn't received.
     * This is IRQ code.
     * @param header The TCP header
     * @param true if this segment contains data
     */

    void TcpConnection::handleIncomingAck(const TcpHeader& header,bool hasData) {

      uint32_t newSuna;

      // if the current state is SYN_RCVD then we can move to established

      if(_state.state==TcpState::SYN_RCVD)
        _state.changeState(*_networkUtilityObjects,TcpState::ESTABLISHED);

      // the gotcha here is to cater for 32-bit overflow while checking that the new s.una
      // is greater than the old which is necessary to avoid winding back the window by
      // accident when segments arrive out of order. We arbitrarily decide that a distance
      // of 2^31 between the pointers is sufficient to indicate a wrap.

      newSuna=NetUtil::ntohl(header.tcp_ackNumber);
      if((newSuna>_state.txWindow.sendUnacknowledged || _state.txWindow.sendUnacknowledged-newSuna>0x80000000))
        _state.txWindow.sendUnacknowledged=newSuna;
      else {

        // if the ACK has no data and did not move the window then re-ack our current state
        // possibly opening our window

        if(!hasData)
          _state.sendAck(*_networkUtilityObjects,sillyWindowAvoidance());
      }
    }


    /**
     * Handle an incoming SYN-ACK.
     * This is IRQ code.
     * @param header The TCP header
     */

    void TcpConnection::handleIncomingSynAck(const TcpHeader& header) {

      const TcpOptionMaximumSegmentSize *mss;

      // the only legal state is SYN_SENT

      if(_state.state!=TcpState::SYN_SENT)
        return;

      // that SYN cost us a sequence number

      _state.txWindow.sendNext++;

      // pull out the state variables from the remote side

      _state.rxWindow.receiveNext=NetUtil::ntohl(header.tcp_sequenceNumber)+1;
      _state.txWindow.sendWindow=NetUtil::ntohs(header.tcp_windowSize);

      // find the MSS option

      if((mss=header.findOption<TcpOptionMaximumSegmentSize>())==nullptr)
        _remoteMss=536;                 // default from the RFC
      else
        _remoteMss=NetUtil::ntohs(mss->tcp_optionMss);

      // we're established, as far as we know

      _state.changeState(*_networkUtilityObjects,TcpState::ESTABLISHED);

      // ACK their SYN-ACK

      _state.sendAck(*_networkUtilityObjects,sillyWindowAvoidance());
    }


    /**
     * Send a SYN segment to the server. This segment has no data. It contains the SYN flag plus our receive buffer
     * size and the MSS option.
     * @return true if it was sent
     */

    bool TcpConnection::sendSyn() {

      // create a NetBuffer to hold the SYN segment

      NetBuffer *nb=new NetBuffer(_additionalHeaderSize+TcpHeader::getNoOptionsHeaderSize(),4);

      // set up MSS (maximum segment size) option

      TcpOptionMaximumSegmentSize *mssOption=reinterpret_cast<TcpOptionMaximumSegmentSize *>(nb->moveWritePointerBack(4));
      mssOption->initialise(_segmentSizeLimit);

      // construct the header

      TcpHeader *header=reinterpret_cast<TcpHeader *>(nb->moveWritePointerBack(TcpHeader::getNoOptionsHeaderSize()));

      // we're acking the SYN, which costs the sender 1 sequence number

      header->initialise(_state.localPort,                          // ports
                         _state.remotePort,
                         _state.txWindow.sendNext,                  // initial sequence number
                         0,                                         // nothing to ACK
                         getReceiveBufferSpaceAvailable(),          // data space available
                         TcpHeaderFlags::SYN);

      // this header is larger than the minimum

      header->setSize(TcpHeader::getNoOptionsHeaderSize()+TcpOptionMaximumSegmentSize::getSize());

      // ask the IP layer to send the packet

      IpTransmitRequestEvent iptre(
          nb,
          _state.remoteAddress,
          IpProtocol::TCP);

      _networkUtilityObjects->NetworkSendEventSender.raiseEvent(iptre);
      return iptre.succeeded;
    }


    /**
     * Send a SYN-ACK segment back to our client. This segment has no data. It contains the SYN
     * and ACK flags plus our receive buffer size and the MSS option.
     * @return true if it worked
     */

    bool TcpConnection::sendSynAck() {

      // create a NetBuffer to hold the SYN-ACK segment. we're dealing with an incoming
      // SYN segment from an IRQ

      NetBuffer *nb=new NetBuffer(_additionalHeaderSize+TcpHeader::getNoOptionsHeaderSize(),4);

      // set up MSS (maximum segment size) option

      TcpOptionMaximumSegmentSize *mssOption=reinterpret_cast<TcpOptionMaximumSegmentSize *>(nb->moveWritePointerBack(4));
      mssOption->initialise(_segmentSizeLimit);

      // construct the header

      TcpHeader *header=reinterpret_cast<TcpHeader *>(nb->moveWritePointerBack(TcpHeader::getNoOptionsHeaderSize()));

      // we're acking the SYN, which costs the sender 1 sequence number

      _state.rxWindow.receiveNext++;

      header->initialise(_state.localPort,                          // ports
                         _state.remotePort,
                         _state.txWindow.sendNext,                  // initial sequence number
                         _state.rxWindow.receiveNext,               // ack the SYN (the SYN consumes a sequence number)
                         getReceiveBufferSpaceAvailable(),          // data space available
                         TcpHeaderFlags::SYN | TcpHeaderFlags::ACK);

      // this header is larger than the minimum

      header->setSize(TcpHeader::getNoOptionsHeaderSize()+TcpOptionMaximumSegmentSize::getSize());

      // increment our sequence number

      _state.txWindow.sendNext++;

      // ask the IP layer to send the packet

      IpTransmitRequestEvent iptre(
            nb,
            _state.remoteAddress,
            IpProtocol::TCP);

      _networkUtilityObjects->NetworkSendEventSender.raiseEvent(iptre);
      return iptre.succeeded;
    }


    /**
     * Send a batch of data to the remote client with an optional timeout. If the timeout is zero
     * then this is effectively a blocking call that will not return until success or a network
     * error occurs.
     *
     * Data is sent in segments to the other side. The size of each segment is bounded by the lower
     * of our MTU and the last known receive window of the recipient. actuallySent is updated to
     * hold the amount of data acknowledged by the other end when this function returns.
     *
     * If tcp_nagleAvoidance is true (the default) then this method tries to send at least two
     * packets per call to force the remote to ACK immediately. If only one packet were to go out
     * per call then we may have to wait up to 200ms for the remote end's Nagle algorithm timer
     * to expire and send us our ACK.
     *
     * The timeout, if non zero, is applied in full to each segment that we send. It means
     * that we will wait for that many milliseconds after we send a segment to receiving an ACK
     * before we give up. There will be an interplay between this timeout and the tcp_sendRetry*
     * configuration parameters.
     *
     * @param data The buffer of data to transmit
     * @param datasize How many bytes of data to transmit
     * @param[out] actuallySent How many bytes we sent and have been acknowledged, updated on success or failure.
     * @param[in] timeoutMillis How long to wait for any blocking state to release, or zero (the default) to wait forever.
     * @return true if all the data was sent, false if there was an error. Even if there is an error it is still possible for data to have been sent. Always check actuallySent to see how much data was sent.
     */

    bool TcpConnection::send(const void *data,uint32_t datasize,uint32_t& actuallySent,uint32_t timeoutMillis) {

      uint32_t bufpos,expectsuna,batchpos,batchbufpos,now,resendtimeout,startwait;
      uint16_t batchwin,batchsendcap;
      TcpHeaderFlags headerFlags;

      actuallySent=0;
      now=MillisecondTimer::millis();

      // we've become active

      _lastActiveTime=now;

      // if the state is SYNC_RCVD then we wait for it to move on

      if(_state.state==TcpState::SYN_RCVD)
        if(!waitForStateChange(TcpState::SYN_RCVD,timeoutMillis))
          return false;

      // the new state must be ESTABLISHED

      if(_state.state!=TcpState::ESTABLISHED)
        return _networkUtilityObjects->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP_CONNECTION,E_INVALID_STATE);

      // we need to handle the zero window case. don't try to send if the window is at zero
      // for a defined interval.

      if(_state.txWindow.sendWindow==0) {

        if(_lastZeroWindowPollTime==0) {
          _lastZeroWindowPollTime=now;      // we can try now, this is the first time we know it to be zero
          _zeroWindowPollDelay=_params.tcp_initialResendDelay;
        }
        else {
          if(MillisecondTimer::hasTimedOut(_lastZeroWindowPollTime,_zeroWindowPollDelay))
            return true;                    // this is not an error, zero bytes were sent because the window is closed
          else {
            _lastZeroWindowPollTime=now;    // we can try again now
            _zeroWindowPollDelay=std::min(_params.tcp_maxResendDelay,_zeroWindowPollDelay*2);
          }
        }
      }
      else
        _lastZeroWindowPollTime=0;          // non-zero window, cancel the poll time

      // bufpos is the index into the user's data of the current batch being sent
      // batchwin is current sender receive window

      bufpos=0;
      batchwin=_state.txWindow.sendWindow;
      resendtimeout=_params.tcp_initialResendDelay;

      // if the data would be sent in one go and nagle avoidance is enabled then force the send
      // to be 2 packets so that the recipient will generate an ACK immediately.

      if(datasize<=batchwin && _params.tcp_nagleAvoidance && datasize>1)
        batchsendcap=(datasize/2)+1;
      else
        batchsendcap=UINT16_MAX;

      // set up the header flags

      headerFlags=TcpHeaderFlags::ACK;
      if(_params.tcp_push)
        headerFlags=headerFlags | TcpHeaderFlags::PSH;

      // keep going while there is data and the connection is open

      while(datasize>0 && !isLocalEndClosed()) {

        uint16_t batchsize,batchremaining;
        bool resend;

        // a batch is how much we push out without waiting for ACKs. We always try to send 1 byte even when the sender
        // window is closed, this effectively polls the sender for window updates if they've been advertising
        // a zero window to us.

        batchsize=std::max(1UL,std::min(datasize,static_cast<uint32_t>(batchwin)));
        batchremaining=batchsize;
        batchpos=_state.txWindow.sendNext;
        batchbufpos=bufpos;

        // expectsuna is the ACK number that we'll be expecting when this batch is done

        expectsuna=_state.txWindow.sendNext+batchsize;

        // keep transmitting segments for this batch or until the local end is closed

        while(batchremaining>0 && !isLocalEndClosed()) {

          uint16_t tosend;

          // send up to the remote MSS in one segment

          tosend=std::min(std::min(batchsendcap,batchremaining),_remoteMss);

          // send this segment if it's not been ACK'd already (can happen if this is a resend)

          if(batchpos+tosend>=_state.txWindow.sendUnacknowledged) {

            // create a netbuffer for the user data - only the header space is alloc'd. the user data
            // is transmitted in-place.

            NetBuffer *nb=new NetBuffer(_additionalHeaderSize+TcpHeader::getNoOptionsHeaderSize(),
                                        0,
                                        reinterpret_cast<const uint8_t *>(data)+batchbufpos,
                                        tosend);

            // create the header

            TcpHeader *header=reinterpret_cast<TcpHeader *>(nb->moveWritePointerBack(TcpHeader::getNoOptionsHeaderSize()));

            header->initialise(_state.localPort,
                               _state.remotePort,
                                batchpos,                       // where we are sending from
                                _state.rxWindow.receiveNext,    //  ack up to receiveNext
                                _state.rxWindow.receiveWindow,  // current window size
                                headerFlags);                   // always ACK

            // ask the IP layer to send the packet

            IpTransmitRequestEvent iptre(
                  nb,
                  _state.remoteAddress,
                  IpProtocol::TCP);

            _networkUtilityObjects->NetworkSendEventSender.raiseEvent(iptre);
            if(!iptre.succeeded)
              return false;
          }

          // update the sequence number (batchpos) and the user buffer position (batchbufpos)

          batchpos+=tosend;
          batchbufpos+=tosend;
          batchremaining-=tosend;
        }

        // reset the resend flag

        resend=false;
        startwait=MillisecondTimer::millis();

        // wait for the ACKs on that last batch to come back

        while(expectsuna!=_state.txWindow.sendUnacknowledged && !isLocalEndClosed()) {

          // check for user timeout, measured from the beginning of the call

          if(timeoutMillis && MillisecondTimer::hasTimedOut(now,timeoutMillis))
            return _networkUtilityObjects->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP_CONNECTION,E_TIMED_OUT);

          // check for resend timeout for this batch

          if(MillisecondTimer::hasTimedOut(startwait,resendtimeout)) {
            resend=true;
            resendtimeout=std::min(_params.tcp_maxResendDelay,resendtimeout*2);
            break;
          }
        }

        // if we're not about to go into a resend of this batch then update the batch position
        // for the next run

        if(!resend) {
          resendtimeout=_params.tcp_initialResendDelay;
          bufpos=batchbufpos;
          _state.txWindow.sendNext=batchpos;      // it's very important that sendNext and actuallySent move in sync
          actuallySent+=batchsize;
          datasize-=batchsize;
          batchwin=_state.txWindow.sendWindow;
        }
      }

      // if we bailed because the state was changed then indicate that to the caller

      if(isLocalEndClosed())
        return _networkUtilityObjects->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP_CONNECTION,E_CONNECTION_RESET);

      return true;
    }


    /**
     * Receive some data from the remote client. If the timeout is zero then this is a blocking call that will
     * not return until success, the other end closes, or a network error occurs. actuallyReceived will be filled
     * in with the actual amount of data received.
     *
     * If the other end closes then 'true' is returned and actuallyReceived may be less than you asked for. Call
     * isRemoteEndClosed() to test if the other end has closed.
     *
     * This is not IRQ safe.
     *
     * @param data Where to receive the data
     * @param dataSize The amount of data to receive
     * @param actuallyReceived The amount of data actually received
     * @param timeoutMillis The total time limit to wait for all blocking calls to complete, or zero to always block.
     * @return true if there was no error.
     */

    bool TcpConnection::receive(void *data,uint32_t dataSize,uint32_t& actuallyReceived,uint32_t timeoutMillis) {

      uint32_t now,received;
      uint8_t *ptr;

      actuallyReceived=0;

      // get current time

      if(timeoutMillis)
        now=MillisecondTimer::millis();
      else
        now=0;      // keep the compiler quiet

      // continue until finished

      ptr=reinterpret_cast<uint8_t *>(data);

      while(dataSize>0) {

        if(_receiveBuffer->availableToRead()) {

          // copy in as much as we can

          received=std::min(dataSize,_receiveBuffer->availableToRead());
          _receiveBuffer->read(ptr,received);

          // update counters

          dataSize-=received;
          actuallyReceived+=received;
          ptr+=received;

          _state.rxWindow.receiveWindow=_receiveBuffer->availableToWrite();

          // reset timeout base

          if(timeoutMillis)
            now=MillisecondTimer::millis();
        }
        else {

          // there is nothing to read. has the remote end closed the connection? if so then nothing
          // more is ever going to arrive. this is not an error condition.

          if(isRemoteEndClosed())
            break;
          else {

            // no data arrived and the remote end is still open. check for timeout.

            if(timeoutMillis && MillisecondTimer::hasTimedOut(now,timeoutMillis)) {

              // if some data was received then this is not an error

              if(actuallyReceived)
                break;

              // no data arrived and we timed out. this is an error

              return _networkUtilityObjects->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP_CONNECTION,E_TIMED_OUT);
            }
          }
        }
      }

      // if we've got some data then we can check if a currently-closed receive window can be opened

      if(actuallyReceived) {

        // this must be done with IRQs suspended

        IrqSuspend suspender;

        // if the receive window is closed and we can now open it then do so

        if(_receiveWindowIsClosed && receiveWindowCanBeOpened()) {
          _receiveWindowIsClosed=false;
          _state.sendAck(*_networkUtilityObjects,sillyWindowAvoidance());
        }
      }

      // finished

      return true;
    }
  }
}


#endif
// END FILE: ../lib/src/net/transport/tcp/TcpConnection.cpp
// START FILE: ../lib/src/net/application/dns/DnsCache.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"

#if defined(STM32PLUS_F4_HAS_MAC) || defined(STM32PLUS_F1_CL_E)

#include "config/net.h"


namespace stm32plus {
  namespace net {


    /**
     * Initialise the cache
     * @param cacheSize The maximum entries in the cache
     * @param rtc pointer to the RTC
     * @return true if it worked
     */

    bool DnsCache::initialise(uint32_t cacheSize,RtcBase *rtc) {

      uint32_t i;

      _maxEntries=cacheSize;
      _rtc=rtc;

      // allocate the entries

      _entries.reset(new Entry[cacheSize]);
      if(_entries.get()==nullptr)
        return false;

      // mark all as unused

      for(i=0;i<_maxEntries;i++)
        _entries[i].expiryTicks=NO_ENTRY;

      return true;
    }


    /**
     * Add a new entry to the cache. An exact match updates the expiry time. Otherwise
     * unused entries are preferred. If no unused entry is found then the entry that's
     * closest to its expiry time is evicted.
     * @param hostname The host to add
     * @param address The corresponding address
     * @param ttl Number of seconds that this address is valid for
     */

    void DnsCache::add(const char *hostname,const IpAddress& address,uint32_t ttl) {

      uint32_t i,unused,closest,closestTicks,now;
      uint16_t hostlen;
      Entry *ptr;

      unused=closest=NO_ENTRY;
      closestTicks=UINT32_MAX;
      now=_rtc->getTick();
      ptr=_entries.get();

      for(i=0;i<_maxEntries;i++,ptr++) {

        if(unused==NO_ENTRY && _entries[i].expiryTicks==NO_ENTRY)
          unused=i;
        else if(!strcasecmp(hostname,ptr->_hostname.get())) {

          // found an exact match, update host and expiry and return

          ptr->address=address;
          ptr->expiryTicks=ttl+now;

          return;
        }
        else {

          if(ptr->expiryTicks<now) {

            // this entry has expired, remove it

            ptr->expiryTicks=NO_ENTRY;
            ptr->_hostname.reset();
          }
          else if(ptr->expiryTicks-now<closestTicks) {
            closest=i;
            closestTicks=ptr->expiryTicks-now;
          }
        }
      }

      // if we have an unused entry then use it, otherwise evict.

      if(unused!=NO_ENTRY)
        i=unused;
      else
        i=closest;

      // set up the entry

      hostlen=strlen(hostname);
      _entries[i]._hostname.reset(new char[hostlen+1]);
      strcpy(_entries[i]._hostname.get(),hostname);
      _entries[i].expiryTicks=ttl+now;
      _entries[i].address=address;
    }


    /**
     * Lookup an entry in the cache
     * @param hostname
     * @param address
     * @return
     */

    bool DnsCache::lookup(const char *hostname,IpAddress& address) {

      uint32_t i;
      Entry *ptr;
      uint32_t now;

      now=_rtc->getTick();

      for(ptr=_entries.get(),i=0;i<_maxEntries;i++,ptr++) {
        if(ptr->expiryTicks!=NO_ENTRY && ptr->expiryTicks>now && !strcasecmp(hostname,ptr->_hostname.get())) {
          address=ptr->address;
          return true;
        }
      }

      return false;
    }
  }
}


#endif
// END FILE: ../lib/src/net/application/dns/DnsCache.cpp
// START FILE: ../lib/src/net/application/ftp/FtpServerDataConnection.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"

#if defined(STM32PLUS_F4_HAS_MAC) || defined(STM32PLUS_F1_CL_E)

#include "config/net_ftp.h"
#include "net/application/ftp/FtpServerConnectionBase.h"


namespace stm32plus {
  namespace net {


    /**
     * Constructor. As this is the data connection and most activity is likely to be downloading
     * we will boost the output streams buffer size to 2*MTU so that the delayed ACK avoidance
     * algorithm that sends size/2 bytes-per send will result in MTU bytes being sent per segment.
     * Typically this will result in a buffer size of 1460*2 = 2920 bytes per data connection.
     * @param params The TCP parameters
     * @param serverbase The command connection that we belong to
     */

    FtpServerDataConnection::FtpServerDataConnection(const Parameters& params,FtpServerConnectionBase *serverbase)
      : TcpConnection(params),
        _commandConnection(serverbase),
        _outputStreams(*this,serverbase->getDataConnectionSendBufferSize()),
        _direction(Direction::NOT_STARTED),
        _state(State::NOT_STARTED) {
    }


    /**
     * Destructor
     */

    FtpServerDataConnection::~FtpServerDataConnection() {
      _commandConnection->clearDataConnection();
    }


    /**
     * Handle the possibility of a write
     * @return true if there were no errors
     */

    bool FtpServerDataConnection::handleWrite() {

      uint32_t actuallySent;

      // cannot write if either end is closed

      if(isLocalEndClosed() || isRemoteEndClosed())
        return false;

      // write to the connection

      if(_outputStreams.canWriteToConnection()) {

        if(!_outputStreams.writeDataToConnection(actuallySent))
          return false;

        if(actuallySent)
          _commandConnection->updateLastActiveTime();
      }

      return true;
    }


    /**
     * Handle the possibility of a read. Read out the received data in chunks until
     * we've got it all. A chunk size is 512b which matches the SD card sector size
     * though it's likely we'll fragment somewhere during the transfer and end up straddling
     * sectors.
     * @return true if there were no errors (being closed is not an error)
     */

    bool FtpServerDataConnection::handleRead() {

      uint32_t actuallyRead,totalRead;
      uint8_t transferBuffer[UPLOAD_TRANSFER_BUFFER_SIZE];      // default is 512 bytes

      // transfer out all data

      totalRead=0;
      while(getDataAvailable()>0) {

        // receive any data available

        if(!receive(transferBuffer,UPLOAD_TRANSFER_BUFFER_SIZE,actuallyRead))
          return false;

        // write back to the stream

        if(actuallyRead>0 && !_uploadStream->write(transferBuffer,actuallyRead))
          return false;

        totalRead+=actuallyRead;
      }

      if(totalRead)
        _commandConnection->updateLastActiveTime();

      return true;
    }


    /**
     * Flush all pending data when reading
     * @return true if it worked
     */

    bool FtpServerDataConnection::flush() {

      if(_direction==Direction::DOWNLOAD) {

        while(!_outputStreams.completed())
          if(!handleWrite())
            return false;
      }

      return true;
    }


    /**
     * Check if the transfer has completed. There'll be an idle period just after the
     * connection is created so it's only finished when it's started running (streams
     * have been added) and there are no streams remaining.
     */

    bool FtpServerDataConnection::finished() const {

      // if downloading then the all streams gone == finshed
      // if uploading then the remote end closing == finished

      if(_direction==Direction::DOWNLOAD)
        return _state==State::RUNNING && _outputStreams.completed();
      else if(_direction==Direction::UPLOAD)
        return getDataAvailable()==0 && isRemoteEndClosed();
      else
        return false;
    }


    /**
     * Add a new string to the output streams
     */

    void FtpServerDataConnection::addString(const char *str) {

      std::string *newstr;

      newstr=new std::string(str);
      (*newstr)+="\r\n";

      addStream(
        new StlStringInputStream(
            newstr,true),
            true
          );
    }


    /**
     * Add a stream to the data connection
     * @param stream The stream to add
     * @param owned true if this stream should be automatically deleted
     */

    void FtpServerDataConnection::addStream(InputStream *stream,bool owned) {
      _outputStreams.addStream(stream,owned);
      _state=State::RUNNING;
    }
  }
}


#endif
// END FILE: ../lib/src/net/application/ftp/FtpServerDataConnection.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma2Stream0InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<2,0>::FPTR DmaInterruptFeatureEnabler<2,0>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA2, stream 0
   */

  #if defined(USE_DMA2_0_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA2_Stream0_IRQHandler() {

      if(DMA_GetITStatus(DMA2_Stream0,DMA_IT_TCIF0)!=RESET) {
        DmaInterruptFeature<2,0>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream0,DMA_IT_TCIF0);
      }
      else if(DMA_GetITStatus(DMA2_Stream0,DMA_IT_HTIF0)!=RESET) {
        DmaInterruptFeature<2,0>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream0,DMA_IT_HTIF0);
      }
      else if(DMA_GetITStatus(DMA2_Stream0,DMA_IT_TEIF0)!=RESET) {
        DmaInterruptFeature<2,0>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA2_Stream0,DMA_IT_TEIF0);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma2Stream0InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma2Stream1InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<2,1>::FPTR DmaInterruptFeatureEnabler<2,1>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA2, stream 1
   */

  #if defined(USE_DMA2_1_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA2_Stream1_IRQHandler() {

      if(DMA_GetITStatus(DMA2_Stream1,DMA_IT_TCIF1)!=RESET) {
        DmaInterruptFeature<2,1>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream1,DMA_IT_TCIF1);
      }
      else if(DMA_GetITStatus(DMA2_Stream1,DMA_IT_HTIF1)!=RESET) {
        DmaInterruptFeature<2,1>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream1,DMA_IT_HTIF1);
      }
      else if(DMA_GetITStatus(DMA2_Stream1,DMA_IT_TEIF1)!=RESET) {
        DmaInterruptFeature<2,1>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA2_Stream1,DMA_IT_TEIF1);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma2Stream1InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma1Stream1InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<1,1>::FPTR DmaInterruptFeatureEnabler<1,1>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA1, stream 1
   */

  #if defined(USE_DMA1_1_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA1_Stream1_IRQHandler() {

      if(DMA_GetITStatus(DMA1_Stream1,DMA_IT_TCIF1)!=RESET) {
        DmaInterruptFeature<1,1>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream1,DMA_IT_TCIF1);
      }
      else if(DMA_GetITStatus(DMA1_Stream1,DMA_IT_HTIF1)!=RESET) {
        DmaInterruptFeature<1,1>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream1,DMA_IT_HTIF1);
      }
      else if(DMA_GetITStatus(DMA1_Stream1,DMA_IT_TEIF1)!=RESET) {
        DmaInterruptFeature<1,1>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA1_Stream1,DMA_IT_TEIF1);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma1Stream1InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma1Stream5InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<1,5>::FPTR DmaInterruptFeatureEnabler<1,5>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA1, stream 5
   */

  #if defined(USE_DMA1_5_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA1_Stream5_IRQHandler() {

      if(DMA_GetITStatus(DMA1_Stream5,DMA_IT_TCIF5)!=RESET) {
        DmaInterruptFeature<1,5>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream5,DMA_IT_TCIF5);
      }
      else if(DMA_GetITStatus(DMA1_Stream5,DMA_IT_HTIF5)!=RESET) {
        DmaInterruptFeature<1,5>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream5,DMA_IT_HTIF5);
      }
      else if(DMA_GetITStatus(DMA1_Stream5,DMA_IT_TEIF5)!=RESET) {
        DmaInterruptFeature<1,5>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA1_Stream5,DMA_IT_TEIF5);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma1Stream5InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma2Stream3InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<2,3>::FPTR DmaInterruptFeatureEnabler<2,3>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA2, stream 3
   */

  #if defined(USE_DMA2_3_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA2_Stream3_IRQHandler() {

      if(DMA_GetITStatus(DMA2_Stream3,DMA_IT_TCIF3)!=RESET) {
        DmaInterruptFeature<2,3>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream3,DMA_IT_TCIF3);
      }
      else if(DMA_GetITStatus(DMA2_Stream3,DMA_IT_HTIF3)!=RESET) {
        DmaInterruptFeature<2,3>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream3,DMA_IT_HTIF3);
      }
      else if(DMA_GetITStatus(DMA2_Stream3,DMA_IT_TEIF3)!=RESET) {
        DmaInterruptFeature<2,3>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA2_Stream3,DMA_IT_TEIF3);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma2Stream3InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma1Stream2InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<1,2>::FPTR DmaInterruptFeatureEnabler<1,2>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA1, stream 2
   */

  #if defined(USE_DMA1_2_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA1_Stream2_IRQHandler() {

      if(DMA_GetITStatus(DMA1_Stream2,DMA_IT_TCIF2)!=RESET) {
        DmaInterruptFeature<1,2>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream2,DMA_IT_TCIF2);
      }
      else if(DMA_GetITStatus(DMA1_Stream2,DMA_IT_HTIF2)!=RESET) {
        DmaInterruptFeature<1,2>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream2,DMA_IT_HTIF2);
      }
      else if(DMA_GetITStatus(DMA1_Stream2,DMA_IT_TEIF2)!=RESET) {
        DmaInterruptFeature<1,2>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA1_Stream2,DMA_IT_TEIF2);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma1Stream2InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma1Stream6InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<1,6>::FPTR DmaInterruptFeatureEnabler<1,6>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA1, stream 6
   */

  #if defined(USE_DMA1_6_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA1_Stream6_IRQHandler() {

      if(DMA_GetITStatus(DMA1_Stream6,DMA_IT_TCIF6)!=RESET) {
        DmaInterruptFeature<1,6>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream6,DMA_IT_TCIF6);
      }
      else if(DMA_GetITStatus(DMA1_Stream6,DMA_IT_HTIF6)!=RESET) {
        DmaInterruptFeature<1,6>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream6,DMA_IT_HTIF6);
      }
      else if(DMA_GetITStatus(DMA1_Stream6,DMA_IT_TEIF6)!=RESET) {
        DmaInterruptFeature<1,6>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA1_Stream6,DMA_IT_TEIF6);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma1Stream6InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma1Stream3InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<1,3>::FPTR DmaInterruptFeatureEnabler<1,3>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA1, stream 3
   */

  #if defined(USE_DMA1_3_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA1_Stream3_IRQHandler() {

      if(DMA_GetITStatus(DMA1_Stream3,DMA_IT_TCIF3)!=RESET) {
        DmaInterruptFeature<1,3>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream3,DMA_IT_TCIF3);
      }
      else if(DMA_GetITStatus(DMA1_Stream3,DMA_IT_HTIF3)!=RESET) {
        DmaInterruptFeature<1,3>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream3,DMA_IT_HTIF3);
      }
      else if(DMA_GetITStatus(DMA1_Stream3,DMA_IT_TEIF3)!=RESET) {
        DmaInterruptFeature<1,3>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA1_Stream3,DMA_IT_TEIF3);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma1Stream3InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma2Stream6InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<2,6>::FPTR DmaInterruptFeatureEnabler<2,6>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA2, stream 6
   */

  #if defined(USE_DMA2_6_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA2_Stream6_IRQHandler() {

      if(DMA_GetITStatus(DMA2_Stream6,DMA_IT_TCIF6)!=RESET) {
        DmaInterruptFeature<2,6>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream6,DMA_IT_TCIF6);
      }
      else if(DMA_GetITStatus(DMA2_Stream6,DMA_IT_HTIF6)!=RESET) {
        DmaInterruptFeature<2,6>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream6,DMA_IT_HTIF6);
      }
      else if(DMA_GetITStatus(DMA2_Stream6,DMA_IT_TEIF6)!=RESET) {
        DmaInterruptFeature<2,6>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA2_Stream6,DMA_IT_TEIF6);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma2Stream6InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma2Stream4InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<2,4>::FPTR DmaInterruptFeatureEnabler<2,4>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA2, stream 4
   */

  #if defined(USE_DMA2_4_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA2_Stream4_IRQHandler() {

      if(DMA_GetITStatus(DMA2_Stream4,DMA_IT_TCIF4)!=RESET) {
        DmaInterruptFeature<2,4>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream4,DMA_IT_TCIF4);
      }
      else if(DMA_GetITStatus(DMA2_Stream4,DMA_IT_HTIF4)!=RESET) {
        DmaInterruptFeature<2,4>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream4,DMA_IT_HTIF4);
      }
      else if(DMA_GetITStatus(DMA2_Stream4,DMA_IT_TEIF4)!=RESET) {
        DmaInterruptFeature<2,4>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA2_Stream4,DMA_IT_TEIF4);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma2Stream4InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma2Stream5InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<2,5>::FPTR DmaInterruptFeatureEnabler<2,5>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA2, stream 5
   */

  #if defined(USE_DMA2_5_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA2_Stream5_IRQHandler() {

      if(DMA_GetITStatus(DMA2_Stream5,DMA_IT_TCIF5)!=RESET) {
        DmaInterruptFeature<2,5>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream5,DMA_IT_TCIF5);
      }
      else if(DMA_GetITStatus(DMA2_Stream5,DMA_IT_HTIF5)!=RESET) {
        DmaInterruptFeature<2,5>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream5,DMA_IT_HTIF5);
      }
      else if(DMA_GetITStatus(DMA2_Stream5,DMA_IT_TEIF5)!=RESET) {
        DmaInterruptFeature<2,5>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA2_Stream5,DMA_IT_TEIF5);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma2Stream5InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma1Stream4InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<1,4>::FPTR DmaInterruptFeatureEnabler<1,4>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA1, stream 4
   */

  #if defined(USE_DMA1_4_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA1_Stream4_IRQHandler() {

      if(DMA_GetITStatus(DMA1_Stream4,DMA_IT_TCIF4)!=RESET) {
        DmaInterruptFeature<1,4>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream4,DMA_IT_TCIF4);
      }
      else if(DMA_GetITStatus(DMA1_Stream4,DMA_IT_HTIF4)!=RESET) {
        DmaInterruptFeature<1,4>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream4,DMA_IT_HTIF4);
      }
      else if(DMA_GetITStatus(DMA1_Stream4,DMA_IT_TEIF4)!=RESET) {
        DmaInterruptFeature<1,4>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA1_Stream4,DMA_IT_TEIF4);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma1Stream4InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma2Stream7InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<2,7>::FPTR DmaInterruptFeatureEnabler<2,7>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA2, stream 7
   */

  #if defined(USE_DMA2_7_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA2_Stream7_IRQHandler() {

      if(DMA_GetITStatus(DMA2_Stream7,DMA_IT_TCIF7)!=RESET) {
        DmaInterruptFeature<2,7>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream7,DMA_IT_TCIF7);
      }
      else if(DMA_GetITStatus(DMA2_Stream7,DMA_IT_HTIF7)!=RESET) {
        DmaInterruptFeature<2,7>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream7,DMA_IT_HTIF7);
      }
      else if(DMA_GetITStatus(DMA2_Stream7,DMA_IT_TEIF7)!=RESET) {
        DmaInterruptFeature<2,7>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA2_Stream7,DMA_IT_TEIF7);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma2Stream7InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma1Stream0InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<1,0>::FPTR DmaInterruptFeatureEnabler<1,0>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA1, stream 0
   */

  #if defined(USE_DMA1_0_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA1_Stream0_IRQHandler() {

      if(DMA_GetITStatus(DMA1_Stream0,DMA_IT_TCIF0)!=RESET) {
        DmaInterruptFeature<1,0>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream0,DMA_IT_TCIF0);
      }
      else if(DMA_GetITStatus(DMA1_Stream0,DMA_IT_HTIF0)!=RESET) {
        DmaInterruptFeature<1,0>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream0,DMA_IT_HTIF0);
      }
      else if(DMA_GetITStatus(DMA1_Stream0,DMA_IT_TEIF0)!=RESET) {
        DmaInterruptFeature<1,0>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA1_Stream0,DMA_IT_TEIF0);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma1Stream0InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma1Stream7InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<1,7>::FPTR DmaInterruptFeatureEnabler<1,7>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA1, stream 7
   */

  #if defined(USE_DMA1_7_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA1_Stream7_IRQHandler() {

      if(DMA_GetITStatus(DMA1_Stream7,DMA_IT_TCIF7)!=RESET) {
        DmaInterruptFeature<1,7>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream7,DMA_IT_TCIF7);
      }
      else if(DMA_GetITStatus(DMA1_Stream7,DMA_IT_HTIF7)!=RESET) {
        DmaInterruptFeature<1,7>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA1_Stream7,DMA_IT_HTIF7);
      }
      else if(DMA_GetITStatus(DMA1_Stream7,DMA_IT_TEIF7)!=RESET) {
        DmaInterruptFeature<1,7>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA1_Stream7,DMA_IT_TEIF7);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma1Stream7InterruptHandler.cpp
// START FILE: ../lib/src/dma/f4/interrupts/Dma2Stream2InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"


// this is only for the F4

#ifdef STM32PLUS_F4

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> DmaInterruptFeatureEnabler<2,2>::FPTR DmaInterruptFeatureEnabler<2,2>::_forceLinkage=nullptr;


extern "C" {

  /**
   * DMA2, stream 2
   */

  #if defined(USE_DMA2_2_INTERRUPT)
    void __attribute__ ((interrupt("IRQ"))) DMA2_Stream2_IRQHandler() {

      if(DMA_GetITStatus(DMA2_Stream2,DMA_IT_TCIF2)!=RESET) {
        DmaInterruptFeature<2,2>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream2,DMA_IT_TCIF2);
      }
      else if(DMA_GetITStatus(DMA2_Stream2,DMA_IT_HTIF2)!=RESET) {
        DmaInterruptFeature<2,2>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_HALF_COMPLETE);
        DMA_ClearITPendingBit(DMA2_Stream2,DMA_IT_HTIF2);
      }
      else if(DMA_GetITStatus(DMA2_Stream2,DMA_IT_TEIF2)!=RESET) {
        DmaInterruptFeature<2,2>::_dmaInstance->DmaInterruptEventSender.raiseEvent(DmaEventType::EVENT_TRANSFER_ERROR);
        DMA_ClearITPendingBit(DMA2_Stream0,DMA_IT_TEIF2);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }
  #endif
}
#endif // STM32PLUS_F4
// END FILE: ../lib/src/dma/f4/interrupts/Dma2Stream2InterruptHandler.cpp
// START FILE: ../lib/src/can/interrupts/f4/Can2InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/can.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

Can2InterruptFeature::FPTR Can2InterruptFeature::_forceLinkage=nullptr;
CanEventSource *Can2InterruptFeature:: _canInstance=nullptr;


extern "C" {

#if defined(USE_CAN2_INTERRUPT)


  void __attribute__ ((interrupt("IRQ"))) CAN2_TX_IRQHandler(void) {

		if(CAN_GetITStatus(CAN2,CAN_IT_TME)!= RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_TRANSMIT_MAILBOX_EMPTY);

		__DSB();      // prevent erroneous recall of this handler due to delayed memory write
	}


	void __attribute__ ((interrupt("IRQ"))) CAN2_RX0_IRQHandler(void) {

	  if(CAN_GetITStatus(CAN2,CAN_IT_FMP0)!=RESET)
	    Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO0_MESSAGE_PENDING);
		else if(CAN_GetITStatus(CAN2,CAN_IT_FF0)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO0_FULL);
		else if(CAN_GetITStatus(CAN2,CAN_IT_FOV0)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO0_OVR);

	  __DSB();      // prevent erroneous recall of this handler due to delayed memory write
	}


	void __attribute__ ((interrupt("IRQ"))) CAN2_RX1_IRQHandler(void) {

	  if(CAN_GetITStatus(CAN2,CAN_IT_FMP1)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO1_MESSAGE_PENDING);
		else if(CAN_GetITStatus(CAN2,CAN_IT_FF1)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO1_FULL);
		else if(CAN_GetITStatus(CAN2,CAN_IT_FOV1)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO1_OVR);

	  __DSB();      // prevent erroneous recall of this handler due to delayed memory write
	}


	void __attribute__ ((interrupt("IRQ"))) CAN2_SCE_IRQHandler(void) {

	  if(CAN_GetITStatus(CAN2,CAN_IT_EWG)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_ERROR_WARNING);
		else if(CAN_GetITStatus(CAN2,CAN_IT_EPV)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_ERROR_PASSIVE);
		else if(CAN_GetITStatus(CAN2,CAN_IT_BOF)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_BUS_OFF);
		else if(CAN_GetITStatus(CAN2,CAN_IT_LEC)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_LAST_ERROR_CODE);
		else if(CAN_GetITStatus(CAN2,CAN_IT_WKU)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_WAKEUP);
		else if(CAN_GetITStatus(CAN2,CAN_IT_SLK)!=RESET)
			Can2InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_SLEEP);

	  __DSB();      // prevent erroneous recall of this handler due to delayed memory write
	}

#endif
}

#endif
// END FILE: ../lib/src/can/interrupts/f4/Can2InterruptHandler.cpp
// START FILE: ../lib/src/can/interrupts/f4/Can1InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/can.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

Can1InterruptFeature::FPTR Can1InterruptFeature::_forceLinkage=nullptr;
CanEventSource *Can1InterruptFeature:: _canInstance=nullptr;


extern "C" {

#if defined(USE_CAN1_INTERRUPT)


  void __attribute__ ((interrupt("IRQ"))) CAN1_TX_IRQHandler(void) {

		if(CAN_GetITStatus(CAN1,CAN_IT_TME)!= RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_TRANSMIT_MAILBOX_EMPTY);

		__DSB();      // prevent erroneous recall of this handler due to delayed memory write
	}


	void __attribute__ ((interrupt("IRQ"))) CAN1_RX0_IRQHandler(void) {

	  if(CAN_GetITStatus(CAN1,CAN_IT_FMP0)!=RESET)
	    Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO0_MESSAGE_PENDING);
		else if(CAN_GetITStatus(CAN1,CAN_IT_FF0)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO0_FULL);
		else if(CAN_GetITStatus(CAN1,CAN_IT_FOV0)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO0_OVR);

	  __DSB();      // prevent erroneous recall of this handler due to delayed memory write
	}


	void __attribute__ ((interrupt("IRQ"))) CAN1_RX1_IRQHandler(void) {

	  if(CAN_GetITStatus(CAN1,CAN_IT_FMP1)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO1_MESSAGE_PENDING);
		else if(CAN_GetITStatus(CAN1,CAN_IT_FF1)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO1_FULL);
		else if(CAN_GetITStatus(CAN1,CAN_IT_FOV1)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_FIFO1_OVR);

	  __DSB();      // prevent erroneous recall of this handler due to delayed memory write
	}


	void __attribute__ ((interrupt("IRQ"))) CAN1_SCE_IRQHandler(void) {

	  if(CAN_GetITStatus(CAN1,CAN_IT_EWG)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_ERROR_WARNING);
		else if(CAN_GetITStatus(CAN1,CAN_IT_EPV)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_ERROR_PASSIVE);
		else if(CAN_GetITStatus(CAN1,CAN_IT_BOF)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_BUS_OFF);
		else if(CAN_GetITStatus(CAN1,CAN_IT_LEC)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_LAST_ERROR_CODE);
		else if(CAN_GetITStatus(CAN1,CAN_IT_WKU)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_WAKEUP);
		else if(CAN_GetITStatus(CAN1,CAN_IT_SLK)!=RESET)
			Can1InterruptFeature::_canInstance->CanInterruptEventSender.raiseEvent(CanEventType::EVENT_SLEEP);

	  __DSB();      // prevent erroneous recall of this handler due to delayed memory write
	}

#endif
}

#endif
// END FILE: ../lib/src/can/interrupts/f4/Can1InterruptHandler.cpp
// START FILE: ../lib/src/spi/interrupts/Spi2InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/spi.h"
#include "config/i2s.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> SpiInterruptFeatureEnabler<2>::FPTR SpiInterruptFeatureEnabler<2>::_forceLinkage=nullptr;
template<> I2SInterruptFeatureEnabler<2>::FPTR I2SInterruptFeatureEnabler<2>::_forceLinkage=nullptr;


extern "C" {

#if defined(USE_SPI2_INTERRUPT) || defined(USE_I2S3_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) SPI2_IRQHandler(void) {
    if(SPI_I2S_GetITStatus(SPI2,SPI_I2S_IT_RXNE)!=RESET) {
      SpiInterruptFeature<2>::_spiInstance->SpiInterruptEventSender.raiseEvent(SpiEventType::EVENT_RECEIVE);
      SPI_I2S_ClearITPendingBit(SPI2,SPI_I2S_IT_RXNE);
    }
    else if(SPI_I2S_GetITStatus(SPI2,SPI_I2S_IT_TXE)!=RESET) {
      SpiInterruptFeature<2>::_spiInstance->SpiInterruptEventSender.raiseEvent(SpiEventType::EVENT_READY_TO_TRANSMIT);
      SPI_I2S_ClearITPendingBit(SPI2,SPI_I2S_IT_TXE);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif
} // extern "C"
// END FILE: ../lib/src/spi/interrupts/Spi2InterruptHandler.cpp
// START FILE: ../lib/src/spi/interrupts/Spi1InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/spi.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> SpiInterruptFeatureEnabler<1>::FPTR SpiInterruptFeatureEnabler<1>::_forceLinkage=nullptr;


#if defined(USE_SPI1_INTERRUPT)

extern "C" {


    void __attribute__ ((interrupt("IRQ"))) SPI1_IRQHandler(void) {
      if(SPI_I2S_GetITStatus(SPI1,SPI_I2S_IT_RXNE)!=RESET) {
        SpiInterruptFeature<1>::_spiInstance->SpiInterruptEventSender.raiseEvent(SpiEventType::EVENT_RECEIVE);
        SPI_I2S_ClearITPendingBit(SPI1,SPI_I2S_IT_RXNE);
      }
      else if(SPI_I2S_GetITStatus(SPI1,SPI_I2S_IT_TXE)!=RESET) {
        SpiInterruptFeature<1>::_spiInstance->SpiInterruptEventSender.raiseEvent(SpiEventType::EVENT_READY_TO_TRANSMIT);
        SPI_I2S_ClearITPendingBit(SPI1,SPI_I2S_IT_TXE);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

}

#endif // extern "C"
// END FILE: ../lib/src/spi/interrupts/Spi1InterruptHandler.cpp
// START FILE: ../lib/src/spi/interrupts/Spi3InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if !defined(STM32PLUS_F1_MD_VL) && !defined(STM32PLUS_F0)

#include "config/spi.h"
#include "config/i2s.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> SpiInterruptFeatureEnabler<3>::FPTR SpiInterruptFeatureEnabler<3>::_forceLinkage=nullptr;
template<> I2SInterruptFeatureEnabler<3>::FPTR I2SInterruptFeatureEnabler<3>::_forceLinkage=nullptr;


extern "C" {

#if defined(USE_SPI3_INTERRUPT) || defined(USE_I2S3_INTERRUPT)

  void __attribute__ ((interrupt("IRQ"))) SPI3_IRQHandler(void) {
    if(SPI_I2S_GetITStatus(SPI3,SPI_I2S_IT_RXNE)!=RESET) {
      SpiInterruptFeature<3>::_spiInstance->SpiInterruptEventSender.raiseEvent(SpiEventType::EVENT_RECEIVE);
      SPI_I2S_ClearITPendingBit(SPI3,SPI_I2S_IT_RXNE);
    }
    else if(SPI_I2S_GetITStatus(SPI3,SPI_I2S_IT_TXE)!=RESET) {
      SpiInterruptFeature<3>::_spiInstance->SpiInterruptEventSender.raiseEvent(SpiEventType::EVENT_READY_TO_TRANSMIT);
      SPI_I2S_ClearITPendingBit(SPI3,SPI_I2S_IT_TXE);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

#endif
} // extern "C"

#endif
// END FILE: ../lib/src/spi/interrupts/Spi3InterruptHandler.cpp
// START FILE: ../lib/src/spi/SpiPollingInputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/spi.h"


namespace stm32plus {

  /*
   * Constructor
   */

  SpiPollingInputStream::SpiPollingInputStream(Spi& spi) :
    _spi(spi) {
  }


  /*
   * Read a byte - can block
   */

  int16_t SpiPollingInputStream::read() {

    uint8_t data;

    while(!_spi.readyToReceive());

    if(!_spi.receive(data))
      return E_STREAM_ERROR;

    return data;
  }

  /*
   * Read many bytes
   */

  bool SpiPollingInputStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

    uint8_t *ptr;
    int16_t data;

    ptr=static_cast<uint8_t *> (buffer);
    actuallyRead=size;

    while(size--) {

      if((data=read())==E_STREAM_ERROR)
        return false;

      *ptr++=data;
    }

    return true;
  }


  /*
   * Cannot skip
   */

  bool SpiPollingInputStream::skip(uint32_t howMuch __attribute__((unused))) {
    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_INPUT_STREAM,E_OPERATION_NOT_SUPPORTED);
  }


  /*
   * Check if data is available - avoids blocking
   */

  bool SpiPollingInputStream::available() {
    return _spi.readyToReceive();
  }
}
// END FILE: ../lib/src/spi/SpiPollingInputStream.cpp
// START FILE: ../lib/src/spi/SpiPollingOutputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/spi.h"


namespace stm32plus {

  /**
   * Constructor for using the output stream in polling mode.
   * @param[in] spi The SPI peripheral for transmitting data.
   */

  SpiPollingOutputStream::SpiPollingOutputStream(Spi& spi) :
    _spi(spi) {
  }

  /*
   * Write one byte
   */

  bool SpiPollingOutputStream::write(uint8_t c) {

    while(!_spi.readyToSend());
    return _spi.send(&c,1);
  }

  /*
   * Write many bytes
   */

  bool SpiPollingOutputStream::write(const void *buffer,uint32_t size) {

    while(!_spi.readyToSend());
    return _spi.send(static_cast<const uint8_t *>(buffer),size);
  }
}
// END FILE: ../lib/src/spi/SpiPollingOutputStream.cpp
// START FILE: ../lib/src/gpio/f4/GpioPinInitialiser.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/gpio.h"

#if defined(STM32PLUS_F4)

namespace stm32plus {

  namespace GpioPinInitialiser {

    /**
     * Simple initialiser for input pins that includes AFIO selection and no output type
     */

    void initialise(GPIO_TypeDef *port,
                    uint16_t pins,
                    Gpio::GpioModeType mode,
                    GPIOSpeed_TypeDef speed,
                    Gpio::GpioPullUpDownType pupdType,
                    uint8_t afSelection) {

      initialise(port,pins,mode,speed,pupdType,Gpio::PUSH_PULL,afSelection);
    }


    /**
     * Simple initialiser that includes AFIO selection
     */

    void initialise(GPIO_TypeDef *port,
                    uint16_t pins,
                    Gpio::GpioModeType mode,
                    GPIOSpeed_TypeDef speed,
                    Gpio::GpioPullUpDownType pupdType,
                    Gpio::GpioOutputType outputType,
                    uint8_t afSelection) {

      uint32_t bit;
      uint8_t source;

      initialise(port,pins,mode,speed,pupdType,outputType);

      // need to configure each of the selected pins for AF

      for(bit=1,source=0;bit<=0x8000;bit<<=1,source++)
        if((pins & bit)!=0)
          GPIO_PinAFConfig(port,source,afSelection);
    }


    /**
     * Simple initialiser for analog input pins
     */

    void initialise(GPIO_TypeDef *port,uint16_t pins) {

      initialise(port,pins,Gpio::ANALOG,GPIO_Speed_50MHz,Gpio::PUPD_NONE,Gpio::PUSH_PULL,0);
    }


    /**
     * Simple pin initialiser when you don't need or want the template support offered by GpioPort
     * and its features.
     * @param port
     * @param pins
     * @param mode
     * @param speed
     * @param pupdType
     * @param outputType
     */

    void initialise(GPIO_TypeDef *port,
                    uint16_t pins,
                    Gpio::GpioModeType mode,
                    GPIOSpeed_TypeDef speed,
                    Gpio::GpioPullUpDownType pupdType,
                    Gpio::GpioOutputType outputType) {

      GPIO_InitTypeDef init;

      // clock on

      RCC_AHB1PeriphClockCmd(port==GPIOA ? RCC_AHB1Periph_GPIOA :
                             port==GPIOB ? RCC_AHB1Periph_GPIOB :
                             port==GPIOC ? RCC_AHB1Periph_GPIOC :
                             port==GPIOD ? RCC_AHB1Periph_GPIOD :
                             port==GPIOE ? RCC_AHB1Periph_GPIOE :
                             port==GPIOF ? RCC_AHB1Periph_GPIOF :
                             port==GPIOG ? RCC_AHB1Periph_GPIOG :
                             port==GPIOH ? RCC_AHB1Periph_GPIOH :
                             RCC_AHB1Periph_GPIOI
                             ,ENABLE);

      // initialise

      init.GPIO_Pin=pins;
      init.GPIO_Speed=speed;

      switch(mode) {

        case Gpio::OUTPUT:
          init.GPIO_Mode=GPIO_Mode_OUT;
          break;

        case Gpio::INPUT:
          init.GPIO_Mode=GPIO_Mode_IN;
          break;

        case Gpio::ANALOG:
          init.GPIO_Mode=GPIO_Mode_AN;
          break;

        case Gpio::ALTERNATE_FUNCTION:
          init.GPIO_Mode=GPIO_Mode_AF;
          break;
      }

      switch(pupdType) {

        case Gpio::PUPD_NONE:
          init.GPIO_PuPd=GPIO_PuPd_NOPULL;
          break;

        case Gpio::PUPD_UP:
          init.GPIO_PuPd=GPIO_PuPd_UP;
          break;

        case Gpio::PUPD_DOWN:
          init.GPIO_PuPd=GPIO_PuPd_DOWN;
          break;
      }

      switch(outputType) {

        case Gpio::OPEN_DRAIN:
          init.GPIO_OType=GPIO_OType_OD;
          break;

        case Gpio::PUSH_PULL:
          init.GPIO_OType=GPIO_OType_PP;
          break;
      }

      GPIO_Init(port,&init);
    }
  }
}

#endif
// END FILE: ../lib/src/gpio/f4/GpioPinInitialiser.cpp
// START FILE: ../lib/src/device/BlockDevice.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/device.h"


namespace stm32plus {

  /**
   * Get the Master Boot Record (MBR) from devices that support it.
   * Calls down to the subclass to read block zero from the device.
   *
   * @param[in] mbr_ Pointer to a caller-owned Mbr structure that this
   *  method will populate.
   *
   * @return false indicates failure and the error provider is populated.
   */

  bool BlockDevice::getMbr(Mbr* mbr_) {
    // check that we support an MBR

    if(getFormatType()!=formatMbr)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_BLOCK_DEVICE,E_NO_MBR);

    // read it from the first sector in the device

    return readBlock(mbr_,0);
  }

}
// END FILE: ../lib/src/device/BlockDevice.cpp
// START FILE: ../lib/src/device/BlockDeviceOutputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/device.h"


namespace stm32plus {

  /**
   * Constructor
   * @param device The block device that this stream is attached to
   * @param firstBlock The index of the first block to begin writing to
   * @param buffered true if the block should be written back after each
   * and every write. false to only write back on flush() or when we move
   * to a new block.
   */

  BlockDeviceOutputStream::BlockDeviceOutputStream(BlockDevice& device,uint32_t firstBlock,bool buffered)
    : _device(device),
      _block(device.getBlockSizeInBytes()) {

    _blockIndex=firstBlock;
    _indexInBlock=0;
    _buffered=buffered;
  }


  /**
   * Destructor. Calls close.
   */

  BlockDeviceOutputStream::~BlockDeviceOutputStream() {
    close();
  }


  /**
   * Write a single byte to the stream/device
   * @param c The byte to write.
   * @return false if it fails
   */

  bool BlockDeviceOutputStream::write(uint8_t c) {
    return write(&c,1);
  }


  /**
   * Write a buffer of bytes
   * @param buffer A pointer to the buffer of bytes to write.
   * @param size The number of bytes in the buffer
   */

  bool BlockDeviceOutputStream::write(const void *buffer,uint32_t size) {

    uint32_t maxToWrite,toWrite;
    const uint8_t *ptr;

    ptr=reinterpret_cast<const uint8_t *>(buffer);

    while(size>0) {

      // write limit per iteration is up to the end of the block

      maxToWrite=_device.getBlockSizeInBytes()-_indexInBlock;
      toWrite=size<maxToWrite ? size : maxToWrite;

      // if necessary, fill the buffer with current data from the device

      if(!checkFillBuffer(toWrite))
        return false;

      // copy in this data

      memcpy(_block.getData()+_indexInBlock,ptr,toWrite);

      ptr+=toWrite;
      _indexInBlock+=toWrite;
      size-=toWrite;

      if(!checkFlush())
        return false;
    }

    return true;
  }


  /**
   * Check if the device must now be flushed given the user preference
   * and the current position of the write pointer
   * @return false if the device fails
   */

  bool BlockDeviceOutputStream::checkFlush() {

    if(!_buffered || _indexInBlock==_device.getBlockSizeInBytes()) {

      // user wants us to flush, or we've run out of space in the block

      if(!_device.writeBlock(_block,_blockIndex))
        return false;

      // if run out of space, increment block and reset pointer

      if(_indexInBlock==_device.getBlockSizeInBytes()) {
        _blockIndex++;
        _indexInBlock=0;
      }
    }

    return true;
  }


  /**
   * Check to see if the byte buffer needs filling to satisfy a
   * prospective write for toWrite bytes
   * @param toWrite The number of bytes we want to write
   * @return false if the device fails
   */

  bool BlockDeviceOutputStream::checkFillBuffer(uint32_t toWrite) {

    // if we are at the start of the block and we want to write less
    // than a full block then we need to get the current contents of
    // that block from the device

    if(_indexInBlock==0) {

      // cannot write anything at this point - we've run out of blocks

      if(_blockIndex==_device.getTotalBlocksOnDevice())
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_BLOCK_DEVICE_OUTPUT_STREAM,E_DEVICE_FULL);

      // need to read if we write less than a block

      if(toWrite<_device.getBlockSizeInBytes())
        return _device.readBlock(_block,_blockIndex);
    }

    return true;
  }


  /**
   * Close will call flush on a buffered stream
   */

  bool BlockDeviceOutputStream::close() {

    if(_buffered)
      return flush();

    return true;
  }


  /**
   * Flush the current block to disk
   */

  bool BlockDeviceOutputStream::flush() {

    // write out if there is something to write

    if(_indexInBlock>0)
      return _device.writeBlock(_block,_blockIndex);

    return true;
  }
}
// END FILE: ../lib/src/device/BlockDeviceOutputStream.cpp
// START FILE: ../lib/src/device/CachedBlockDevice.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/device.h"


namespace stm32plus {

  /**
   * Constructor
   *
   * @param[in] bd The block device being cached. Must not go out of scope.
   * @param[in] numCachedBlocks The number of blocks to cache. This parameter controls the memory used by this class.
   */

  CachedBlockDevice::CachedBlockDevice(BlockDevice& bd,uint32_t numCachedBlocks) :
    _device(bd), _numCachedBlocks(numCachedBlocks), _blockSize(bd.getBlockSizeInBytes()) {
    uint32_t i;

    _cachedBlocks=new uint8_t *[numCachedBlocks];
    _cacheIndex=new CacheEntry[numCachedBlocks];

    for(i=0;i<numCachedBlocks;i++) {
      _cachedBlocks[i]=new uint8_t[_blockSize];
      _cacheIndex[i].BlockIndex=FREE_CACHE_ENTRY;
      _cacheIndex[i].CacheIndex=i;
    }
  }

  /**
   * Destructor. Free memory allocated by the cache.
   */

  CachedBlockDevice::~CachedBlockDevice() {

    uint32_t i;

    for(i=0;i<_numCachedBlocks;i++)
      delete[] _cachedBlocks[i];

    delete _cachedBlocks;
    delete _cacheIndex;
  }

  /*
   * read a block
   */

  bool CachedBlockDevice::readBlock(void *dest,uint32_t blockIndex) {

    uint32_t i;

    // try to find in the cache index

    for(i=0;i<_numCachedBlocks&&_cacheIndex[i].BlockIndex!=FREE_CACHE_ENTRY;i++) {

      if(_cacheIndex[i].BlockIndex==blockIndex) {

        // cache hit

        memcpy(dest,_cachedBlocks[_cacheIndex[i].CacheIndex],_blockSize);
        moveToFront(i);
        return true;
      }
    }

    // cache miss, read from device

    if(!_device.readBlock(dest,blockIndex))
      return false;

    // write to the cache

    writeToCache(dest,blockIndex);
    return true;
  }

  /*
   * write a block
   */

  bool CachedBlockDevice::writeBlock(const void *src,uint32_t blockIndex) {

    // write through

    if(!_device.writeBlock(src,blockIndex))
      return false;

    // and into the cache

    writeToCache(src,blockIndex);
    return true;
  }

  /*
   * find cache entry and write
   */

  void CachedBlockDevice::writeToCache(const void *data,uint32_t blockIndex) {

    uint32_t i;
    CacheEntry evictedEntry;

    // if already in the cache index then move its entry to the front

    for(i=0;i<_numCachedBlocks&&_cacheIndex[i].BlockIndex!=FREE_CACHE_ENTRY;i++) {

      if(_cacheIndex[i].BlockIndex==blockIndex) {
        moveToFront(i);
        memcpy(_cachedBlocks[_cacheIndex[i].CacheIndex],data,_blockSize);
        return;
      }
    }

    // move up the whole index losing the last one

    evictedEntry=_cacheIndex[_numCachedBlocks-1];
    memmove(&_cacheIndex[1],&_cacheIndex[0],sizeof(CacheEntry)*(_numCachedBlocks-1));

    // this is a new entry into the index so store its data

    memcpy(_cachedBlocks[evictedEntry.CacheIndex],data,_blockSize);

    evictedEntry.BlockIndex=blockIndex;
    _cacheIndex[0]=evictedEntry;
  }

  /*
   * move an entry to the front of the index
   */

  void CachedBlockDevice::moveToFront(uint32_t index) {

    if(index!=0) {

      CacheEntry entry;

      entry=_cacheIndex[index];
      memmove(&_cacheIndex[1],&_cacheIndex[0],sizeof(CacheEntry)*index);
      _cacheIndex[0]=entry;
    }
  }

  /*
   * multi-block write
   */

  bool CachedBlockDevice::writeBlocks(const void *src,uint32_t blockIndex,uint32_t numBlocks) {

    uint32_t i;
    const uint8_t *ptr;

    ptr=static_cast<const uint8_t *> (src);

    for(i=0;i<numBlocks;i++) {

      if(!writeBlock(ptr,blockIndex+i))
        return false;

      ptr+=_blockSize;
    }

    return true;
  }

  /*
   * multi-block read
   */

  bool CachedBlockDevice::readBlocks(void *dest,uint32_t blockIndex,uint32_t numBlocks) {
    uint32_t i;
    uint8_t *ptr;

    ptr=static_cast<uint8_t *> (dest);

    for(i=0;i<numBlocks;i++) {

      if(!readBlock(ptr,blockIndex+i))
        return false;

      ptr+=_blockSize;
    }

    return true;
  }

  /*
   * pass through to device
   */

  BlockDevice::formatType CachedBlockDevice::getFormatType() {
    return _device.getFormatType();
  }

  uint32_t CachedBlockDevice::getBlockSizeInBytes() {
    return _blockSize;
  }

  uint32_t CachedBlockDevice::getTotalBlocksOnDevice() {
    return _device.getTotalBlocksOnDevice();
  }
}
// END FILE: ../lib/src/device/CachedBlockDevice.cpp
// START FILE: ../lib/src/device/BlockDeviceInputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/device.h"


namespace stm32plus {

  /**
   * Constructor
   * @param device The block device that this stream is attached to
   * @param firstBlock The index of the first block to begin writing to
   */

  BlockDeviceInputStream::BlockDeviceInputStream(BlockDevice& device,uint32_t firstBlock)
    : _device(device),
      _block(device.getBlockSizeInBytes()) {

    _blockIndex=_originalBlockIndex=firstBlock;
    _indexInBlock=0;
  }


  /**
   * Read a character from the stream
   * @return the character read or E_END_OF_STREAM / E_STREAM_ERROR
   */

  int16_t BlockDeviceInputStream::read() {

    int16_t errorCode;

    // need 1 byte

    if((errorCode=requireBytes())!=ErrorProvider::ERROR_NO_ERROR)
      return errorCode;

    // get from the block

    return _block[_indexInBlock++];
  }


  /**
   * Read a sequence of bytes. Return false if an error occurs or there are no more
   * bytes to read. Returns true if at least one byte was read successfully. Fewer
   * bytes may be read than you asked for if the end of the device was reached. Check
   * actuallyRead for the total returned.
   * @param buffer Where to write to
   * @param Maximum byte size to read
   * @param actuallyRead How much was actually read.
   * @return false if it fails or no bytes are available
   */

  bool BlockDeviceInputStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

    uint32_t available,count;
    uint8_t *ptr;
    int16_t errorCode;

    // reset count

    actuallyRead=0;
    ptr=reinterpret_cast<uint8_t *>(buffer);

    while(size>0) {

      // max per loop can be up to the block end

      available=_device.getBlockSizeInBytes()-_indexInBlock;
      count=size<available ? size : available;

      // make sure they're here

      if((errorCode=requireBytes())!=ErrorProvider::ERROR_NO_ERROR) {

        // no bytes available now is an error if no bytes
        // have been available at all

        if(errorCode==E_END_OF_STREAM)
          return actuallyRead>0;

        // some other device failure

        return false;
      }

      // copy what we have

      memcpy(ptr,_block.getData()+_indexInBlock,count);
      ptr+=count;
      actuallyRead+=count;
      size-=count;
      _indexInBlock+=count;
    }

    return true;
  }


  /**
   *  Can't close but it's not a fail
   *  @return true
   */

  bool BlockDeviceInputStream::close() {
    return true;
  }


  /**
   * Can skip if there's enough blocks to move into
   * @return false if it would fail - the internal position is not changed on failure
   */

  bool BlockDeviceInputStream::skip(uint32_t howMuch) {

    uint32_t newBlock,newIndex;

    // bump forward as many whole blocks as required

    newBlock=_blockIndex+(howMuch / _device.getBlockSizeInBytes());

    // and by how much in addition to whole blocks

    newIndex=_blockIndex+(howMuch % _device.getBlockSizeInBytes());

    // gone past a block boundary? update if so

    if(newIndex>=_device.getBlockSizeInBytes()) {
      newBlock++;
      newIndex-=_device.getBlockSizeInBytes();
    }

    // check for end of device

    if(newBlock>=_device.getTotalBlocksOnDevice())
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_BLOCK_DEVICE_INPUT_STREAM,E_INVALID_SEEK_POSITION);

    // update positions and read in the new block

    if(newBlock!=_blockIndex)
      if(!_device.readBlock(_block,newBlock))
        return false;

    _blockIndex=newBlock;
    _indexInBlock=newIndex;

    return true;
  }


  /**
   * return true if there is more data available
   * @return false if no more data is available
   */

  bool BlockDeviceInputStream::available() {

    // data is available if we're not at the last block
    // or the index in the block is less than the end

    return _blockIndex<_device.getTotalBlocksOnDevice() ||
           _indexInBlock<_device.getBlockSizeInBytes();
  }


  /**
   * Reset stream to the beginning. This is supported
   * @return true
   */

  bool BlockDeviceInputStream::reset() {

    _blockIndex=_originalBlockIndex;
    _indexInBlock=0;

    return true;
  }


  /**
   * require the given number of bytes to be available.
   * @param numBytes must not run past the size of a block
   */

  int16_t BlockDeviceInputStream::requireBytes() {

    // if the index has hit the end, advance to new block

    if(_indexInBlock==_device.getBlockSizeInBytes()) {

      _indexInBlock=0;
      _blockIndex++;

      // check for end of the device

      if(_blockIndex==_device.getTotalBlocksOnDevice())
        return E_END_OF_STREAM;
    }

    // if we're at position zero then new bytes must be read in

    if(_indexInBlock==0)
      if(!_device.readBlock(_block,_blockIndex))
        return E_STREAM_ERROR;

    return ErrorProvider::ERROR_NO_ERROR;
  }
}
// END FILE: ../lib/src/device/BlockDeviceInputStream.cpp
// START FILE: ../lib/src/rcc/RccBusInformation.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/rcc.h"


namespace stm32plus {


  #if defined(STM32PLUS_F1) || defined(STM32PLUS_F4)

  /*
   * Get the APB1 prescaler value
   */

  uint16_t RccBusInformation::getAPB1Prescaler() {

    switch(RCC->CFGR & RCC_CFGR_PPRE1) {

      case RCC_CFGR_PPRE1_DIV1:
        return 1;

      case RCC_CFGR_PPRE1_DIV2:
        return 2;

      case RCC_CFGR_PPRE1_DIV4:
        return 4;

      case RCC_CFGR_PPRE1_DIV8:
        return 8;

      case RCC_CFGR_PPRE1_DIV16:
      default:
        return 16;
    }
  }


  /*
   * Get the APB2 prescaler value
   */

  uint16_t RccBusInformation::getAPB2Prescaler() {

    switch(RCC->CFGR & RCC_CFGR_PPRE2) {

      case RCC_CFGR_PPRE2_DIV1:
        return 1;

      case RCC_CFGR_PPRE2_DIV2:
        return 2;

      case RCC_CFGR_PPRE2_DIV4:
        return 4;

      case RCC_CFGR_PPRE2_DIV8:
        return 8;

      case RCC_CFGR_PPRE2_DIV16:
      default:
        return 16;
    }
  }


#elif defined (STM32PLUS_F0)


  /*
   * Get the APB2 prescaler value
   */

  uint16_t RccBusInformation::getAPBPrescaler() {

    switch(RCC->CFGR & RCC_CFGR_PPRE) {

      case RCC_CFGR_PPRE_DIV1:
        return 1;

      case RCC_CFGR_PPRE_DIV2:
        return 2;

      case RCC_CFGR_PPRE_DIV4:
        return 4;

      case RCC_CFGR_PPRE_DIV8:
        return 8;

      case RCC_CFGR_PPRE_DIV16:
      default:
        return 16;
    }
  }


#endif


  /*
   * Get the AHB prescaler value
   */

  uint16_t RccBusInformation::getAHBPrescaler() {

    switch(RCC->CFGR & RCC_CFGR_HPRE) {

      case RCC_CFGR_HPRE_DIV1:
        return 1;

      case RCC_CFGR_HPRE_DIV2:
        return 2;

      case RCC_CFGR_HPRE_DIV4:
        return 4;

      case RCC_CFGR_HPRE_DIV8:
        return 8;

      case RCC_CFGR_HPRE_DIV16:
        return 16;

      case RCC_CFGR_HPRE_DIV64:
        return 64;

      case RCC_CFGR_HPRE_DIV128:
        return 128;

      case RCC_CFGR_HPRE_DIV256:
        return 256;

      case RCC_CFGR_HPRE_DIV512:
      default:
        return 512;
    }
  }
}
// END FILE: ../lib/src/rcc/RccBusInformation.cpp
// START FILE: ../lib/src/usb/f4/phy/interrupts/UsbFsInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/usb/device/device.h"

using namespace stm32plus::usb;


#if defined(USE_OTG_FS_INTERRUPT)


// static initialisers

InternalFsPhyInterruptFeature::FPTR InternalFsPhyInterruptFeature::_forceLinkage=nullptr;
UsbEventSource *InternalFsPhyInterruptFeature::_usbEventSource=nullptr;


extern "C" {

  void __attribute__ ((interrupt("IRQ"))) OTG_FS_IRQHandler(void) {

    InternalFsPhyInterruptFeature::_usbEventSource->UsbEventSender.raiseEvent(OtgFsInterruptEvent());

    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/usb/f4/phy/interrupts/UsbFsInterruptHandler.cpp
// START FILE: ../lib/src/usb/f4/Hal.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"


#if defined(STM32PLUS_F4)


using namespace stm32plus;


/**
 * Delay for the given number of milliseconds
 */

extern "C" {
  void HAL_Delay(uint32_t ms) {
    MillisecondTimer::delay(ms);
  }
}

#endif
// END FILE: ../lib/src/usb/f4/Hal.cpp
// START FILE: ../lib/src/usb/f4/device/hid/MouseReportDescriptor.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/usb/device/hid.h"


namespace stm32plus {
  namespace usb {

    /**
     * The mouse report descriptor bytes
     */

    const uint8_t MouseReportDescriptor[50]={
      0x05, 0x01,     // USAGE_PAGE (Generic Desktop)
      0x09, 0x02,     // USAGE (Mouse)
      0xa1, 0x01,     // COLLECTION (Application)
      0x09, 0x01,     // USAGE (Pointer)
      0xa1, 0x00,     // COLLECTION (Physical)
      0x05, 0x09,     // USAGE_PAGE (Button)
      0x19, 0x01,     // USAGE_MINIMUM (Button 1)
      0x29, 0x03,     // USAGE_MAXIMUM (Button 3)
      0x15, 0x00,     // LOGICAL_MINIMUM (0)
      0x25, 0x01,     // LOGICAL_MAXIMUM (1)
      0x95, 0x03,     // REPORT_COUNT (3)
      0x75, 0x01,     // REPORT_SIZE (1)
      0x81, 0x02,     // INPUT (Data,Var,Abs)
      0x95, 0x01,     // REPORT_COUNT (1)
      0x75, 0x05,     // REPORT_SIZE (5)
      0x81, 0x03,     // INPUT (Cnst,Var,Abs)
      0x05, 0x01,     // USAGE_PAGE (Generic Desktop)
      0x09, 0x30,     // USAGE (X)
      0x09, 0x31,     // USAGE (Y)
      0x15, 0x81,     // LOGICAL_MINIMUM (-127)
      0x25, 0x7f,     // LOGICAL_MAXIMUM (127)
      0x75, 0x08,     // REPORT_SIZE (8)
      0x95, 0x02,     // REPORT_COUNT (2)
      0x81, 0x06,     // INPUT (Data,Var,Rel)
      0xc0,           // END_COLLECTION
      0xc0            // END_COLLECTION
    };
  }
}


#endif
// END FILE: ../lib/src/usb/f4/device/hid/MouseReportDescriptor.cpp
// START FILE: ../lib/src/usb/f4/device/hid/KeyboardReportDescriptor.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/usb/device/hid.h"


namespace stm32plus {
  namespace usb {

    /**
     * The keyboard report descriptor bytes
     */


    const uint8_t KeyboardReportDescriptor[63] = {
      0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
      0x09, 0x06,                    // USAGE (Keyboard)
      0xa1, 0x01,                    // COLLECTION (Application)
      0x75, 0x01,                    //   REPORT_SIZE (1)
      0x95, 0x08,                    //   REPORT_COUNT (8)
      0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
      0x19, 0xe0,                    //   USAGE_MINIMUM (Keyboard LeftControl)(224)
      0x29, 0xe7,                    //   USAGE_MAXIMUM (Keyboard Right GUI)(231)
      0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
      0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
      0x81, 0x02,                    //   INPUT (Data,Var,Abs) ; Modifier byte
      0x95, 0x01,                    //   REPORT_COUNT (1)
      0x75, 0x08,                    //   REPORT_SIZE (8)
      0x81, 0x03,                    //   INPUT (Cnst,Var,Abs) ; Reserved byte
      0x95, 0x05,                    //   REPORT_COUNT (5)
      0x75, 0x01,                    //   REPORT_SIZE (1)
      0x05, 0x08,                    //   USAGE_PAGE (LEDs)
      0x19, 0x01,                    //   USAGE_MINIMUM (Num Lock)
      0x29, 0x05,                    //   USAGE_MAXIMUM (Kana)
      0x91, 0x02,                    //   OUTPUT (Data,Var,Abs) ; LED report
      0x95, 0x01,                    //   REPORT_COUNT (1)
      0x75, 0x03,                    //   REPORT_SIZE (3)
      0x91, 0x03,                    //   OUTPUT (Cnst,Var,Abs) ; LED report padding
      0x95, 0x06,                    //   REPORT_COUNT (6)
      0x75, 0x08,                    //   REPORT_SIZE (8)
      0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
      0x25, 0x65,                    //   LOGICAL_MAXIMUM (101)
      0x05, 0x07,                    //   USAGE_PAGE (Keyboard)(Key Codes)
      0x19, 0x00,                    //   USAGE_MINIMUM (Reserved (no event indicated))(0)
      0x29, 0x65,                    //   USAGE_MAXIMUM (Keyboard Application)(101)
      0x81, 0x00,                    //   INPUT (Data,Ary,Abs)
      0xc0                           // END_COLLECTION
    };
  }
}


#endif
// END FILE: ../lib/src/usb/f4/device/hid/KeyboardReportDescriptor.cpp
// START FILE: ../lib/src/usb/f4/device/UsbDevice.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/usb/device/device.h"


using namespace stm32plus;
using namespace stm32plus::usb;


/**
  * @brief  Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev) {
  return stm32plus::usb::usb_device_internal::notifyEvent(pdev,UsbEventDescriptor::EventType::DEVICE_INIT);
}


/**
  * @brief  De-Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_DeInit(USBD_HandleTypeDef *pdev) {
  return stm32plus::usb::usb_device_internal::notifyEvent(pdev,UsbEventDescriptor::EventType::DEVICE_DEINIT);
}


/**
  * @brief  Starts the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev) {
  return stm32plus::usb::usb_device_internal::notifyEvent(pdev,UsbEventDescriptor::EventType::DEVICE_START);
}


/**
  * @brief  Stops the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_Stop(USBD_HandleTypeDef *pdev) {
  return stm32plus::usb::usb_device_internal::notifyEvent(pdev,UsbEventDescriptor::EventType::DEVICE_STOP);
}


/**
  * @brief  Opens an endpoint of the Low Level Driver.
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @param  ep_type: Endpoint Type
  * @param  ep_mps: Endpoint Max Packet Size
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev,uint8_t ep_addr,uint8_t ep_type,uint16_t ep_mps) {

  DeviceSdkOpenEndpointEvent event(ep_addr,static_cast<EndpointType>(ep_type),ep_mps);

  reinterpret_cast<UsbEventSource *>(pdev->pUserData)->UsbEventSender.raiseEvent(event);
  return event.retval;
}


/**
  * @brief  Closes an endpoint of the Low Level Driver.
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev,uint8_t ep_addr) {
  return stm32plus::usb::usb_device_internal::endpointEvent(pdev,UsbEventDescriptor::EventType::DEVICE_CLOSE_ENDPOINT,ep_addr);
}


/**
  * @brief  Flushes an endpoint of the Low Level Driver.
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_FlushEP(USBD_HandleTypeDef *pdev,uint8_t ep_addr) {
  return stm32plus::usb::usb_device_internal::endpointEvent(pdev,UsbEventDescriptor::EventType::DEVICE_FLUSH_ENDPOINT,ep_addr);
}


/**
  * @brief  Sets a Stall condition on an endpoint of the Low Level Driver.
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr) {
  return stm32plus::usb::usb_device_internal::endpointEvent(pdev,UsbEventDescriptor::EventType::DEVICE_STALL_ENDPOINT,ep_addr);
}


/**
  * @brief  Clears a Stall condition on an endpoint of the Low Level Driver.
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev,uint8_t ep_addr) {
  return stm32plus::usb::usb_device_internal::endpointEvent(pdev,UsbEventDescriptor::EventType::DEVICE_CLEAR_STALL_ENDPOINT,ep_addr);
}


/**
  * @brief  Returns Stall condition.
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Stall (1: Yes, 0: No)
  */

uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev,uint8_t ep_addr) {

  DeviceSdkIsStalledEndpointEvent event(ep_addr);

  reinterpret_cast<UsbEventSource *>(pdev->pUserData)->UsbEventSender.raiseEvent(event);
  return event.isStalled;
}


/**
  * @brief  Assigns a USB address to the device.
  * @param  pdev: Device handle
  * @param  dev_addr: device address - pointless parameter because it's in the pdev structure!
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev,uint8_t /* dev_addr */) {
  return stm32plus::usb::usb_device_internal::notifyEvent(pdev,UsbEventDescriptor::EventType::DEVICE_SET_USB_ADDRESS);
}


/**
  * @brief  Transmits data over an endpoint.
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev,uint8_t ep_addr,uint8_t *pbuf,uint16_t size) {

  DeviceSdkDataEndpointEvent event(UsbEventDescriptor::EventType::DEVICE_TRANSMIT,ep_addr,pbuf,size);

  reinterpret_cast<UsbEventSource *>(pdev->pUserData)->UsbEventSender.raiseEvent(event);
  return event.retval;
}


/**
  * @brief  Prepares an endpoint for reception.
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD Status
  */

USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev,uint8_t ep_addr,uint8_t *pbuf,uint16_t size) {

  DeviceSdkDataEndpointEvent event(UsbEventDescriptor::EventType::DEVICE_PREPARE_RECEIVE,ep_addr,pbuf,size);

  reinterpret_cast<UsbEventSource *>(pdev->pUserData)->UsbEventSender.raiseEvent(event);
  return event.retval;
}


/**
  * @brief  Returns the last transfered packet size.
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval Recived Data Size
  */

uint32_t USBD_LL_GetRxDataSize(USBD_HandleTypeDef *pdev,uint8_t ep_addr) {

  DeviceSdkGetLastTransferredSizeEndpointEvent event(ep_addr);

  reinterpret_cast<UsbEventSource *>(pdev->pUserData)->UsbEventSender.raiseEvent(event);
  return event.lastTransferred;
}


/**
  * @brief  Delays routine for the USB Device Library.
  * @param  Delay: Delay in ms
  * @retval None
  */

void USBD_LL_Delay(uint32_t delay) {
  MillisecondTimer::delay(delay);
}


/**
 * Reset IRQ callback
 */

void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd) {

  reinterpret_cast<UsbEventSource *>(
    reinterpret_cast<USBD_HandleTypeDef *>(hpcd->pData)->pUserData
  )->UsbEventSender.raiseEvent(DeviceSdkResetInterruptEvent());
}


/**
 * Suspend IRQ callback
 */

void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd) {
  reinterpret_cast<UsbEventSource *>(
    reinterpret_cast<USBD_HandleTypeDef *>(hpcd->pData)->pUserData
  )->UsbEventSender.raiseEvent(DeviceSdkSuspendInterruptEvent());
}


/**
 * Resume IRQ callback
 */

void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd) {
  reinterpret_cast<UsbEventSource *>(
    reinterpret_cast<USBD_HandleTypeDef *>(hpcd->pData)->pUserData
  )->UsbEventSender.raiseEvent(DeviceSdkResumeInterruptEvent());
}


/**
 * Connect callback
 */

void HAL_PCD_ConnectCallback(PCD_HandleTypeDef *hpcd) {
  reinterpret_cast<UsbEventSource *>(
    reinterpret_cast<USBD_HandleTypeDef *>(hpcd->pData)->pUserData
  )->UsbEventSender.raiseEvent(DeviceSdkConnectInterruptEvent());
}


/**
 * Disconnect callback
 */

void HAL_PCD_DisconnectCallback(PCD_HandleTypeDef *hpcd) {
  reinterpret_cast<UsbEventSource *>(
    reinterpret_cast<USBD_HandleTypeDef *>(hpcd->pData)->pUserData
  )->UsbEventSender.raiseEvent(DeviceSdkDisconnectInterruptEvent());
}


/**
 * Setup stage callback
 */

void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd) {
  reinterpret_cast<UsbEventSource *>(
    reinterpret_cast<USBD_HandleTypeDef *>(hpcd->pData)->pUserData
  )->UsbEventSender.raiseEvent(DeviceSdkSetupStageInterruptEvent());
}


/**
 * Data out stage callback
 */

void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd,uint8_t epnum) {
  reinterpret_cast<UsbEventSource *>(
    reinterpret_cast<USBD_HandleTypeDef *>(hpcd->pData)->pUserData
  )->UsbEventSender.raiseEvent(DeviceSdkDataOutStageInterruptEvent(epnum));
}


/**
 * Data in stage callback
 */

void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd,uint8_t epnum) {
  reinterpret_cast<UsbEventSource *>(
    reinterpret_cast<USBD_HandleTypeDef *>(hpcd->pData)->pUserData
  )->UsbEventSender.raiseEvent(DeviceSdkDataInStageInterruptEvent(epnum));
}


#endif
// END FILE: ../lib/src/usb/f4/device/UsbDevice.cpp
// START FILE: ../lib/src/usart/interrupts/Usart6InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


#if defined(STM32PLUS_F4)

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> UsartInterruptFeatureEnabler<6>::FPTR UsartInterruptFeatureEnabler<6>::_forceLinkage=nullptr;
template<> UsartEventSource *UsartInterruptFeature<6>::_usartInstance=nullptr;


extern "C" {

  #if defined(USE_USART6_INTERRUPT)

    void __attribute__ ((interrupt("IRQ"))) USART6_IRQHandler(void) {
      if(USART_GetITStatus(USART6,USART_IT_RXNE)!=RESET) {
        UsartInterruptFeature<6>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_RECEIVE);
        USART_ClearITPendingBit(USART6,USART_IT_RXNE);
      }
      else if(USART_GetITStatus(USART6,USART_IT_TXE)!=RESET) {
        UsartInterruptFeature<6>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_READY_TO_TRANSMIT);
        USART_ClearITPendingBit(USART6,USART_IT_TXE);
      }
      else if(USART_GetITStatus(USART6,USART_IT_TC)!=RESET) {
        UsartInterruptFeature<6>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_TRANSMIT_COMPLETE);
        USART_ClearITPendingBit(USART6,USART_IT_TC);
      }
      else if(USART_GetITStatus(USART6,USART_IT_PE)!=RESET) {
        UsartInterruptFeature<6>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_PARITY_ERROR);
        USART_ClearITPendingBit(USART6,USART_IT_PE);
      }
      else if(USART_GetITStatus(USART6,USART_IT_IDLE)!=RESET) {
        UsartInterruptFeature<6>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_IDLE);
        USART_ClearITPendingBit(USART6,USART_IT_IDLE);
      }
      else if(USART_GetITStatus(USART6,USART_IT_LBD)!=RESET) {
        UsartInterruptFeature<6>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_LINE_BREAK_DETECT);
        USART_ClearITPendingBit(USART6,USART_IT_LBD);
      }
      else if(USART_GetITStatus(USART6,USART_IT_CTS)!=RESET) {
        UsartInterruptFeature<6>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_CLEAR_TO_SEND);
        USART_ClearITPendingBit(USART6,USART_IT_CTS);
      }
      else if(USART_GetITStatus(USART6,USART_IT_ERR)!=RESET) {
        UsartInterruptFeature<6>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_ERROR);
        USART_ClearITPendingBit(USART6,USART_IT_ERR);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

  #endif
}

#endif
// END FILE: ../lib/src/usart/interrupts/Usart6InterruptHandler.cpp
// START FILE: ../lib/src/usart/interrupts/Usart1InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> UsartInterruptFeatureEnabler<1>::FPTR UsartInterruptFeatureEnabler<1>::_forceLinkage=nullptr;
template<> UsartEventSource *UsartInterruptFeature<1> ::_usartInstance=nullptr;


extern "C" {

  #if defined(USE_USART1_INTERRUPT)

    void __attribute__ ((interrupt("IRQ"))) USART1_IRQHandler(void) {
      if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET) {
        UsartInterruptFeature<1>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_RECEIVE);
        USART_ClearITPendingBit(USART1,USART_IT_RXNE);
      }
      else if(USART_GetITStatus(USART1,USART_IT_TXE)!=RESET) {
        UsartInterruptFeature<1>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_READY_TO_TRANSMIT);
        USART_ClearITPendingBit(USART1,USART_IT_TXE);
      }
      else if(USART_GetITStatus(USART1,USART_IT_TC)!=RESET) {
        UsartInterruptFeature<1>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_TRANSMIT_COMPLETE);
        USART_ClearITPendingBit(USART1,USART_IT_TC);
      }
      else if(USART_GetITStatus(USART1,USART_IT_PE)!=RESET) {
        UsartInterruptFeature<1>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_PARITY_ERROR);
        USART_ClearITPendingBit(USART1,USART_IT_PE);
      }
      else if(USART_GetITStatus(USART1,USART_IT_IDLE)!=RESET) {
        UsartInterruptFeature<1>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_IDLE);
        USART_ClearITPendingBit(USART1,USART_IT_IDLE);
      }
      else if(USART_GetITStatus(USART1,USART_IT_LBD)!=RESET) {
        UsartInterruptFeature<1>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_LINE_BREAK_DETECT);
        USART_ClearITPendingBit(USART1,USART_IT_LBD);
      }
      else if(USART_GetITStatus(USART1,USART_IT_CTS)!=RESET) {
        UsartInterruptFeature<1>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_CLEAR_TO_SEND);
        USART_ClearITPendingBit(USART1,USART_IT_CTS);
      }
      else if(USART_GetITStatus(USART1,USART_IT_ERR)!=RESET) {
        UsartInterruptFeature<1>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_ERROR);
        USART_ClearITPendingBit(USART1,USART_IT_ERR);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

  #endif
}
// END FILE: ../lib/src/usart/interrupts/Usart1InterruptHandler.cpp
// START FILE: ../lib/src/usart/interrupts/Uart4InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"

#if !defined(STM32PLUS_F1_MD_VL) && !defined(STM32PLUS_F0)

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> UsartInterruptFeatureEnabler<4>::FPTR UsartInterruptFeatureEnabler<4>::_forceLinkage=nullptr;
template<> UsartEventSource *UsartInterruptFeature<4> ::_usartInstance=nullptr;


extern "C" {

  #if defined(USE_UART4_INTERRUPT)

    void __attribute__ ((interrupt("IRQ"))) UART4_IRQHandler(void) {
      if(USART_GetITStatus(UART4,USART_IT_RXNE)!=RESET) {
        UsartInterruptFeature<4>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_RECEIVE);
        USART_ClearITPendingBit(UART4,USART_IT_RXNE);
      }
      else if(USART_GetITStatus(UART4,USART_IT_TXE)!=RESET) {
        UsartInterruptFeature<4>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_READY_TO_TRANSMIT);
        USART_ClearITPendingBit(UART4,USART_IT_TXE);
      }
      else if(USART_GetITStatus(UART4,USART_IT_TC)!=RESET) {
        UsartInterruptFeature<4>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_TRANSMIT_COMPLETE);
        USART_ClearITPendingBit(UART4,USART_IT_TC);
      }
      else if(USART_GetITStatus(UART4,USART_IT_PE)!=RESET) {
        UsartInterruptFeature<4>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_PARITY_ERROR);
        USART_ClearITPendingBit(UART4,USART_IT_PE);
      }
      else if(USART_GetITStatus(UART4,USART_IT_IDLE)!=RESET) {
        UsartInterruptFeature<4>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_IDLE);
        USART_ClearITPendingBit(UART4,USART_IT_IDLE);
      }
      else if(USART_GetITStatus(UART4,USART_IT_LBD)!=RESET) {
        UsartInterruptFeature<4>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_LINE_BREAK_DETECT);
        USART_ClearITPendingBit(UART4,USART_IT_LBD);
      }
      else if(USART_GetITStatus(UART4,USART_IT_ERR)!=RESET) {
        UsartInterruptFeature<4>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_ERROR);
        USART_ClearITPendingBit(UART4,USART_IT_ERR);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

  #endif
}

#endif
// END FILE: ../lib/src/usart/interrupts/Uart4InterruptHandler.cpp
// START FILE: ../lib/src/usart/interrupts/Uart5InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"

#if !defined(STM32PLUS_F1_MD_VL) && !defined(STM32PLUS_F0)

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> UsartInterruptFeatureEnabler<5>::FPTR UsartInterruptFeatureEnabler<5>::_forceLinkage=nullptr;
template<> UsartEventSource *UsartInterruptFeature<5>::_usartInstance=nullptr;


extern "C" {

  #if defined(USE_UART5_INTERRUPT)

    void __attribute__ ((interrupt("IRQ"))) UART5_IRQHandler(void) {
      if(USART_GetITStatus(UART5,USART_IT_RXNE)!=RESET) {
        UsartInterruptFeature<5>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_RECEIVE);
        USART_ClearITPendingBit(UART5,USART_IT_RXNE);
      }
      else if(USART_GetITStatus(UART5,USART_IT_TXE)!=RESET) {
        UsartInterruptFeature<5>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_READY_TO_TRANSMIT);
        USART_ClearITPendingBit(UART5,USART_IT_TXE);
      }
      else if(USART_GetITStatus(UART5,USART_IT_TC)!=RESET) {
        UsartInterruptFeature<5>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_TRANSMIT_COMPLETE);
        USART_ClearITPendingBit(UART5,USART_IT_TC);
      }
      else if(USART_GetITStatus(UART5,USART_IT_PE)!=RESET) {
        UsartInterruptFeature<5>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_PARITY_ERROR);
        USART_ClearITPendingBit(UART5,USART_IT_PE);
      }
      else if(USART_GetITStatus(UART5,USART_IT_IDLE)!=RESET) {
        UsartInterruptFeature<5>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_IDLE);
        USART_ClearITPendingBit(UART5,USART_IT_IDLE);
      }
      else if(USART_GetITStatus(UART5,USART_IT_LBD)!=RESET) {
        UsartInterruptFeature<5>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_LINE_BREAK_DETECT);
        USART_ClearITPendingBit(UART5,USART_IT_LBD);
      }
      else if(USART_GetITStatus(UART5,USART_IT_ERR)!=RESET) {
        UsartInterruptFeature<5>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_ERROR);
        USART_ClearITPendingBit(UART5,USART_IT_ERR);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

  #endif
} // extern "C"


#endif
// END FILE: ../lib/src/usart/interrupts/Uart5InterruptHandler.cpp
// START FILE: ../lib/src/usart/interrupts/Usart3InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


#if defined(STM32PLUS_F1) || defined(STM32PLUS_F4)


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> UsartInterruptFeatureEnabler<3>::FPTR UsartInterruptFeatureEnabler<3>::_forceLinkage=nullptr;
template<> UsartEventSource *UsartInterruptFeature<3>::_usartInstance=nullptr;


extern "C" {

  #if defined(USE_USART3_INTERRUPT)

    void __attribute__ ((interrupt("IRQ"))) USART3_IRQHandler(void) {
      if(USART_GetITStatus(USART3,USART_IT_RXNE)!=RESET) {
        UsartInterruptFeature<3>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_RECEIVE);
        USART_ClearITPendingBit(USART3,USART_IT_RXNE);
      }
      else if(USART_GetITStatus(USART3,USART_IT_TXE)!=RESET) {
        UsartInterruptFeature<3>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_READY_TO_TRANSMIT);
        USART_ClearITPendingBit(USART3,USART_IT_TXE);
      }
      else if(USART_GetITStatus(USART3,USART_IT_TC)!=RESET) {
        UsartInterruptFeature<3>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_TRANSMIT_COMPLETE);
        USART_ClearITPendingBit(USART3,USART_IT_TC);
      }
      else if(USART_GetITStatus(USART3,USART_IT_PE)!=RESET) {
        UsartInterruptFeature<3>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_PARITY_ERROR);
        USART_ClearITPendingBit(USART3,USART_IT_PE);
      }
      else if(USART_GetITStatus(USART3,USART_IT_IDLE)!=RESET) {
        UsartInterruptFeature<3>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_IDLE);
        USART_ClearITPendingBit(USART3,USART_IT_IDLE);
      }
      else if(USART_GetITStatus(USART3,USART_IT_LBD)!=RESET) {
        UsartInterruptFeature<3>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_LINE_BREAK_DETECT);
        USART_ClearITPendingBit(USART3,USART_IT_LBD);
      }
      else if(USART_GetITStatus(USART3,USART_IT_CTS)!=RESET) {
        UsartInterruptFeature<3>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_CLEAR_TO_SEND);
        USART_ClearITPendingBit(USART3,USART_IT_CTS);
      }
      else if(USART_GetITStatus(USART3,USART_IT_ERR)!=RESET) {
        UsartInterruptFeature<3>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_ERROR);
        USART_ClearITPendingBit(USART3,USART_IT_ERR);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

  #endif
}


#endif
// END FILE: ../lib/src/usart/interrupts/Usart3InterruptHandler.cpp
// START FILE: ../lib/src/usart/interrupts/Usart2InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> UsartInterruptFeatureEnabler<2>::FPTR UsartInterruptFeatureEnabler<2>::_forceLinkage=nullptr;
template<> UsartEventSource *UsartInterruptFeature<2>::_usartInstance=nullptr;


extern "C" {

  #if defined(USE_USART2_INTERRUPT)

    void __attribute__ ((interrupt("IRQ"))) USART2_IRQHandler(void) {
      if(USART_GetITStatus(USART2,USART_IT_RXNE)!=RESET) {
        UsartInterruptFeature<2>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_RECEIVE);
        USART_ClearITPendingBit(USART2,USART_IT_RXNE);
      }
      else if(USART_GetITStatus(USART2,USART_IT_TXE)!=RESET) {
        UsartInterruptFeature<2>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_READY_TO_TRANSMIT);
        USART_ClearITPendingBit(USART2,USART_IT_TXE);
      }
      else if(USART_GetITStatus(USART2,USART_IT_TC)!=RESET) {
        UsartInterruptFeature<2>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_TRANSMIT_COMPLETE);
        USART_ClearITPendingBit(USART2,USART_IT_TC);
      }
      else if(USART_GetITStatus(USART2,USART_IT_PE)!=RESET) {
        UsartInterruptFeature<2>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_PARITY_ERROR);
        USART_ClearITPendingBit(USART2,USART_IT_PE);
      }
      else if(USART_GetITStatus(USART2,USART_IT_IDLE)!=RESET) {
        UsartInterruptFeature<2>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_IDLE);
        USART_ClearITPendingBit(USART2,USART_IT_IDLE);
      }
      else if(USART_GetITStatus(USART2,USART_IT_LBD)!=RESET) {
        UsartInterruptFeature<2>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_LINE_BREAK_DETECT);
        USART_ClearITPendingBit(USART2,USART_IT_LBD);
      }
      else if(USART_GetITStatus(USART2,USART_IT_CTS)!=RESET) {
        UsartInterruptFeature<2>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_CLEAR_TO_SEND);
        USART_ClearITPendingBit(USART2,USART_IT_CTS);
      }
      else if(USART_GetITStatus(USART2,USART_IT_ERR)!=RESET) {
        UsartInterruptFeature<2>::_usartInstance->UsartInterruptEventSender.raiseEvent(UsartEventType::EVENT_ERROR);
        USART_ClearITPendingBit(USART2,USART_IT_ERR);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

  #endif
}
// END FILE: ../lib/src/usart/interrupts/Usart2InterruptHandler.cpp
// START FILE: ../lib/src/usart/UsartPollingOutputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


namespace stm32plus {

  /**
   * Constructor for using the output stream in polling mode.
   * @param[in] usart The USART peripheral for transmitting data.
   */

  UsartPollingOutputStream::UsartPollingOutputStream(Usart& usart) :
    _usart(usart) {
  }

  /*
   * Write one byte
   */

  bool UsartPollingOutputStream::write(uint8_t c) {
    _usart.send(c);
    return true;
  }

  /*
   * Write many bytes
   */

  bool UsartPollingOutputStream::write(const void *buffer,uint32_t size) {

    const uint8_t *ptr;

    ptr=static_cast<const uint8_t *>(buffer);

    while(size--)
      _usart.send(*ptr++);

    return true;
  }
}
// END FILE: ../lib/src/usart/UsartPollingOutputStream.cpp
// START FILE: ../lib/src/usart/UsartPollingInputStream.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


namespace stm32plus {

  /**
   * Constructor
   * @param usart The USART peripheral class to interact with
   */

  UsartPollingInputStream::UsartPollingInputStream(Usart& usart) :
    _usart(usart) {
  }


  /*
   * Read a byte
   */

  int16_t UsartPollingInputStream::read() {

    uint8_t data;

    if((data=_usart.receive())==0xff && errorProvider.getLast()!=ErrorProvider::ERROR_NO_ERROR)
      return E_STREAM_ERROR;

    return data;
  }

  /*
   * Read many bytes
   */

  bool UsartPollingInputStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

    uint8_t *ptr;
    int16_t data;

    ptr=static_cast<uint8_t *> (buffer);
    actuallyRead=size;

    while(size--) {

      if((data=read())==E_STREAM_ERROR)
        return false;

      *ptr++=data;
    }

    return true;
  }


  /*
   * Cannot skip
   */

  bool UsartPollingInputStream::skip(uint32_t howMuch __attribute__((unused))) {
    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_INPUT_STREAM,E_OPERATION_NOT_SUPPORTED);
  }


  /*
   * Check if data is available
   */

  bool UsartPollingInputStream::available() {
    return _usart.dataAvailable();
  }
}
// END FILE: ../lib/src/usart/UsartPollingInputStream.cpp
// START FILE: ../lib/src/rng/f4/features/RngInterruptFeature.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/rng.h"


using namespace stm32plus;


/**
 * Template static data member initialisation
 */

RngEventSource *RngInterruptFeature::_rngInstance;


// static initialisers for the hack that forces the IRQ handlers to be linked

RngInterruptFeatureEnabler::FPTR RngInterruptFeatureEnabler::_forceLinkage=nullptr;


#if defined(USE_RNG_INTERRUPT)

extern "C" {

  /**
   * IRQ handler for HASH and RNG
   */

  void __attribute__ ((interrupt("IRQ"))) HASH_RNG_IRQHandler(void) {

    if(RNG_GetITStatus(RNG_IT_CEI)!=RESET) {
      RngInterruptFeature::_rngInstance->RngInterruptEventSender.raiseEvent(RngEventType::EVENT_CLOCK_ERROR,0);
      RNG_ClearITPendingBit(RNG_IT_CEI);
    }
    else if(RNG_GetITStatus(RNG_IT_SEI)!=RESET) {
      RngInterruptFeature::_rngInstance->RngInterruptEventSender.raiseEvent(RngEventType::EVENT_SEED_ERROR,0);
      RNG_ClearITPendingBit(RNG_IT_SEI);
    }
    else if(RNG_GetFlagStatus(RNG_FLAG_DRDY))
      RngInterruptFeature::_rngInstance->RngInterruptEventSender.raiseEvent(RngEventType::EVENT_DATA_READY,RNG_GetRandomNumber());

    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}


#endif
#endif
// END FILE: ../lib/src/rng/f4/features/RngInterruptFeature.cpp
// START FILE: ../lib/src/adc/interrupts/f4/AdcInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/adc.h"


#if defined(STM32PLUS_F4)

using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

AdcInterruptFeature::FPTR AdcInterruptFeature::_forceLinkage=nullptr;
AdcEventSource *AdcInterruptFeature ::_adcInstance=nullptr;


extern "C" {

  #if defined(USE_ADC_INTERRUPT)

    void __attribute__ ((interrupt("IRQ"))) ADC_IRQHandler(void) {

      uint16_t raised1,raised2,raised3;

      // ADC1 interrupts - the more likely to be a source. we'll prioritise these checks so
      // the most likely are checked first and optimise slightly by not repeatedly calling
      // the inefficient ADC_GetITStatus call

      raised1=ADC1->SR & (ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_AWD | ADC_SR_OVR);
      raised2=ADC2->SR & (ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_AWD | ADC_SR_OVR);
      raised3=ADC3->SR & (ADC_SR_EOC | ADC_SR_JEOC | ADC_SR_AWD | ADC_SR_OVR);

      if((raised1 & ADC_SR_EOC)!=0 && (ADC1->CR1 & ADC_CR1_EOCIE)!=0) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_REGULAR_END_OF_CONVERSION,1);
        ADC_ClearITPendingBit(ADC1,ADC_IT_EOC);
      }
      else if((raised1 & ADC_SR_JEOC)!=0 && (ADC1->CR1 & ADC_CR1_JEOCIE)!=0) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_INJECTED_END_OF_CONVERSION,1);
        ADC_ClearITPendingBit(ADC1,ADC_IT_JEOC);
      }
      else if((raised1 & ADC_SR_AWD)!=0 && (ADC1->CR1 & ADC_CR1_AWDIE)!=0) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_ANALOG_WATCHDOG,1);
        ADC_ClearITPendingBit(ADC1,ADC_IT_AWD);
      }
      else if((raised1 & ADC_SR_OVR && (ADC1->CR1 & ADC_CR1_OVRIE)!=0)) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_OVERFLOW,1);
        ADC_ClearITPendingBit(ADC1,ADC_IT_OVR);
      }

      // ADC2 interrupts

      else if((raised2 & ADC_SR_EOC)!=0 && (ADC2->CR1 & ADC_CR1_EOCIE)!=0) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_REGULAR_END_OF_CONVERSION,2);
        ADC_ClearITPendingBit(ADC2,ADC_IT_EOC);
      }
      else if((raised2 & ADC_SR_JEOC)!=0 && (ADC2->CR1 & ADC_CR1_JEOCIE)!=0) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_INJECTED_END_OF_CONVERSION,2);
        ADC_ClearITPendingBit(ADC2,ADC_IT_JEOC);
      }
      else if((raised2 & ADC_SR_AWD)!=0 && (ADC2->CR1 & ADC_CR1_AWDIE)!=0) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_ANALOG_WATCHDOG,2);
        ADC_ClearITPendingBit(ADC2,ADC_IT_AWD);
      }
      else if((raised2 & ADC_SR_OVR && (ADC2->CR1 & ADC_CR1_OVRIE)!=0)) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_OVERFLOW,2);
        ADC_ClearITPendingBit(ADC2,ADC_IT_OVR);
      }

      // ADC3 interrupts

      else if((raised3 & ADC_SR_EOC)!=0 && (ADC3->CR1 & ADC_CR1_EOCIE)!=0) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_REGULAR_END_OF_CONVERSION,3);
        ADC_ClearITPendingBit(ADC3,ADC_IT_EOC);
      }
      else if((raised3 & ADC_SR_JEOC)!=0 && (ADC3->CR1 & ADC_CR1_JEOCIE)!=0) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_INJECTED_END_OF_CONVERSION,3);
        ADC_ClearITPendingBit(ADC3,ADC_IT_JEOC);
      }
      else if((raised3 & ADC_SR_AWD)!=0 && (ADC3->CR1 & ADC_CR1_AWDIE)!=0) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_ANALOG_WATCHDOG,3);
        ADC_ClearITPendingBit(ADC3,ADC_IT_AWD);
      }
      else if((raised3 & ADC_SR_OVR && (ADC3->CR1 & ADC_CR1_OVRIE)!=0)) {
        AdcInterruptFeature::_adcInstance->AdcInterruptEventSender.raiseEvent(AdcEventType::EVENT_OVERFLOW,3);
        ADC_ClearITPendingBit(ADC3,ADC_IT_OVR);
      }

      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

  #endif
}
#endif
// END FILE: ../lib/src/adc/interrupts/f4/AdcInterruptHandler.cpp
// START FILE: ../lib/src/adc/Adc.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"
#include "config/adc.h"

#if defined(STM32PLUS_F4) || defined (STM32PLUS_F1)

namespace stm32plus {

  uint8_t Adc::_regularChannelRank[3];
  uint8_t Adc::_injectedChannelRank[3];
}


#endif
// END FILE: ../lib/src/adc/Adc.cpp
// START FILE: ../lib/src/filesystem/TokenisedPathname.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {

  /**
   * Constructor
   * @param[in] pathname_ The pathname to tokenise.
   */

  TokenisedPathname::TokenisedPathname(const char *pathname_) :
    TokenisedString(pathname_,"\\/") {
  }
}
// END FILE: ../lib/src/filesystem/TokenisedPathname.cpp
// START FILE: ../lib/src/filesystem/FileSystem.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {

  /*
   * Constructor
   */

  FileSystem::FileSystem(BlockDevice& blockDevice_,const TimeProvider& timeProvider_,uint32_t firstSectorIndex_) :
    _blockDevice(blockDevice_), _timeProvider(timeProvider_) {

    _firstSectorIndex=firstSectorIndex_;
  }

  /**
   * Destructor
   */

  FileSystem::~FileSystem() {
  }

  /**
   * Get a filesystem instance given the input parameters.
   *
   * @param[in] blockDevice The block device that holds the filesystem.
   * @param[in] timeProvider The provider of time information for write operations.
   * @param[out] newFileSystem The pointer to the new file system that the caller can use. Caller must delete when finished.
   * @return false if it fails.
   */

  bool FileSystem::getInstance(BlockDevice& blockDevice,const TimeProvider& timeProvider,FileSystem*& newFileSystem) {

    fat::FatFileSystem *fatFs;

    // is it FAT?

    if(fat::FatFileSystem::getInstance(blockDevice,timeProvider,fatFs)) {
      newFileSystem=fatFs;
      return true;
    }

    // nothing else supported

    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_UNKNOWN_FILESYSTEM);
  }

  /**
   * Read a sector from the file system.
   *
   * @param[in] sectorIndex The sector index on the file system to read. Zero is the first sector on the file system, not the block device.
   * @param[in,out] buffer Caller supplied buffer large enough to hold a sector.
   * @return false if it fails.
   */

  bool FileSystem::readSector(uint32_t sectorIndex,void *buffer) {

    uint32_t blockIndex,sectorOffset;

    // convert sector to block index and read

    blockIndex=sectorIndexToBlockIndex(_firstSectorIndex + sectorIndex);

    // optimisation: where block size = sector size, read directly to the output buffer

    if(_blockDevice.getBlockSizeInBytes() == getSectorSizeInBytes())
      return _blockDevice.readBlock(buffer,blockIndex);
    else {

      Memblock<uint8_t> block(_blockDevice.getBlockSizeInBytes());

      if(!_blockDevice.readBlock(block,blockIndex))
        return false;

      // copy out of the block to the sector

      sectorOffset=sectorOffsetIntoBlock(sectorIndex);
      memcpy(buffer,static_cast<uint8_t *> (block) + sectorOffset,getSectorSizeInBytes());

      // done

      return true;
    }
  }

  /**
   * Write a sector to the file system.
   *
   * @param[in] sectorIndex The sector index on the file system to read. Zero is the first sector on the file system, not the block device.
   * @param[in] buffer Buffer that holds the sector data to write.
   * @return false if it fails.
   */

  bool FileSystem::writeSector(uint32_t sectorIndex,void *buffer) {

    uint32_t blockIndex;

    errorProvider.clear();

    // not supporting non-aligned block/sector sizes for now

    if(_blockDevice.getBlockSizeInBytes() != getSectorSizeInBytes())
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_UNEQUAL_BLOCK_SECTOR_SIZES);

    // convert sector to block index and write

    blockIndex=sectorIndexToBlockIndex(_firstSectorIndex + sectorIndex);

    // optimisation: where block size = sector size, read directly to the output buffer

    return _blockDevice.writeBlock(buffer,blockIndex);
  }

  /*
   * Convert a sector index to a block index
   */

  uint32_t FileSystem::sectorIndexToBlockIndex(uint32_t sectorIndex_) const {
    return sectorIndex_ / _sectorsPerBlock;
  }

  /*
   * Get the byte offset into a block of the sector
   */

  uint32_t FileSystem::sectorOffsetIntoBlock(uint32_t sectorIndex_) const {
    return (sectorIndex_ % _sectorsPerBlock) * getSectorSizeInBytes();
  }

  /**
   * Get the time provider reference.
   *
   * @return A constant reference to the time provider.
   */

  const TimeProvider& FileSystem::getTimeProvider() const {
    return _timeProvider;
  }
}
// END FILE: ../lib/src/filesystem/FileSystem.cpp
// START FILE: ../lib/src/filesystem/File.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {

  /**
   * Default Constructor, set the current position to zero.
   */

  File::File() {
    _offset=0;
  }

  /**
   * Get the current offset
   * @return The current file offset.
   */

  uint32_t File::getOffset() const {
    return _offset;
  }
}
// END FILE: ../lib/src/filesystem/File.cpp
// START FILE: ../lib/src/filesystem/fat/FatIterator.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor.
     * @param[in] fs_ A reference to the FAT filesystem class. Must stay in scope.
     * @param[in] firstIndex_ The index of the first FAT entry to start iterating at.
     * @param[in] wrap_ true if the iterator should wrap back to zero if
     * it hits the last entry in the FAT. When wrap_ is true iteration will still
     * stop when a wrapped iteration hits firstIndex_.
     */

    FatIterator::FatIterator(FatFileSystem& fs_,uint32_t firstIndex_,bool wrap_) :
      _fs(fs_), _sectorBuffer(_fs.getSectorSizeInBytes()) {

      _firstIndex=firstIndex_;
      _currentIndex=firstIndex_;
      _lastSectorIndex=UINT32_MAX;
      _wrap=wrap_;
      _first=true;
      _entriesPerFat=_fs.getCountOfClusters();
    }

    /**
     * Move to the next position.
     * @return false if it fails.
     */

    bool FatIterator::next() {

      uint32_t sectorIndex;

      if(!_first) {

        // advance the current index until hits the end

        if(++_currentIndex==_entriesPerFat) {

          // if wrapping, go back to zero else end here

          if(_wrap)
            _currentIndex=0;
          else
            return errorProvider.set(ErrorProvider::ERROR_PROVIDER_ITERATOR,E_END_OF_ENTRIES);
        }

        // if we're back at the first index then that's the end

        if(_currentIndex==_firstIndex)
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_ITERATOR,E_END_OF_ENTRIES);
      } else
        _first=false;

      // get the sector index

      sectorIndex=_fs.getBootSector().BPB_RsvdSecCnt+((_currentIndex*_fs.getFatEntrySizeInBytes())/_fs.getSectorSizeInBytes());

      // read the sector if it's new

      if(sectorIndex!=_lastSectorIndex)
        if(!_fs.readSector(sectorIndex,_sectorBuffer))
          return false;

      // done

      return true;
    }

    /**
     * Return the current index.
     * @return The current index into the FAT table (not the FAT table entry content).
     */

    uint32_t FatIterator::current() {
      return _currentIndex;

    }

    /**
     * Return the contents of the FAT entry at the current index.
     * @return The contents of the FAT table at the current position.
     */

    uint32_t FatIterator::currentContent() {
      uint32_t offset;

      offset=(_currentIndex*_fs.getFatEntrySizeInBytes())%_fs.getSectorSizeInBytes();
      return _fs.getFatEntryFromMemory(_sectorBuffer+offset);
    }
  }
}

// END FILE: ../lib/src/filesystem/fat/FatIterator.cpp
// START FILE: ../lib/src/filesystem/fat/Fat16FileSystem.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor. This is normally called by the factory method in FileSystem.
     *
     * @param[in] blockDevice The block device that holds this filesystem.
     * @param[in] timeProvider A provider of time information for write access to the file system.
     * @param[in] bootSector The boot sector (BPB) for this file system.
     * @param[in] firstSectorIndex The index of the first sector on the block device of this file system.
     * @param[in] countOfClusters The total clusters allocated to this file system.
     *
     * @see FileSystem::getInstance
     */

    Fat16FileSystem::Fat16FileSystem(BlockDevice& blockDevice,const TimeProvider& timeProvider,const fat::BootSector& bootSector,uint32_t firstSectorIndex,uint32_t countOfClusters) :
      FatFileSystem(blockDevice,timeProvider,bootSector,firstSectorIndex,countOfClusters) {

      // up-front calculation of important constants

      _rootDirFirstSector=_bootSector.BPB_RsvdSecCnt+(_bootSector.BPB_NumFATs*_bootSector.BPB_FATSz16);
      _rootDirSectors=((_bootSector.BPB_RootEntCnt*32)+(_bootSector.BPB_BytsPerSec-1))/_bootSector.BPB_BytsPerSec;
      _firstDataSector=_bootSector.BPB_RsvdSecCnt+(_bootSector.BPB_NumFATs*_bootSector.BPB_FATSz16)+_rootDirSectors;
    }

    /**
     * Destructor
     */

    Fat16FileSystem::~Fat16FileSystem() {
    }

    /**
     * @copydoc FatFileSystem::getFileSystemType
     * Returns FileSystemType::Fat16
     */

    FileSystem::FileSystemType Fat16FileSystem::getFileSystemType() const {
      return Fat16;
    }

    /*
     * @copydoc FatFileSystem::getFatEntryFromMemory
     */

    uint32_t Fat16FileSystem::getFatEntryFromMemory(void *addr) const {
      return *static_cast<uint16_t *> (addr);
    }

    /*
     * @copydoc FatFileSystem::setFatEntryToMemory
     */

    void Fat16FileSystem::setFatEntryToMemory(void *addr,uint32_t entry) const {
      *static_cast<uint16_t *> (addr)=static_cast<uint16_t> (entry);
    }

    /**
     * @copydoc FatFileSystem::getFatEntrySizeInBytes
     * Returns 2.
     */

    uint32_t Fat16FileSystem::getFatEntrySizeInBytes() const {
      return 2;
    }

    /**
     * @copydoc FatFileSystem::getBadClusterMarker
     * Returns 0xFFF7.
     */

    uint32_t Fat16FileSystem::getBadClusterMarker() const {
      return 0xFFF7;
    }

    /**
     * @copydoc FatFileSystem::getSectorsPerFat
     */

    uint32_t Fat16FileSystem::getSectorsPerFat() const {
      return _bootSector.BPB_FATSz16;
    }

    /**
     * @copydoc FatFileSystem::isEndOfClusterChainMarker
     * Returns true if >= 0xFFF8.
     */

    bool Fat16FileSystem::isEndOfClusterChainMarker(uint32_t clusterNumber) const {
      return clusterNumber>=0xFFF8;
    }

    /**
     * @copydoc FatFileSystem::getEndOfClusterChainMarker
     * Returns 0xFFF8.
     */

    uint32_t Fat16FileSystem::getEndOfClusterChainMarker() const {
      return 0xFFF8;
    }

    /**
     * Return the number of sectors in the root directory.
     * @return The number of sectors in this root directory.
     */

    uint32_t Fat16FileSystem::getRootDirSectors() const {
      return _rootDirSectors;
    }

    /**
     * @copydoc FatFileSystem::getRootDirectoryIterator
     */

    DirectoryEntryIterator *Fat16FileSystem::getRootDirectoryIterator(DirectoryEntryIterator::Options options) {
      return new Fat16RootDirectoryEntryIterator(*this,options);
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/Fat16FileSystem.cpp
// START FILE: ../lib/src/filesystem/fat/DirectoryEntryWithLocation.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Return true if this a file entry
     *
     * @return true if it's a file
     */

    bool DirectoryEntryWithLocation::isFile() {
      return (Dirent.sdir.DIR_Attr & (DirectoryEntry::ATTR_VOLUME_ID | DirectoryEntry::ATTR_DIRECTORY))==0;
    }

    /**
     * Return true if this a directory entry.
     *
     * @return true if it's a directory.
     */

    bool DirectoryEntryWithLocation::isDirectory() {
      return (Dirent.sdir.DIR_Attr & DirectoryEntry::ATTR_DIRECTORY)!=0;
    }

    /**
     * Copy times across from here to the destination.
     * @param[in] dest_ The target for the copy of the date/time members.
     */

    void DirectoryEntryWithLocation::copyTimesTo(DirectoryEntry& dest_) {

      dest_.sdir.DIR_CrtDate=Dirent.sdir.DIR_CrtDate;
      dest_.sdir.DIR_CrtTime=Dirent.sdir.DIR_CrtTime;
      dest_.sdir.DIR_CrtTimeTenth=Dirent.sdir.DIR_CrtTimeTenth;
      dest_.sdir.DIR_LstAccDate=Dirent.sdir.DIR_LstAccDate;
      dest_.sdir.DIR_WrtDate=Dirent.sdir.DIR_WrtDate;
      dest_.sdir.DIR_WrtTime=Dirent.sdir.DIR_WrtTime;
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/DirectoryEntryWithLocation.cpp
// START FILE: ../lib/src/filesystem/fat/FilenameHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {


  /**
   * Get the current filename.
   * @return An internal null terminated pointer to the filename. Do not delete.
   */

    const char *FilenameHandler::getFilename() {
      return _longFilename==nullptr ? _shortFilename : _longFilename;
    }


  /**
   * Constructor. Set initial state.
   */

    FilenameHandler::FilenameHandler() {

      initialise();
    }


    /*
     * initialise
     */

    void FilenameHandler::initialise() {

      _longFilename=nullptr;
      _sectorIndices=nullptr;
      _sectorOffsetIndices=nullptr;

      _state=STATE_NONE;
    }


  /**
   * Destructor. Delete internal buffers.
   */

    FilenameHandler::~FilenameHandler() {
      cleanup();
    }


    /**
     * Cleanup and re-initialise for another run
     */

    void FilenameHandler::reinitialise() {
      cleanup();
      initialise();
    }


    /*
     * De-allocate
     */

    void FilenameHandler::cleanup() {
      
      if(_longFilename!=nullptr)
        delete [] _longFilename;

      if(_sectorIndices!=nullptr)
        delete [] _sectorIndices;

      if(_sectorOffsetIndices!=nullptr)
        delete [] _sectorOffsetIndices;
    }


  /**
   * Handle the next directory entry. The caller should repeatedly call this method until
   * a short directory entry is encountered. Since a long name immediately precedes its short equivalent
   * when the short name is hit then the long name will have already been processed here.
   *
   * @param[in] entry The directory entry to process.
   * @return false if there is a processing failure.
   */

    bool FilenameHandler::handleEntry(DirectoryEntryWithLocation& entry) {

      errorProvider.clear();

    // entry passed in here should already have been checked to ensure it's valid
    // and has not been deleted.

      if((entry.Dirent.sdir.DIR_Attr & DirectoryEntry::ATTR_LONG_NAME_MASK)==DirectoryEntry::ATTR_LONG_NAME)
        return handleLongName(entry);
      else
        return handleShortName(entry);
    }


  /*
   * Handle a short name
   */

    bool FilenameHandler::handleShortName(DirectoryEntryWithLocation& entry) {

      int i,j;
      DirectoryEntry& dirent=entry.Dirent;

      if(_state==STATE_LONG_FILENAME_IN_PROGRESS) {

      // we've hit the short version of a long filename, the countdown of long filename
      // entries must have hit 1 at this point

        if(_currentIndex!=1)
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FAT_DIRECTORY,E_CORRUPT_LONG_FILENAME,0);

        setSectorDetails(entry,0);
      }
      else {

      // old-style short name, this will fit in the short name buffer

        if(_longFilename!=nullptr) {
          delete [] _longFilename;
          _longFilename=nullptr;
        }

      // copy the first 8 characters, or up to the first space

        for(i=0;i<8 && dirent.sdir.DIR_Name[i]!=' ';i++)
          _shortFilename[i]=dirent.sdir.DIR_Name[i];

      // is there an extension? if so then take up to 3 characters

        if(dirent.sdir.DIR_Name[8]!=' ') {

          _shortFilename[i++]='.';

          for(j=8;j<11 && dirent.sdir.DIR_Name[j]!=' ';j++,i++)
            _shortFilename[i]=dirent.sdir.DIR_Name[j];
        }

        _shortFilename[i]='\0';

        setSectorDetails(entry,0,1);
      }

      _state=STATE_READY;
      return true;
    }


  /*
   * Handle a long name
   */

    bool FilenameHandler::handleLongName(DirectoryEntryWithLocation& entry) {

      char *dest,subcomponent[13];
      int subcomponentLength;
      const uint16_t *src;

      DirectoryEntry& dirent=entry.Dirent;

    // get the characters from the name, supporting only 8 bit characters

      dest=subcomponent;
      src=dirent.ldir.LDIR_Name1;

      for(subcomponentLength=0;subcomponentLength<13 && *src;subcomponentLength++) {

        *dest++=(char)*src++;

      // move to the next part of the name when we hit the end

        if(subcomponentLength==4)
          src=dirent.ldir.LDIR_Name2;
        else if(subcomponentLength==10)
          src=dirent.ldir.LDIR_Name3;
      }

      if((dirent.ldir.LDIR_Ord & DirectoryEntry::LAST_LONG_ENTRY)!=0) {

      // this is the start of the reverse sequence of name fragments
      // the state cannot be parsing an existing sequence

        if(_state==STATE_LONG_FILENAME_IN_PROGRESS)
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FAT_DIRECTORY,E_INVALID_STATE,0);

        _currentIndex=dirent.ldir.LDIR_Ord & ~DirectoryEntry::LAST_LONG_ENTRY;

      // name length is this block size + 13*the number of following blocks

        _length=subcomponentLength+(_currentIndex-1)*13;

      // free old filename if present

        if(_longFilename!=nullptr)
          delete [] _longFilename;

      // where are we storing?

        if(_length>=sizeof(_shortFilename)) {
          _longFilename=new char[_length+1];
          _longFilename[_length]='\0';
        }
        else {
          _longFilename=nullptr;
          _shortFilename[_length]='\0';
        }

      // create new array to hold sector details and store

        setSectorDetails(entry,_currentIndex,_currentIndex+1);
      }
      else {

      // check that we are in sequence

        if(_currentIndex!=dirent.ldir.LDIR_Ord+1)
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FAT_DIRECTORY,E_CORRUPT_LONG_FILENAME,0);

        _currentIndex=dirent.ldir.LDIR_Ord;
        setSectorDetails(entry,_currentIndex);
      }

    // copy the filename into position

      dest=_longFilename==nullptr ? _shortFilename : _longFilename;
      memcpy(dest+(_currentIndex-1)*13,subcomponent,subcomponentLength);

    // set the current state

      _state=STATE_LONG_FILENAME_IN_PROGRESS;
      return true;
    }


  /*
   * set the sector details that we store here. we store the locations of the dirents that make up this
   * [long]filename so that a caller can use them to delete the file.
   */

    void FilenameHandler::setSectorDetails(DirectoryEntryWithLocation& entry,uint32_t sectorIndex,uint32_t newSize) {
      
      if(newSize!=0) {
        _sectorIndices=new uint32_t[newSize];
        _sectorOffsetIndices=new uint32_t[newSize];
        _direntCount=newSize;
      }

      _sectorIndices[sectorIndex]=entry.SectorNumber;
      _sectorOffsetIndices[sectorIndex]=entry.IndexWithinSector;
    }


  /**
   * Get the sector indices array. This array holds the sector locations of each dirent that makes up the filename.
   * This can be used to efficiently delete the file if the caller needs to.
   *
   * @return An internal pointer to the sector indices array. Do not delete.
   */

    uint32_t *FilenameHandler::getSectorIndices() {
      return _sectorIndices;
    }
    
    
  /**
   * Get the sector offset indices array. Each entry in this array is paired with an entry in the getSectorIndices() array
   * to give the exact location in a sector of the directory entry. The sector index tells you where on disk the entry lies
   * and the sector offset tells you where in the sector the entry lies. The entries in this array are byte offsets into the
   * sectors.
   *
   * @return An internal pointer to the sector offset indices array. Do not delete.
   */

    uint32_t *FilenameHandler::getSectorOffsetIndices() {
      return _sectorOffsetIndices;
    }


  /**
   * Get the number of dirents holding this filename.
   * @return The number of dirents, which corresponds to the number of entries in the getSectorIndices() and getSectorOffsetIndices()
   * arrays.
   */

    uint32_t FilenameHandler::getDirentCount() {
      return _direntCount;
    }

  }
}
// END FILE: ../lib/src/filesystem/fat/FilenameHandler.cpp
// START FILE: ../lib/src/filesystem/fat/FatFile.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor.
     * @param[in] fs_ A reference to the FAT filesystem class.
     * @param[in] dirent_ The directory entry that points to this file.
     */

    FatFile::FatFile(FatFileSystem& fs_,DirectoryEntryWithLocation& dirent_) :
      _fs(fs_),
      _sectorBuffer(_fs.getSectorSizeInBytes()),
      _iterator(fs_,
                (static_cast<uint32_t> (dirent_.Dirent.sdir.DIR_FstClusHI) << 16) | dirent_.Dirent.sdir.DIR_FstClusLO,
                ClusterChainIterator::extensionExtend) {

      _dirent=dirent_; // struct copy
    }


    /*
     * @copydoc File::read
     */

    bool FatFile::read(void *ptr_,uint32_t size_,uint32_t& actuallyRead_) {

      uint32_t sectorSize=_fs.getSectorSizeInBytes();
      uint32_t fileLength,sectorOffset,copySize,available,remainingInFile;
      uint8_t *current;

      fileLength=getLength();

      // early fail for zero length file

      if(fileLength == 0)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILE,E_END_OF_FILE);

      // offset into first sector is probably non-zero

      sectorOffset=_offset % sectorSize;

      // continue while we need data

      current=static_cast<uint8_t *> (ptr_);
      actuallyRead_=0;

      while(size_ > 0) {

        // check for EOF, return true: actuallyRead will confirm the data actually retrieved

        if(_offset == fileLength)
          return true;

        // are we on a new sector?

        if(_offset % sectorSize == 0 && !_iterator.next())
          return false;

        // read a sector

        if(!_iterator.readSector(_sectorBuffer))
          return false;

        // calculate the copy size

        remainingInFile=fileLength - _offset;
        available=remainingInFile < sectorSize - sectorOffset ? remainingInFile : sectorSize - sectorOffset;
        copySize=size_ < available ? size_ : available;

        // copy out

        memcpy(current,_sectorBuffer + sectorOffset,copySize);

        size_-=copySize;
        current+=copySize;

        // update the position

        _offset+=copySize;
        actuallyRead_+=copySize;

        // we are now definitely on a sector boundary

        sectorOffset=0;
      }

      return true;
    }

    /**
     * @copydoc File::write
     */

    bool FatFile::write(const void *ptr_,uint32_t size_) {

      uint16_t d,t;
      const uint8_t *current=static_cast<const uint8_t *> (ptr_);
      DirectoryEntry& dirent=_dirent.Dirent;
      uint32_t sectorOffset,amountToCopy,sectorSize=_fs.getSectorSizeInBytes();

      // need to get the file pointer on to a sector boundary

      if(_offset % sectorSize > 0) {

        // there has to be a valid sector in the iterator
        // calculate the offset for the new data and the amount to copy in

        sectorOffset=_offset % sectorSize;
        amountToCopy=sectorSize - sectorOffset;

        if(amountToCopy > size_)
          amountToCopy=size_;

        // read the partially filled sector

        if(!_iterator.readSector(_sectorBuffer))
          return false;

        // copy in our data

        memcpy(_sectorBuffer + sectorOffset,current,amountToCopy);

        // write it back

        if(!_iterator.writeSector(_sectorBuffer))
          return false;

        // update pointers

        current+=amountToCopy;
        size_-=amountToCopy;
        _offset+=amountToCopy;

        if(_offset > dirent.sdir.DIR_FileSize)
          dirent.sdir.DIR_FileSize=_offset;
      }

      // we're on a sector boundary, loop until out of data

      while(size_ > 0) {

        // move to the next sector if we're on the end

        if(_offset % sectorSize == 0 && !_iterator.next())
          return false;

        // if this was a zero length file getting data for the first time then
        // update the dirent for it

        if(getLength() == 0) {
          dirent.sdir.DIR_FstClusLO=_iterator.getClusterNumber() & 0xFFFF;
          dirent.sdir.DIR_FstClusHI=_iterator.getClusterNumber() >> 16;
        }

        if(size_ < sectorSize && getLength() != _offset) {

          // must be the last part to write, and we are not at the end of the file
          // therefore we need to merge what's left to write with the existing content

          if(!_iterator.readSector(_sectorBuffer))
            return false;

          amountToCopy=size_;
        } else {
          amountToCopy=sectorSize; // we will overwrite the whole sector...

          if(amountToCopy > size_) // ...except when we don't have enough to do that
            amountToCopy=size_;
        }

        memcpy(_sectorBuffer,current,amountToCopy);

        // write the sector full of data

        if(!_iterator.writeSector(_sectorBuffer))
          return false;

        // update pointers

        current+=amountToCopy;
        size_-=amountToCopy;
        _offset+=amountToCopy;

        if(_offset > dirent.sdir.DIR_FileSize)
          dirent.sdir.DIR_FileSize=_offset;
      }

      // set the last modified time
      // gcc will not allow us to make a reference to a field in a packed struct :-;

      DirectoryEntryIterator::calculateFatDateTime(_fs.getTimeProvider().getTime(),d,t);
      dirent.sdir.DIR_WrtDate=d;
      dirent.sdir.DIR_WrtTime=t;

      // write back the modified dirent

      return _fs.writeDirectoryEntry(_dirent);
    }

    /**
     * @copydoc File::seek
     */

    bool FatFile::seek(int32_t offset_,SeekFrom origin_) {

      uint32_t newOffset;
      uint32_t sectorCount;
      DirectoryEntry& dirent=_dirent.Dirent;

      // get the new origin

      switch(origin_) {

        case SeekCurrent:
          newOffset=_offset + offset_;
          break;

        case SeekEnd:
          newOffset=dirent.sdir.DIR_FileSize - 1 + offset_;
          break;

        case SeekStart:
        default:
          newOffset=offset_;
          break;
      }

      // validate (one past the end is a valid "position")

      if(newOffset > dirent.sdir.DIR_FileSize)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILE,E_INVALID_FILE_POSITION);

      // translate to sectors

      sectorCount=(newOffset / _fs.getSectorSizeInBytes());
      if(newOffset % _fs.getSectorSizeInBytes() > 0)
        sectorCount++;

      _iterator.reset((static_cast<uint32_t> (dirent.sdir.DIR_FstClusHI) << 16) | dirent.sdir.DIR_FstClusLO);

      while(sectorCount--)
        if(!_iterator.next())
          return false;

      _offset=newOffset;
      return true;
    }

    /**
     * @copydoc File::getLength
     */

    uint32_t FatFile::getLength() {
      return _dirent.Dirent.sdir.DIR_FileSize;
    }

    /**
     * Get the dirent.
     * @return The directory entry of this file.
     */

    const DirectoryEntryWithLocation& FatFile::getDirectoryEntryWithLocation() {
      return _dirent;
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/FatFile.cpp
// START FILE: ../lib/src/filesystem/fat/IteratingFreeClusterFinder.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /*
     * Constructor
     */

    IteratingFreeClusterFinder::IteratingFreeClusterFinder(FatFileSystem& fs_,uint32_t firstFatEntry_) :
      FreeClusterFinder(fs_), _iterator(fs_,firstFatEntry_,true) {

    }

    /**
     * Find the next free entry by using a FatIterator initialised with the freeCluster_ parameter
     * to find the next free cluster. A cluster that contains zero is free.
     *
     * @param freeCluster_ A reference to a caller supplied uint32_t that will be filled in with the next
     * free cluster that the iterator finds.
     * @return false if there is an error, check error provider for error details.
     *
     * @see FreeClusterFinder::find
     */

    bool IteratingFreeClusterFinder::find(uint32_t& freeCluster_) {

      while(_iterator.next()) {

        if(_iterator.currentContent() == 0) {
          // a zero entry is free

          freeCluster_=_iterator.current();
          return true;
        }
      }

      // if we reached the end then return the true error

      if(errorProvider.isLastError(ErrorProvider::ERROR_PROVIDER_ITERATOR,FatIterator::E_END_OF_ENTRIES))
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FREE_CLUSTER_FINDER,E_NO_FREE_CLUSTERS);

      // something else went wrong, propagate it

      return false;
    }

  }
}
// END FILE: ../lib/src/filesystem/fat/IteratingFreeClusterFinder.cpp
// START FILE: ../lib/src/filesystem/fat/Fat16FileSystemFormatter.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * @brief Initialise the class and do the format.
     *
     * Check the error provider status to find out whether the format worked. The format operation prepares the FAT data structures. It does not
     * do a low-level format of the device.
     *
     * @param[in] blockDevice The device to format.
     * @param[in] firstSectorIndex The zero-based index of the first sector of the partition, or the device as a whole if partitions are not supported.
     * @param[in] numSectors The total number of sectors to format on this device.
     * @param[in] volumeLabel The new name for the volume, max 11 characters.
     */

    Fat16FileSystemFormatter::Fat16FileSystemFormatter(BlockDevice& blockDevice,uint32_t firstSectorIndex,uint32_t numSectors,const char *volumeLabel)
      : FatFileSystemFormatter(blockDevice,firstSectorIndex,numSectors,volumeLabel) {

      // write the reserved sectors

      if(!writeReservedSectors())
        return;

      // the two FAT tables start at sector #1, write them

      if(!writeFats(_firstSectorIndex+_bootSector.BPB_RsvdSecCnt,_bootSector.BPB_FATSz16))
        return;

      // write the root directory entry, which comes right after the two FATs

      writeRootDirectoryEntries(_firstSectorIndex+_bootSector.BPB_RsvdSecCnt+(_bootSector.BPB_FATSz16*2));
    }


    /*
     * Prepare a new bootsector for FAT16
     */

    bool Fat16FileSystemFormatter::createNewBootSector() {

      uint32_t tmpVal1,tmpVal2,fatSize;

      // call the base class

      if(!FatFileSystemFormatter::createNewBootSector())
        return false;

      // generate sectors per cluster from the MS specification document

      if(_numSectors <= 8400 || _numSectors > 4194304) // 4.1Mb lower limit, 2Gb upper limit
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FAT16_FILESYSTEM_FORMATTER,E_INVALID_DISK_SIZE);

      if(_numSectors <= 32680)            // 16Mb
        _bootSector.BPB_SecPerClus=2;
      else if(_numSectors <= 262144)      // 128Mb
        _bootSector.BPB_SecPerClus=4;
      else if(_numSectors <= 524288)      // 256Mb
        _bootSector.BPB_SecPerClus=8;
      else if(_numSectors <= 1048576)     // 512Mb
        _bootSector.BPB_SecPerClus=16;
      else if(_numSectors <= 2097152)     // 1Gb
        _bootSector.BPB_SecPerClus=32;
      else
        _bootSector.BPB_SecPerClus=64;    // 2Gb

      _bootSector.BPB_RsvdSecCnt=1;
      _bootSector.BPB_RootEntCnt=512;

      if(_numSectors < 0x10000) {
        _bootSector.BPB_TotSec16=_numSectors;
        _bootSector.BPB_TotSec32=0;
      } else {
        _bootSector.BPB_TotSec16=0;
        _bootSector.BPB_TotSec32=_numSectors;
      }

      // this part lifted from the MS document

      tmpVal1=_numSectors - 33;                           // DskSize  (BPB_ResvdSecCnt + RootDirSectors);
      tmpVal2=(256 * _bootSector.BPB_SecPerClus) + 2;     // (256 * BPB_SecPerClus) + BPB_NumFATs

      fatSize=(tmpVal1 + (tmpVal2 - 1)) / tmpVal2;
      _bootSector.BPB_FATSz16=fatSize & 0xFFFF;

      _bootSector.fat16.BS_DrvNum=0x80;
      _bootSector.fat16.BS_Reserved1=0;
      _bootSector.fat16.BS_BootSig=0x29;
      _bootSector.fat16.BS_VolID=0xBADF00D;
      memcpy(_bootSector.fat16.BS_VolLab,_volumeLabel,11);
      memcpy(_bootSector.fat16.BS_FilSysType,"FAT16   ",8);

      return true;
    }

    /*
     * format the reserved sectors on the device
     */

    bool Fat16FileSystemFormatter::writeReservedSectors() {

      // FAT16 only has the boot sector and nothing else

      return writeBootSector(_firstSectorIndex);
    }


    /*
     * initialise the two reserved clusters at the start of the FAT
     */

    void Fat16FileSystemFormatter::initReservedClusters(uint8_t *sector_) const {

      uint16_t cluster,*fat;

      fat=reinterpret_cast<uint16_t *>(sector_);
      cluster=0xff00 | MEDIA_TYPE;

      fat[0]=cluster;
      fat[1]=0xFFFF;        // EOC
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/Fat16FileSystemFormatter.cpp
// START FILE: ../lib/src/filesystem/fat/FatFileSystem.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /*
     * Constructor
     */

    FatFileSystem::FatFileSystem(BlockDevice& blockDevice,const TimeProvider& timeProvider,const fat::BootSector& bootSector,uint32_t firstSectorIndex,uint32_t countOfClusters) :
      FileSystem(blockDevice,timeProvider,firstSectorIndex) {

      _countOfClusters=countOfClusters;
      _bootSector=bootSector; // struct copy
      _fatFirstSector=_bootSector.BPB_RsvdSecCnt; // sector index of the FAT
      _sectorsPerBlock=blockDevice.getBlockSizeInBytes() / _bootSector.BPB_BytsPerSec;
    }

    /**
     * Virtual destructor, does nothing.
     */

    FatFileSystem::~FatFileSystem() {
    }

    /**
     * Get the correct FAT implementation for this block device.
     *
     * @param[in] blockDevice The block device that holds the file system.
     * @param[in] timeProvider A provider of the current time that will be used by the methods that create and modify data to
     * update the directory entry with write times.
     * @param[out] newFileSystem Reference to a caller supplied pointer that will be filled in with the appropriate FatFileSystem instance.
     * The caller owns this pointer and must delete it when finished.
     * @return false if it fails, error provider will be filled in.
     */

    bool FatFileSystem::getInstance(BlockDevice& blockDevice,const TimeProvider& timeProvider,FatFileSystem*& newFileSystem) {

      ByteMemblock bootSectorBytes(blockDevice.getBlockSizeInBytes());
      fat::BootSector bs;
      uint32_t rootDirSectors,fatSize,totalSectors,dataSectors,countOfClusters,firstSectorIndex;

      // read block zero

      if(!blockDevice.readBlock(bootSectorBytes,0))
        return false;

      // check the signature bytes

      if(bootSectorBytes[510] != 0x55 || bootSectorBytes[511] != 0xaa)
        return false;

      // copy the boot sector - the endian-ness matches the STM32

      memcpy(&bs,bootSectorBytes,sizeof(bs));

      // is this REALLY a boot sector and not an MBR?

      if((bs.BS_jmpBoot[0]!=0xe9 && bs.BS_jmpBoot[0]!=0xeb) || bs.BPB_BytsPerSec!=512) {

        Mbr *mbr=reinterpret_cast<Mbr *>(bootSectorBytes.getData());

        firstSectorIndex=mbr->partitions[0].lbaFirstSector;
        if(!blockDevice.readBlock(bootSectorBytes,firstSectorIndex))
          return false;

        if(bootSectorBytes[510] != 0x55 || bootSectorBytes[511] != 0xaa)
          return false;

        memcpy(&bs,bootSectorBytes,sizeof(bs));
      }
      else
        firstSectorIndex=0;

      // check that the sector size matches

      if(blockDevice.getBlockSizeInBytes() != bs.BPB_BytsPerSec)
        return false;

      // calculate the total clusters
      // note that on a FAT32 volume, the BPB_RootEntCnt value is always 0; so on a FAT32 volume, RootDirSectors is always 0

      rootDirSectors=((bs.BPB_RootEntCnt * 32) + (bs.BPB_BytsPerSec - 1)) / bs.BPB_BytsPerSec;

      // next, we determine the count of sectors in the data region of the volume:

      if(bs.BPB_FATSz16 != 0)
        fatSize=bs.BPB_FATSz16;
      else
        fatSize=bs.fat32.BPB_FATSz32;

      if(bs.BPB_TotSec16 != 0)
        totalSectors=bs.BPB_TotSec16;
      else
        totalSectors=bs.BPB_TotSec32;

      dataSectors=totalSectors - (bs.BPB_RsvdSecCnt + (bs.BPB_NumFATs * fatSize) + rootDirSectors);

      // now we determine the count of clusters:

      countOfClusters=dataSectors / bs.BPB_SecPerClus;

      // now return an appropriate FS

      if(countOfClusters < 4085)
        return false; // FAT12 not supported
      else if(countOfClusters < 65525)
        newFileSystem=new Fat16FileSystem(blockDevice,timeProvider,bs,firstSectorIndex,countOfClusters);
      else
        newFileSystem=new Fat32FileSystem(blockDevice,timeProvider,bs,firstSectorIndex,countOfClusters);

      return true;
    }

    /**
     * Read a sector from a cluster in a file.
     * @param[in] clusterIndex The cluster index of the sector.
     * @param[in] sectorIndexInCluster The sector index in the cluster, with zero being the first sector in the cluster.
     * @param[in] buffer The buffer to receive the sector data. Must be large enough.
     * @return false if it fails.
     */

    bool FatFileSystem::readSectorFromCluster(uint32_t clusterIndex,uint32_t sectorIndexInCluster,void *buffer) {

      uint32_t sectorIndex;

      // convert the cluster number to a sector number

      sectorIndex=sectorIndexInCluster + clusterToSector(clusterIndex);

      // read it

      return readSector(sectorIndex,buffer);
    }

    /**
     * Write a sector to a cluster.
     * @param[in] clusterIndex The cluster index of the sector.
     * @param[in] sectorIndexInCluster The sector index in the cluster, with zero being the first sector in the cluster.
     * @param[in] buffer The buffer that holds the sector data to write.
     * @return false if it fails.
     */

    bool FatFileSystem::writeSectorToCluster(uint32_t clusterIndex,uint32_t sectorIndexInCluster,void *buffer) {

      uint32_t sectorIndex;

      // convert the cluster number to a sector number

      sectorIndex=sectorIndexInCluster + clusterToSector(clusterIndex);

      // write it

      return writeSector(sectorIndex,buffer);
    }

    /**
     * Read a fat entry for a cluster.
     * @param[in] clusterNumber The cluster number to read from.
     * @param[out] fatEntryForCluster The FAT entry for this cluster.
     * @return false if it fails
     */

    bool FatFileSystem::readFatEntry(uint32_t clusterNumber,uint32_t& fatEntryForCluster) {

      uint32_t sectorIndex,fatEntOffset,fatOffset;
      ByteMemblock sector(_bootSector.BPB_BytsPerSec);

      // get the byte offset into the fat of the cluster entry

      fatOffset=clusterNumber * getFatEntrySizeInBytes();

      // now get the sector index that holds the fat entry and the offset into that sector of the fat entry

      sectorIndex=_bootSector.BPB_RsvdSecCnt + (fatOffset / _bootSector.BPB_BytsPerSec);
      fatEntOffset=fatOffset % _bootSector.BPB_BytsPerSec;

      // read the sector

      if(!readSector(sectorIndex,sector))
        return false;

      // get the value from the fat

      fatEntryForCluster=getFatEntryFromMemory(static_cast<uint8_t *> (sector) + fatEntOffset);
      return true;
    }

    /**
     * Return a new directory iterator for the directory at the given path.
     *
     * @param[in] pathname The path to the directory to iterate over.
     * @param[out] newIterator A pointer reference that this class will create. The caller owns this pointer and must delete it when finished.
     */

    bool FatFileSystem::getDirectoryIterator(const char *pathname,DirectoryIterator*& newIterator) {

      FatDirectoryIterator *it;

      if(!FatDirectoryIterator::getInstance(*this,pathname,it))
        return false;

      newIterator=it;
      return true;
    }

    /**
     * Get file information for the given pathname.
     * @param[in] filename The pathname to the file.
     * @param[out] info Reference to a file information structure that this call will create and fill in. The caller owns this pointer
     * and must delete it when finished.
     * @return false if it fails.
     */

    bool FatFileSystem::getFileInformation(const char *filename,FileInformation*& info) {

      DirectoryEntryWithLocation dirent;

      TokenisedPathname tp(filename);
      if(!getDirectoryEntry(tp,dirent))
        return false;

      info=new FatFileInformation(filename,dirent);
      return true;
    }


    /**
     * Create a new directory.
     * @param[in] dirname The full pathname to the new directory.
     * @return false if it fails.
     */

    bool FatFileSystem::createDirectory(const char *dirname) {

      DirectoryEntryWithLocation dirent;
      DirectoryEntry dot,dotDot;
      ByteMemblock sector(getSectorSizeInBytes());
      uint8_t i;

      // create a file for this directory

      if(!createFile(dirname))
        return false;

      // get the dirent for the 'file' that we just created

      TokenisedPathname tp(dirname);
      if(!getDirectoryEntry(tp,dirent))
        return false;

      // open the file and write a single zero'd cluster

      FatFile file(*this,dirent);
      memset(sector,0,getSectorSizeInBytes());

      for(i=0;i < _bootSector.BPB_SecPerClus;i++)
        if(!file.write(sector,getSectorSizeInBytes()))
          return false;

      // copy back the dirent from the modified file

      dirent=file.getDirectoryEntryWithLocation();

      // create the "." and ".." entries

      memset(&dot,0,sizeof(dot));
      memset(&dotDot,0,sizeof(dotDot));

      memset(dot.sdir.DIR_Name,' ',sizeof(dot.sdir.DIR_Name));
      dot.sdir.DIR_Name[0]='.';
      dot.sdir.DIR_Attr=DirectoryEntry::ATTR_DIRECTORY;
      dot.sdir.DIR_FstClusLO=dirent.Dirent.sdir.DIR_FstClusLO;
      dot.sdir.DIR_FstClusHI=dirent.Dirent.sdir.DIR_FstClusHI;
      dirent.copyTimesTo(dot);

      // get the cluster number of the parent

      if(!getParentDirectoryFirstCluster(tp,&dotDot.sdir.DIR_FstClusLO,&dotDot.sdir.DIR_FstClusHI))
        return false;

      memset(dotDot.sdir.DIR_Name,' ',sizeof(dotDot.sdir.DIR_Name));
      dotDot.sdir.DIR_Name[0]='.';
      dotDot.sdir.DIR_Name[1]='.';
      dotDot.sdir.DIR_Attr=DirectoryEntry::ATTR_DIRECTORY;
      dirent.copyTimesTo(dotDot);

      // write the two special directories

      if(!file.seek(0,File::SeekStart))
        return false;

      if(!file.write(&dot,sizeof(dot)) || !file.write(&dotDot,sizeof(dotDot)))
        return false;

      // now change the 'file' to be a directory and we're complete

      dirent.Dirent.sdir.DIR_Attr=DirectoryEntry::ATTR_DIRECTORY;
      dirent.Dirent.sdir.DIR_FileSize=0;

      return writeDirectoryEntry(dirent);
    }

    /**
     * Create a new file. The new file will have zero length. Long filenames are supported.
     * @param[in] filename The full pathname of the new file.
     * @return false if it fails.
     */

    bool FatFileSystem::createFile(const char *filename) {

      FatDirectoryIterator *it;
      bool retval;

      // tokenise the path, must have a component

      TokenisedPathname tp(filename);
      if(tp.getNumTokens() == 0)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_INVALID_PATHNAME);

      // cannot create a file that exists

      if(getDirectoryIteratorPointingToFile(tp,it)) {
        delete it;
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_FILE_EXISTS);
      }

      // limit the range so that we get an iterator on to the parent

      tp.resetRange();
      tp.setRange(0,tp.getNumTokens() - 2);

      if(!FatDirectoryIterator::getInstance(*this,tp,it))
        return false;

      // reset the range so that we can see the filename on the end

      tp.resetRange();

      // create the dirents for this new file

      LongNameDirentGenerator lndg(tp.last(),it->getDirectoryEntryIterator(),0,0);

      if(errorProvider.getLast() != 0) {
        delete it;
        return false;
      }

      // write the dirents to the owning directory

      retval=it->getDirectoryEntryIterator().writeDirents(lndg.getDirents(),lndg.getDirentCount());
      delete it;
      return retval;
    }

    /**
     * Open an existing file.
     * @param[in] filename The full pathname of the existing file.
     * @param[out] newFile A pointer to the File class that the caller can use to manipulate the file. The caller must
     * delete this pointer when finished.
     * @return false if it fails.
     */

    bool FatFileSystem::openFile(const char *filename,File*& newFile) {

      DirectoryEntryWithLocation dirent;

      // tokenise the path

      TokenisedPathname tp(filename);
      if(tp.getNumTokens() == 0)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_INVALID_PATHNAME);

      // get the directory entry for this file

      if(!getDirectoryEntry(tp,dirent))
        return false;

      // create the file object

      newFile=new FatFile(*this,dirent);
      return true;
    }

    /**
     * Return true if directory has content (files or directories).
     * @param[in] dirname The full pathame of the directory to test.
     * @param[out] hasContent Set to true if this directory has content, false if not.
     * @return false if it fails.
     */

    bool FatFileSystem::directoryHasContent(const char *dirname,bool& hasContent) {

      DirectoryIterator *it;

      // get an iterator on to the directory

      if(!getDirectoryIterator(dirname,it))
        return false;

      // preset for dropping off the end of the loop

      hasContent=false;

      while(it->next()) {

        // any entry other than the two specials means we have content

        if(!it->isCurrentDirectory() && !it->isParentDirectory()) {
          hasContent=true;
          break;
        }
      }

      delete it;
      return true;
    }

    /**
     * Delete a directory. The directory must be empty of all files and subdirectories.
     * @param[in] dirname_ The full pathname to the directory.
     * @return false if it fails.
     */

    bool FatFileSystem::deleteDirectory(const char *dirname_) {

      FatDirectoryIterator *it;
      bool retval,hasContent;

      // cannot have content

      if(!directoryHasContent(dirname_,hasContent))
        return false;

      if(hasContent)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_DIRECTORY_NOT_EMPTY);

      // tokenise the path. can't delete the root directory

      TokenisedPathname tp(dirname_);
      if(tp.getNumTokens() == 0)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_INVALID_PATHNAME);

      // get the directory entry for the file

      if(!getDirectoryIteratorPointingToFile(tp,it))
        return false;

      // it must be a file

      DirectoryEntryWithLocation& dirent=it->getDirectoryEntryWithLocation();

      if(!dirent.isDirectory())
        retval=errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_NOT_A_DIRECTORY);
      else if(it->isParentDirectory() || it->isCurrentDirectory())
        retval=errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_INVALID_PATHNAME);
      else
        retval=fullyDelete(*it);

      delete it;
      return retval;
    }

    /**
     * Delete a file.
     * @param[in] filename The full pathname to the file that is to be deleted.
     * @return false if it fails.
     */

    bool FatFileSystem::deleteFile(const char *filename) {

      FatDirectoryIterator *it;
      bool retval;

      // tokenise the path

      TokenisedPathname tp(filename);
      if(tp.getNumTokens() == 0)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_INVALID_PATHNAME);

      // get the directory entry for the file

      if(!getDirectoryIteratorPointingToFile(tp,it))
        return false;

      // it must be a file

      DirectoryEntryWithLocation& dirent=it->getDirectoryEntryWithLocation();
      if(!dirent.isFile())
        retval=errorProvider.set(ErrorProvider::ERROR_PROVIDER_FILESYSTEM,E_NOT_A_FILE);
      else
        retval=fullyDelete(*it);

      delete it;
      return retval;
    }

    /*
     * deallocate and delete
     */

    bool FatFileSystem::fullyDelete(FatDirectoryIterator& it) {

      DirectoryEntry& dirent=it.getDirectoryEntryWithLocation().Dirent;
      uint32_t firstCluster;

      // deallocate the cluster chain

      firstCluster=static_cast<uint32_t> (dirent.sdir.DIR_FstClusHI) << 16 | dirent.sdir.DIR_FstClusLO;
      if(firstCluster != 0)
        deAllocateClusterChain(firstCluster);

      // free the dirents that made up this filename

      return deleteDirents(it);
    }

    /*
     * delete the set of dirents that make up this file
     */

    bool FatFileSystem::deleteDirents(FatDirectoryIterator& fdi) {

      uint32_t i;
      FilenameHandler& fh=fdi.getDirectoryEntryIterator().getFilenameHandler();
      ByteMemblock sector(getSectorSizeInBytes());
      DirectoryEntry *de;
      uint32_t lastSectorIndex,thisSectorIndex;

      lastSectorIndex=0;
      for(i=0;i < fh.getDirentCount();i++) {

        thisSectorIndex=fh.getSectorIndices()[i];

        // read the sector holding the dirent

        if(thisSectorIndex != lastSectorIndex) {

          if(lastSectorIndex != 0 && !writeSector(thisSectorIndex,sector))
            return false;

          if(!readSector(thisSectorIndex,sector))
            return false;

          lastSectorIndex=thisSectorIndex;
        }

        // get a pointer to the dirent and set the 'deleted' byte in the first char of the filename

        de=reinterpret_cast<DirectoryEntry *> (sector.getData() + fh.getSectorOffsetIndices()[i] * sizeof(DirectoryEntry));
        de->sdir.DIR_Name[0]=0xe5;
      }

      // write back the sector

      if(lastSectorIndex != 0 && !writeSector(lastSectorIndex,sector))
        return false;

      return true;
    }

    /**
     * De-allocate (free) a cluster chain. Failure may result in lost clusters.
     * @param[in] firstCluster The first cluster in the chain.
     * @return false if it fails.
     */

    bool FatFileSystem::deAllocateClusterChain(uint32_t firstCluster) {

      uint32_t clusterNumber;

      // de-allocate every cluster in the chain

      ClusterChainIterator cit(*this,firstCluster,ClusterChainIterator::extensionDontExtend);

      // free clusters by setting each one in the chain to zero one step behind the iterator

      clusterNumber=0;
      while(cit.next()) {

        // free the last cluster number

        if(clusterNumber != 0 && !writeFatEntry(clusterNumber,0))
          return false;

        clusterNumber=cit.current();
      }

      if(clusterNumber != 0 && !writeFatEntry(clusterNumber,0))
        return false;

      return true;
    }

    /*
     * Get the directory entry for a file
     */

    bool FatFileSystem::getDirectoryEntry(TokenisedPathname& pathTokens,DirectoryEntryWithLocation& dirent) {

      FatDirectoryIterator *parent;

      if(!getDirectoryIteratorPointingToFile(pathTokens,parent))
        return false;

      // get the directory entry from the iterator

      dirent=parent->getDirectoryEntryWithLocation(); // struct copy
      delete parent;

      return true;
    }

    /*
     * Get the directory iterator pointing to a file
     */

    bool FatFileSystem::getDirectoryIteratorPointingToFile(TokenisedPathname& pathTokens,FatDirectoryIterator *& parent) {

      // limit the range so that we get an iterator on to the parent

      pathTokens.setRange(0,pathTokens.getNumTokens() - 2);
      if(!FatDirectoryIterator::getInstance(*this,pathTokens,parent))
        return false;

      // reset the range so that we can see the filename on the end

      pathTokens.resetRange();

      // move the directory iterator to this filename

      if(!parent->moveTo(pathTokens.last())) {
        delete parent;
        parent=nullptr;
        return false;
      }

      return true;
    }

    /*
     * Get the first cluster number of the file's parent. Note that this returns zero if the root directory
     * is the parent even though there is a valid first cluster fo the root of FAT32 file systems
     */

    bool FatFileSystem::getParentDirectoryFirstCluster(TokenisedPathname& pathTokens,uint16_t* lo,uint16_t* hi) {

      FatDirectoryIterator *it;

      // limit the range so that we get an iterator on to the parent

      pathTokens.resetRange();
      pathTokens.setRange(0,pathTokens.getNumTokens() - 2);

      if(pathTokens.getNumTokens() == 0) {
        *lo=0; // the parent is the root directory
        *hi=0;
      } else {

        if(!FatDirectoryIterator::getInstance(*this,pathTokens,it))
          return false;

        // find "."

        if(!it->moveTo(".")) {
          delete it;
          return false;
        }

        DirectoryEntryWithLocation& dirent=it->getDirectoryEntryWithLocation();

        *lo=dirent.Dirent.sdir.DIR_FstClusLO;
        *hi=dirent.Dirent.sdir.DIR_FstClusHI;

        delete it;
      }

      return true;
    }

    /**
     * Get a reference to the boot sector
     * @return An internal reference to the filesystem boot sector.
     */

    const fat::BootSector& FatFileSystem::getBootSector() const {
      return _bootSector;
    }

    /**
     * Get the total cluster count.
     * @return The total cluster count.
     */

    uint32_t FatFileSystem::getCountOfClusters() const {
      return _countOfClusters;
    }

    /**
     * Convert cluster index to sector index.
     * @param[in] clusterNumber The cluster number to convert.
     * @return The sector index.
     */

    uint32_t FatFileSystem::clusterToSector(uint32_t clusterNumber) const {
      return _firstDataSector + ((clusterNumber - 2) * _bootSector.BPB_SecPerClus);
    }

    /**
     * Get the first sector of the root directory.
     * @return The first sector index.
     */

    uint32_t FatFileSystem::getRootDirectoryFirstSector() const {
      return _rootDirFirstSector;
    }

    /**
     * Get the size in bytes of a sector.
     * @return The sector size, in bytes.
     */

    uint32_t FatFileSystem::getSectorSizeInBytes() const {
      return _bootSector.BPB_BytsPerSec;
    }

    /**
     * Allocate a new cluster into the chain. This function will seek to the end of the cluster
     * chain and then allocate a new cluster and link it to the end of the chain.
     *
     * @param[in] anyClusterInChain Any cluster number in the chain.
     * @param[out] newCluster The newly allocated cluster number.
     * @return false if it fails.
     */

    bool FatFileSystem::allocateNewCluster(uint32_t anyClusterInChain,uint32_t& newCluster) {

      // find a free cluster

      if(!findFreeCluster(newCluster))
        return false;

      // step to the end of the cluster chain if this is not the first cluster in an empty file

      if(anyClusterInChain != 0) {

        ClusterChainIterator cit(*this,anyClusterInChain,ClusterChainIterator::extensionDontExtend);
        while(cit.next())
          ;

        // ensure reason for ending is that we hit the end

        if(!errorProvider.isLastError(ErrorProvider::ERROR_PROVIDER_ITERATOR,ClusterChainIterator::E_END_OF_ENTRIES))
          return false;

        // link the free cluster to the previous EOC

        if(!writeFatEntry(cit.current(),newCluster))
          return false;
      }

      // write EOC to free cluster

      return writeFatEntry(newCluster,getEndOfClusterChainMarker());
    }

    /**
     * Write an entry to both copies of the FAT. The assumption here is that both FAT entries are
     * identical, as they should be except in the case of recoverable corruption.
     * @param[in] fatEntryIndex The FAT index to write to.
     * @param[in] fatEntryContent The content of the entry to write.
     * @return false if it fails.
     */

    bool FatFileSystem::writeFatEntry(uint32_t fatEntryIndex,uint32_t fatEntryContent) {

      uint32_t sectorIndex,fatEntOffset,fatOffset;
      Memblock<uint8_t> sector(_bootSector.BPB_BytsPerSec);

      // get the byte offset into the fat of the cluster entry

      fatOffset=fatEntryIndex * getFatEntrySizeInBytes();

      // now get the sector index that holds the fat entry and the offset into that sector of the fat entry

      sectorIndex=_bootSector.BPB_RsvdSecCnt + (fatOffset / _bootSector.BPB_BytsPerSec);
      fatEntOffset=fatOffset % _bootSector.BPB_BytsPerSec;

      // read the sector from FAT #1

      if(!readSector(sectorIndex,sector))
        return false;

      // modify the value in the sector

      setFatEntryToMemory(sector + fatEntOffset,fatEntryContent);

      // write the sector back to FAT #1

      if(!writeSector(sectorIndex,sector))
        return false;

      // write the sector back to FAT #2 - big assumption here that FAT #1 and FAT#2 are identical

      sectorIndex+=getSectorsPerFat();
      return writeSector(sectorIndex,sector);
    }

    /**
     * Write a directory entry back to the device.
     * @param[in] dirent_ The directory entry to write back.
     * @return false if it fails.
     */

    bool FatFileSystem::writeDirectoryEntry(DirectoryEntryWithLocation& dirent_) {

      ByteMemblock sector(getSectorSizeInBytes());

      // read the sector containing the directory entry

      if(!readSector(dirent_.SectorNumber,sector))
        return false;

      // copy the dirent into the sector

      DirectoryEntry& dirent=dirent_.Dirent;
      memcpy(sector + sizeof(DirectoryEntry) * dirent_.IndexWithinSector,&dirent,sizeof(DirectoryEntry));

      // write back the sector

      return writeSector(dirent_.SectorNumber,sector);
    }

    /**
     * Find a free cluster. This implementation - being for an MCU - assumes that the FS is likely to
     * be on flash therefore the wear resistant implementation is used. Swap to the linear implementation
     * if this is not the case.
     *
     * @param[out] freeCluster The free cluster number.
     * @return false if it fails.
     */

    bool FatFileSystem::findFreeCluster(uint32_t& freeCluster) {

      WearResistFreeClusterFinder freeFinder(*this);
      return freeFinder.find(freeCluster);
    }

    /**
     * Get free space on the device in bytes.
     * Units will be clusters, the multiplier being sectorsPerCluster * bytesPerSector. So to get the free
     * space in bytes you need to multiply freeUnits_ by unitsMultiplier_. This allows for device sizes
     * greater than 4Gb.
     * @param[out] freeUnits The number of free units.
     * @param[out] unitsMultiplier What to multiply freeUnits_ by to get a byte size.
     * @return false if it fails.
     */

    bool FatFileSystem::getFreeSpace(uint32_t& freeUnits,uint32_t& unitsMultiplier) {

      uint32_t sectorIndex,entriesPerSector,i,count;
      ByteMemblock sector(getSectorSizeInBytes());
      uint8_t *ptr;

      // read each FAT sector

      freeUnits=0;
      count=0;

      entriesPerSector=getSectorSizeInBytes() / getFatEntrySizeInBytes();

      for(sectorIndex=_bootSector.BPB_RsvdSecCnt;sectorIndex < _bootSector.BPB_RsvdSecCnt + getSectorsPerFat() && count != _countOfClusters + 2;sectorIndex++) {

        // read the FAT sector

        if(!readSector(sectorIndex,sector))
          return false;

        // look for free entries in the FAT

        ptr=sector;
        for(i=0;i < entriesPerSector && count != _countOfClusters + 2;i++) {

          if(getFatEntryFromMemory(ptr) == 0)
            freeUnits++;

          ptr+=getFatEntrySizeInBytes();
          count++;
        }
      }

      // set the multiplier

      unitsMultiplier=static_cast<uint32_t> (_bootSector.BPB_SecPerClus) * getSectorSizeInBytes();
      return true;
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/FatFileSystem.cpp
// START FILE: ../lib/src/filesystem/fat/LinearFreeClusterFinder.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor
     * @param[in] fs A reference to the FAT file system. Must not go out of scope.
     */

    LinearFreeClusterFinder::LinearFreeClusterFinder(FatFileSystem& fs) :
      IteratingFreeClusterFinder(fs,0) {
    }


    /**
     * Find a sequence of at least the given number of clusters that are all free
     */

    bool LinearFreeClusterFinder::findMultipleSequential(uint32_t clustersRequired,uint32_t& firstCluster) {

      uint32_t i;

      // start searching the FAT

      while(_iterator.next()) {

        // found a free entry

        if(_iterator.currentContent() == 0) {

          firstCluster=_iterator.current();

          // search for continuous free entries after this one

          for(i=1;i<clustersRequired;i++) {

            if(!_iterator.next()) {

              // did we hit the end?

              if(errorProvider.isLastError(ErrorProvider::ERROR_PROVIDER_ITERATOR,FatIterator::E_END_OF_ENTRIES))
                return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FREE_CLUSTER_FINDER,E_NO_FREE_CLUSTERS);

              // some other error

              return false;
            }

            // if this is not free, leave now

            if(_iterator.currentContent()!=0)
              break;
          }

          if(i==clustersRequired)
            return true;
        }
      }

      // if we reached the end then return the true error

      if(errorProvider.isLastError(ErrorProvider::ERROR_PROVIDER_ITERATOR,FatIterator::E_END_OF_ENTRIES))
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FREE_CLUSTER_FINDER,E_NO_FREE_CLUSTERS);

      // something else went wrong, propagate it

      return false;
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/LinearFreeClusterFinder.cpp
// START FILE: ../lib/src/filesystem/fat/Fat16RootDirectoryEntryIterator.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor.
     * @param[in] fs_ The filesystem reference for this iterator.
     * @param[in] options_ Options that control how to iterator over this directory.
     */

    Fat16RootDirectoryEntryIterator::Fat16RootDirectoryEntryIterator(FatFileSystem& fs_,Options options_) :
      DirectoryEntryIterator(fs_,options_),
      _currentSector(fs_.getBootSector().BPB_BytsPerSec) {

      _entriesPerSector=_fs.getBootSector().BPB_BytsPerSec/sizeof(DirectoryEntry);
      _rootDirMaxEntries=_fs.getBootSector().BPB_RootEntCnt;

      reset();
    }

    /*
     * reset the iteration
     */

    void Fat16RootDirectoryEntryIterator::reset() {
      _currentIndex=-1;
      _firstEntryInCurrentSector=-1;
    }

    /*
     * Get the byte offset into the sector of this entry
     */

    uint32_t Fat16RootDirectoryEntryIterator::entryOffsetInSector(uint32_t entryIndex_) const {
      return (entryIndex_%_entriesPerSector)*sizeof(DirectoryEntry);
    }

    /*
     * Return true if the current entry is in the current sector.
     * Assumes _currentIndex!=-1 and _firstEntryInCurrentSector!=-1
     */

    bool Fat16RootDirectoryEntryIterator::isEntryInCurrentSector() const {
      return _currentIndex-_firstEntryInCurrentSector<_entriesPerSector;
    }

    /*
     * Get the sector index for the given entry
     */

    uint32_t Fat16RootDirectoryEntryIterator::sectorIndexForEntry(uint32_t entryIndex_) const {
      return _fs.getRootDirectoryFirstSector()+(entryIndex_/_entriesPerSector);
    }

    /*
     * Move to next entry
     */

    bool Fat16RootDirectoryEntryIterator::internalNext() {

      uint32_t offset;

      // update to next entry, or zero if this is the first move

      _currentIndex++;

      // check for the end of this fixed length structure

      if(_currentIndex==_rootDirMaxEntries)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_ITERATOR,E_END_OF_ENTRIES);

      // first time?

      if(_currentIndex==0||!isEntryInCurrentSector()) {

        // current index is not in the cached sector, read new sector

        if(!readSectorForEntry(_currentIndex))
          return false;
      }

      // get the offset into the sector and copy

      offset=entryOffsetInSector(_currentIndex);

      memcpy(&_currentEntry.Dirent,static_cast<uint8_t *> (_currentSector)+offset,sizeof(DirectoryEntry));
      _currentEntry.SectorNumber=sectorIndexForEntry(_currentIndex);
      _currentEntry.IndexWithinSector=_currentIndex%_entriesPerSector;

      // check for end-of-entries

      if((_currentEntry.Dirent.sdir.DIR_Attr&DirectoryEntry::ATTR_LONG_NAME_MASK)!=DirectoryEntry::ATTR_LONG_NAME&&_currentEntry.Dirent.sdir.DIR_Name[0]=='\0')
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_ITERATOR,E_END_OF_ENTRIES);

      return true;
    }

    /*
     * Read a sector for the given entry index
     */

    bool Fat16RootDirectoryEntryIterator::readSectorForEntry(uint32_t entryIndex_) {

      uint32_t sectorIndex;

      // check if reached the end

      if(entryIndex_/_entriesPerSector>=((Fat16FileSystem&)_fs).getRootDirSectors())
        return false;

      sectorIndex=sectorIndexForEntry(entryIndex_);
      return _fs.readSector(sectorIndex,_currentSector);
    }

    /*
     * 'extend' the directory to include space for new entries. The directory has a fixed number sectors
     *  so we cannot allocate more if the end is reached
     */

    bool Fat16RootDirectoryEntryIterator::extendDirectory(DirectoryEntry *dirents_,uint32_t direntCount_) {

      DirectoryEntryWithLocation dloc;
      uint32_t i;

      // go to the end

      reset();
      while(next())
        ;
      if(!errorProvider.isLastError(ErrorProvider::ERROR_PROVIDER_ITERATOR,Iterator<DirectoryEntryWithLocation>::E_END_OF_ENTRIES))
        return false;

      // have we got space?

      if(_currentIndex>_rootDirMaxEntries-direntCount_)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_ITERATOR,E_ROOT_DIRECTORY_FULL);

      for(i=0;i<=direntCount_;i++) {

        if(_currentIndex+i<_rootDirMaxEntries) { // may not be space for the end marker

          dloc.SectorNumber=sectorIndexForEntry(_currentIndex+i);
          dloc.IndexWithinSector=(_currentIndex+i)%_entriesPerSector;

          if(i==direntCount_)
            memset(&dloc.Dirent,0,sizeof(dloc.Dirent)); // end of entries marker
          else
            dloc.Dirent=dirents_[i]; // struct copy

          if(!_fs.writeDirectoryEntry(dloc))
            return false;
        }
      }

      return true;
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/Fat16RootDirectoryEntryIterator.cpp
// START FILE: ../lib/src/filesystem/fat/LongNameDirentGenerator.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor. Generates the dirents from the supplied parameters. Check the error provider
     * afterwards for errors.
     *
     * @param[in] longName_ The desired long name for the new file.
     * @param[in] targetDir_ A directory iterator pointing to the directory that will hold the new file.
     * @param[in] createDate_ The creation date of the new file.
     * @param[in] createTime_ The creation time of the new file. The tenths field will be set to zero.
     */

    LongNameDirentGenerator::LongNameDirentGenerator(const char *longName_,DirectoryEntryIterator& targetDir_,uint16_t createDate_,uint16_t createTime_)
      : _targetDir(targetDir_),
        _longName(longName_),
        _dirents(nullptr),
        _createDate(createDate_),
        _createTime(createTime_),
        _currentIteratorIndex(-1) {

      if(generateDirentsFromLongName())
        errorProvider.clear();
    }

    /**
     * Virtual destructor, frees memory used by the directory entries.
     */

    LongNameDirentGenerator::~LongNameDirentGenerator() {
      if(_dirents != nullptr)
        delete[] _dirents;
    }

    /**
     * Get the number of dirents.
     * @return The number of dirents required to store the new file.
     */

    int LongNameDirentGenerator::getDirentCount() {
      return _direntCount;
    }

    /**
     * Get the dirents array.
     * @return An internal pointer to the array of dirents that the constructor generated. Owned by
     * this class, do not delete.
     */

    DirectoryEntry *LongNameDirentGenerator::getDirents() {
      return _dirents;
    }

    /*
     * Generate the DirectoryEntry structures from the long name
     */

    bool LongNameDirentGenerator::generateDirentsFromLongName() {

      char shortName[12];
      int namelen=0;
      DirectoryEntry *de;
      const char *src;
      uint8_t checksum,ordinal;

      // if the long name is a valid short name then there will be only
      // 1 dirent for the short name

      if(isLongNameValidShortName()) {
        _direntCount=1;
      } else {

        // 13 characters per dirent

        namelen=strlen(_longName);
        _direntCount=(namelen / 13) + (namelen % 13 == 0 ? 1 : 2);
      }

      // check for unique name. Only long names can have the short name
      // modified up

      if(!findUniqueShortName(shortName))
        return false; // FAIL.

      // need memory for these structures

      _dirents=new DirectoryEntry[_direntCount];

      // create the short entry, the last in the sequence

      de=&_dirents[_direntCount - 1];

      memcpy(de->sdir.DIR_Name,shortName,11);
      de->sdir.DIR_Attr=DirectoryEntry::ATTR_ARCHIVE;
      de->sdir.DIR_CrtDate=de->sdir.DIR_LstAccDate=de->sdir.DIR_WrtDate=_createDate;
      de->sdir.DIR_CrtTime=de->sdir.DIR_WrtTime=_createTime;
      de->sdir.DIR_CrtTimeTenth=0;
      de->sdir.DIR_FileSize=0;
      de->sdir.DIR_FstClusHI=de->sdir.DIR_FstClusLO=0;
      de->sdir.DIR_NTRes=0;

      if(_direntCount > 1) {

        // create the long entries

        src=_longName;
        checksum=shortNameChecksum(_dirents[_direntCount - 1].sdir.DIR_Name);
        ordinal=1;

        // long entries are in reverse order

        for(de=&_dirents[_direntCount - 2];de >= _dirents;de--) {

          // index of this long entry

          de->ldir.LDIR_Ord=ordinal++;

          if(de == _dirents)
            de->ldir.LDIR_Ord|=0x40;

          // basics

          de->ldir.LDIR_Attr=DirectoryEntry::ATTR_LONG_NAME;
          de->ldir.LDIR_Type=0;
          de->ldir.LDIR_Chksum=checksum;
          de->ldir.LDIR_FstClusLO=0;

          // name parts

          copyChars(src,namelen,de->ldir.LDIR_Name1,5);
          copyChars(src,namelen,de->ldir.LDIR_Name2,6);
          copyChars(src,namelen,de->ldir.LDIR_Name3,2);
        }
      }

      return true;
    }

    /*
     * find unique short name for the long name
     */

    bool LongNameDirentGenerator::findUniqueShortName(char *shortName_) {

      char lossyName[11];
      int tailNumber;
      bool found;

      _targetDir.reset();

      // first pass through to ensure that the filename is unique

      while(_targetDir.next()) {
        if(!strcasecmp(_targetDir.getFilename(),_longName))
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_LONG_FILENAME_GENERATOR,E_FILE_EXISTS);
      }

      // generate the short name

      generateShortName(shortName_);

      // if there will only one dirent then that's it

      if(_direntCount == 1)
        return true;

      // now need to ensure that the short name does not clash with another
      // start the process by checking the unadulterated short name

      for(tailNumber=1,found=true;found;tailNumber++) {

        // compute the lossy name

        computeLossyShortName(shortName_,lossyName,tailNumber);

        _targetDir.reset();
        found=false;

        // search directory entries

        while(_targetDir.next()) {

          // check the dirent shortname against the current lossy name (or short name if first around)

          if(!memcmp(_targetDir.current().Dirent.sdir.DIR_Name,lossyName,11)) {
            found=true;
            break;
          }
        }
      }

      // keep the current find

      memcpy(shortName_,lossyName,11);
      return true;
    }

    /*
     * copy in characters
     */

    void LongNameDirentGenerator::copyChars(const char *& src_,int& srcLen_,uint16_t *dest_,int destLen_) {

      char *dest,padding,c;

      // the chars in the name are 16 bit unicode and we only support 8-bit chars encoded as
      // xx00 so we'll need to treat the dest as an 8-bit pointer to ensure that
      // endian-ness of the CPU doesn't come into play

      dest=reinterpret_cast<char *> (dest_);

      while(destLen_--) {

        // when past the nul terminated string pad to end with 0xff

        if(srcLen_ < 0) {
          c='\xff';
          padding='\xff';
        } else {
          c=*src_++; // still in the string, take a character including the ending nul
          padding='\0';
          srcLen_--;
        }

        *dest++=c;
        *dest++=padding;
      }
    }

    /*
     * check if this long name is a valid short name
     */

    bool LongNameDirentGenerator::isLongNameValidShortName() const {

      static const char *permittedSpecialCharacters="$%'-_@~!(){}^#&";

      int seenChars;
      const char *ptr,*dotPos;

      dotPos=nullptr;
      seenChars=0;

      for(ptr=_longName;*ptr;ptr++) {

        // no more than 3 characters after the dot

        if(dotPos != nullptr && ptr - dotPos > 3)
          return false;

        // one period is permitted

        if(*ptr == '.') {

          if(dotPos != nullptr)
            return false;

          dotPos=ptr;
        } else {

          // must be a permitted character (upper case alphanum, >127 or in the special set)

          if(!isupper(*ptr) && !isdigit(*ptr) && *ptr < 128 && strchr(permittedSpecialCharacters,*ptr) == nullptr)
            return false;

          // no more than 11 characters total not including the dot

          if(++seenChars > 11)
            return false;
        }
      }

      // it's OK

      return true;
    }

    /*
     * Generate equivalent short name from long name
     * shortName_ must point to at least 11 chars
     * this function will not null terminate the short name
     */

    void LongNameDirentGenerator::generateShortName(char *shortName_) const {

      char *dest;
      const char *src,*lastDot;
      int copied;

      copied=0;
      lastDot=strrchr(_longName,'.');

      // copy first 8 chars, or up to the last period, or the end

      for(src=_longName,dest=shortName_;copied < 8 && *src && src != lastDot;src++) {

        if(*src != ' ' && *src != '.') {
          *dest++=toupper(*src);
          copied++;
        }
      }

      // fill out remaining base name with spaces

      while(copied < 8) {
        *dest++=' ';
        copied++;
      }

      // copy up to three non-space chars after the last dot

      copied=0;

      if(lastDot) {

        src=lastDot + 1;
        while(copied < 3 && *src) {

          if(*src != ' ') {
            *dest++=toupper(*src);
            src++;
            copied++;
          }
        }
      }

      // fill out with spaces

      while(copied < 3) {
        *dest++=' ';
        copied++;
      }
    }

    /*
     * Generate a lossy name from the short name
     * e.g. FOO.DOC is FOO~1.DOC
     * short name layout must be in the dirent format,
     * e.g. FOO.DOC = "FOO     DOC"
     * tailNumber_ must not be greater than 999999
     */

    void LongNameDirentGenerator::computeLossyShortName(const char *shortName_,char *lossyName_,int tailNumber_) const {

      char tail[8];
      int state,tailSize,i;
      const char *src,*bodyPtr;

      // get the tail size

      tail[0]='~';
      StringUtil::itoa(tailNumber_,tail + 1,10);
      tailSize=strlen(tail);

      // start copying the basename (state=0) until either a space is encountered
      // or we must switch to the tail because of space

      src=bodyPtr=shortName_;
      state=0;

      for(i=0;i < 11;i++) {

        if(state == 0 && (*src == ' ' || i + tailSize == 8)) {

          // switch to copying the tail

          state=1;
          src=tail;
        } else if(state == 1 && *src == '\0') {

          // tail is copied, back to the basename

          state=2;
          src=bodyPtr;
        }

        *lossyName_++=*src++;
        bodyPtr++;
      }
    }

    /*
     * Compute the checksum for the short name. The short name must be exactly 11
     * characters long.
     */

    uint8_t LongNameDirentGenerator::shortNameChecksum(const uint8_t *shortName_) const {

      int i;
      uint8_t sum;

      // NOTE: The operation is an unsigned char rotate right

      sum=0;
      for(i=11;i > 0;i--)
        sum=((sum & 1) ? 0x80 : 0) + (sum >> 1) + *shortName_++;

      return sum;
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/LongNameDirentGenerator.cpp
// START FILE: ../lib/src/filesystem/fat/DirectoryEntryIterator.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /*
     * Constructor
     */

    DirectoryEntryIterator::DirectoryEntryIterator(FatFileSystem& fs_,Options options_) :
      _fs(fs_) {
      _options=options_;
    }

    /*
     * return the current entry
     */

    DirectoryEntryWithLocation& DirectoryEntryIterator::current() {
      return _currentEntry;
    }

    /**
     * Return the current filename. If a long name is present then it will be returned.
     * @return The current filename.
     */

    const char *DirectoryEntryIterator::getFilename() {
      return _filename.getFilename();
    }

    /**
     * Get the filename handler.
     * @return A reference to the filename handler.
     */

    FilenameHandler& DirectoryEntryIterator::getFilenameHandler() {
      return _filename;
    }

    /**
     * @copydoc Iterator::next
     *
     * The options are taken into account and entries may be skipped if that's what has been specified.
     */

    bool DirectoryEntryIterator::next() {

      bool repeat,deleted;

      errorProvider.clear();

      _filename.reinitialise();

      do {

        if(!internalNext())
          return false;

        // handle filename as long as this entry is not deleted

        DirectoryEntry& dirent=_currentEntry.Dirent;

        deleted=dirent.sdir.DIR_Name[0] == 0xe5;
        if(!deleted && !_filename.handleEntry(_currentEntry))
          return false;

        // repeat if entry is deleted and we are skipping those or if entry
        // is a long name entry and we are parsing them in one step

        if(deleted)
          repeat=(_options & OPT_SKIP_DELETED) != 0;
        else if((dirent.sdir.DIR_Attr & DirectoryEntry::ATTR_LONG_NAME_MASK) == DirectoryEntry::ATTR_LONG_NAME)
          repeat=(_options & OPT_PARSE_LONG_NAMES) != 0;
        else
          repeat=false;

      } while(repeat);

      // reset the dates and times - these are lazily calculated as required

      _lastAccessDateTime=_lastWriteDateTime=_creationDateTime=INT32_MAX;

      return true;
    }

    /**
     * Get the last access date/time as a Unix time_t
     *
     * @return The last access date/time.
     */

    time_t DirectoryEntryIterator::getLastAccessDateTime() {

      if(_lastAccessDateTime != INT32_MAX)
        return _lastAccessDateTime;

      return calculateUnixTime(_currentEntry.Dirent.sdir.DIR_LstAccDate,0,_lastAccessDateTime);
    }

    /**
     * Get the last write date/time as a unix time_t
     *
     * @return The last write date/time.
     */

    time_t DirectoryEntryIterator::getLastWriteDateTime() {

      if(_lastWriteDateTime != INT32_MAX)
        return _lastWriteDateTime;

      DirectoryEntry& dirent=_currentEntry.Dirent;
      return calculateUnixTime(dirent.sdir.DIR_WrtDate,dirent.sdir.DIR_WrtTime,_lastWriteDateTime);
    }

    /**
     * Get the creation date/time as a unix time_t
     *
     * @return The creation date/time.
     */

    time_t DirectoryEntryIterator::getCreationDateTime() {
      if(_creationDateTime != INT32_MAX)
        return _creationDateTime;

      DirectoryEntry& dirent=_currentEntry.Dirent;
      return calculateUnixTime(dirent.sdir.DIR_CrtDate,dirent.sdir.DIR_CrtTime,_creationDateTime);
    }

    /**
     * Static helper to calculate Unix date/time from MSDOS date+time
     * @param[in] date_ MSDOS date.
     * @param[in] time_ MSDOS time.
     * @param[out] result_ The Unix time_t.
     *
     * @return The same as result_.
     */

    time_t DirectoryEntryIterator::calculateUnixTime(uint16_t date_,uint16_t time_,time_t& result_) {

      struct tm timeInfo;

      timeInfo.tm_mday=date_ & 31; // 5 bits (base=1)
      timeInfo.tm_mon=((date_ >> 5) & 15) - 1; // 4 bits (base=1)
      timeInfo.tm_year=((date_ >> 9) & 127) + 80; // 7 bits (base=1980)

      timeInfo.tm_sec=(time_ & 31) * 2; // 5 bits (resolution=2 secs)
      timeInfo.tm_min=(time_ >> 5) & 63; // 6 bits (base=0)
      timeInfo.tm_hour=(time_ >> 11) & 31; // 5 bits (base=0)

      result_=mktime(&timeInfo);
      return result_;
    }

    /**
     * Convert MSDOS date+time from unix time
     *
     * @param[in] unixTime_ The Unix time_t to convert.
     * @param[out] date_ The MSDOS FAT date.
     * @param[out] time_ The MSDOS FAT time.
     */

    void DirectoryEntryIterator::calculateFatDateTime(time_t unixTime_,uint16_t& date_,uint16_t& time_) {

      struct tm *timeInfo;

      // get components

      timeInfo=gmtime(&unixTime_);

      // set the date

      date_=(static_cast<uint32_t> (timeInfo->tm_year - 80) << 9) | (static_cast<uint32_t> (timeInfo->tm_mon + 1) << 5) | timeInfo->tm_mday;

      // set the time

      time_=(static_cast<uint32_t> (timeInfo->tm_hour) << 11) | (static_cast<uint32_t> (timeInfo->tm_min) << 5) | (static_cast<uint32_t> (timeInfo->tm_sec) >> 1);
    }

    /**
     * Write some new dirents to this directory. If the directory contains a contiguous sequence of deleted
     * large enough to hold the new sequence then these entries are used. If not then new entries are allocated
     * on the end of the directory. Whichever happens, the new dirents are guaranteed not to be broken up.
     *
     * @param[in] dirents_ The dirents to write to this directory.
     * @param[in] direntCount_ The number of dirents to write.
     * @return false if it fails.
     */

    bool DirectoryEntryIterator::writeDirents(DirectoryEntry *dirents_,int direntCount_) {

      DirectoryEntryWithLocation *entries;
      Options oldOptions;
      int foundCount,i;

      // save old options and make sure we see deleted entries now

      oldOptions=_options;
      _options=OPT_PARSE_LONG_NAMES;

      // reset the iterator

      reset();

      // start searching for deleted entries

      foundCount=0;
      entries=new DirectoryEntryWithLocation[direntCount_];

      while(next()) {

        if(current().Dirent.sdir.DIR_Name[0] == 0xE5) {

          // if first in sequence, remember it

          entries[foundCount++]=current(); // struct copy

          // if found enough, remember the last

          if(foundCount == direntCount_) {

            // finished with this

            _options=oldOptions;

            // now write the dirents

            for(i=0;i < foundCount;i++) {

              entries[i].Dirent=dirents_[i]; // struct copy

              if(!_fs.writeDirectoryEntry(entries[i])) {
                delete[] entries;
                return false;
              }
            }

            delete[] entries;
            return true;
          }
        } else
          foundCount=0; // reset the counter
      }

      // we're done with these

      delete[] entries;
      _options=oldOptions;

      // not enough contiguous deleted entries available
      // extend the directory to make space for them

      return extendDirectory(dirents_,direntCount_);
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/DirectoryEntryIterator.cpp
// START FILE: ../lib/src/filesystem/fat/ClusterChainIterator.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor
     *
     * @param[in] fs_ The filesystem reference.
     * @param[in] firstClusterNumber_ The number of the first cluster in the chain.
     * @param[in] extend_ Whether or not to extend when the end is reached.
     */

    ClusterChainIterator::ClusterChainIterator(FatFileSystem& fs_,uint32_t firstClusterNumber_,ExtensionMode extend_) :
      _fs(fs_) {
      _currentClusterNumber=firstClusterNumber_;
      _first=true;
      _firstClusterNumber=firstClusterNumber_;
      _extend=extend_;
    }

    /**
     * Reset the iterator to the beginning.
     * @param[in] firstClusterNumber_ The first cluster in the chain.
     */

    void ClusterChainIterator::reset(uint32_t firstClusterNumber_) {
      _currentClusterNumber=firstClusterNumber_;
      _first=true;
    }

    /*
     * Get the current cluster number
     */

    uint32_t ClusterChainIterator::current() {
      return _currentClusterNumber;
    }

    /**
     * Get the current sector number.
     * @return The current sector number.
     */

    uint32_t ClusterChainIterator::currentSectorNumber() {
      return _fs.clusterToSector(_currentClusterNumber);
    }

    /*
     * Move to the next in the chain
     */

    bool ClusterChainIterator::next() {

      uint32_t nextNumber;

      // clear error

      errorProvider.clear();

      // first call to next() must return the first cluster

      if(_first) {
        nextNumber=_currentClusterNumber;
        _first=false;
      } else {

        // read from the FAT

        if(!_fs.readFatEntry(_currentClusterNumber,nextNumber))
          return false;
      }

      // reached the end?

      if(nextNumber == 0 || _fs.isEndOfClusterChainMarker(nextNumber)) {
        if(_extend == extensionExtend) {

          // try to extend the cluster chain with a new entry

          if(!_fs.allocateNewCluster(_currentClusterNumber,nextNumber))
            return false;
        } else
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_ITERATOR,E_END_OF_ENTRIES);
      }

      // check for bad cluster

      if(nextNumber == _fs.getBadClusterMarker())
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FAT_FILESYSTEM,FatFileSystem::E_BAD_CLUSTER);

      // OK

      _currentClusterNumber=nextNumber;
      return true;
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/ClusterChainIterator.cpp
// START FILE: ../lib/src/filesystem/fat/FatFileSystemFormatter.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {


    /*
     * Constructor
     */

    FatFileSystemFormatter::FatFileSystemFormatter(BlockDevice& blockDevice_,uint32_t firstSectorIndex_,uint32_t numSectors_,const char *volumeLabel_)
      : _blockDevice(blockDevice_) {

      int i;

      errorProvider.clear();

      // copy up to 11 characters from the volume label

      memset(_volumeLabel,' ',sizeof(_volumeLabel));
      for(i=0;i<11 && volumeLabel_[i];i++)
        _volumeLabel[i]=volumeLabel_[i];

      _numSectors=numSectors_;
      _firstSectorIndex=firstSectorIndex_;
    }


    /*
     * Prepare the parts of the bootsector that are FAT independent
     */

    bool FatFileSystemFormatter::createNewBootSector() {

      _bootSector.BS_jmpBoot[0]=0xeb;
      _bootSector.BS_jmpBoot[1]=0x58;
      _bootSector.BS_jmpBoot[2]=0x90;

      memcpy(_bootSector.BS_OEMName,"MSDOS5.0",8);

      _bootSector.BPB_BytsPerSec=512;

      _bootSector.BPB_NumFATs=2;
      _bootSector.BPB_Media=MEDIA_TYPE; // media type
      _bootSector.BPB_SecPerTrk=63;
      _bootSector.BPB_NumHeads=255;
      _bootSector.BPB_HiddSec=_firstSectorIndex;

      return true;
    }

    /*
     * Format a boot sector and write it to disk
     */

    bool FatFileSystemFormatter::writeBootSector(uint32_t bootSectorIndex_) {

      ByteMemblock sector(512);

    // create a new boot sector at the start of the block

      if(!createNewBootSector())
        return false;

      memcpy(sector.getData(),&_bootSector,sizeof(_bootSector));

    // write signature to sector

      setReservedSectorSignature(sector);

    // write to the device

      return _blockDevice.writeBlock(sector,bootSectorIndex_);
    }


    /*
     * Add the signature 0x55,0xAA
     */

    void FatFileSystemFormatter::setReservedSectorSignature(uint8_t *sector_) const {

      sector_[0x1fe]=0x55;
      sector_[0x1ff]=0xaa;
    }


    /*
     * Format the FAT structures
     */

    bool FatFileSystemFormatter::writeFats(uint32_t firstFatFirstSector_,uint32_t sectorsPerFat_) const {

      ByteMemblock sector(512);
      uint32_t i,j,sectorIndex;

      // two copies of the FAT, back to back

      sectorIndex=firstFatFirstSector_;

      for(i=0;i<2;i++) {

        // initialise the two reserved clusters

        memset(sector,0,512);
        initReservedClusters(sector);

        // write this sector
        if(!_blockDevice.writeBlock(sector,sectorIndex++))
          return false;

        // write the remaining sectors

        memset(sector,0,512);

        for(j=0;j<sectorsPerFat_;j++)
          if(!_blockDevice.writeBlock(sector,sectorIndex++))
            return false;
      }

      // done

      return true;
    }


    /*
     * Initialise the volume label
     */

    void FatFileSystemFormatter::initVolumeLabelDirent(uint8_t *rootDirSector_) const {

      ShortDirectoryEntry *dirent;

      dirent=reinterpret_cast<ShortDirectoryEntry *>(rootDirSector_);

      memset(dirent,0,32);
      memcpy(dirent->DIR_Name,_volumeLabel,11);
      dirent->DIR_Attr=DirectoryEntry::ATTR_VOLUME_ID;
    }


    /*
     * Initialise and write the root directory entries
     */

    bool FatFileSystemFormatter::writeRootDirectoryEntries(uint32_t sectorIndex_) const {

      ByteMemblock sector(512);

      // zero the sector and then write the volume label into it

      memset(sector.getData(),0,512);
      initVolumeLabelDirent(sector);

      // write to the device

      return _blockDevice.writeBlock(sector,sectorIndex_);
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/FatFileSystemFormatter.cpp
// START FILE: ../lib/src/filesystem/fat/FileSectorIterator.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

  /**
   * Constructor.
   * @param[in] fs_ A reference to the FAT file system. Must not go out of scope.
   * @param[in] firstClusterIndex_ The number of the first cluster in this file.
   * @param[in] extend_ Whether or not to extend the file by allocating new clusters when the end is reached. File writers
   * typically want to extend a file when the end is reached, file readers do not.
   */

    FileSectorIterator::FileSectorIterator(FatFileSystem& fs_,uint32_t firstClusterIndex_,ClusterChainIterator::ExtensionMode extend_)
      : _iterator(fs_,firstClusterIndex_,extend_),_fs(fs_) {

      _sectorIndexInCluster=0x10000;        // force initial move
      _sectorsPerCluster=fs_.getBootSector().BPB_SecPerClus;
    }


  /**
   * Reset the iterator to the first cluster.
   * @param firstClusterNumber_ The first cluster in the file.
   */

    void FileSectorIterator::reset(uint32_t firstClusterNumber_) {
      _sectorIndexInCluster=0x10000;
      _iterator.reset(firstClusterNumber_);
    }


  /**
   * Move to next sector in the file.
   * @see Iterator::next
   * @return false if the move fails due to error or end of sectors.
   */

    bool FileSectorIterator::next() {

    // check if move required

      if(++_sectorIndexInCluster>=_sectorsPerCluster) {
        if(!_iterator.next())
          return false;

        _sectorIndexInCluster=0;
      }

      return true;
    }


  /**
   * Get the current cluster number
   * @return The current cluster number.
   */

    uint32_t FileSectorIterator::getClusterNumber() {
      return _iterator.current();
    }


  /**
   * Read sector from the cluster.
   * @param buffer_ A caller-supplied buffer that will receive the sector data.
   * @return false if the read fails.
   */

    bool FileSectorIterator::readSector(void *buffer_) {
      return _fs.readSectorFromCluster(_iterator.current(),_sectorIndexInCluster,buffer_);
    }


  /**
   * Write sector to the cluster.
   * @param[in] buffer_ A caller supplied buffer that holds the sector data to write.
   * @return false if the write fails.
   */

    bool FileSectorIterator::writeSector(void *buffer_) {
      return _fs.writeSectorToCluster(_iterator.current(),_sectorIndexInCluster,buffer_);
    }


  /**
   * Return the current sector number.
   * @return The number of the current sector (a linear sequence from the start of the device).
   */

    uint32_t FileSectorIterator::current() {
      return _iterator.currentSectorNumber()+_sectorIndexInCluster;
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/FileSectorIterator.cpp
// START FILE: ../lib/src/filesystem/fat/FreeClusterFinder.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /*
     * Constructor
     */

    FreeClusterFinder::FreeClusterFinder(FatFileSystem& fs_) :
      _fs(fs_) {
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/FreeClusterFinder.cpp
// START FILE: ../lib/src/filesystem/fat/Fat32FileSystem.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor. This is normally called by the factory method in FileSystem.
     *
     * @param[in] blockDevice The block device that holds this filesystem.
     * @param[in] timeProvider A provider of time information for write access to the file system.
     * @param[in] bootSector The boot sector (BPB) for this file system.
     * @param[in] firstSectorIndex The index of the first sector on the block device of this file system.
     * @param[in] countOfClusters The total clusters allocated to this file system.
     *
     * @see FileSystem::getInstance
     */

    Fat32FileSystem::Fat32FileSystem(BlockDevice& blockDevice,const TimeProvider& timeProvider,const fat::BootSector& bootSector,uint32_t firstSectorIndex,uint32_t countOfClusters) :
      FatFileSystem(blockDevice,timeProvider,bootSector,firstSectorIndex,countOfClusters) {

      _rootDirFirstSector=clusterToSector(_bootSector.fat32.BPB_RootClus);
      _firstDataSector=_bootSector.BPB_RsvdSecCnt+(_bootSector.BPB_NumFATs*_bootSector.fat32.BPB_FATSz32);
    }

    /**
     * Destructor
     */

    Fat32FileSystem::~Fat32FileSystem() {
    }

    /**
     * @copydoc FatFileSystem::getFileSystemType
     * Returns FileSystemType::Fat32
     */

    FileSystem::FileSystemType Fat32FileSystem::getFileSystemType() const {
      return Fat32;
    }

    /**
     * @copydoc FatFileSystem::getFatEntrySizeInBytes
     * Returns 4.
     */

    uint32_t Fat32FileSystem::getFatEntrySizeInBytes() const {
      return 4;
    }

    /**
     * @copydoc FatFileSystem::getSectorsPerFat
     */

    uint32_t Fat32FileSystem::getSectorsPerFat() const {
      return _bootSector.fat32.BPB_FATSz32;
    }

    /**
     * @copydoc FatFileSystem::getBadClusterMarker
     * Returns 0x0FFFFFF7.
     */

    uint32_t Fat32FileSystem::getBadClusterMarker() const {
      return 0x0FFFFFF7;
    }

    /**
     * @copydoc FatFileSystem::isEndOfClusterChainMarker
     * Returns 0x0FFFFFF8.
     */

    bool Fat32FileSystem::isEndOfClusterChainMarker(uint32_t clusterNumber) const {
      return clusterNumber>=0x0FFFFFF8;
    }

    /**
     * @copydoc FatFileSystem::getEndOfClusterChainMarker
     * Returns 0xFFFFFFF8.
     */

    uint32_t Fat32FileSystem::getEndOfClusterChainMarker() const {
      return 0xFFFFFFF8;
    }

    /**
     * @copydoc FatFileSystem::getFatEntryFromMemory
     * Returns the entry and'd with 0x0FFFFFFF;
     */

    uint32_t Fat32FileSystem::getFatEntryFromMemory(void *addr) const {
      return *static_cast<uint32_t *> (addr)&0x0FFFFFFF;
    }

    /**
     * @copydoc FatFileSystem::setFatEntryToMemory
     */

    void Fat32FileSystem::setFatEntryToMemory(void *addr,uint32_t entry) const {
      *static_cast<uint32_t *> (addr)=entry;
    }

    /**
     * @copydoc FatFileSystem::getRootDirectoryIterator
     */

    DirectoryEntryIterator *Fat32FileSystem::getRootDirectoryIterator(DirectoryEntryIterator::Options options) {
      return new NormalDirectoryEntryIterator(*this,_bootSector.fat32.BPB_RootClus,options);
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/Fat32FileSystem.cpp
// START FILE: ../lib/src/filesystem/fat/FatFileInformation.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor. Extract attributes from dirent.
     *
     * @param[in] filename_ The name of the file to get information for.
     * @param[in] dirent_ The corresponding dirent for this file.
     */

    FatFileInformation::FatFileInformation(const char *filename_,const DirectoryEntryWithLocation& dirent_) {

      _attributes=dirent_.Dirent.sdir.DIR_Attr;
      _filename=filename_;
      _length=dirent_.Dirent.sdir.DIR_FileSize;

      DirectoryEntryIterator::calculateUnixTime(dirent_.Dirent.sdir.DIR_CrtDate,dirent_.Dirent.sdir.DIR_CrtTime,_creationDate);
      DirectoryEntryIterator::calculateUnixTime(dirent_.Dirent.sdir.DIR_WrtDate,dirent_.Dirent.sdir.DIR_WrtTime,_lastWriteDateTime);
      DirectoryEntryIterator::calculateUnixTime(dirent_.Dirent.sdir.DIR_LstAccDate,0,_lastAccessDateTime);
    }

    /**
     * @copydoc FileInformation::getAttributes
     */

    uint32_t FatFileInformation::getAttributes() const {
      return _attributes;
    }

    /**
     * @copydoc FileInformation::getFilename
     */

    const char *FatFileInformation::getFilename() const {
      return _filename;
    }

    /**
     * @copydoc FileInformation::getCreationDateTime
     */

    time_t FatFileInformation::getCreationDateTime() const {
      return _creationDate;
    }

    /**
     * @copydoc FileInformation::getLastWriteDateTime
     */

    time_t FatFileInformation::getLastWriteDateTime() const {
      return _lastWriteDateTime;
    }

    /**
     * @copydoc FileInformation::getLastAccessDateTime
     */

    time_t FatFileInformation::getLastAccessDateTime() const {
      return _lastAccessDateTime;
    }

    /**
     * @copydoc FileInformation::getLength
     */

    uint32_t FatFileInformation::getLength() const {
      return _length;
    }

  }
}
// END FILE: ../lib/src/filesystem/fat/FatFileInformation.cpp
// START FILE: ../lib/src/filesystem/fat/Fat32FileSystemFormatter.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {


    /**
     * @brief Initialise the class and do the format.
     *
     * Check the error provider status to find out whether the format worked. The format operation prepares the FAT data structures. It does not
     * do a low-level format of the device.
     *
     * @param[in] blockDevice The device to format.
     * @param[in] firstSectorIndex The zero-based index of the first sector of the partition, or the device as a whole if partitions are not supported.
     * @param[in] numSectors The total number of sectors to format on this device.
     * @param[in] volumeLabel The new name for the volume, max 11 characters.
     */

    Fat32FileSystemFormatter::Fat32FileSystemFormatter(BlockDevice& blockDevice,uint32_t firstSectorIndex,uint32_t numSectors,const char *volumeLabel)
      : FatFileSystemFormatter(blockDevice,firstSectorIndex,numSectors,volumeLabel) {

      uint32_t rootDirFirstSector,firstDataSector;

      // write the reserved sectors

      if(!writeReservedSectors())
        return;

      // the two FAT tables start at sector #6, write them

      if(!writeFats(_firstSectorIndex+_bootSector.BPB_RsvdSecCnt,_bootSector.fat32.BPB_FATSz32))
        return;

      // root dir sector is a little more troublesome than FAT16 since it's at cluster #2

      firstDataSector=_bootSector.BPB_RsvdSecCnt+(_bootSector.BPB_NumFATs*_bootSector.fat32.BPB_FATSz32);
      rootDirFirstSector=firstDataSector+((_bootSector.fat32.BPB_RootClus-2)*_bootSector.BPB_SecPerClus);

      // write the root directory entry

      writeRootDirectoryEntries(_firstSectorIndex+rootDirFirstSector);
    }


    /*
     * Prepare a new bootsector for FAT32
     */

    bool Fat32FileSystemFormatter::createNewBootSector() {

      uint32_t tmpVal1,tmpVal2;

      // call the base class

      if(!FatFileSystemFormatter::createNewBootSector())
        return false;

      // generate sectors per cluster from the MS specification document

      if(_numSectors <= 66600)            // 32.5Mb lower limit
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_FAT32_FILESYSTEM_FORMATTER,E_INVALID_DISK_SIZE);

      if(_numSectors <= 532480)           // 260Mb
        _bootSector.BPB_SecPerClus=1;
      else if(_numSectors <= 16777216)    // 8Gb
        _bootSector.BPB_SecPerClus=8;
      else if(_numSectors <= 33554432)    // 16Gb
        _bootSector.BPB_SecPerClus=16;
      else if(_numSectors <= 67108864)    // 32Gb
        _bootSector.BPB_SecPerClus=32;
      else
        _bootSector.BPB_SecPerClus=64;    // > 32Gb

      _bootSector.BPB_RsvdSecCnt=32;
      _bootSector.BPB_RootEntCnt=0;
      _bootSector.BPB_TotSec16=0;
      _bootSector.BPB_FATSz16=0;
      _bootSector.BPB_TotSec32=_numSectors;

      // this part lifted from the MS specification

      tmpVal1=_numSectors - 32;
      tmpVal2=((256 * _bootSector.BPB_SecPerClus) + 2) / 2;

      _bootSector.fat32.BPB_FATSz32=(tmpVal1 + (tmpVal2 - 1)) / tmpVal2;

      _bootSector.fat32.BPB_ExtFlags=0;
      _bootSector.fat32.BPB_FSVer=0;
      _bootSector.fat32.BPB_RootClus=2;
      _bootSector.fat32.BPB_FSInfo=1;         // fsinfo sector in reserved area
      _bootSector.fat32.BPB_BkBootSec=6;      // backup boot sector in reserved area
      memset(_bootSector.fat32.BPB_Reserved,0,sizeof(_bootSector.fat32.BPB_Reserved));
      _bootSector.fat32.BS_DrvNum=0x80;
      _bootSector.fat32.BS_Reserved1=0;
      _bootSector.fat32.BS_BootSig=0x29;
      _bootSector.fat32.BS_VolID=0xBADF00D;
      memcpy(_bootSector.fat32.BS_VolLab,_volumeLabel,11);
      memcpy(_bootSector.fat32.BS_FilSysType,"FAT32   ",8);

      return true;
    }


    /*
     * Format the reserved sectors
     */

    bool Fat32FileSystemFormatter::writeReservedSectors() {

      ByteMemblock fsinfo(512);

      // boot sector and backup

      if(!writeBootSector(_firstSectorIndex) || !writeBootSector(_firstSectorIndex+6))
        return false;

      // fsinfo structure at reserved #1

      createNewFsInfo(*reinterpret_cast<Fat32FsInfo *>(fsinfo.getData()));
      return _blockDevice.writeBlock(fsinfo,1);
    }


    /*
     * Set up a new FsInfo structure
     */

    void Fat32FileSystemFormatter::createNewFsInfo(Fat32FsInfo& fsinfo) const {

      fsinfo.FSI_LeadSig=0x41615252;
      memset(fsinfo.FSI_Reserved1,0,sizeof(fsinfo.FSI_Reserved1));
      fsinfo.FSI_StrucSig=0x61417272;
      fsinfo.FSI_Free_Count=0xFFFFFFFF;
      fsinfo.FSI_Nxt_Free=0xFFFFFFFF;
      memset(fsinfo.FSI_Reserved2,0,sizeof(fsinfo.FSI_Reserved2));
      fsinfo.FSI_TrailSig=0xAA550000;
    }

    /*
     * initialise the two reserved clusters at the start of the FAT
     */

    void Fat32FileSystemFormatter::initReservedClusters(uint8_t *sector) const {

      uint32_t cluster,*fat;

      fat=reinterpret_cast<uint32_t *>(sector);
      cluster=0x0fffff00 | MEDIA_TYPE;

      fat[0]=cluster;
      fat[1]=0x0FFFFFFF;
      fat[2]=0x0FFFFFFF;        // EOC for the root directory at cluster 2
    }

  }
}
// END FILE: ../lib/src/filesystem/fat/Fat32FileSystemFormatter.cpp
// START FILE: ../lib/src/filesystem/fat/WearResistFreeClusterFinder.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor: generate a random starting index between zero and the number of FAT entries.
     *
     * @param[in] fs_ A reference to the fat file system class. Must stay in scope.
     */

    WearResistFreeClusterFinder::WearResistFreeClusterFinder(FatFileSystem& fs_) :
      IteratingFreeClusterFinder(fs_,rand()%(fs_.getSectorsPerFat()*fs_.getSectorSizeInBytes())/fs_.getFatEntrySizeInBytes()) {
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/WearResistFreeClusterFinder.cpp
// START FILE: ../lib/src/filesystem/fat/NormalDirectoryEntryIterator.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /**
     * Constructor.
     * @param[in] fs_ A reference to the fat file system class. Must stay in scope.
     * @param[in] firstClusterIndex_ The first cluster number of this directory.
     * @param[in] options_ The options to use while iterating.
     */

    NormalDirectoryEntryIterator::NormalDirectoryEntryIterator(FatFileSystem& fs_,uint32_t firstClusterIndex_,Options options_) :
      DirectoryEntryIterator(fs_,options_), _iterator(fs_,firstClusterIndex_,ClusterChainIterator::extensionDontExtend) {

      // force a move to the first sector in next()

      _firstClusterIndex=firstClusterIndex_;
      _indexWithinSector=0x10000;
      _currentDirentIndex=-1;
    }

    /*
     * reset the iterator
     */

    void NormalDirectoryEntryIterator::reset() {
      _iterator.reset(_firstClusterIndex);
      _indexWithinSector=0x10000;
      _currentDirentIndex=-1;
    }

    /*
     * Internal next()
     */

    bool NormalDirectoryEntryIterator::internalNext() {

      ByteMemblock sector(_fs.getSectorSizeInBytes());

      // check if need to move

      if(++_indexWithinSector >= _fs.getBootSector().BPB_BytsPerSec / sizeof(DirectoryEntry)) {
        if(!_iterator.next())
          return false;

        _indexWithinSector=0;
      }

      // copy the current entry out of the sector

      DirectoryEntry& dirent=_currentEntry.Dirent;

      if(!_iterator.readSector(sector))
        return false;

      memcpy(&dirent,sector + (_indexWithinSector * sizeof(DirectoryEntry)),sizeof(DirectoryEntry));
      _currentEntry.SectorNumber=_iterator.current();
      _currentEntry.IndexWithinSector=_indexWithinSector;

      // check for end-of-entries

      if((dirent.sdir.DIR_Attr & DirectoryEntry::ATTR_LONG_NAME_MASK) != DirectoryEntry::ATTR_LONG_NAME && dirent.sdir.DIR_Name[0] == '\0')
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_ITERATOR,E_END_OF_ENTRIES);

      // done

      _currentDirentIndex++;
      return true;
    }

    /*
     * Extend the directory to hold new entries
     */

    bool NormalDirectoryEntryIterator::extendDirectory(DirectoryEntry *dirents_,uint32_t direntCount_) {

      uint32_t sectors,i,entriesPerSector,indexInSector;
      ByteMemblock sector(_fs.getSectorSizeInBytes());
      void *dest;

      // get the number of entries in this directory

      reset();
      while(next())
        ;
      if(!errorProvider.isLastError(ErrorProvider::ERROR_PROVIDER_ITERATOR,Iterator<DirectoryEntryWithLocation>::E_END_OF_ENTRIES))
        return false;

      // get a file sector iterator that extends and move to the sector

      FileSectorIterator it(_fs,_firstClusterIndex,ClusterChainIterator::extensionExtend);

      entriesPerSector=_fs.getSectorSizeInBytes() / sizeof(DirectoryEntry);
      sectors=(_currentDirentIndex + 1) / entriesPerSector;
      indexInSector=(_currentDirentIndex + 1) % entriesPerSector;

      for(i=0;i <= sectors;i++)
        if(!it.next())
          return false;

      // read the current sector

      if(!it.readSector(sector))
        return false;

      // start writing

      for(i=0;i <= direntCount_;i++) {

        dest=sector.getData() + (sizeof(DirectoryEntry) * indexInSector);

        if(i == direntCount_)
          memset(dest,0,sizeof(DirectoryEntry)); // new end marker
        else
          memcpy(dest,&dirents_[i],sizeof(DirectoryEntry));

        if(++indexInSector == entriesPerSector) {

          // write the completed sector

          if(!it.writeSector(sector.getData()))
            return false;

          // advance to the next and read it

          if(!it.next() || !it.readSector(sector))
            return false;

          indexInSector=0;
        }
      }

      // write back if we've got some remaining

      if(indexInSector > 0 && !it.writeSector(sector.getData()))
        return false;

      // done

      return true;
    }
  }
}
// END FILE: ../lib/src/filesystem/fat/NormalDirectoryEntryIterator.cpp
// START FILE: ../lib/src/filesystem/fat/FatDirectoryIterator.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/filesystem.h"


namespace stm32plus {
  namespace fat {

    /*
     * Constructor - open the directory pointed to by dirent
     */

    FatDirectoryIterator::FatDirectoryIterator(FatFileSystem& fs,DirectoryEntryWithLocation& direntWithLocation) :
      _fs(fs) {

      DirectoryEntry& dirent=direntWithLocation.Dirent;

      _entryIterator=new NormalDirectoryEntryIterator(fs,(uint32_t)dirent.sdir.DIR_FstClusLO | ((uint32_t)dirent.sdir.DIR_FstClusHI) << 16,DirectoryEntryIterator::OPT_DEFAULT_REAL_ENTRIES);
    }

    /*
     * Constructor over the root directory
     */

    FatDirectoryIterator::FatDirectoryIterator(FatFileSystem& fs) :
      _fs(fs) {

      _entryIterator=_fs.getRootDirectoryIterator(DirectoryEntryIterator::OPT_DEFAULT_REAL_ENTRIES);
    }

    /**
     * Virtual destructor, clean up internal iterator.
     */

    FatDirectoryIterator::~FatDirectoryIterator() {

      if(_entryIterator != nullptr)
        delete _entryIterator;
    }

    /**
     * Get the directory entry iterator
     * @return The internal directory entry iterator.
     */

    DirectoryEntryIterator& FatDirectoryIterator::getDirectoryEntryIterator() {
      return *_entryIterator;
    }

    /**
     * @copydoc Iterator::current
     */

    const FileInformation& FatDirectoryIterator::current() {
      return *this;
    }

    /**
     * @copydoc FileInformation::getFilename
     */

    const char *FatDirectoryIterator::getFilename() const {
      return _entryIterator->getFilename();
    }

    /**
     * @copydoc FileInformation::getAttributes
     */

    uint32_t FatDirectoryIterator::getAttributes() const {
      return _entryIterator->current().Dirent.sdir.DIR_Attr;
    }

    /**
     *@copydoc FileInformation::getCreationDateTime
     */

    time_t FatDirectoryIterator::getCreationDateTime() const {
      return _entryIterator->getCreationDateTime();
    }

    /**
     * @copydoc FileInformation::getLastWriteDateTime
     */

    time_t FatDirectoryIterator::getLastWriteDateTime() const {
      return _entryIterator->getLastWriteDateTime();
    }

    /**
     * @copydoc FileInformation::getLastAccessDateTime
     */

    time_t FatDirectoryIterator::getLastAccessDateTime() const {
      return _entryIterator->getLastAccessDateTime();
    }

    /**
     * @copydoc DirectoryIterator::isCurrentDirectory
     */

    bool FatDirectoryIterator::isCurrentDirectory() {
      return !strcmp(_entryIterator->getFilename(),"."); // only dirs can have this name
    }

    /**
     * @copydoc DirectoryIterator::isParentDirectory
     */

    bool FatDirectoryIterator::isParentDirectory() {
      return !strcmp(_entryIterator->getFilename(),".."); // only dirs can have this name
    }

    /**
     * @copydoc FileInformation::getLength
     */

    uint32_t FatDirectoryIterator::getLength() const {
      return _entryIterator->current().Dirent.sdir.DIR_FileSize;
    }

    /**
     * @copydoc DirectoryIterator::getSubdirectoryIterator
     */

    bool FatDirectoryIterator::getSubdirectoryIterator(DirectoryIterator*& newIterator) {

      // ensure that this is a directory we are currently looking at

      if((_entryIterator->current().Dirent.sdir.DIR_Attr & DirectoryEntry::ATTR_DIRECTORY) == 0)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_DIRECTORY_ITERATOR,E_NOT_A_DIRECTORY);

      // open it

      newIterator=new FatDirectoryIterator(_fs,_entryIterator->current());
      return true;
    }

    /**
     * @copydoc DirectoryIterator::moveTo
     */

    bool FatDirectoryIterator::moveTo(const char *filename) {

      while(next()) {

        if(!strcasecmp(getFilename(),filename))
          return true;
      }

      // not found

      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_DIRECTORY_ITERATOR,E_ENTRY_NOT_FOUND);
    }

    /**
     * @copydoc DirectoryIterator::openFile
     */

    bool FatDirectoryIterator::openFile(File*& newFile) {

      newFile=new FatFile(_fs,_entryIterator->current());

      return true;
    }

    /**
     * @copydoc Iterator::next
     */

    bool FatDirectoryIterator::next() {

      // move to next

      return _entryIterator->next();
    }

    /**
     * Create an instance of the directory iterator suitable for the given directory.
     *
     * @param[in] fs Reference to the filesystem class.
     * @param[in] tp The tokenised pathname that points to this directory.
     * @param[out] newIterator The directory iterator created by this call if it succeeds. Caller must delete this pointer when finished.
     * @return false if it fails.
     */

    bool FatDirectoryIterator::getInstance(FatFileSystem& fs,const TokenisedPathname& tp,FatDirectoryIterator *& newIterator) {

      int i;
      DirectoryEntryIterator *it,*tempIterator;

      // check for root directory

      if(tp.getNumTokens()==0) {

        // create a new iterator over the root directory

        newIterator=new FatDirectoryIterator(fs);
        return true;
      }

      // iterate for every component of the name

      it=nullptr;

      for(i=0;i<tp.getNumTokens();i++) {

        if(it==nullptr) {

          // create a new iterator over the root directory

          it=fs.getRootDirectoryIterator(DirectoryEntryIterator::OPT_DEFAULT_REAL_ENTRIES);
        } else {

          // create a new iterator over the subdirectory we just found

          DirectoryEntry& dirent=it->current().Dirent;

          tempIterator=new NormalDirectoryEntryIterator(fs,dirent.sdir.DIR_FstClusLO | (((uint32_t)dirent.sdir.DIR_FstClusHI) << 16),DirectoryEntryIterator::OPT_DEFAULT_REAL_ENTRIES);
          delete it;
          it=tempIterator;
        }

        // get next entry

        do {
          if(!it->next())
            return errorProvider.set(ErrorProvider::ERROR_PROVIDER_DIRECTORY_ITERATOR,E_DIRECTORY_NOT_FOUND);

          // test the filename in the entry against the component

        } while(strcasecmp(it->getFilename(),tp[i]) != 0);
      }

      // the final entry must be a directory

      if(!it->current().isDirectory())
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_DIRECTORY_ITERATOR,E_NOT_A_DIRECTORY);

      newIterator=new FatDirectoryIterator(fs,it->current());

      delete it;
      return true;
    }

    /**
     * Get the DirectoryEntryWithLocation structure for this entry.
     * @return The directory entry structure.
     */

    DirectoryEntryWithLocation& FatDirectoryIterator::getDirectoryEntryWithLocation() {
      return _entryIterator->current();
    }

  }
}
// END FILE: ../lib/src/filesystem/fat/FatDirectoryIterator.cpp
// START FILE: ../lib/src/timing/MillisecondTimer.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "timing/MillisecondTimer.h"



namespace stm32plus {


  volatile uint32_t MillisecondTimer::_counter;


  /**
   * Initialise SysTick to tick at 1ms by initialising it with SystemCoreClock/1000.
   */

  void MillisecondTimer::initialise() {
    _counter=0;
    SysTick_Config(SystemCoreClock / 1000);
  }


  /**
   * Delay for given time. Waits for the current value of the systick counter to reach a target.
   * @param millis The amount of time to wait.
   */

  void MillisecondTimer::delay(uint32_t millis) {

    uint32_t target;

    target=_counter+millis;
    while(_counter<target);
  }
}


/**
 * SysTick interrupt handler
 */

extern "C" {
  void __attribute__ ((weak,interrupt("IRQ"))) SysTick_Handler(void) {
    stm32plus::MillisecondTimer::_counter++;
  }
}
// END FILE: ../lib/src/timing/MillisecondTimer.cpp
// START FILE: ../lib/src/debug/SemiHosting.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"
#include "config/debug.h"


namespace stm32plus {
  SemiHosting shost;
}
// END FILE: ../lib/src/debug/SemiHosting.cpp
// START FILE: ../lib/src/nvic/Nvic.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/nvic.h"


namespace stm32plus {

  /**
   * The singleton that can be referenced from anywhere in the app
   */

  Nvic nvicController;
}
// END FILE: ../lib/src/nvic/Nvic.cpp
// START FILE: ../lib/src/i2c/interrupts/f4/I2C3InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/i2c.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> I2CInterruptFeatureEnabler<3>::FPTR I2CInterruptFeatureEnabler<3>::_forceLinkage=nullptr;
template<> I2CEventSource *I2CInterruptFeature<3> ::_i2cInstance=nullptr;


extern "C" {

  #if defined(USE_I2C3_INTERRUPT)

    void __attribute__ ((interrupt("IRQ"))) I2C3_EV_IRQHandler(void) {

      if(I2C_GetITStatus(I2C3,I2C_IT_TXE)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_READY_TO_TRANSMIT);
        I2C_ClearITPendingBit(I2C3,I2C_IT_TXE);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_RXNE)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_RECEIVE);
        I2C_ClearITPendingBit(I2C3,I2C_IT_RXNE);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_STOPF)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_STOP_BIT_RECEIVED);
        I2C_ClearITPendingBit(I2C3,I2C_IT_STOPF);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_ADD10)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_10_BIT_HEADER_SENT);
        I2C_ClearITPendingBit(I2C3,I2C_IT_ADD10);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_BTF)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_BYTE_TRANSFER_SENT);
        I2C_ClearITPendingBit(I2C3,I2C_IT_BTF);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_ADDR)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_ADDRESS_SENT);
        I2C_ClearITPendingBit(I2C3,I2C_IT_ADDR);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_SB)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_START_BIT_SENT);
        I2C_ClearITPendingBit(I2C3,I2C_IT_SB);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

    void __attribute__ ((interrupt("IRQ"))) I2C3_ER_IRQHandler(void) {

      if(I2C_GetITStatus(I2C3,I2C_IT_SMBALERT)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_SMB_ALERT);
        I2C_ClearITPendingBit(I2C3,I2C_IT_SMBALERT);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_TIMEOUT)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_TIMEOUT);
        I2C_ClearITPendingBit(I2C3,I2C_IT_TIMEOUT);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_PECERR)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_PEC_ERROR);
        I2C_ClearITPendingBit(I2C3,I2C_IT_PECERR);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_OVR)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_OVERRUN);
        I2C_ClearITPendingBit(I2C3,I2C_IT_OVR);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_AF)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_ACK_FAILURE);
        I2C_ClearITPendingBit(I2C3,I2C_IT_AF);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_ARLO)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_ARBITRATION_LOSS);
        I2C_ClearITPendingBit(I2C3,I2C_IT_ARLO);
      }
      else if(I2C_GetITStatus(I2C3,I2C_IT_BERR)!=RESET) {
        I2CInterruptFeature<3>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_BUS_ERROR);
        I2C_ClearITPendingBit(I2C3,I2C_IT_BERR);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

  #endif
}

#endif // STM32PLUS_F4

// END FILE: ../lib/src/i2c/interrupts/f4/I2C3InterruptHandler.cpp
// START FILE: ../lib/src/i2c/interrupts/I2C1InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if !defined(STM32PLUS_F0)

#include "config/i2c.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> I2CInterruptFeatureEnabler<1>::FPTR I2CInterruptFeatureEnabler<1>::_forceLinkage=nullptr;
template<> I2CEventSource *I2CInterruptFeature<1> ::_i2cInstance=nullptr;


extern "C" {

  #if defined(USE_I2C1_INTERRUPT)

    void __attribute__ ((interrupt("IRQ"))) I2C1_EV_IRQHandler(void) {

      if(I2C_GetITStatus(I2C1,I2C_IT_TXE)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_READY_TO_TRANSMIT);
        I2C_ClearITPendingBit(I2C1,I2C_IT_TXE);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_RXNE)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_RECEIVE);
        I2C_ClearITPendingBit(I2C1,I2C_IT_RXNE);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_STOPF)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_STOP_BIT_RECEIVED);
        I2C_ClearITPendingBit(I2C1,I2C_IT_STOPF);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_ADD10)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_10_BIT_HEADER_SENT);
        I2C_ClearITPendingBit(I2C1,I2C_IT_ADD10);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_BTF)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_BYTE_TRANSFER_SENT);
        I2C_ClearITPendingBit(I2C1,I2C_IT_BTF);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_ADDR)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_ADDRESS_SENT);
        I2C_ClearITPendingBit(I2C1,I2C_IT_ADDR);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_SB)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_START_BIT_SENT);
        I2C_ClearITPendingBit(I2C1,I2C_IT_SB);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

    void __attribute__ ((interrupt("IRQ"))) I2C1_ER_IRQHandler(void) {

      if(I2C_GetITStatus(I2C1,I2C_IT_SMBALERT)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_SMB_ALERT);
        I2C_ClearITPendingBit(I2C1,I2C_IT_SMBALERT);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_TIMEOUT)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_TIMEOUT);
        I2C_ClearITPendingBit(I2C1,I2C_IT_TIMEOUT);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_PECERR)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_PEC_ERROR);
        I2C_ClearITPendingBit(I2C1,I2C_IT_PECERR);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_OVR)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_OVERRUN);
        I2C_ClearITPendingBit(I2C1,I2C_IT_OVR);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_AF)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_ACK_FAILURE);
        I2C_ClearITPendingBit(I2C1,I2C_IT_AF);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_ARLO)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_ARBITRATION_LOSS);
        I2C_ClearITPendingBit(I2C1,I2C_IT_ARLO);
      }
      else if(I2C_GetITStatus(I2C1,I2C_IT_BERR)!=RESET) {
        I2CInterruptFeature<1>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_BUS_ERROR);
        I2C_ClearITPendingBit(I2C1,I2C_IT_BERR);
      }
      __DSB();      // prevent erroneous recall of this handler due to delayed memory write
    }

  #endif
}

#endif
// END FILE: ../lib/src/i2c/interrupts/I2C1InterruptHandler.cpp
// START FILE: ../lib/src/i2c/interrupts/I2C2InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if !defined(STM32PLUS_F0)

#include "config/i2c.h"


using namespace stm32plus;


// static initialisers for the hack that forces the IRQ handlers to be linked

template<> I2CInterruptFeatureEnabler<2>::FPTR I2CInterruptFeatureEnabler<2>::_forceLinkage=nullptr;
template<> I2CEventSource *I2CInterruptFeature<2> ::_i2cInstance=nullptr;


extern "C" {

  #if defined(USE_I2C2_INTERRUPT)

    void __attribute__ ((interrupt("IRQ"))) I2C2_EV_IRQHandler(void) {

      if(I2C_GetITStatus(I2C2,I2C_IT_TXE)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_READY_TO_TRANSMIT);
        I2C_ClearITPendingBit(I2C2,I2C_IT_TXE);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_RXNE)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_RECEIVE);
        I2C_ClearITPendingBit(I2C2,I2C_IT_RXNE);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_STOPF)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_STOP_BIT_RECEIVED);
        I2C_ClearITPendingBit(I2C2,I2C_IT_STOPF);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_ADD10)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_10_BIT_HEADER_SENT);
        I2C_ClearITPendingBit(I2C2,I2C_IT_ADD10);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_BTF)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_BYTE_TRANSFER_SENT);
        I2C_ClearITPendingBit(I2C2,I2C_IT_BTF);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_ADDR)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_ADDRESS_SENT);
        I2C_ClearITPendingBit(I2C2,I2C_IT_ADDR);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_SB)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_START_BIT_SENT);
        I2C_ClearITPendingBit(I2C2,I2C_IT_SB);
      }
    }

    void __attribute__ ((interrupt("IRQ"))) I2C2_ER_IRQHandler(void) {

      if(I2C_GetITStatus(I2C2,I2C_IT_SMBALERT)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_SMB_ALERT);
        I2C_ClearITPendingBit(I2C2,I2C_IT_SMBALERT);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_TIMEOUT)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_TIMEOUT);
        I2C_ClearITPendingBit(I2C2,I2C_IT_TIMEOUT);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_PECERR)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_PEC_ERROR);
        I2C_ClearITPendingBit(I2C2,I2C_IT_PECERR);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_OVR)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_OVERRUN);
        I2C_ClearITPendingBit(I2C2,I2C_IT_OVR);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_AF)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_ACK_FAILURE);
        I2C_ClearITPendingBit(I2C2,I2C_IT_AF);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_ARLO)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_ARBITRATION_LOSS);
        I2C_ClearITPendingBit(I2C2,I2C_IT_ARLO);
      }
      else if(I2C_GetITStatus(I2C2,I2C_IT_BERR)!=RESET) {
        I2CInterruptFeature<2>::_i2cInstance->I2CInterruptEventSender.raiseEvent(I2CEventType::EVENT_BUS_ERROR);
        I2C_ClearITPendingBit(I2C2,I2C_IT_BERR);
      }
    }

  #endif
}


#endif
// END FILE: ../lib/src/i2c/interrupts/I2C2InterruptHandler.cpp
// START FILE: ../lib/src/i2c/features/I2CSingleByteMasterPollingFeature.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"
#include "config/i2c.h"


namespace stm32plus {


  /**
   * Reset one or more bits
   * @param address The register address
   * @param mask The bitmask to clear
   * @return true if it worked
   */

  bool I2CSingleByteMasterPollingFeature::resetBits(uint8_t address,uint8_t mask) const {

    uint8_t value;

    // read current register value

    if(!readByte(address,value))
      return false;

    // clear the bits

    value&=~mask;

    // write back to the register

    return writeByte(address,value);
  }


  /**
   * Set one or more bits
   * @param address The register address
   * @param mask The bitmask to set
   * @return true if it worked
   */

  bool I2CSingleByteMasterPollingFeature::setBits(uint8_t address,uint8_t mask) const {

    uint8_t value;

    // read current register value

    if(!readByte(address,value))
      return false;

    // set the bits

    value|=mask;

    // write back to the register

    return writeByte(address,value);
  }


  /**
   * Set a value by merging into the current value. The bits defined by the mask are the
   * ones that get set by this call. The bits that are zero in the mask are preserved.
   * @param address The register address
   * @param value The value to mask in
   * @param mask The mask that defines the values to set
   * @return true if it worked
   */

  bool I2CSingleByteMasterPollingFeature::setMask(uint8_t address,uint8_t newbits,uint8_t mask) const {

    uint8_t value;

    // read current register value

    if(!readByte(address,value))
      return false;

    // set the bits

    value&=~mask;
    value|=newbits;

    // write back to the register

    return writeByte(address,value);
  }
}
// END FILE: ../lib/src/i2c/features/I2CSingleByteMasterPollingFeature.cpp
// START FILE: ../lib/src/i2c/features/f1,f4/I2CMasterPollingFeature.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"

#if defined(STM32PLUS_F1) || defined(STM32PLUS_F4)

#include "config/i2c.h"


namespace stm32plus {


  /**
   * Read some bytes from the slave.
   * @param address The first byte of the address
   * @param count How many bytes to read
   * @param output Where to put the bytes
   * @return false if there's an error, true otherwise
   */

  bool I2CMasterPollingFeature::readBytes(const uint8_t *address,uint8_t *output,uint32_t count) const {

    // do the protocol up to the actual data read

    if(!prepareRead(address))
      return false;

    // loop reading the bytes from the slave

    while(count--) {

      // an ACK is required in between each byte except the last.
      // the last byte gets a NACK after it and before the STOP

      if(!count) {

        __disable_irq();
        I2C_AcknowledgeConfig(_i2c,DISABLE);
        I2C_GenerateSTOP(_i2c,ENABLE);
        __enable_irq();
      }

      if(!checkEvent(I2C_EVENT_MASTER_BYTE_RECEIVED))
        return false;

      // read the data byte

      *output++=I2C_ReceiveData(_i2c);
    }

    return true;
  }


  /**
   * Prepare for a read from the slave. This will do the I2C protocol up to the point of sending the
   * address bytes to read from. After the successful completion of this function you are expected to complete
   * the read either by polling or by DMA using the I2CDmaReaderFeature class.
   * @param address The I2C address
   * @return true if it worked
   */

  bool I2CMasterPollingFeature::prepareRead(const uint8_t *address) const {

    uint8_t count;

    // enable ACKs for the reads

    I2C_AcknowledgeConfig(_i2c,ENABLE);

    // generate the start condition

    I2C_GenerateSTART(_i2c,ENABLE);

    // Test on I2C EV5 and clear it

    if(!checkEvent(I2C_EVENT_MASTER_MODE_SELECT))
      return false;

    // send the slave address

    I2C_Send7bitAddress(_i2c,_slaveAddress,I2C_Direction_Transmitter);

    // Test on I2C EV6 and clear it

    if(!checkEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
      return false;

    // send the address

    for(count=_i2c.getAddressSize();count;count--) {

      I2C_SendData(_i2c,*address++);

      // Test on I2C EV8 and clear it

      if(!checkEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
        return false;
    }

    // clear AF flag if arised */

    ((I2C_TypeDef *)_i2c)->SR1=0x0400;

    // generate the start condition again

    I2C_GenerateSTART(_i2c,ENABLE);

    // Test on I2C EV6 and clear it

    if(!checkEvent(I2C_EVENT_MASTER_MODE_SELECT))
      return false;

    // send the slave address

    I2C_Send7bitAddress(_i2c,_slaveAddress,I2C_Direction_Receiver);

    // Test on I2C EV6 and clear it

    return checkEvent(I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED);
  }


  /**
   * Write some bytes to the slave
   * @param address The register address
   * @param count The number of bytes to write
   * @param input The source of data to write
   * @return false if it fails, true if it succeeds
   */

  bool I2CMasterPollingFeature::writeBytes(const uint8_t *address,const uint8_t *input,uint32_t count) const {

    // do the protocol up to and including the address transfer

    if(!prepareWrite(address))
      return false;

    // now start transferring the data

    while(count--) {

      // send data

      I2C_SendData(_i2c,*input++);

      // test on I2C EV8 and clear it

      if(!checkEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
        return false;
    }

    // send STOP condition

    I2C_GenerateSTOP(_i2c,ENABLE);
    return true;
  }


  /**
   * Prepare for a write to the peripheral. The I2C protocol is followed up to the point of
   * sending the address but not the data. After the successful return of this function you are
   * expected to initiate the data transfer either by polling write or by DMA write using
   * the I2CDmaWriterFeature class.
   * @param address The I2C address to prepare writing to
   * @return true if it worked
   */

  bool I2CMasterPollingFeature::prepareWrite(const uint8_t *address) const {

    uint8_t count;

    // generate the start condition

    I2C_GenerateSTART(_i2c,ENABLE);

    // Test on I2C EV5 and clear it

    if(!checkEvent(I2C_EVENT_MASTER_MODE_SELECT))
      return false;

    // send the slave address

    I2C_Send7bitAddress(_i2c,_slaveAddress,I2C_Direction_Transmitter);

    // Test on I2C EV6 and clear it */

    if(!checkEvent(I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
      return false;

    for(count=_i2c.getAddressSize();count;count--) {

      // send the address byte

      I2C_SendData(_i2c,*address++);

      // Test on I2C EV8 and clear it

      if(!checkEvent(I2C_EVENT_MASTER_BYTE_TRANSMITTED))
        return false;
    }

    return true;
  }


  /**
   * Check that an event has occurred, or timeout
   * @param eventId The event to check
   * @return false if it fails
   */

  bool I2CMasterPollingFeature::checkEvent(uint32_t eventId) const {

    uint32_t timeoutStart;

    // get the time now

    timeoutStart=MillisecondTimer::millis();

    // wait for the event to be raised or timeout his hit (should take care of timeout wrap here)

    while(!I2C_CheckEvent(_i2c,eventId)) {
      if(MillisecondTimer::millis()-timeoutStart>_timeout)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_I2C,I2C::E_I2C_TIMEOUT);
    }

    return true;
  }
}


#endif
// END FILE: ../lib/src/i2c/features/f1,f4/I2CMasterPollingFeature.cpp
// START FILE: ../lib/src/concurrent/Mutex.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "concurrent/Mutex.h"
#include "timing/MillisecondTimer.h"


#if !defined(STM32PLUS_F0)

namespace stm32plus {


  /**
   * Constructor, set flag to unclaimed
   */

  Mutex::Mutex() {
    _flag=0;
  }


  /**
   * Try to claim the mutex, give up after the specified number of millis
   * @param millisToWait max time to wait, set to zero to never block
   * @return true if was claimed
   */

  bool Mutex::claim(uint32_t millisToWait) {

    uint8_t oldval,newval;
    uint32_t now;

    if(millisToWait)
      now=MillisecondTimer::millis();

    do {

      // get the current mutex value

      if((oldval=__LDREXB(&_flag))==0) {

        // try to claim it and return if OK

        if((newval=__STREXB(1,&_flag))==0) {
          __DMB();
          return true;
        }
      }

      // abort if not allowed to wait

      if(!millisToWait)
        return false;

    } while(!MillisecondTimer::hasTimedOut(now,millisToWait));

    return false;
  }


  /**
   * Release a locked mutex
   */

  void Mutex::release() {
    _flag=0;
  }
}

#endif
// END FILE: ../lib/src/concurrent/Mutex.cpp
// START FILE: ../lib/src/concurrent/IrqSuspend.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/concurrent.h"


namespace stm32plus {

  uint32_t IrqSuspend::_counter=0;
}
// END FILE: ../lib/src/concurrent/IrqSuspend.cpp
// START FILE: ../lib/src/fsmc/FsmcSram.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"

#if defined(STM32PLUS_F1_HD) || defined(STM32F40_41xxx)

#include "config/fsmc.h"


namespace stm32plus {

  /// FSMC address lines on port G
  constexpr extern const uint16_t Sram_pgmap[16]= {
    GPIO_Pin_0,
    GPIO_Pin_0 | GPIO_Pin_1,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_13,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_13 | GPIO_Pin_14
  };

  /// FSMC address lines on port F
  constexpr extern const uint16_t Sram_pfmap[10]= {
    GPIO_Pin_0,
    GPIO_Pin_0 | GPIO_Pin_1,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_12,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_12 | GPIO_Pin_13,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14,
    GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15
  };

  /// FSMC address lines on port E
  constexpr extern const uint16_t Sram_pemap[7]= {
    GPIO_Pin_3,
    GPIO_Pin_3 | GPIO_Pin_4,
    GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,
    GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6,
    GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_2,
    GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_2,
    GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_2
  };

  /// FSMC address lines on port D
  constexpr extern const uint16_t Sram_pdmap[3]={
    GPIO_Pin_11,
    GPIO_Pin_11 | GPIO_Pin_12,
    GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13
  };
}

#endif
// END FILE: ../lib/src/fsmc/FsmcSram.cpp
// START FILE: ../lib/src/button/PushButton.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/button.h"


namespace stm32plus {

  /**
   * Constructor
   *
   * @param[in] pin The pin to use. If the pressed state is HIGH then this should be input pull down, otherwise input pull up
   * @param[in] pressedState true if the pressed state is HIGH, false if it is LOW
   */

  PushButton::PushButton(const GpioPinRef& pin,bool pressedState)
    : _pin(pin) {

    // setup GPIO for the pin

    _pressedState=pressedState;
    _internalState=Idle;
  }


  /**
   * Get the current state
   * @return The current state
   */

  PushButton::ButtonState PushButton::getState() {
    uint32_t newTime;
    uint8_t state;

    // read the pin and flip it if this switch reads high when open

    state=_pin.read();

    if(_pressedState)
      state^=true;

    // if state is low then wherever we were then
    // we are now back at not pressed

    if(!state) {
      _internalState=Idle;
      return NotPressed;
    }

    // sample the counter

    newTime=MillisecondTimer::millis();

    // act on the internal state machine

    switch(_internalState) {
      case Idle:
        _internalState=DebounceDelay;
        _lastTime=newTime;
        break;

      case DebounceDelay:
        if(newTime - _lastTime >= DEBOUNCE_DELAY_MILLIS) {
          // been high for at least the debounce time

          return Pressed;
        }
        break;
    }

    // nothing happened at this time

    return NotPressed;
  }
}
// END FILE: ../lib/src/button/PushButton.cpp
// START FILE: ../lib/src/button/AutoRepeatPushButton.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/button.h"


namespace stm32plus {

  /**
   * Constructor
   * @param[in] pin The pin that the button is wired to.
   * @param[in] pressedState true if the pressed state is HIGH, false if it is low.
   * @param[in] initialDelayMillis The delay before repeating starts.
   * @param[in] repeatDelayMillis The delay between repeats.
   */

  AutoRepeatPushButton::AutoRepeatPushButton(const GpioPinRef& pin,bool pressedState,uint32_t initialDelayMillis,uint32_t repeatDelayMillis)
  : PushButton(pin,pressedState) {

    // setup the encapsulated class and remember params

    _initialDelayMillis=initialDelayMillis;
    _repeatDelayMillis=repeatDelayMillis;
  }


  /**
   * Get the current state of the button.
   * @return The current state.
   */

  PushButton::ButtonState AutoRepeatPushButton::getState() {

    uint32_t now;

    // if button is not pressed then our state machine is reset

    if(PushButton::getState()==NotPressed) {
      _internalState=Idle;
      return NotPressed;
    }

    now=MillisecondTimer::millis();

    switch(_internalState) {

      // first press, record that we are now waiting for the
      // initial repeat and save the time we started.

      case Idle:
        _internalState=WaitingForInitial;
        _lastEventTime=now;
        return Pressed;

        // lead up to the initial repeat. When the time is reached
        // advance the state into the multi-repeat stage

      case WaitingForInitial:
        if(now-_lastEventTime>=_initialDelayMillis)
        {
          _internalState=WaitingForRepeat;
          _lastEventTime=now;
          return Pressed;
        }
        else
          return NotPressed;

        // we're in the repeat loop. Return 'Pressed' each time
        // the time interval is passed

      case WaitingForRepeat:
        if(now-_lastEventTime>=_repeatDelayMillis)
        {
          _lastEventTime=now;
          return Pressed;
        }
        else
          return NotPressed;
    }

    // should never get here

    return NotPressed;
  }
}
// END FILE: ../lib/src/button/AutoRepeatPushButton.cpp
// START FILE: ../lib/src/sdcard/SdioDmaSdCard.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F1_HD) || defined(STM32PLUS_F4)

#include "config/sdcard.h"


namespace stm32plus {

  /**
   * Constructor
   */

  SdioDmaSdCard::SdioDmaSdCard(bool autoInitialise) {

    // subscribe to the SDIO and DMA events

    SdioEventSource::SdioInterruptEventSender.insertSubscriber(SdioInterruptEventSourceSlot::bind(this,&SdioDmaSdCard::onSdioEvent));
    DmaEventSource::DmaInterruptEventSender.insertSubscriber(DmaInterruptEventSourceSlot::bind(this,&SdioDmaSdCard::onDmaEvent));

    // initialise if we're supposed to do that

    if(autoInitialise) {

      // user must check error provider after the constructor finishes

      errorProvider.clear();
      powerOn() && initialiseCard();
    }
  }


  /*
   * Get block size in bytes. This is hardcoded to 512.
   */

  uint32_t SdioDmaSdCard::getBlockSizeInBytes() {
    return BLOCK_SIZE;
  }


  /**
   * Get the total number of blocks on this card.
   * @return The total number of blocks
   */

  uint32_t SdioDmaSdCard::getTotalBlocksOnDevice() {
    return getCardCapacityInBytes()/getBlockSizeInBytes();
  }


  /**
   * Get the card capacity in bytes
   * @return The total capacity as a 64-bit total
   */

  uint64_t SdioDmaSdCard::getCardCapacityInBytes() const {
    return _cardInfo.CardCapacity;
  }


  /**
   * Get the device format type
   * @return An enumeration that tells you whether this device has a Master Boot Record (MBR) or not.
   */

  BlockDevice::formatType SdioDmaSdCard::getFormatType() {

    switch(_cardInfo.SD_csd.FileFormat) {

      case 0:
        return formatMbr;

      case 1:
        return formatNoMbr;

      default:
        return formatUnknown;
    }
  }


  /**
   * Read a single block
   * @param dest Where to store the block data
   * @param blockIndex The block index to read
   * @return true if it worked
   */

  bool SdioDmaSdCard::readBlock(void *dest,uint32_t blockIndex) {

    _dmaFinished=_sdioFinished=false;

    // enable the relevant interrupts

    SdioInterruptFeature::enableInterrupts(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR);
    SdioDmaChannelInterruptFeature::enableInterrupts(SdioDmaChannelInterruptFeature::COMPLETE | SdioDmaChannelInterruptFeature::TRANSFER_ERROR);

    // issue the command

    if(!readBlockCommand(blockIndex,BLOCK_SIZE))
      return false;

    // use DMA to transfer the data

    beginRead(dest,BLOCK_SIZE);

    // wait for completion or error

    if(!waitForTransfer())
      return false;

    // wait for the peripheral to go quiet

    SdCardSdioFeature::waitForReceiveComplete();
    return true;
  }


  /**
   * Read multiple blocks. As of today I have an issue in that the low level multiblock commands are not
   * signalling completion. Until I fix that, multiblock commands are emulated with single block commands
   * @param dest Where to read the data
   * @param blockIndex The block index to start reading from
   * @param numBlocks The total number of 512 byte blocks to read
   * @return false if it fails
   */

  bool SdioDmaSdCard::readBlocks(void *dest,uint32_t blockIndex,uint32_t numBlocks) {

    _dmaFinished=_sdioFinished=false;

    // enable the relevant interrupts

    SdioInterruptFeature::enableInterrupts(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR);
    SdioDmaChannelInterruptFeature::enableInterrupts(SdioDmaChannelInterruptFeature::COMPLETE | SdioDmaChannelInterruptFeature::TRANSFER_ERROR);

    // issue the command

    if(!readBlocksCommand(blockIndex,BLOCK_SIZE,numBlocks))
      return false;

    // use DMA to transfer the data

    beginRead(dest,numBlocks*BLOCK_SIZE);

    // wait for completion or error and send the stop transfer command

    if(!waitForTransfer() || !stopTransfer())
      return false;

    // wait for the peripheral to go quiet

    SdCardSdioFeature::waitForReceiveComplete();
    return true;
  }


  /**
   * Write a single block
   * @param src Memory address of the data to write
   * @param blockIndex The block index to write
   * @return false if it fails
   */

  bool SdioDmaSdCard::writeBlock(const void *src,uint32_t blockIndex) {

    _dmaFinished=_sdioFinished=false;

    // enable the relevant interrupts

    SdioInterruptFeature::enableInterrupts(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR);
    SdioDmaChannelInterruptFeature::enableInterrupts(SdioDmaChannelInterruptFeature::COMPLETE | SdioDmaChannelInterruptFeature::TRANSFER_ERROR);

    // issue the command

    if(!writeBlockCommand(blockIndex,BLOCK_SIZE))
      return false;

    // use DMA to transfer the data

    beginWrite(src,BLOCK_SIZE);

    // wait for completion or error

    if(!waitForTransfer())
      return false;

    // wait for the peripheral to go quiet

    SdCardSdioFeature::waitForTransmitComplete();
    return true;
  }


  /**
   * Write many blocks. As of today I have an issue in that the low level multiblock commands are not
   * signalling completion. Until I fix that, multiblock commands are emulated with single block commands
   * @param src Source of the data to write
   * @param blockIndex The first block start writing at
   * @param numBlocks The number of blocks to write
   * @return false if it fails
   */

  bool SdioDmaSdCard::writeBlocks(const void *src,uint32_t blockIndex,uint32_t numBlocks) {

    _dmaFinished=_sdioFinished=false;

    // enable the relevant interrupts

    SdioInterruptFeature::enableInterrupts(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR);
    SdioDmaChannelInterruptFeature::enableInterrupts(SdioDmaChannelInterruptFeature::COMPLETE | SdioDmaChannelInterruptFeature::TRANSFER_ERROR);

    // issue the command

    if(!writeBlocksCommand(blockIndex,BLOCK_SIZE,numBlocks))
      return false;

    // use DMA to transfer the data

    beginWrite(src,numBlocks*BLOCK_SIZE);

    // wait for completion or error and issue the stop transfer command

    if(!waitForTransfer() || !stopTransfer())
      return false;

    // wait for the peripheral to go quiet

    SdCardSdioFeature::waitForTransmitComplete();
    return true;
  }


  /**
   * Wait for transfer complete, or error
   * @return
   */

  bool SdioDmaSdCard::waitForTransfer() const {

    // first wait for the SDIO interrupt

    while(!_sdioFinished);
    while(!_dmaFinished);

    // clear static flags

    SDIO_ClearFlag(SDIO_STATIC_FLAGS);

    // check for error

    return _sdioErrorCode==ErrorProvider::ERROR_NO_ERROR && _dmaErrorCode==ErrorProvider::ERROR_NO_ERROR;
  }


  /**
   * SDIO interrupt handler
   * @param set The type of event
   */

  void SdioDmaSdCard::onSdioEvent(SdioEventType set) {

    bool disableSdioInterrupts=false,disableDmaInterrupts=false;

    switch(set) {

      case SdioEventType::EVENT_DATA_END:
        _sdioErrorCode=ErrorProvider::ERROR_NO_ERROR;
        disableSdioInterrupts=true;
        break;

      case SdioEventType::EVENT_CRC_FAIL:
        _sdioErrorCode=E_CRC_FAIL;
        disableSdioInterrupts=disableDmaInterrupts=true;
        break;

      case SdioEventType::EVENT_TIMEOUT:
        _sdioErrorCode=E_TIMEOUT;
        disableSdioInterrupts=disableDmaInterrupts=true;
        break;

      case SdioEventType::EVENT_RX_OVERRUN:
        _sdioErrorCode=E_RXOVERRUN;
        disableSdioInterrupts=disableDmaInterrupts=true;
        break;

      case SdioEventType::EVENT_TX_OVERRUN:
        _sdioErrorCode=E_TXOVERRUN;
        disableSdioInterrupts=disableDmaInterrupts=true;
        break;

      case SdioEventType::EVENT_START_BIT_ERROR:
        _sdioErrorCode=E_STARTBITERROR;
        disableSdioInterrupts=disableDmaInterrupts=true;
        break;

      default:
        _sdioErrorCode=E_SDIO_ERROR;
        disableSdioInterrupts=disableDmaInterrupts=true;
        break;
    }

    // disable the relevant interrupts

    if(disableSdioInterrupts) {
      SdioInterruptFeature::disableInterrupts(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR);
      _sdioFinished=true;
    }

    if(disableDmaInterrupts) {
      SdioDmaChannelInterruptFeature::disableInterrupts(DMA_IT_TC | DMA_IT_TE);
      _dmaFinished=true;
    }
  }


  /**
   * SDIO DMA interrupt events
   */

  void SdioDmaSdCard::onDmaEvent(DmaEventType det) {

    bool disableSdioInterrupts=false,disableDmaInterrupts=false;

    switch(det) {

      case DmaEventType::EVENT_COMPLETE:
        _dmaErrorCode=ErrorProvider::ERROR_NO_ERROR;
        disableDmaInterrupts=true;
        break;

      case DmaEventType::EVENT_TRANSFER_ERROR:
        _dmaErrorCode=E_DMA_TRANSFER_ERROR;
        disableSdioInterrupts=disableDmaInterrupts=true;
        break;

      default:
        _sdioErrorCode=E_SDIO_ERROR;
        disableSdioInterrupts=disableDmaInterrupts=true;
        break;
    }

    // disable the relevant interrupts

    if(disableSdioInterrupts) {
      SdioInterruptFeature::disableInterrupts(SDIO_IT_DCRCFAIL | SDIO_IT_DTIMEOUT | SDIO_IT_DATAEND | SDIO_IT_RXOVERR | SDIO_IT_STBITERR);
      _sdioFinished=true;
    }

    if(disableDmaInterrupts) {
      SdioDmaChannelInterruptFeature::disableInterrupts(DMA_IT_TC | DMA_IT_TE);
      _dmaFinished=true;
    }
  }
}

#endif
// END FILE: ../lib/src/sdcard/SdioDmaSdCard.cpp
// START FILE: ../lib/src/sdcard/features/SdioInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F1_HD) || defined(STM32PLUS_F4)

#include "config/sdcard.h"


using namespace stm32plus;


// initialise the static member

SdioEventSource *SdioInterruptFeature::_sdioInstance=nullptr;

// static initialisers for the hack that forces the IRQ handlers to be linked

SdioInterruptFeature::FPTR SdioInterruptFeature::_forceLinkage=nullptr;


#if defined(USE_SDIO_INTERRUPT)

extern "C" {

    void __attribute__ ((interrupt("IRQ"))) SDIO_IRQHandler(void) {

    if(SDIO_GetITStatus(SDIO_IT_DATAEND) != RESET) {

      SdioInterruptFeature::_sdioInstance->SdioInterruptEventSender.raiseEvent(SdioEventType::EVENT_DATA_END);
      SDIO_ClearITPendingBit(SDIO_IT_DATAEND);

    } else if(SDIO_GetITStatus(SDIO_IT_DCRCFAIL) != RESET) {

      SdioInterruptFeature::_sdioInstance->SdioInterruptEventSender.raiseEvent(SdioEventType::EVENT_CRC_FAIL);
      SDIO_ClearITPendingBit(SDIO_IT_DCRCFAIL);

    } else if(SDIO_GetITStatus(SDIO_IT_DTIMEOUT) != RESET) {

      SdioInterruptFeature::_sdioInstance->SdioInterruptEventSender.raiseEvent(SdioEventType::EVENT_TIMEOUT);
      SDIO_ClearITPendingBit(SDIO_IT_DTIMEOUT);

    } else if(SDIO_GetITStatus(SDIO_IT_RXOVERR) != RESET) {

      SdioInterruptFeature::_sdioInstance->SdioInterruptEventSender.raiseEvent(SdioEventType::EVENT_RX_OVERRUN);
      SDIO_ClearITPendingBit(SDIO_IT_RXOVERR);

    } else if(SDIO_GetITStatus(SDIO_IT_TXUNDERR) != RESET) {

      SdioInterruptFeature::_sdioInstance->SdioInterruptEventSender.raiseEvent(SdioEventType::EVENT_TX_OVERRUN);
      SDIO_ClearITPendingBit(SDIO_IT_TXUNDERR);

    } else if(SDIO_GetITStatus(SDIO_IT_STBITERR) != RESET) {

      SdioInterruptFeature::_sdioInstance->SdioInterruptEventSender.raiseEvent(SdioEventType::EVENT_START_BIT_ERROR);
      SDIO_ClearITPendingBit(SDIO_IT_STBITERR);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif // extern "C"

#endif
// END FILE: ../lib/src/sdcard/features/SdioInterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/ExtiEthernetWakeupInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line19> *ExtiPeripheral<EXTI_Line19>::_extiInstance=nullptr;


#if defined(USE_EXTI_ETH_WAKEUP_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) ETH_WKUP_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line19)!=RESET) {
        ExtiEthernetWakeup::_extiInstance->ExtiInterruptEventSender.raiseEvent(19);
        EXTI_ClearITPendingBit(EXTI_Line19);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/ExtiEthernetWakeupInterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/Exti4InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line4> *ExtiPeripheral<EXTI_Line4>::_extiInstance=nullptr;


#if defined(USE_EXTI4_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) EXTI4_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line4)!=RESET) {
        Exti4::_extiInstance->ExtiInterruptEventSender.raiseEvent(4);
        EXTI_ClearITPendingBit(EXTI_Line4);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/Exti4InterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/ExtiRtcWakeupInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line22> *ExtiPeripheral<EXTI_Line22>::_extiInstance=nullptr;


#if defined(USE_EXTI_RTC_WAKEUP_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) RTC_WKUP_IRQHandler(void) {

    if(RTC_GetITStatus(RTC_IT_WUT)!=RESET) {
      ExtiRtcWakeup::_extiInstance->ExtiInterruptEventSender.raiseEvent(22);
      EXTI_ClearITPendingBit(EXTI_Line22);
      RTC_ClearITPendingBit(RTC_IT_WUT);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/ExtiRtcWakeupInterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/Exti9_5InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line5> *ExtiPeripheral<EXTI_Line5>::_extiInstance=nullptr;
template<> ExtiPeripheral<EXTI_Line6> *ExtiPeripheral<EXTI_Line6>::_extiInstance=nullptr;
template<> ExtiPeripheral<EXTI_Line7> *ExtiPeripheral<EXTI_Line7>::_extiInstance=nullptr;
template<> ExtiPeripheral<EXTI_Line8> *ExtiPeripheral<EXTI_Line8>::_extiInstance=nullptr;
template<> ExtiPeripheral<EXTI_Line9> *ExtiPeripheral<EXTI_Line9>::_extiInstance=nullptr;


#if defined(USE_EXTI9_5_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) EXTI9_5_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line5)!=RESET) {
      Exti5::_extiInstance->ExtiInterruptEventSender.raiseEvent(5);
      EXTI_ClearITPendingBit(EXTI_Line5);
    }
    else if(EXTI_GetITStatus(EXTI_Line6)!=RESET) {
      Exti6::_extiInstance->ExtiInterruptEventSender.raiseEvent(6);
      EXTI_ClearITPendingBit(EXTI_Line6);
    }
    else if(EXTI_GetITStatus(EXTI_Line7)!=RESET) {
      Exti7::_extiInstance->ExtiInterruptEventSender.raiseEvent(7);
      EXTI_ClearITPendingBit(EXTI_Line7);
    }
    else if(EXTI_GetITStatus(EXTI_Line8)!=RESET) {
      Exti8::_extiInstance->ExtiInterruptEventSender.raiseEvent(8);
      EXTI_ClearITPendingBit(EXTI_Line8);
    }
    else if(EXTI_GetITStatus(EXTI_Line9)!=RESET) {
      Exti9::_extiInstance->ExtiInterruptEventSender.raiseEvent(9);
      EXTI_ClearITPendingBit(EXTI_Line9);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/Exti9_5InterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/Exti15_10InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line10> *ExtiPeripheral<EXTI_Line10>::_extiInstance=nullptr;
template<> ExtiPeripheral<EXTI_Line11> *ExtiPeripheral<EXTI_Line11>::_extiInstance=nullptr;
template<> ExtiPeripheral<EXTI_Line12> *ExtiPeripheral<EXTI_Line12>::_extiInstance=nullptr;
template<> ExtiPeripheral<EXTI_Line13> *ExtiPeripheral<EXTI_Line13>::_extiInstance=nullptr;
template<> ExtiPeripheral<EXTI_Line14> *ExtiPeripheral<EXTI_Line14>::_extiInstance=nullptr;
template<> ExtiPeripheral<EXTI_Line15> *ExtiPeripheral<EXTI_Line15>::_extiInstance=nullptr;


#if defined(USE_EXTI15_10_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) EXTI15_10_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line10)!=RESET) {
      Exti10::_extiInstance->ExtiInterruptEventSender.raiseEvent(10);
      EXTI_ClearITPendingBit(EXTI_Line10);
    }
    else if(EXTI_GetITStatus(EXTI_Line11)!=RESET) {
      Exti11::_extiInstance->ExtiInterruptEventSender.raiseEvent(11);
      EXTI_ClearITPendingBit(EXTI_Line11);
    }
    else if(EXTI_GetITStatus(EXTI_Line12)!=RESET) {
      Exti12::_extiInstance->ExtiInterruptEventSender.raiseEvent(12);
      EXTI_ClearITPendingBit(EXTI_Line12);
    }
    else if(EXTI_GetITStatus(EXTI_Line13)!=RESET) {
      Exti13::_extiInstance->ExtiInterruptEventSender.raiseEvent(13);
      EXTI_ClearITPendingBit(EXTI_Line13);
    }
    else if(EXTI_GetITStatus(EXTI_Line14)!=RESET) {
      Exti14::_extiInstance->ExtiInterruptEventSender.raiseEvent(14);
      EXTI_ClearITPendingBit(EXTI_Line14);
    }
    else if(EXTI_GetITStatus(EXTI_Line15)!=RESET) {
      Exti15::_extiInstance->ExtiInterruptEventSender.raiseEvent(15);
      EXTI_ClearITPendingBit(EXTI_Line15);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/Exti15_10InterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/Exti2InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line2> *ExtiPeripheral<EXTI_Line2>::_extiInstance=nullptr;


#if defined(USE_EXTI2_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) EXTI2_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line2)!=RESET) {
        Exti2::_extiInstance->ExtiInterruptEventSender.raiseEvent(2);
        EXTI_ClearITPendingBit(EXTI_Line2);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/Exti2InterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/ExtiUsbHsWakeupInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line20> *ExtiPeripheral<EXTI_Line20>::_extiInstance=nullptr;


#if defined(USE_EXTI_USB_HS_WAKEUP_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) OTG_HS_WKUP_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line20)!=RESET) {
        ExtiUsbHsWakeup::_extiInstance->ExtiInterruptEventSender.raiseEvent(20);
        EXTI_ClearITPendingBit(EXTI_Line20);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/ExtiUsbHsWakeupInterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/Exti1InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line1> *ExtiPeripheral<EXTI_Line1>::_extiInstance=nullptr;


#if defined(USE_EXTI1_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) EXTI1_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line1)!=RESET) {
        Exti1::_extiInstance->ExtiInterruptEventSender.raiseEvent(1);
        EXTI_ClearITPendingBit(EXTI_Line1);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/Exti1InterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/ExtiUsbFsWakeupInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line18> *ExtiPeripheral<EXTI_Line18>::_extiInstance=nullptr;


#if defined(USE_EXTI_USB_FS_WAKEUP_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) OTG_FS_WKUP_IRQHandler(void) {

    if(ExtiUsbFsWakeup::_extiInstance) {
      if(EXTI_GetITStatus(EXTI_Line18)!=RESET) {
          ExtiUsbFsWakeup::_extiInstance->ExtiInterruptEventSender.raiseEvent(18);
          EXTI_ClearITPendingBit(EXTI_Line18);
      }
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/ExtiUsbFsWakeupInterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/ExtiTamperTimestampInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line21> *ExtiPeripheral<EXTI_Line21>::_extiInstance=nullptr;


#if defined(USE_EXTI_TAMP_STAMP_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) TAMP_STAMP_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line21)!=RESET) {
        ExtiTamperTimestamp::_extiInstance->ExtiInterruptEventSender.raiseEvent(21);
        EXTI_ClearITPendingBit(EXTI_Line21);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/ExtiTamperTimestampInterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/Exti3InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line3> *ExtiPeripheral<EXTI_Line3>::_extiInstance=nullptr;


#if defined(USE_EXTI3_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) EXTI3_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line3)!=RESET) {
        Exti3::_extiInstance->ExtiInterruptEventSender.raiseEvent(3);
        EXTI_ClearITPendingBit(EXTI_Line3);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/Exti3InterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/Exti0InterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line0> *ExtiPeripheral<EXTI_Line0>::_extiInstance=nullptr;


#if defined(USE_EXTI0_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) EXTI0_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line0)!=RESET) {
        Exti0::_extiInstance->ExtiInterruptEventSender.raiseEvent(0);
        EXTI_ClearITPendingBit(EXTI_Line0);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
#endif
// END FILE: ../lib/src/exti/interrupts/f4/Exti0InterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/f4/ExtiRtcAlarmInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line17> *ExtiPeripheral<EXTI_Line17>::_extiInstance=nullptr;


#if defined(USE_EXTI_RTC_ALARM_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) RTC_Alarm_IRQHandler(void) {

    if(RTC_GetITStatus(RTC_IT_ALRA)!=RESET) {
      ExtiRtcAlarm::_extiInstance->ExtiInterruptEventSender.raiseEvent(17);
      RTC_ClearITPendingBit(RTC_IT_ALRA);
      EXTI_ClearITPendingBit(EXTI_Line17);
    }
    else if(RTC_GetITStatus(RTC_IT_ALRB)!=RESET) {
      ExtiRtcAlarm::_extiInstance->ExtiInterruptEventSender.raiseEvent(17);
      RTC_ClearITPendingBit(RTC_IT_ALRB);
      EXTI_ClearITPendingBit(EXTI_Line17);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }

  void RTCAlarm_IRQHandler(void) {
    RTC_Alarm_IRQHandler();
  }

}

#endif
#endif

// END FILE: ../lib/src/exti/interrupts/f4/ExtiRtcAlarmInterruptHandler.cpp
// START FILE: ../lib/src/exti/interrupts/ExtiPvdInterruptHandler.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/exti.h"


using namespace stm32plus;


// static initialiser for the hack that forces the IRQ handlers to be linked

template<> ExtiPeripheral<EXTI_Line16> *ExtiPeripheral<EXTI_Line16>::_extiInstance=nullptr;


#if defined(USE_EXTI_PVD_INTERRUPT)

extern "C" {

  void __attribute__ ((interrupt("IRQ"))) PVD_IRQHandler(void) {

    if(EXTI_GetITStatus(EXTI_Line16)!=RESET) {
        ExtiPvd::_extiInstance->ExtiInterruptEventSender.raiseEvent(16);
        EXTI_ClearITPendingBit(EXTI_Line16);
    }
    __DSB();      // prevent erroneous recall of this handler due to delayed memory write
  }
}

#endif
// END FILE: ../lib/src/exti/interrupts/ExtiPvdInterruptHandler.cpp
// START FILE: ../lib/src/flash/f4/InternalFlashSectorMap.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/flash/internal.h"


namespace stm32plus {

  /**
   * Size map declaration for the F40x and F41x devices. 12 sectors.
   */

  const uint8_t InternalFlashSectorMapF40xF41x::SizeMap[12]={
    16,16,16,16,64,128,128,128,128,128,128,128
  };


  /**
   * Size map declaration for the F42x and F43x devices. 24 sectors.
   */

  const uint8_t InternalFlashSectorMapF42xF43x::SizeMap[24]={
    16,16,16,16,64,128,128,128,128,128,128,128,16,16,16,16,64,128,128,128,128,128,128,128
  };
}


#endif
// END FILE: ../lib/src/flash/f4/InternalFlashSectorMap.cpp
// START FILE: ../lib/src/rtc/f4/RtcMeasuredLsiFrequencyProvider.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/rtc.h"


namespace stm32plus {


  /**
   * Compute the LSI frequency using TIM5 to measure it
   * @return the frequency in Hz
   */

  uint32_t RtcMeasuredLsiFrequencyProvider::getLsiFrequency() {

    /**
     * Use a local class as the observer for the TIM5 channel 4 interrupts
     */

    class T5Observer {

      private:
        volatile bool _completed;
        uint16_t _period;
        uint8_t _captureIndex;
        uint16_t _captures[2];

      public:

        T5Observer() {
          _completed=false;
          _captureIndex=0;
        }

        bool completed() const {
          return _completed;
        }

        uint16_t getPeriod() const {
          return _period;
        }

        void onTimerEvent(TimerEventType tet,uint8_t /* timerNumber */) {

          if(tet==TimerEventType::EVENT_COMPARE4) {

            if(_captureIndex==0 || _captureIndex==1) {

              _captures[_captureIndex++]=TIM_GetCapture4(TIM5);

              if(_captureIndex==2) {
                _period=(uint16_t)(0xFFFF-_captures[0]+_captures[1]+1);
                _completed=true;
              }
            }
          }
        }

    } interruptObserver;

    // Declare an instance of timer5

    Timer5<
      Timer5InternalClockFeature,         // used only for its calculation of the timer clock frequency
      TimerChannel4Feature<               // we need channel 4
        TimerChannelICRisingEdgeFeature,  // rising edge trigger
        TimerChannelICDirectTiFeature,    // direct TI connection
        TimerChannelICPreScaler8Feature,  // input capture prescaler of 8
        TimerChannelICFilterFeature<0>    // no filter
      >,
      Timer5InterruptFeature,       // we'll be using interrupts
      Timer5RemapLsiFeature         // we will remap LSI output to TIM5 ch4 input
    > timer5;

    // insert our local class as an interrupt event subscriber

    timer5.TimerInterruptEventSender.insertSubscriber(TimerInterruptEventSourceSlot::bind(&interruptObserver,&T5Observer::onTimerEvent));

    // enable interrupts and the timer

    timer5.Timer::enablePeripheral();
    timer5.clearPendingInterruptsFlag(TIM_IT_CC4);
    timer5.enableInterrupts(TIM_IT_CC4);

    // wait until completed

    while(!interruptObserver.completed());

    // disable the timer, interrupts and de-init the timer

    timer5.Timer::disablePeripheral();

    timer5.disableInterrupts(TIM_IT_CC4);
    timer5.deinitialise();

    // return the calculated frequency

    uint32_t frequency=timer5.getClock()/interruptObserver.getPeriod()*8;
    return frequency;
  }
}

#endif
// END FILE: ../lib/src/rtc/f4/RtcMeasuredLsiFrequencyProvider.cpp
// START FILE: ../lib/include/string/Ascii.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/**
 * @file Ascii.h
 * Wrapper class for converting types to ASCII and offering an operator const char *() to get
 * at the results. Intended for inline use with implicit conversion.
 */

namespace stm32plus {
  namespace StringUtil {

    /**
     * ASCII converter class
     */

    class Ascii {

      protected:
        scoped_array<char> _buffer;

      public:
        Ascii(long l);

        operator const char *() const;
    };


    /**
     * Constructor with long
     * @param l The long to convert
     */

    inline Ascii::Ascii(long l)
      : _buffer(new char[20]) {

      StringUtil::modp_uitoa10(l,_buffer.get());
    }


    /**
     * Cast conversion
     */

    inline Ascii::operator const char *() const {
      return _buffer.get();
    }
  }
}
// END FILE: ../lib/include/string/Ascii.h
// START FILE: ../lib/include/string/StdStringUtil.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/**
 * @file
 * Various string utilities. We provide integer to ASCII and optimised to-ASCII conversions for
 * double-precision and uint32_t values.
 */

namespace stm32plus {
  namespace StdStringUtil {

    static const char *defaultTrimChars="\n\r\t ";

    /**
     * Remove white space (\n\r\t ) from the start of a string
     * @param str the string to left-trim
     */

    inline void trimLeft(std::string& str,const char *trimChars=defaultTrimChars) {

      std::string::size_type pos;

      if((pos=str.find_first_not_of(trimChars))==std::string::npos)
        str.clear();
      else if(pos!=0)
        str=str.substr(pos);
    }


    /**
     * Remove white space (\n\r\t ) from the end of a string
     * @param str the string to right-trim
     */

    inline void trimRight(std::string& str,const char *trimChars=defaultTrimChars) {

      std::string::size_type pos;

      if((pos=str.find_last_not_of(trimChars))==std::string::npos)
        str.clear();
      else if(pos!=str.size()-1)
        str=str.substr(0,pos+1);
    }


    /**
     * Remove white space (\n\r\t ) from both ends of a string
     * @param str the string to fully trim
     */

    inline void trim(std::string& str,const char *trimChars=defaultTrimChars) {
      trimLeft(str,trimChars);
      trimRight(str,trimChars);
    }


    /**
     * Tokenise a string based on supplied separators
     * @param cmdText
     */

    inline void tokenise(const std::string& cmdText,const char *separators,std::vector<std::string>& words) {

      std::string::size_type first,last;

      // tokenise the command

      for(first=cmdText.find_first_not_of(separators);first!=std::string::npos && last!=std::string::npos;) {

        if((last=cmdText.find_first_of(separators,first))==std::string::npos)
          break;

        words.push_back(cmdText.substr(first,last-first));
        first=cmdText.find_first_not_of(separators,last);
      }

      if(first!=std::string::npos)
        words.push_back(cmdText.substr(first,cmdText.length()-first));
    }
  }
}
// END FILE: ../lib/include/string/StdStringUtil.h
// START FILE: ../lib/include/string/TokenisedString.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief A string broken down into components.
   *
   * Access to the components should always start at zero and
   * stop at getNumTokens(). Internally a range of tokens is managed through setRange();
   */

  class TokenisedString {

    protected:
      char **_tokens;
      int _numTokens;
      int _first;
      int _last;

    public:
      TokenisedString(const char *original_,const char *separators_);
      virtual ~TokenisedString();

      int getNumTokens() const;

      const char *operator[](int pos_) const;
      const char *last() const;

      void setRange(int first_,int last_);
      void resetRange();
  };
}
// END FILE: ../lib/include/string/TokenisedString.h
// START FILE: ../lib/include/string/StringUtil.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/**
 * @file
 * Various string utilities. We provide integer to ASCII and optimised to-ASCII conversions for
 * double-precision and uint32_t values.
 */

namespace stm32plus {
  namespace StringUtil {

    char* itoa(int value,char* result,int base);
    uint32_t modp_uitoa10(uint32_t value,char *str);
    uint16_t modp_dtoa(double value,int8_t prec,char *str);
    void toHex(const void *buffer,uint32_t bufferSize,char *output);
  }
}
// END FILE: ../lib/include/string/StringUtil.h
// START FILE: ../lib/include/stream/TextOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * This class wraps an existing output stream and provides additional functionality
   * to write out text values using the << operator. e.g. stream << 3 will write
   * the text string "3" to the stream instead of the binary integer 3.
   */

  class TextOutputStream : public OutputStream {

    protected:
      OutputStream& _stream;

    public:

      TextOutputStream(OutputStream& stream);

      // can't do these as a template with specialisation because you can't specialise
      // members in a template class that isn't also fully specialised

      TextOutputStream& operator<<(const char *str);
      TextOutputStream& operator<<(char c);
      TextOutputStream& operator<<(int32_t val);
      TextOutputStream& operator<<(uint32_t val);
      TextOutputStream& operator<<(int16_t val);
      TextOutputStream& operator<<(uint16_t val);
      TextOutputStream& operator<<(const DoublePrecision& val);
      TextOutputStream& operator<<(double val);

      // overrides from OutputStream

      virtual bool write(uint8_t c) override;
      virtual bool write(const void *buffer,uint32_t size) override;
      virtual bool close() override;
      virtual bool flush() override;
  };


  /**
   * Constructor
   * @param stream The stream that we are wrapping
   */

  inline TextOutputStream::TextOutputStream(OutputStream& stream)
    : _stream(stream) {

  }

  /**
   * character string operator
   * @param str The character string
   * @return self reference
   */

  inline TextOutputStream& TextOutputStream::operator<<(const char *str) {
    write(str,strlen(str));
    return *this;
  }


  /**
   * Character writer
   * @param c The character
   * @return self-reference
   */

  inline TextOutputStream& TextOutputStream::operator<<(char c) {
    write(c);
    return *this;
  }


  /**
   * integer writer
   * @param val The integer
   * @return self reference
   */

  inline TextOutputStream& TextOutputStream::operator<<(int32_t val) {

    char buf[15];
    StringUtil::itoa(val,buf,10);
    write(buf,strlen(buf));

    return *this;
  }


  /**
   * Unsigned int writer
   * @param val The integer
   * @return self reference
   */

  inline TextOutputStream& TextOutputStream::operator<<(uint32_t val) {

    char buf[15];
    StringUtil::modp_uitoa10(val,buf);
    write(buf,strlen(buf));

    return *this;
  }


  /**
   * Signed 16-bit writer
   * @param val The integer
   * @return self reference
   */

  inline TextOutputStream& TextOutputStream::operator<<(int16_t val) {
    return operator<<((int32_t)val);
  }


  /**
   * Unsigned 16-bit writer
   * @param val The integer
   * @return self reference
   */

  inline TextOutputStream& TextOutputStream::operator<<(uint16_t val) {
    return operator<<((uint32_t)val);
  }


  /**
   * Double writer
   * @param val The double to write
   * @return self reference
   */

  inline TextOutputStream& TextOutputStream::operator<<(const DoublePrecision& val) {

    char str[25];

    StringUtil::modp_dtoa(val.Value,val.Precision,str);
    write(str,strlen(str));
    return *this;
  }


  /**
   * Double writer
   *  @param val The double to write
   * @return self reference
   */

  inline TextOutputStream& TextOutputStream::operator<<(double val) {
    operator<<(DoublePrecision(val,DoublePrecision::MAX_DOUBLE_FRACTION_DIGITS));
    return *this;
  }


  /**
   * Write a byte - call through to the underlying stream
   * @param buffer The buffer
   * @param size The size
   * @return the underlying stream success result
   */

  inline bool TextOutputStream::write(uint8_t c) {
    return _stream.write(c);
  }


  /**
   * Write a buffer - call through to the underlying stream
   * @param buffer The buffer
   * @param size The size
   * @return the underlying stream success result
   */

  inline bool TextOutputStream::write(const void *buffer,uint32_t size) {
    return _stream.write(buffer,size);
  }


  /**
   * Close the stream (do nothing)
   * @return true
   */

  inline bool TextOutputStream::close() {
    return true;
  }


  /**
   * Flush the stream
   * @return the underlying stream flush result
   */

  inline bool TextOutputStream::flush() {
    return _stream.flush();
  }
}

// END FILE: ../lib/include/stream/TextOutputStream.h
// START FILE: ../lib/include/stream/StreamBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Abstract class defining how an input stream behaves.
   *
   * Input streams give you the ability to read data sequentially. The base
   * class supplies an implementation of the popular stream operators
   * << and >>. These should be used with care as error handling is
   * not easily implemented.
   */

  class StreamBase {

    protected:
      virtual ~StreamBase() {}

    public:

      /**
       * Error codes
       */

      enum {
        /// End of stream has been reached
        E_END_OF_STREAM=-1,

        /// An error occurred while reading from the stream
        E_STREAM_ERROR=-2,

        /// The operation is not supported
        E_OPERATION_NOT_SUPPORTED=-3
      };

    public:

      /**
       * Close the stream. If the stream does not support the operation
       * then it returns true.
       * @return false if it fails.
       */

      virtual bool close()=0;
  };
}
// END FILE: ../lib/include/stream/StreamBase.h
// START FILE: ../lib/include/stream/ReadAheadInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


namespace stm32plus {


  /**
   * Helper stream to provide read-ahead capabilities for the stream it wraps. This is useful
   * for when it is expensive to read small amounts from the underlying stream
   */

  class ReadAheadInputStream : public InputStream {

    protected:
      InputStream& _is;
      uint8_t *_buffer;
      uint32_t _pos;
      uint32_t _bufferSize;
      uint32_t _maxBufferSize;

    protected:
      bool refillBuffer();

    public:
      ReadAheadInputStream(InputStream& is,uint32_t bufferSize);
      virtual ~ReadAheadInputStream() {}

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;
      virtual bool reset() override;

      // overrides from StreamBase

      virtual bool close() override;
  };


  /**
   * Constructor
   * @param is The wrapped stream
   * @param bufferSize The internal buffer size
   */

  inline ReadAheadInputStream::ReadAheadInputStream(InputStream& is,uint32_t bufferSize)
    : _is(is),
      _buffer(reinterpret_cast<uint8_t *>(malloc(bufferSize))),
      _pos(bufferSize),
      _bufferSize(bufferSize),
      _maxBufferSize(bufferSize) {
  }


  /**
   * Read a single byte
   * @return the byte or E_END_OF_STREAM
   */

  inline int16_t ReadAheadInputStream::read() {

    if(_pos==_bufferSize) {

      // get some more bytes

      if(!refillBuffer())
        return E_STREAM_ERROR;

      // none means end of stream

      if(_pos==_bufferSize)
        return E_END_OF_STREAM;
    }

    return _buffer[_pos++];
  }


  /**
   * Read many characters
   * @param buffer Where to read out to
   * @param size Number requested
   * @param actuallyRead Number actually read out
   * @return true, always. zero actually read indicates EOF
   */

  inline bool ReadAheadInputStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

    uint8_t *ptr;
    uint32_t count;

    actuallyRead=0;
    ptr=reinterpret_cast<uint8_t *>(buffer);

    while(size) {

      // ensure there's data

      if(_pos==_bufferSize) {

        if(!refillBuffer())
          return false;

        // check for end of stream

        if(_pos==_bufferSize)
          return true;
      }

      count=std::min(_bufferSize-_pos,size);
      memcpy(ptr,_buffer+_pos,count);
      _pos+=count;

      ptr+=count;
      size-=count;
      actuallyRead+=count;
    }

    return true;
  }


  /**
   * Refill the internal buffer from the stream
   * @return true if no error
   */

  inline bool ReadAheadInputStream::refillBuffer() {

    uint32_t actuallyRead;

    // try to read max from underlying stream

    if(!_is.read(_buffer,_maxBufferSize,actuallyRead))
      return false;

    // EOF check

    if(actuallyRead==0)
      return true;

    // adjust pointers

    _pos=0;
    _bufferSize=actuallyRead;
    return true;
  }


  /**
   * Seek forward in the stream
   * @param howMuch amount to seek
   * @return unsupported operation
   */

  inline bool ReadAheadInputStream::skip(uint32_t /* howMuch */) {
    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_READ_AHEAD_INPUT_STREAM,E_OPERATION_NOT_SUPPORTED);
  }


  /**
   * Return true if some data is available for reading
   * @return true if data is available
   */

  inline bool ReadAheadInputStream::available() {
    return _pos!=_bufferSize || _is.available();
  }


  /**
   * Reset to the start of the stream
   * @return Always true
   */

  inline bool ReadAheadInputStream::reset() {
    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_READ_AHEAD_INPUT_STREAM,E_OPERATION_NOT_SUPPORTED);
  }


  /**
   * Do nothing close
   * @return true always
   */

  inline bool ReadAheadInputStream::close() {
    return true;
  }
}
// END FILE: ../lib/include/stream/ReadAheadInputStream.h
// START FILE: ../lib/include/stream/InputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Abstract class defining how an input stream behaves.
   *
   * Input streams give you the ability to read data sequentially. The base
   * class supplies an implementation of the popular stream operators
   * << and >>. These should be used with care as error handling is
   * not easily implemented.
   */

  class InputStream : public StreamBase {

    protected:
      InputStream& opRead(void *buffer,uint32_t bufferSize);

    public:
      virtual ~InputStream() {}

      // some convenience operators when you don't care about errors or endian-ness

      InputStream& operator>>(int8_t& c);
      InputStream& operator>>(int16_t& c);
      InputStream& operator>>(int32_t& c);
      InputStream& operator>>(uint8_t& c);
      InputStream& operator>>(uint16_t& c);
      InputStream& operator>>(uint32_t& c);

      /**
       * Read a byte from the stream, potentially blocking until data
       * is available.
       *
       * @return If the read succeeds then the byte
       * is returned in the lower 8 bytes, hence the return value is in the
       * range 0..255. If the read fails then the return value is E_STREAM_ERROR.
       * If the end of the stream has been reached then the return value is
       * E_END_OF_STREAM.
       */

      virtual int16_t read()=0;

      /**
       * Read a sequence of bytes from the stream, potentially blocking
       * if data is not available.
       *
       * @param[in,out] buffer The location to store the data.
       * @param[in] size The number of bytes to try to read.
       * @param[in] actuallyRead The number of bytes actually read, which may be less than the size
       *  requested if the end of the file is reached.
       * @return false if the read fails.
       */

      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead)=0;

      /**
       * Seek forward by the given number of bytes.
       * @param[in] howMuch The amount to try to seek.
       * @return false if it fails.
       */

      virtual bool skip(uint32_t howMuch)=0;

      /**
       * Peek into a blocking stream and return true if data is available
       * to read. Allows the caller to prevent blocking by checking if there
       * is data available.
       *
       * @return true if there is data available, false if not.
       */

      virtual bool available()=0;


      /**
       * Seek the stream back to the beginning.
       * @return false if the stream does not support being reset or an error occurred.
       */

      virtual bool reset()=0;
  };
}
// END FILE: ../lib/include/stream/InputStream.h
// START FILE: ../lib/include/stream/OutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Abstract base class for output streams.
   *
   * An output stream gives you the ability to write data sequentially
   * to a device.
   */

  class OutputStream : public StreamBase {

    protected:
      OutputStream& opWrite(void *buffer,uint32_t bufferSize);

    public:
      virtual ~OutputStream() {}

      // some convenience operators when you don't care about errors or endian-ness

      OutputStream& operator<<(int8_t c);
      OutputStream& operator<<(int16_t c);
      OutputStream& operator<<(int32_t c);
      OutputStream& operator<<(uint8_t c);
      OutputStream& operator<<(uint16_t c);
      OutputStream& operator<<(uint32_t c);
      OutputStream& operator<<(const char *string);

      /**
       * Write a byte to the stream.
       * @param[in] c The byte to write.
       * @return false if it fails.
       */

      virtual bool write(uint8_t c)=0;

      /**
       * Write a buffer of data to the stream.
       * @param[in] buffer The buffer of data to write.
       * @param[in] size The number of bytes to write.
       * @return false if the write fails.
       */

      virtual bool write(const void *buffer,uint32_t size)=0;

      /**
       * Flush any cached data to the stream. If the stream does not support
       * caching then it returns true.
       * @return false if it fails.
       */

      virtual bool flush()=0;
  };
}
// END FILE: ../lib/include/stream/OutputStream.h
// START FILE: ../lib/include/stream/Reader.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Abstract class defining the methods that a reader implementation
   * must implement.
   */

  class Reader : public InputStream {

    public:

      /**
       * Read a line of text from the stream. A line is delimited by an LF or
       * a CRLF sequence or the end of file. If the line is longer than maxLength
       * then the line is truncated. The returned line will be \0 terminated meaning
       * that maxLength includes the \0 character.
       * @param buffer Where to store the line
       * @param maxLength The maximum number of characters to read
       * @return true if it worked
       */

      virtual bool readLine(char *buffer,uint32_t maxLength)=0;
  };
}
// END FILE: ../lib/include/stream/Reader.h
// START FILE: ../lib/include/stream/StlStringInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


namespace stm32plus {


  /**
   * Helper class to read from an STL string using the InputStream interface
   */

  class StlStringInputStream : public InputStream {

    public:
      enum {
        E_INVALID_SEEK_POSITION = 1
      };

    protected:
      const std::string *_string;
      bool _delete;
      std::string::size_type _pos;

    public:
      StlStringInputStream(const std::string *str,bool takeOwnership);
      virtual ~StlStringInputStream();

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;
      virtual bool reset() override;

      // overrides from StreamBase

      virtual bool close() override;
  };


  /**
   * Constructor
   * @param str The string pointer
   * @param takeOwnership true if we must delete on destruction
   */

  inline StlStringInputStream::StlStringInputStream(const std::string *str,bool takeOwnership)
    : _string(str),
      _delete(takeOwnership),
      _pos(0) {
  }


  /**
   * Destructor
   */

  inline StlStringInputStream::~StlStringInputStream() {
    if(_delete)
      delete _string;
  }


  /**
   * Read a single byte
   * @return the byte or E_END_OF_STREAM
   */

  inline int16_t StlStringInputStream::read() {

    if(_pos==_string->length())
      return E_END_OF_STREAM;

    return (*_string)[_pos++];
  }


  /**
   * Read many characters
   * @param buffer Where to read out to
   * @param size Number requested
   * @param actuallyRead Number actually read out
   * @return true, always. zero actually read indicates EOF
   */

  inline bool StlStringInputStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

    actuallyRead=std::min(size,static_cast<uint32_t>(_string->length()-_pos));

    if(actuallyRead) {
      memcpy(buffer,_string->c_str()+_pos,actuallyRead);
      _pos+=actuallyRead;
    }

    return true;
  }


  /**
   * Seek forward in the stream
   * @param howMuch amount to seek
   * @return true if OK, false if tried to seek past end
   */

  inline bool StlStringInputStream::skip(uint32_t howMuch) {

    // check validity of how much

    if(howMuch>_string->length()-_pos)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_STL_STRING_INPUT_STREAM,E_INVALID_SEEK_POSITION);

    // move forward

    _pos+=howMuch;
    return true;
  }


  /**
   * Return true if some data is available for reading
   * @return true if data is available
   */

  inline bool StlStringInputStream::available() {
    return _string->length()!=_pos;
  }


  /**
   * Reset to the start of the stream
   * @return Always true
   */

  inline bool StlStringInputStream::reset() {
    _pos=0;
    return true;
  }


  /**
   * Do nothing close
   * @return true always
   */

  inline bool StlStringInputStream::close() {
    return true;
  }
}
// END FILE: ../lib/include/stream/StlStringInputStream.h
// START FILE: ../lib/include/stream/LinearBufferInputOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Class to support a linear I/O buffer.
   *
   * The buffer has a start and an end and
   * does not wrap around like the circular buffer. The reset() call can be used to reset
   * both the input pointer and the resetOutput() call can be used to reset the output pointer.
   */

  class LinearBufferInputOutputStream : public BufferedInputOutputStream {
    public:

      // constructors

      LinearBufferInputOutputStream(void *buffer,uint32_t size);
      LinearBufferInputOutputStream(uint32_t initialSize);

      void resetOutput();

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;
      virtual bool reset() override;

      // overrides from OutputStream

      virtual bool write(uint8_t c) override;
      virtual bool write(const void *buffer,uint32_t size) override;

      virtual bool flush() override {
        return true;
      }

      // overrides from both

      virtual bool close() override {
        return true;
      }
  };
}
// END FILE: ../lib/include/stream/LinearBufferInputOutputStream.h
// START FILE: ../lib/include/stream/LzgDecompressionInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * @brief Decompress LZG-compressed bytes
   *
   * LzgDecompressionInputStream acts as a filter, taking LZG-compressed bytes from an
   * input stream that you supply and making them available as an uncompressed stream
   * through this class's own implementation of InputStream.
   */

  class LzgDecompressionStream : public InputStream {

    public:
      enum {
        E_UNSUPPORTED_COMPRESSED_DATA = 1
      };

    protected:
      InputStream& _input;
      uint32_t _compressedSize;

      uint32_t _compressedDataAvailable;
      uint8_t _circbuf[2056];               // note the size of this - ensure you can afford it
      uint8_t *_dst,*_dstEnd;
      char _isMarkerSymbolLUT[256];
      uint8_t _marker1,_marker2,_marker3,_marker4;

      uint8_t *_historyCopyPosition;
      uint32_t _historyCopyDataAvailable;

    protected:
      bool readNextUncompressedByte(uint8_t& nextByte);
      bool nextByteFromStream(uint8_t& nextByte);
      uint8_t getByteFromHistoryCopy();

    public:
      LzgDecompressionStream(InputStream& input,uint32_t compressedSize);
      virtual ~LzgDecompressionStream() {}

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool close() override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;
      virtual bool reset() override;
  };
}
// END FILE: ../lib/include/stream/LzgDecompressionInputStream.h
// START FILE: ../lib/include/stream/ByteArrayInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


namespace stm32plus {


  /**
   * Helper class to read from a byte array using the InputStream interface. This class does
   * not take ownership of the byte array. It is expected that the user will keep it in scope
   * while this class is in use.
   */

  class ByteArrayInputStream : public InputStream {

    public:
      enum {
        E_INVALID_SEEK_POSITION = 1
      };

    protected:
      const uint8_t *_data;
      uint32_t _size;
      uint32_t _pos;

    public:
      ByteArrayInputStream(const void *data,uint32_t size);
      virtual ~ByteArrayInputStream() {}

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;
      virtual bool reset() override;

      // overrides from StreamBase

      virtual bool close() override;
  };


  /**
   * Constructor
   * @param data The string pointer
   * @param size The data size in bytes
   */

  inline ByteArrayInputStream::ByteArrayInputStream(const void *data,uint32_t size)
    : _data(reinterpret_cast<const uint8_t *>(data)),
      _size(size),
      _pos(0) {
  }


  /**
   * Read a single byte
   * @return the byte or E_END_OF_STREAM
   */

  inline int16_t ByteArrayInputStream::read() {

    if(_pos==_size)
      return E_END_OF_STREAM;

    return _data[_pos++];
  }


  /**
   * Read many characters
   * @param buffer Where to read out to
   * @param size Number requested
   * @param actuallyRead Number actually read out
   * @return true, always. zero actually read indicates EOF
   */

  inline bool ByteArrayInputStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

    actuallyRead=std::min(size,static_cast<uint32_t>(_size-_pos));

    if(actuallyRead) {
      memcpy(buffer,_data+_pos,actuallyRead);
      _pos+=actuallyRead;
    }

    return true;
  }


  /**
   * Seek forward in the stream
   * @param howMuch amount to seek
   * @return true if OK, false if tried to seek past end
   */

  inline bool ByteArrayInputStream::skip(uint32_t howMuch) {

    // check validity of how much

    if(howMuch>_size-_pos)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_BYTE_ARRAY_INPUT_STREAM,E_INVALID_SEEK_POSITION);

    // move forward

    _pos+=howMuch;
    return true;
  }


  /**
   * Return true if some data is available for reading
   * @return true if data is available
   */

  inline bool ByteArrayInputStream::available() {
    return _size!=_pos;
  }


  /**
   * Reset to the start of the stream
   * @return Always true
   */

  inline bool ByteArrayInputStream::reset() {
    _pos=0;
    return true;
  }


  /**
   * Do nothing close
   * @return true always
   */

  inline bool ByteArrayInputStream::close() {
    return true;
  }
}
// END FILE: ../lib/include/stream/ByteArrayInputStream.h
// START FILE: ../lib/include/stream/ConnectedInputOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Plumbing class to connect together an input and output stream.
   *
   * This class connects an input stream to an output stream. Data is read from the input
   * stream and written to the output stream
   */

  class ConnectedInputOutputStream {
    protected:
      InputStream& _inputStream;
      OutputStream& _outputStream;

    public:
      ConnectedInputOutputStream(InputStream& is,OutputStream& os);
      virtual ~ConnectedInputOutputStream() {
      }

      bool readWrite(uint32_t size,uint32_t& actuallyWritten);
      bool readWrite();
  };
}
// END FILE: ../lib/include/stream/ConnectedInputOutputStream.h
// START FILE: ../lib/include/stream/CircularBufferInputOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Buffered IO stream operating as a circular buffer.
   *
   * The buffer is non-blocking and it will not overwrite data that has not been read. The
   * read and write functions will return errors if the buffer is full. Read functions will
   * set E_END_OF_STREAM when there is no data available. Write functions will return E_BUFFER_FULL
   * if there is not enough space for the write.
   *
   * This is designed to be safe for using with interrupts. e.g. an ISR writes to to the class
   * and the main code reads from it, or vice-versa. The write() and read() functions do not share
   * any internal state members and all state members are <= the native word size of the MCU.
   */

  class CircularBufferInputOutputStream : public BufferedInputOutputStream {

    protected:
      bool _wrappedWrite;

    public:

      /**
       * Constructor.
       * @param fixedSize The fixed size of the circular buffer. This parameter should be set to reflect how far 'ahead'
       *    writes can get from reads in the buffer.
       */

      CircularBufferInputOutputStream(uint32_t fixedSize) :
        BufferedInputOutputStream(fixedSize) {
        _wrappedWrite=false;
      }

      bool isFull() const;

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;

      /**
       * @copydoc InputStream::skip
       */

      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;

      // overrides from OutputStream

      virtual bool write(uint8_t c) override;
      virtual bool write(const void *buffer,uint32_t size) override;

      virtual bool flush() override {
        return true;
      }

      /**
       * Cannot reset this stream
       * @return Always false and sets error code to E_OPERATION_NOT_SUPPORTED
       */

      virtual bool reset() override {
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_CIRCULAR_BUFFER_INPUT_STREAM,E_OPERATION_NOT_SUPPORTED);
      }

      // common methods

      virtual bool close() override {
        return true;
      }
  };


  /**
   * Check if the buffer is full
   * @return true if it's full
   */

  inline bool CircularBufferInputOutputStream::isFull() const {
    return _readPtr==_writePtr && _wrappedWrite;
  }
}
// END FILE: ../lib/include/stream/CircularBufferInputOutputStream.h
// START FILE: ../lib/include/stream/ByteArrayOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief output stream for writing to an auto-resizing memory block
   *
   * This stream writes to a memory block allocated on the heap that automatically
   * increases to take new data. The intial size and the size of subsequent
   * resizes are customizable.
   */

  class ByteArrayOutputStream : public OutputStream {

    protected:
      ByteMemblock _memblock;
      uint32_t _currentUsage;
      uint32_t _resizeAmount;
      uint32_t _initialSize;

    public:
      ByteArrayOutputStream(uint32_t initialSize=100,uint32_t resizeAmount=100);
      virtual ~ByteArrayOutputStream() {}

      uint32_t getSize() const;
      uint8_t *getBuffer() const;

      void clear();

      // overrides from OutputStream

      virtual bool write(uint8_t c) override;
      virtual bool write(const void *buffer,uint32_t size) override;
      virtual bool close() override;
      virtual bool flush() override;
  };
}
// END FILE: ../lib/include/stream/ByteArrayOutputStream.h
// START FILE: ../lib/include/stream/BufferedInputOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Base class for a stream that maintains a memory buffer of bytes.
   */

  class BufferedInputOutputStream : public InputStream, public OutputStream {

    protected:
      uint8_t *_buffer;
      uint32_t _bufferSize;
      volatile uint8_t *_readPtr;
      volatile uint8_t *_writePtr;
      bool _needToFree;

    public:

      /**
       * Error codes
       */

      enum {
        /// invalid seek size, you probably tried to seek forward beyond the available data
        E_INVALID_SEEK_SIZE=1,
        /// There is not enough space in the buffer for this operation
        E_BUFFER_FULL
      };

    public:

      /**
       * Constructor. Allocates memory for the initial size of the buffer.
       *
       * @param[in] initialSize The size to allocate.
       */

      BufferedInputOutputStream(uint32_t initialSize) {
        _readPtr=_writePtr=_buffer=static_cast<uint8_t *> (malloc(initialSize));
        _bufferSize=initialSize;
        _needToFree=true;
      }


      /**
       * Constructor. Buffer is provided by caller and will not be freed here.
       * @param[in] buffer The caller-allocated buffer.
       * @param[in] size The size of the caller supplied buffer
       */

      BufferedInputOutputStream(void *buffer,uint32_t size) {
        _readPtr=_writePtr=_buffer=static_cast<uint8_t*>(buffer);
        _bufferSize=size;
        _needToFree=false;
      }

      /**
       * Destructor, frees up the internal buffer.
       */

      virtual ~BufferedInputOutputStream() {
        if(_needToFree)
          free(_buffer);
      }

  };
}
// END FILE: ../lib/include/stream/BufferedInputOutputStream.h
// START FILE: ../lib/include/error/ErrorProvider.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#include <stdint.h>

namespace stm32plus {

  /**
   * @brief structured error handler.
   *
   * The error handler is a global singleton, much as I dislike them. An error code
   * is a 32 bit value. Bits 00-15 are a provider specific error code. Bits 16-23
   * are the provider identifier.
   */

  class ErrorProvider {
    protected:
      uint32_t _errorCode;      // includes provider code
      uint32_t _errorCause;
      uint32_t _provider;

    public:

      /**
       * Error codes
       */

      enum {
        /// There was no error
        ERROR_NO_ERROR=0
      };

      enum {
        ERROR_PROVIDER_SD_SDIO                                    = 0,
        ERROR_PROVIDER_FILESYSTEM                                 = 1,
        ERROR_PROVIDER_FAT_FILESYSTEM                             = 2,
        ERROR_PROVIDER_FAT16_FILESYSTEM                           = 3,
        ERROR_PROVIDER_FAT32_FILESYSTEM                           = 4,
        ERROR_PROVIDER_FAT16_FILESYSTEM_FORMATTER                 = 5,
        ERROR_PROVIDER_FAT32_FILESYSTEM_FORMATTER                 = 6,
        ERROR_PROVIDER_FAT_DIRECTORY                              = 7,
        ERROR_PROVIDER_ITERATOR                                   = 8,
        ERROR_PROVIDER_TEST                                       = 9,
        ERROR_PROVIDER_DIRECTORY_ITERATOR                         = 10,
        ERROR_PROVIDER_ILI9481_LCD_INTERFACE                      = 11,
        ERROR_PROVIDER_ILI9327_LCD_INTERFACE                      = 12,
        ERROR_PROVIDER_ILI9325_LCD_INTERFACE                      = 13,
        ERROR_PROVIDER_HX8347_LCD_INTERFACE                       = 14,
        ERROR_PROVIDER_REMOVABLE_STORAGE_DEVICE                   = 15,
        ERROR_PROVIDER_BLOCK_DEVICE                               = 16,
        ERROR_PROVIDER_FILE                                       = 17,
        ERROR_PROVIDER_FREE_CLUSTER_FINDER                        = 18,
        ERROR_PROVIDER_LONG_FILENAME_GENERATOR                    = 19,
        ERROR_PROVIDER_USART                                      = 20,
        ERROR_PROVIDER_BUFFERED_IOSTREAM                          = 21,
        ERROR_PROVIDER_SPI                                        = 22,
        ERROR_PROVIDER_I2S                                        = 23,
        ERROR_PROVIDER_DMA                                        = 24,
        ERROR_PROVIDER_BITMAP_CACHE                               = 25,
        ERROR_PROVIDER_SPI_INPUT_STREAM                           = 26,
        ERROR_PROVIDER_USART_INPUT_STREAM                         = 27,
        ERROR_PROVIDER_CIRCULAR_BUFFER_INPUT_STREAM               = 28,
        ERROR_PROVIDER_AT45DB161D                                 = 29,
        ERROR_PROVIDER_SRAM                                       = 30,
        ERROR_PROVIDER_TOUCH_SCREEN                               = 31,
        ERROR_PROVIDER_TOUCH_SCREEN_CALIBRATION                   = 32,
        ERROR_PROVIDER_LZG_DECOMPRESSION_STREAM                   = 33,
        ERROR_PROVIDER_INPUT_STREAM                               = 34,
        ERROR_PROVIDER_OUTPUT_STREAM                              = 35,
        ERROR_PROVIDER_BLOCK_DEVICE_OUTPUT_STREAM                 = 36,
        ERROR_PROVIDER_BLOCK_DEVICE_INPUT_STREAM                  = 37,
        ERROR_PROVIDER_I2C                                        = 38,
        ERROR_PROVIDER_HASH                                       = 39,
        ERROR_PROVIDER_WORK_QUEUE                                 = 40,
        ERROR_PROVIDER_DAC                                        = 41,
        ERROR_PROVIDER_RNG                                        = 42,
        ERROR_PROVIDER_SERIAL_EEPROM                              = 43,
        ERROR_PROVIDER_STL_STRING_INPUT_STREAM                    = 44,
        ERROR_PROVIDER_BYTE_ARRAY_INPUT_STREAM                    = 45,
        ERROR_PROVIDER_READ_AHEAD_INPUT_STREAM                    = 46,
        ERROR_PROVIDER_NET_MAC                                    = 47,
        ERROR_PROVIDER_NET_PHY                                    = 48,
        ERROR_PROVIDER_NET_ARP                                    = 49,
        ERROR_PROVIDER_NET_IP                                     = 50,
        ERROR_PROVIDER_NET_IP_PACKET_REASSEMBLER                  = 51,
        ERROR_PROVIDER_NET_PING                                   = 52,
        ERROR_PROVIDER_NET_UDP                                    = 53,
        ERROR_PROVIDER_NET_TCP                                    = 54,
        ERROR_PROVIDER_NET_TCP_SERVER                             = 55,
        ERROR_PROVIDER_NET_TCP_CONNECTION                         = 56,
        ERROR_PROVIDER_NET_TCP_CONNECTION_ARRAY                   = 57,
        ERROR_PROVIDER_NET_TCP_TEXT_LINE_RECEIVER                 = 58,
        ERROR_PROVIDER_NET_TCP_INPUT_STREAM                       = 59,
        ERROR_PROVIDER_NET_TCP_OUTPUT_STREAM                      = 60,
        ERROR_PROVIDER_NET_DHCP                                   = 61,
        ERROR_PROVIDER_NET_LINK_LOCAL_IP                          = 62,
        ERROR_PROVIDER_NET_DNS                                    = 63,
        ERROR_PROVIDER_NET_IPPORTS                                = 64,
        ERROR_PROVIDER_NET_IP_DISABLED_PACKET_FRAGMENT_FEATURE    = 65,
        ERROR_PROVIDER_NET_IP_DISABLED_PACKET_REASSEMBLER_FEATURE = 66,
        ERROR_PROVIDER_NET_HTTP_CLIENT                            = 67,
        ERROR_PROVIDER_SPI_FLASH                                  = 68,
        ERROR_PROVIDER_SPI_FLASH_INPUT_STREAM                     = 69,
        ERROR_PROVIDER_USB_DEVICE                                 = 70,
        ERROR_PROVIDER_USB_IN_ENDPOINT                            = 71,
        ERROR_PROVIDER_INTERNAL_FLASH                             = 72,
        ERROR_PROVIDER_INTERNAL_FLASH_SETTINGS                    = 73,
        ERROR_PROVIDER_CAN                                        = 74
      };

    public:

      /**
       * Get the last error.
       * @return The last error to occur or ERROR_NO_ERROR if successful.
       */

      uint32_t getLast() const {
        return _errorCode;
      }


      /**
       * Check if we have an error
       * @return true if we have an error
       */

      bool hasError() const {
        return _errorCode!=ERROR_NO_ERROR;
      }


      /**
       * @return just the error code part (no provider)
       */

      uint16_t getCode() const {
        return _errorCode & 0xFFFF;
      }

      /**
       * Compare the parameters to the last error.
       * @param[in] provider The 16-bit provider code.
       * @param[in] error The 16-bit error code.
       * @return True if the parameters match the last error stored here.
       */

      bool isLastError(uint16_t provider,uint16_t error) const {
        return _errorCode == ((static_cast<uint32_t>(provider) << 16) | error);
      }

      /**
       * Get the error cause, a 32-bit provider-specific value that may be
       * associated with the error that occurred.
       *
       * @return The error cause.
       */

      uint32_t getCause() const {
        return _errorCause;
      }

      /**
       * Get the provider code.
       * @return The provider code.
       */

      uint32_t getProvider() const {
        return _provider;
      }

      /**
       * Clear the status. Resets the last error to zero.
       */

      bool clear() {
        _errorCode=0;
        _errorCause=0;
        return true;
      }

      /**
       * Set the last error to the given values
       * @param[in] errorProviderCode The provider code from the enumeration in this class.
       * @param[in] errorCode The error code from the set defined by the provider.
       * @param[in] errorCause Optional 32-bit value associated with this error.
       * @return false, which is the convention for the return value of a method that wants to indicate to its caller that it has failed.
       */

      bool set(uint32_t errorProviderCode,uint32_t errorCode,uint32_t errorCause=0) {
        _provider=errorProviderCode;
        _errorCode=errorCode | (errorProviderCode << 16);
        _errorCause=errorCause;
        return false;
      }
  };

  /**
   * This is the error provider singleton that is visble throughout the library and externally to users.
   */

  extern ErrorProvider errorProvider;
}
// END FILE: ../lib/include/error/ErrorProvider.h
// START FILE: ../lib/include/timer/f4/Timer8.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Timer8 is an advanced control timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer8 : public AdvancedControlTimer<Timer8<Features...>,PERIPHERAL_TIMER8>,
                 public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer8<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer8()
        : AdvancedControlTimer<TimerType,PERIPHERAL_TIMER8>(TIM8),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/f4/Timer8.h
// START FILE: ../lib/include/timer/f4/Timer4.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Timer4 is a general purpose timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer4 : public GeneralPurposeTimer<Timer4<Features...>,PERIPHERAL_TIMER4>,
                 public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer4<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer4()
        : GeneralPurposeTimer<TimerType,PERIPHERAL_TIMER4>(TIM4),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/f4/Timer4.h
// START FILE: ../lib/include/timer/f4/Timer9.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Timer9 is a general purpose timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer9 : public GeneralPurposeTimer<Timer9<Features...>,PERIPHERAL_TIMER9>,
                 public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer9<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer9()
        : GeneralPurposeTimer<TimerType,PERIPHERAL_TIMER9>(TIM9),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/f4/Timer9.h
// START FILE: ../lib/include/timer/f4/Timer10.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Timer10 is a general purpose timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer10 : public GeneralPurposeTimer<Timer10<Features...>,PERIPHERAL_TIMER10>,
                  public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer10<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer10()
        : GeneralPurposeTimer<TimerType,PERIPHERAL_TIMER10>(TIM10),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/f4/Timer10.h
// START FILE: ../lib/include/timer/f4/Timer12.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Timer12 is a general purpose timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer12 : public GeneralPurposeTimer<Timer12<Features...>,PERIPHERAL_TIMER12>,
                 public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer12<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer12()
        : GeneralPurposeTimer<TimerType,PERIPHERAL_TIMER12>(TIM12),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/f4/Timer12.h
// START FILE: ../lib/include/timer/f4/Timer11.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Timer11 is a general purpose timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer11 : public GeneralPurposeTimer<Timer11<Features...>,PERIPHERAL_TIMER11>,
                  public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer11<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer11()
        : GeneralPurposeTimer<TimerType,PERIPHERAL_TIMER11>(TIM11),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/f4/Timer11.h
// START FILE: ../lib/include/timer/f4/Timer13.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Timer13 is a general purpose timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer13 : public GeneralPurposeTimer<Timer13<Features...>,PERIPHERAL_TIMER13>,
                  public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer13<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer13()
        : GeneralPurposeTimer<TimerType,PERIPHERAL_TIMER13>(TIM13),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/f4/Timer13.h
// START FILE: ../lib/include/timer/f4/Timer5.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Timer5 is a general purpose timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer5 : public GeneralPurposeTimer<Timer5<Features...>,PERIPHERAL_TIMER5>,
                 public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer5<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer5()
        : GeneralPurposeTimer<TimerType,PERIPHERAL_TIMER5>(TIM5),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/f4/Timer5.h
// START FILE: ../lib/include/timer/f4/Timer7.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Timer7 is a basic timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer7 : public BasicTimer<Timer7<Features...>,PERIPHERAL_TIMER7>,
                 public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer7<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer7()
        : BasicTimer<TimerType,PERIPHERAL_TIMER7>(TIM7),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/f4/Timer7.h
// START FILE: ../lib/include/timer/f4/TimerAlternateFunctionMapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Specialisation of the AF mapper for this peripheral. The F4 has the same AF ID
   * regardless of the port so we specialise only on the peripheral
   */

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER1,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM1
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER2,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM2
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER3,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM3
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER4,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM4
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER5,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM5
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER8,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM8
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER9,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM9
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER10,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM10
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER11,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM11
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER12,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM12
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER13,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM13
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_TIMER14,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_TIM14
    };
  };
}
// END FILE: ../lib/include/timer/f4/TimerAlternateFunctionMapper.h
// START FILE: ../lib/include/timer/GeneralPurposeTimer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * General purpose timers are TIM2..5, 9..14
   * @tparam TTimer The timer class type (Timer1, Timer2...)
   */

  template<class TTimer,PeripheralName TPeripheralName>
  class GeneralPurposeTimer : public TimerPeripheral<TTimer,TPeripheralName> {

    protected:
      GeneralPurposeTimer(TIM_TypeDef *peripheralAddress);
 };


  /**
   * Constructor
   */

  template<class TTimer,PeripheralName TPeripheralName>
  inline GeneralPurposeTimer<TTimer,TPeripheralName>::GeneralPurposeTimer(TIM_TypeDef *peripheralAddress)
    : TimerPeripheral<TTimer,TPeripheralName>(peripheralAddress) {
  }
}
// END FILE: ../lib/include/timer/GeneralPurposeTimer.h
// START FILE: ../lib/include/timer/TimerEventSource.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Timer event types
   */

  enum class TimerEventType : uint8_t {
    EVENT_COMPARE1,
    EVENT_COMPARE2,
    EVENT_COMPARE3,
    EVENT_COMPARE4,
    EVENT_UPDATE,
    EVENT_TRIGGER,
    EVENT_BREAK,
    EVENT_COM
  };


  /**
   * The signature for timer events: void myHandler(TimerEventType tet,uint8_t timerNumber);
   * timerNumber is required to differentiate between timers multiplexed on the same IRQ
   */

  DECLARE_EVENT_SIGNATURE(TimerInterrupt,void(TimerEventType,uint8_t));


  /**
   * Base structure that holds just the event subscriber/publisher for timers
   */

  struct TimerEventSource {
    DECLARE_EVENT_SOURCE(TimerInterrupt);
  };
}
// END FILE: ../lib/include/timer/TimerEventSource.h
// START FILE: ../lib/include/timer/Timer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Base class for timer implementations.
   *
   * The timer is observable for interrupts when the implementation has enabled them
   */

  class Timer {

    protected:
      TIM_TypeDef *_peripheralAddress;
      TIM_TimeBaseInitTypeDef _timeBase;
      uint32_t _clock;
      uint32_t _counterMax;

    protected:
      Timer(TIM_TypeDef *peripheralAddress);

    public:
      operator TIM_TypeDef *();
      operator TIM_TimeBaseInitTypeDef *();

      void enablePeripheral() const;
      void disablePeripheral() const;

      uint32_t getPeriod() const;
      uint32_t getClock() const;
      uint32_t getCounterMax() const;
      uint32_t getCounter() const;

      void setClock(uint32_t clock);
      void setCounter(uint32_t counter) const;

      void setPrescaler(uint16_t prescaler,uint16_t reloadMode=TIM_PSCReloadMode_Immediate) const;
      void initialiseTimeBase(uint32_t period,uint16_t prescaler,uint16_t clockDivision,uint16_t counterMode);
      void setTimeBaseByFrequency(uint32_t frequency,uint32_t arr,uint16_t counterMode=TIM_CounterMode_Up);
      void deinitialise();
  };


  /*
   * Constructor
   */

  inline Timer::Timer(TIM_TypeDef *peripheralAddress)
    : _peripheralAddress(peripheralAddress) {

    // clear this down ready for the initialisation that must come shortly after

    TIM_TimeBaseStructInit(&_timeBase);
  }


  /**
   * Initialise the time base for this timer
   * @param period Configures the period value to be loaded into the active Auto-Reload Register at the next update event.
   * @param prescaler Configures the prescaler value used to divide the TIM clock.
   * @param clockDivision TIM_CKD_DIV1/2/4
   * @param counterMode TIM_CounterMode_Up/Down
   */

  inline void Timer::initialiseTimeBase(uint32_t period,uint16_t prescaler,uint16_t clockDivision,uint16_t counterMode) {

    _timeBase.TIM_Period=period;
    _timeBase.TIM_Prescaler=prescaler;
    _timeBase.TIM_ClockDivision=clockDivision;
    _timeBase.TIM_CounterMode=counterMode;

    TIM_TimeBaseInit(_peripheralAddress,&_timeBase);
  }


  /**
   * Convenience function to set the timer clock (TIMxCLK) to the desired frequency. The counter will
   * be an up counter (by default) with a period equal to the arr (auto-reload) value. The lowest
   * frequency that can be set is TIMxCLK / 65536. For a 72Mhz core clock this is 1098 Hz.
   * @param frequency The frequency in Hz.
   * @param arr The auto reload value (0..0xFFFF/0xFFFFFFFF). The timer counter reverses/resets at this value.
   * @param counterMode TIM_CounterMode_* value
   */

  inline void Timer::setTimeBaseByFrequency(uint32_t frequency,uint32_t arr,uint16_t counterMode) {

    initialiseTimeBase(arr,(_clock/frequency)-1,0,counterMode);
  }


  /**
   * Get the maximum value of the timer counter. For 32-bit timers (TIM2/5 on the F4 and TIM2
   * on the F0) this will be 0xFFFFFFFF and for all others it's 0xFFFF
   * @return The maximum counter value
   */

  inline uint32_t Timer::getCounterMax() const {
    return _counterMax;
  }


  /**
   * Return the actual period (the value loaded into the reload register is this period-1)
   * @return The period
   */

  inline uint32_t Timer::getPeriod() const {
    return _timeBase.TIM_Period;
  }


  /**
   * Get the clock value for this timer. For internally clocked APB1 peripherals this is HCLK/2, for
   * internally clocked APB2 peripherals this is HCLK
   * @return The clock frequency in Hz
   */

  inline uint32_t Timer::getClock() const {
    return _clock;
  }


  /**
   * Get the current value of the counter
   * @return The counter value
   */

  inline uint32_t Timer::getCounter() const {
    return TIM_GetCounter(_peripheralAddress);
  }


  /**
   * Get the clock value for this timer. For internally clocked APB1 peripherals this is HCLK/2, for
   * internally clocked APB2 peripherals this is HCLK
   * @param clock The clock frequency in Hz
   */

  inline void Timer::setClock(uint32_t clock) {
    _clock=clock;
  }


  /**
   * Reset the counter to a known value. Useful when not counting automatically, e.g.
   * on an external input.
   * @param counter The new value for the counter
   */

  inline void Timer::setCounter(uint32_t counter) const {
    TIM_SetCounter(_peripheralAddress,counter);
  }


  /**
   * Return the peripheral address
   * @return TIM_TypeDef * peripheral address
   */

  inline Timer::operator TIM_TypeDef *() {
    return _peripheralAddress;
  }


  /**
   * Return the timebase initialisation structure
   */

  inline Timer::operator TIM_TimeBaseInitTypeDef *() {
    return &_timeBase;
  }


  /**
   * Enable this timer
   */

  inline void Timer::enablePeripheral() const {
    TIM_Cmd(_peripheralAddress,ENABLE);
  }


  /**
   * Disable this timer
   */

  inline void Timer::disablePeripheral() const {
    TIM_Cmd(_peripheralAddress,DISABLE);
  }


  /**
   * Set the timer prescaler
   * @param prescaler prescaler value
   * @param reloadMode TIM_PSCReloadMode value (TIM_PSCReloadMode_Update/TIM_PSCReloadMode_Immediate). Default is immediate.
   */

  inline void Timer::setPrescaler(uint16_t prescaler,uint16_t reloadMode) const {
    TIM_PrescalerConfig(_peripheralAddress,prescaler,reloadMode);
  }


  /**
   * De-initialise the timer completely
   */

  inline void Timer::deinitialise() {
    TIM_DeInit(_peripheralAddress);
  }
}
// END FILE: ../lib/include/timer/Timer.h
// START FILE: ../lib/include/timer/AdvancedControlTimer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Advanced control timers are TIM1, TIM8
   * @tparam TTimer The timer class type (Timer1, Timer2...)
   * @tparam TPeripheralName the peripheral class for the clocks
   */

  template<class TTimer,PeripheralName TPeripheralName>
  class AdvancedControlTimer : public TimerPeripheral<TTimer,TPeripheralName> {

    protected:
      AdvancedControlTimer(TIM_TypeDef *peripheralAddress);

    public:
      void initialiseTimeBaseWithRepeat(uint16_t period,uint16_t prescaler,uint16_t clockDivision,uint16_t counterMode,uint8_t repeatCount);
      void setTimeBaseByFrequencyWithRepeat(uint32_t frequency,uint16_t arr,uint16_t counterMode,uint8_t repeatCount);
  };


  /**
   * Constructor
   */

  template<class TTimer,PeripheralName TPeripheralName>
  inline AdvancedControlTimer<TTimer,TPeripheralName>::AdvancedControlTimer(TIM_TypeDef *peripheralAddress)
    : TimerPeripheral<TTimer,TPeripheralName>(peripheralAddress) {
  }


  /**
   * Initialise the time base for this timer
   * @param period Configures the period value to be loaded into the active Auto-Reload Register at the next update event.
   * @param prescaler Configures the prescaler value used to divide the TIM clock.
   * @param clockDivision TIM_CKD_DIV1/2/4
   * @param counterMode TIM_CounterMode_Up/Down
   * @param repeatCount The number of times that a counter must repeat its end-to-end cycle before generating Update.
   */

  template<class TTimer,PeripheralName TPeripheralName>
  inline void AdvancedControlTimer<TTimer,TPeripheralName>::initialiseTimeBaseWithRepeat(uint16_t period,uint16_t prescaler,uint16_t clockDivision,uint16_t counterMode,uint8_t repeatCount) {

    // repeat count is unique to the advanced control timers. Set the value and call the
    // base to complete the init.

    this->_timeBase.TIM_RepetitionCounter=repeatCount;
    Timer::initialiseTimeBase(period,prescaler,clockDivision,counterMode);
  }


  /**
   * Convenience function to set the timer clock (TIMxCLK) to the desired frequency. The counter will
   * be an up counter (by default) with a period equal to the arr (auto-reload) value. The lowest
   * frequency that can be set is TIMxCLK / 65536. For a 72Mhz core clock this is 1098 Hz.
   * @param frequency The frequency in Hz.
   * @param arr The auto reload value (0..65535). The timer counter reverses/resets at this value.
   * @param counterMode TIM_CounterMode_* value
   * @param repeatCount The number of times that a counter must repeat its end-to-end cycle before generating Update.
   */

  template<class TTimer,PeripheralName TPeripheralName>
  inline void AdvancedControlTimer<TTimer,TPeripheralName>::setTimeBaseByFrequencyWithRepeat(uint32_t frequency,uint16_t arr,uint16_t counterMode,uint8_t repeatCount) {

    this->_timeBase.TIM_RepetitionCounter=repeatCount;
    Timer::initialiseTimeBase(arr,(this->_clock/frequency)-1,0,counterMode);
  }
}
// END FILE: ../lib/include/timer/AdvancedControlTimer.h
// START FILE: ../lib/include/timer/Timer14.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Timer14 is a general purpose timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer14 : public GeneralPurposeTimer<Timer14<Features...>,PERIPHERAL_TIMER14>,
                  public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer14<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer14()
        : GeneralPurposeTimer<TimerType,PERIPHERAL_TIMER14>(TIM14),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/Timer14.h
// START FILE: ../lib/include/timer/Timer6.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Timer6 is a basic timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer6 : public BasicTimer<Timer6<Features...>,PERIPHERAL_TIMER6>,
                 public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer6<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer6()
        : BasicTimer<TimerType,PERIPHERAL_TIMER6>(TIM6),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/Timer6.h
// START FILE: ../lib/include/timer/Timer2.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Timer2 is a general purpose timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer2 : public GeneralPurposeTimer<Timer2<Features...>,PERIPHERAL_TIMER2>,
                 public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer2<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer2()
        : GeneralPurposeTimer<TimerType,PERIPHERAL_TIMER2>(TIM2),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/Timer2.h
// START FILE: ../lib/include/timer/TimerPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

 /**
  * The level of remapping required (none, partial1, partial2, full)
  * Not all remap levels are available for each timer. check the ST reference manual for details
  */

  enum TimerGpioRemapLevel {
    TIMER_REMAP_NONE     = 0,
    TIMER_REMAP_PARTIAL1 = 1,
    TIMER_REMAP_PARTIAL2 = 2,
    TIMER_REMAP_FULL     = 3
  };


  /**
   * Generic timer functionality
   * @tparam TTimer The timer class type (Timer1, Timer2...)
   * @tparam TPeripheralName the peripheral class for the clocks
   */

  template<class TTimer,PeripheralName TPeripheralName>
  class TimerPeripheral : public Timer {

    protected:
      TimerPeripheral(TIM_TypeDef *peripheralAddress);
      ~TimerPeripheral();

    public:
      void setPrescalerImmediately(uint16_t value);
      void setPrescalerAtUpdate(uint16_t value);
  };


  /**
   * Constructor
   */

  template<class TTimer,PeripheralName TPeripheralName>
  inline TimerPeripheral<TTimer,TPeripheralName>::TimerPeripheral(TIM_TypeDef *peripheralAddress)
    : Timer(peripheralAddress) {

    // set the counter max (32 or 16-bit)

    _counterMax=PeripheralTraits<TPeripheralName>::COUNTER_MAX;

    // enable the clock before the feature constructors are called

    ClockControl<TPeripheralName>::On();
  }


  /**
   * Destructor
   */

  template<class TTimer,PeripheralName TPeripheralName>
  inline TimerPeripheral<TTimer,TPeripheralName>::~TimerPeripheral() {

    // disable the clock

    ClockControl<TPeripheralName>::Off();
  }


  /**
   * Set the prescaler for this timer immediately
   * @param value the prescaler
   */

  template<class TTimer,PeripheralName TPeripheralName>
  inline void TimerPeripheral<TTimer,TPeripheralName>::setPrescalerImmediately(uint16_t value) {
    TIM_PrescalerConfig(*this,value,TIM_PSCReloadMode_Immediate);
  }


  /**
   * Set the prescaler for this timer at the update event
   * @param value the prescaler
   */

  template<class TTimer,PeripheralName TPeripheralName>
  inline void TimerPeripheral<TTimer,TPeripheralName>::setPrescalerAtUpdate(uint16_t value) {
    TIM_PrescalerConfig(*this,value,TIM_PSCReloadMode_Update);
  }
}
// END FILE: ../lib/include/timer/TimerPeripheral.h
// START FILE: ../lib/include/timer/BasicTimer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * General purpose timers on the F1 are TIM2..5
   * @tparam TTimer The timer class type (Timer1, Timer2...)
   */

  template<class TTimer,PeripheralName TPeripheralName>
  class BasicTimer : public TimerPeripheral<TTimer,TPeripheralName> {

    protected:
      BasicTimer(TIM_TypeDef *peripheralAddress);
 };


  /**
   * Constructor
   */

  template<class TTimer,PeripheralName TPeripheralName>
  inline BasicTimer<TTimer,TPeripheralName>::BasicTimer(TIM_TypeDef *peripheralAddress)
    : TimerPeripheral<TTimer,TPeripheralName>(peripheralAddress) {
  }
}
// END FILE: ../lib/include/timer/BasicTimer.h
// START FILE: ../lib/include/timer/Timer3.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Timer3 is a general purpose timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer3 : public GeneralPurposeTimer<Timer3<Features...>,PERIPHERAL_TIMER3>,
                 public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer3<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer3()
        : GeneralPurposeTimer<TimerType,PERIPHERAL_TIMER3>(TIM3),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/Timer3.h
// START FILE: ../lib/include/timer/features/f4/Timer5RemapLsiFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Remap LSI output to TIM5 channel 4 input
   */

  class Timer5RemapLsiFeature : public TimerFeatureBase {

    public:
      Timer5RemapLsiFeature(Timer& timer);
  };


  /**
   * Constructor
   * @param timer
   */

  inline Timer5RemapLsiFeature::Timer5RemapLsiFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    TIM_RemapConfig(TIM5,TIM5_LSI);
  }
}
// END FILE: ../lib/include/timer/features/f4/Timer5RemapLsiFeature.h
// START FILE: ../lib/include/timer/features/f4/TimerInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


/*
 * Forward declare the IRQ handler names
 */

extern "C" void TIM1_UP_TIM10_IRQHandler();
extern "C" void TIM1_BRK_TIM9_IRQHandler();
extern "C" void TIM1_TRG_COM_TIM11_IRQHandler();
extern "C" void TIM1_CC_IRQHandler();
extern "C" void TIM2_IRQHandler();
extern "C" void TIM3_IRQHandler();
extern "C" void TIM4_IRQHandler();
extern "C" void TIM5_IRQHandler();
extern "C" void TIM6_DAC_IRQHandler();
extern "C" void TIM7_IRQHandler();
extern "C" void TIM8_BRK_TIM12_IRQHandler();
extern "C" void TIM8_UP_TIM13_IRQHandler();
extern "C" void TIM8_TRG_COM_TIM14_IRQHandler();
extern "C" void TIM8_CC_IRQHandler();


namespace stm32plus {


  /**
   * Timer feature to handle interrupts
   * @tparam TTimerNumber The number of the timer 1..14
   */

  template<uint8_t TTimerNumber>
  class TimerInterruptFeature : public TimerFeatureBase,
                                public TimerEventSource {

    protected:
      uint16_t _interruptMask;
      uint8_t _nvicPriority;
      uint8_t _nvicSubPriority;

    public:
      static TimerEventSource *_timerInstance;

    public:
      TimerInterruptFeature(Timer& timer);
      ~TimerInterruptFeature();

      void setNvicPriorities(uint8_t priority,uint8_t subPriority=0);

      void enableInterrupts(uint16_t interruptMask);
      void disableInterrupts(uint16_t interruptMask);

      void clearPendingInterruptsFlag(uint16_t interruptMask) const;
  };

  /*
   * Typedefs for easy use
   */

  typedef TimerInterruptFeature<1> Timer1InterruptFeature;
  typedef TimerInterruptFeature<2> Timer2InterruptFeature;
  typedef TimerInterruptFeature<3> Timer3InterruptFeature;
  typedef TimerInterruptFeature<4> Timer4InterruptFeature;
  typedef TimerInterruptFeature<5> Timer5InterruptFeature;
  typedef TimerInterruptFeature<6> Timer6InterruptFeature;
  typedef TimerInterruptFeature<7> Timer7InterruptFeature;
  typedef TimerInterruptFeature<8> Timer8InterruptFeature;
  typedef TimerInterruptFeature<9> Timer9InterruptFeature;
  typedef TimerInterruptFeature<10> Timer10InterruptFeature;
  typedef TimerInterruptFeature<11> Timer11InterruptFeature;
  typedef TimerInterruptFeature<12> Timer12InterruptFeature;
  typedef TimerInterruptFeature<13> Timer13InterruptFeature;
  typedef TimerInterruptFeature<14> Timer14InterruptFeature;

  /**
   * Template static data member initialisation
   */

  template<uint8_t TTimerNumber>
  TimerEventSource *TimerInterruptFeature<TTimerNumber>::_timerInstance;


  /**
   * Constructor, initialises the interrupt mask for this class to zero.
   */

  template<uint8_t TTimerNumber>
  inline TimerInterruptFeature<TTimerNumber>::TimerInterruptFeature(Timer& timer)
    : TimerFeatureBase(timer) {
    _interruptMask=0;
    _nvicPriority=_nvicSubPriority=0;
    _timerInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  template<uint8_t TTimerNumber>
  inline TimerInterruptFeature<TTimerNumber>::~TimerInterruptFeature() {
    if(_interruptMask!=0)
      disableInterrupts(_interruptMask);
  }


  /**
   * Set the NVIC priority and subpriority numbers.  This function just remembers your
   * numbers. The actual setting of the priority happens in enableInterrupts()
   * @param priority
   * @param subPriority
   */

  template<uint8_t TTimerNumber>
  inline void TimerInterruptFeature<TTimerNumber>::setNvicPriorities(uint8_t priority,uint8_t subPriority) {
    _nvicPriority=priority;
    _nvicSubPriority=subPriority;
  }


  /**
   * Enable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. TIM_IT_UPDATE, TIM_IT_CC1..4
   */

  template<uint8_t TTimerNumber>
  inline void TimerInterruptFeature<TTimerNumber>::enableInterrupts(uint16_t interruptMask) {

    _interruptMask|=interruptMask;
    TimerInterruptFeatureEnabler<TTimerNumber>::enable(interruptMask,_nvicPriority,_nvicSubPriority);
    TIM_ITConfig(_timer,interruptMask,ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. TIM_IT_UPDATE, TIM_IT_CC1..4
   */

  template<uint8_t TTimerNumber>
  inline void TimerInterruptFeature<TTimerNumber>::disableInterrupts(uint16_t interruptMask) {
    _interruptMask&=~interruptMask;
    TIM_ITConfig(_timer,interruptMask,DISABLE);
  }


  /**
   * Clear the selected pending interrupt flags
   * @param interruptMask The bitmask of interrupts, e.g. TIM_IT_UPDATE, TIM_IT_CC1..4
   */

  template<uint8_t TTimerNumber>
  inline void TimerInterruptFeature<TTimerNumber>::clearPendingInterruptsFlag(uint16_t interruptMask) const {
    TIM_ClearITPendingBit(_timer,interruptMask);
  }


  /**
   * Enabler specialisation, timer 1
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<1>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {

    if((interruptMask & TIM_IT_Update)!=0) {
      _forceLinkage=&TIM1_UP_TIM10_IRQHandler;
      Nvic::configureIrq(TIM1_UP_TIM10_IRQn,ENABLE,priority,subPriority);
    }

    if((interruptMask & TIM_IT_Break)!=0) {
      _forceLinkage=&TIM1_BRK_TIM9_IRQHandler;
      Nvic::configureIrq(TIM1_BRK_TIM9_IRQn,ENABLE,priority,subPriority);
    }

    if((interruptMask & (TIM_IT_COM | TIM_IT_Trigger))!=0) {
      _forceLinkage=&TIM1_TRG_COM_TIM11_IRQHandler;
      Nvic::configureIrq(TIM1_TRG_COM_TIM11_IRQn,ENABLE,priority,subPriority);
    }

    if((interruptMask & (TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4))!=0) {
      _forceLinkage=&TIM1_CC_IRQHandler;
      Nvic::configureIrq(TIM1_CC_IRQn,ENABLE,priority,subPriority);
    }
  }


  /**
   * Enabler specialisation, timer 2
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<2>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & (TIM_IT_Update | TIM_IT_Trigger | TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4))!=0) {
      _forceLinkage=&TIM2_IRQHandler;
      Nvic::configureIrq(TIM2_IRQn,ENABLE,priority,subPriority);
    }
  }


  /**
   * Enabler specialisation, timer 3
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<3>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & (TIM_IT_Update | TIM_IT_Trigger | TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4))!=0) {
       _forceLinkage=&TIM3_IRQHandler;
      Nvic::configureIrq(TIM3_IRQn,ENABLE,priority,subPriority);
    }
  }


  /**
   * Enabler specialisation, timer 4
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<4>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & (TIM_IT_Update | TIM_IT_Trigger | TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4))!=0) {
      _forceLinkage=&TIM4_IRQHandler;
      Nvic::configureIrq(TIM4_IRQn,ENABLE,priority,subPriority);
    }
  }


  /**
   * Enabler specialisation, timer 5
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<5>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & (TIM_IT_Update | TIM_IT_Trigger | TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4))!=0) {
      _forceLinkage=&TIM5_IRQHandler;
      Nvic::configureIrq(TIM5_IRQn,ENABLE,priority,subPriority);
    }
  }

#if defined(STM32PLUS_F4_HAS_TIM6_7_8_12_13_14)

  /**
   * Enabler specialisation, timer 6
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<6>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & TIM_IT_Update)!=0) {
      _forceLinkage=&TIM6_DAC_IRQHandler;
      Nvic::configureIrq(TIM6_DAC_IRQn,ENABLE,priority,subPriority);
    }
  }


  /**
   * Enabler specialisation, timer 7
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<7>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & TIM_IT_Update)!=0) {
      _forceLinkage=&TIM7_IRQHandler;
      Nvic::configureIrq(TIM7_IRQn,ENABLE,priority,subPriority);
    }
  }


  /**
   * Enabler specialisation, timer 8
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<8>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {

    if((interruptMask & TIM_IT_Update)!=0) {
      _forceLinkage=&TIM8_UP_TIM13_IRQHandler;
      Nvic::configureIrq(TIM8_UP_TIM13_IRQn,ENABLE,priority,subPriority);
    }

    if((interruptMask & TIM_IT_Break)!=0) {
      _forceLinkage=&TIM8_BRK_TIM12_IRQHandler;
      Nvic::configureIrq(TIM8_BRK_TIM12_IRQn,ENABLE,priority,subPriority);
    }

    if((interruptMask & (TIM_IT_COM | TIM_IT_Trigger))!=0) {
      _forceLinkage=&TIM8_TRG_COM_TIM14_IRQHandler;
      Nvic::configureIrq(TIM8_TRG_COM_TIM14_IRQn,ENABLE,priority,subPriority);
    }

    if((interruptMask & (TIM_IT_CC1 | TIM_IT_CC2 | TIM_IT_CC3 | TIM_IT_CC4))!=0) {
      _forceLinkage=&TIM8_CC_IRQHandler;
      Nvic::configureIrq(TIM8_CC_IRQn,ENABLE,priority,subPriority);
    }
  }

#endif

  /**
   * Enabler specialisation, timer 9
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<9>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & (TIM_IT_Update | TIM_IT_Trigger | TIM_IT_CC1 | TIM_IT_CC2))!=0) {
      _forceLinkage=&TIM1_BRK_TIM9_IRQHandler;
      Nvic::configureIrq(TIM1_BRK_TIM9_IRQn,ENABLE,priority,subPriority);
    }
  }


  /**
   * Enabler specialisation, timer 10
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<10>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & (TIM_IT_Update | TIM_IT_Trigger | TIM_IT_CC1 | TIM_IT_CC2))!=0) {
      _forceLinkage=&TIM1_UP_TIM10_IRQHandler;
      Nvic::configureIrq(TIM1_UP_TIM10_IRQn,ENABLE,priority,subPriority);
    }
  }


  /**
   * Enabler specialisation, timer 11
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<11>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & (TIM_IT_Update | TIM_IT_Trigger | TIM_IT_CC1 | TIM_IT_CC2))!=0) {
      _forceLinkage=&TIM1_TRG_COM_TIM11_IRQHandler;
      Nvic::configureIrq(TIM1_TRG_COM_TIM11_IRQn,ENABLE,priority,subPriority);
    }
  }

#if defined(STM32PLUS_F4_HAS_TIM6_7_8_12_13_14)

  /**
   * Enabler specialisation, timer 12
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<12>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & (TIM_IT_Update | TIM_IT_Trigger | TIM_IT_CC1 | TIM_IT_CC2))!=0) {
      _forceLinkage=&TIM8_BRK_TIM12_IRQHandler;
      Nvic::configureIrq(TIM8_BRK_TIM12_IRQn,ENABLE,priority,subPriority);
    }
  }


  /**
   * Enabler specialisation, timer 13
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<13>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & (TIM_IT_Update | TIM_IT_Trigger | TIM_IT_CC1 | TIM_IT_CC2))!=0) {
      _forceLinkage=&TIM8_UP_TIM13_IRQHandler;
      Nvic::configureIrq(TIM8_UP_TIM13_IRQn,ENABLE,priority,subPriority);
    }
  }


  /**
   * Enabler specialisation, timer 14
   * @param interruptMask TIM_* interrupts to be enabled
   */

  template<>
  inline void TimerInterruptFeatureEnabler<14>::enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority) {
    if((interruptMask & (TIM_IT_Update | TIM_IT_Trigger | TIM_IT_CC1 | TIM_IT_CC2))!=0) {
      _forceLinkage=&TIM8_TRG_COM_TIM14_IRQHandler;
      Nvic::configureIrq(TIM8_TRG_COM_TIM14_IRQn,ENABLE,priority,subPriority);
    }
  }

#endif

}
// END FILE: ../lib/include/timer/features/f4/TimerInterruptFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer4GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM4_PinPackage_Remap_None {
    typedef gpio::PE0 TIM4_ETR_Pin;
    typedef gpio::PB6 TIM4_CH1_Pin;
    typedef gpio::PB7 TIM4_CH2_Pin;
    typedef gpio::PB8 TIM4_CH3_Pin;
    typedef gpio::PB9 TIM4_CH4_Pin;
  };

  struct TIM4_PinPackage_Remap_Full {
    typedef gpio::PD12 TIM4_CH1_Pin;
    typedef gpio::PD13 TIM4_CH2_Pin;
    typedef gpio::PD14 TIM4_CH3_Pin;
    typedef gpio::PD15 TIM4_CH4_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM4_ETR {

    TIM4_ETR() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM4_ETR_Pin::Port),
          TPinPackage::TIM4_ETR_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER4>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER4,
          TPinPackage::TIM4_ETR_Pin::Port,
          TPinPackage::TIM4_ETR_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM4_CH1_IN {

    TIM4_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM4_CH1_Pin::Port),
          TPinPackage::TIM4_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER4>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER4,
          TPinPackage::TIM4_CH1_Pin::Port,
          TPinPackage::TIM4_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM4_CH1_OUT=TIM4_CH1_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM4_CH2_IN {

    TIM4_CH2_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM4_CH2_Pin::Port),
          TPinPackage::TIM4_CH2_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER4>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER4,
          TPinPackage::TIM4_CH2_Pin::Port,
          TPinPackage::TIM4_CH2_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM4_CH2_OUT=TIM4_CH2_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM4_CH3_IN {

    TIM4_CH3_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM4_CH3_Pin::Port),
          TPinPackage::TIM4_CH3_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER4>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER4,
          TPinPackage::TIM4_CH3_Pin::Port,
          TPinPackage::TIM4_CH3_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM4_CH3_OUT=TIM4_CH3_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM4_CH4_IN {

    TIM4_CH4_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM4_CH4_Pin::Port),
          TPinPackage::TIM4_CH4_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER4>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER4,
          TPinPackage::TIM4_CH4_Pin::Port,
          TPinPackage::TIM4_CH4_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM4_CH4_OUT=TIM4_CH4_IN<TPinPackage>;

  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer4GpioFeature<TIMER_REMAP_NONE,TIM4_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer4GpioFeature;

  template<template<typename> class... Features>
  struct Timer4GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM4_PinPackage_Remap_None>... {
    Timer4GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer4GpioFeature<TIMER_REMAP_FULL,Features...> : TimerFeatureBase,Features<TIM4_PinPackage_Remap_Full>... {
    Timer4GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer4CustomGpioFeature : TimerFeatureBase,Features... {
    Timer4CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer4GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer11GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM11_PinPackage_Remap_None {
    typedef gpio::PB9 TIM11_CH1_Pin;
  };

  struct TIM11_PinPackage_Remap_Full {
    typedef gpio::PF7 TIM11_CH1_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM11_CH1_IN {

    TIM11_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM11_CH1_Pin::Port),
          TPinPackage::TIM11_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER11>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER11,
          TPinPackage::TIM11_CH1_Pin::Port,
          TPinPackage::TIM11_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM11_CH1_OUT=TIM11_CH1_IN<TPinPackage>;

  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer11GpioFeature<TIMER_REMAP_NONE,TIM11_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer11GpioFeature;

  template<template<typename> class... Features>
  struct Timer11GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM11_PinPackage_Remap_None>... {
    Timer11GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer11GpioFeature<TIMER_REMAP_FULL,Features...> : TimerFeatureBase,Features<TIM11_PinPackage_Remap_Full>... {
    Timer11GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer11CustomGpioFeature : TimerFeatureBase,Features... {
    Timer11CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer11GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer13GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM13_PinPackage_Remap_None {
    typedef gpio::PA6 TIM13_CH1_Pin;
  };

  struct TIM13_PinPackage_Remap_Full {
    typedef gpio::PF8 TIM13_CH1_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM13_CH1_IN {

    TIM13_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM13_CH1_Pin::Port),
          TPinPackage::TIM13_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER13>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER13,
          TPinPackage::TIM13_CH1_Pin::Port,
          TPinPackage::TIM13_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM13_CH1_OUT=TIM13_CH1_IN<TPinPackage>;

  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer13GpioFeature<TIMER_REMAP_NONE,TIM13_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer13GpioFeature;

  template<template<typename> class... Features>
  struct Timer13GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM13_PinPackage_Remap_None>... {
    Timer13GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer13GpioFeature<TIMER_REMAP_FULL,Features...> : TimerFeatureBase,Features<TIM13_PinPackage_Remap_Full>... {
    Timer13GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer13CustomGpioFeature : TimerFeatureBase,Features... {
    Timer13CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer13GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer3GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM3_PinPackage_Remap_None {
    typedef gpio::PD2 TIM3_ETR_Pin;
    typedef gpio::PA6 TIM3_CH1_Pin;
    typedef gpio::PA7 TIM3_CH2_Pin;
    typedef gpio::PB0 TIM3_CH3_Pin;
    typedef gpio::PB1 TIM3_CH4_Pin;
  };

  struct TIM3_PinPackage_Remap_Partial2 {
    typedef gpio::PB4 TIM3_CH1_Pin;
    typedef gpio::PB5 TIM3_CH2_Pin;
    typedef gpio::PB0 TIM3_CH3_Pin;
    typedef gpio::PB1 TIM3_CH4_Pin;
  };

  struct TIM3_PinPackage_Remap_Full {
    typedef gpio::PC6 TIM3_CH1_Pin;
    typedef gpio::PC7 TIM3_CH2_Pin;
    typedef gpio::PC8 TIM3_CH3_Pin;
    typedef gpio::PC9 TIM3_CH4_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM3_ETR {

    TIM3_ETR() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM3_ETR_Pin::Port),
          TPinPackage::TIM3_ETR_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER3>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER3,
          TPinPackage::TIM3_ETR_Pin::Port,
          TPinPackage::TIM3_ETR_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM3_CH1_IN {

    TIM3_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM3_CH1_Pin::Port),
          TPinPackage::TIM3_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER3>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER3,
          TPinPackage::TIM3_CH1_Pin::Port,
          TPinPackage::TIM3_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM3_CH1_OUT=TIM3_CH1_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM3_CH2_IN {

    TIM3_CH2_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM3_CH2_Pin::Port),
          TPinPackage::TIM3_CH2_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER3>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER3,
          TPinPackage::TIM3_CH2_Pin::Port,
          TPinPackage::TIM3_CH2_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM3_CH2_OUT=TIM3_CH2_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM3_CH3_IN {

    TIM3_CH3_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM3_CH3_Pin::Port),
          TPinPackage::TIM3_CH3_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER3>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER3,
          TPinPackage::TIM3_CH3_Pin::Port,
          TPinPackage::TIM3_CH3_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM3_CH3_OUT=TIM3_CH3_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM3_CH4_IN {

    TIM3_CH4_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM3_CH4_Pin::Port),
          TPinPackage::TIM3_CH4_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER3>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER3,
          TPinPackage::TIM3_CH4_Pin::Port,
          TPinPackage::TIM3_CH4_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM3_CH4_OUT=TIM3_CH4_IN<TPinPackage>;

  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer3GpioFeature<TIMER_REMAP_NONE,TIM3_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer3GpioFeature;

  template<template<typename> class... Features>
  struct Timer3GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM3_PinPackage_Remap_None>... {
    Timer3GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer3GpioFeature<TIMER_REMAP_PARTIAL2,Features...> : TimerFeatureBase,Features<TIM3_PinPackage_Remap_Partial2>... {
    Timer3GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer3GpioFeature<TIMER_REMAP_FULL,Features...> : TimerFeatureBase,Features<TIM3_PinPackage_Remap_Full>... {
    Timer3GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer3CustomGpioFeature : TimerFeatureBase,Features... {
    Timer3CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer3GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer2RemapEthernetPtpFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Remap ethernet PTP to timer 2 ITR1
   */

  class Timer2RemapEthernetPtpFeature : public TimerFeatureBase {

    public:
      Timer2RemapEthernetPtpFeature(Timer& timer);
  };


  /**
   * Constructor
   * @param timer
   */

  inline Timer2RemapEthernetPtpFeature::Timer2RemapEthernetPtpFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    TIM_RemapConfig(TIM2,TIM2_ETH_PTP);
  }
}
// END FILE: ../lib/include/timer/features/f4/Timer2RemapEthernetPtpFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer9GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM9_PinPackage_Remap_None {
    typedef gpio::PA2 TIM9_CH1_Pin;
    typedef gpio::PA3 TIM9_CH2_Pin;
  };

  struct TIM9_PinPackage_Remap_Full {
    typedef gpio::PE5 TIM9_CH1_Pin;
    typedef gpio::PE6 TIM9_CH2_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM9_CH1_IN {

    TIM9_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM9_CH1_Pin::Port),
          TPinPackage::TIM9_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER9>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER9,
          TPinPackage::TIM9_CH1_Pin::Port,
          TPinPackage::TIM9_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM9_CH1_OUT=TIM9_CH1_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM9_CH2_IN {

    TIM9_CH2_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM9_CH2_Pin::Port),
          TPinPackage::TIM9_CH2_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER9>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER9,
          TPinPackage::TIM9_CH2_Pin::Port,
          TPinPackage::TIM9_CH2_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM9_CH2_OUT=TIM9_CH2_IN<TPinPackage>;

  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer9GpioFeature<TIMER_REMAP_NONE,TIM9_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer9GpioFeature;

  template<template<typename> class... Features>
  struct Timer9GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM9_PinPackage_Remap_None>... {
    Timer9GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer9GpioFeature<TIMER_REMAP_FULL,Features...> : TimerFeatureBase,Features<TIM9_PinPackage_Remap_Full>... {
    Timer9GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer9CustomGpioFeature : TimerFeatureBase,Features... {
    Timer9CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer9GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer5GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM5_PinPackage_Remap_None {
    typedef gpio::PA0 TIM5_CH1_Pin;
    typedef gpio::PA1 TIM5_CH2_Pin;
    typedef gpio::PA2 TIM5_CH3_Pin;
    typedef gpio::PA3 TIM5_CH4_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM5_CH1_IN {

    TIM5_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM5_CH1_Pin::Port),
          TPinPackage::TIM5_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER5>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER5,
          TPinPackage::TIM5_CH1_Pin::Port,
          TPinPackage::TIM5_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM5_CH1_OUT=TIM5_CH1_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM5_CH2_IN {

    TIM5_CH2_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM5_CH2_Pin::Port),
          TPinPackage::TIM5_CH2_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER5>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER5,
          TPinPackage::TIM5_CH2_Pin::Port,
          TPinPackage::TIM5_CH2_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM5_CH2_OUT=TIM5_CH2_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM5_CH3_IN {

    TIM5_CH3_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM5_CH3_Pin::Port),
          TPinPackage::TIM5_CH3_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER5>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER5,
          TPinPackage::TIM5_CH3_Pin::Port,
          TPinPackage::TIM5_CH3_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM5_CH3_OUT=TIM5_CH3_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM5_CH4_IN {

    TIM5_CH4_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM5_CH4_Pin::Port),
          TPinPackage::TIM5_CH4_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER5>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER5,
          TPinPackage::TIM5_CH4_Pin::Port,
          TPinPackage::TIM5_CH4_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM5_CH4_OUT=TIM5_CH4_IN<TPinPackage>;

  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer5GpioFeature<TIMER_REMAP_NONE,TIM5_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer5GpioFeature;

  template<template<typename> class... Features>
  struct Timer5GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM5_PinPackage_Remap_None>... {
    Timer5GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer5CustomGpioFeature : TimerFeatureBase,Features... {
    Timer5CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer5GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer2RemapUsbFullSpeedSofFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Remap USB FS SOF to timer 2 ITR1
   */

  class Timer2RemapUsbFullSpeedSofFeature : public TimerFeatureBase {

    public:
      Timer2RemapUsbFullSpeedSofFeature(Timer& timer);
  };


  /**
   * Constructor
   * @param timer
   */

  inline Timer2RemapUsbFullSpeedSofFeature::Timer2RemapUsbFullSpeedSofFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    TIM_RemapConfig(TIM2,TIM2_USBFS_SOF);
  }
}
// END FILE: ../lib/include/timer/features/f4/Timer2RemapUsbFullSpeedSofFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer8GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM8_PinPackage_Remap_None {
    typedef gpio::PA0 TIM8_ETR_Pin;
    typedef gpio::PA6 TIM8_BKIN_Pin;
    typedef gpio::PA7 TIM8_CH1N_Pin;
    typedef gpio::PB0 TIM8_CH2N_Pin;
    typedef gpio::PB1 TIM8_CH3N_Pin;
    typedef gpio::PC6 TIM8_CH1_Pin;
    typedef gpio::PC7 TIM8_CH2_Pin;
    typedef gpio::PC8 TIM8_CH3_Pin;
    typedef gpio::PC9 TIM8_CH4_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM8_ETR {

    TIM8_ETR() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM8_ETR_Pin::Port),
          TPinPackage::TIM8_ETR_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER8>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER8,
          TPinPackage::TIM8_ETR_Pin::Port,
          TPinPackage::TIM8_ETR_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM8_BKIN {

    TIM8_BKIN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM8_BKIN_Pin::Port),
          TPinPackage::TIM8_BKIN_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER8>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER8,
          TPinPackage::TIM8_BKIN_Pin::Port,
          TPinPackage::TIM8_BKIN_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM8_CH1N {

    TIM8_CH1N() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM8_CH1N_Pin::Port),
          TPinPackage::TIM8_CH1N_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER8>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER8,
          TPinPackage::TIM8_CH1N_Pin::Port,
          TPinPackage::TIM8_CH1N_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM8_CH2N {

    TIM8_CH2N() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM8_CH2N_Pin::Port),
          TPinPackage::TIM8_CH2N_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER8>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER8,
          TPinPackage::TIM8_CH2N_Pin::Port,
          TPinPackage::TIM8_CH2N_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM8_CH3N {

    TIM8_CH3N() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM8_CH3N_Pin::Port),
          TPinPackage::TIM8_CH3N_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER8>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER8,
          TPinPackage::TIM8_CH3N_Pin::Port,
          TPinPackage::TIM8_CH3N_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM8_CH1_IN {

    TIM8_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM8_CH1_Pin::Port),
          TPinPackage::TIM8_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER8>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER8,
          TPinPackage::TIM8_CH1_Pin::Port,
          TPinPackage::TIM8_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM8_CH1_OUT=TIM8_CH1_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM8_CH2_IN {

    TIM8_CH2_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM8_CH2_Pin::Port),
          TPinPackage::TIM8_CH2_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER8>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER8,
          TPinPackage::TIM8_CH2_Pin::Port,
          TPinPackage::TIM8_CH2_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM8_CH2_OUT=TIM8_CH2_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM8_CH3_IN {

    TIM8_CH3_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM8_CH3_Pin::Port),
          TPinPackage::TIM8_CH3_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER8>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER8,
          TPinPackage::TIM8_CH3_Pin::Port,
          TPinPackage::TIM8_CH3_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM8_CH3_OUT=TIM8_CH3_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM8_CH4_IN {

    TIM8_CH4_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM8_CH4_Pin::Port),
          TPinPackage::TIM8_CH4_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER8>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER8,
          TPinPackage::TIM8_CH4_Pin::Port,
          TPinPackage::TIM8_CH4_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM8_CH4_OUT=TIM8_CH4_IN<TPinPackage>;

  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer8GpioFeature<TIMER_REMAP_NONE,TIM8_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer8GpioFeature;

  template<template<typename> class... Features>
  struct Timer8GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM8_PinPackage_Remap_None>... {
    Timer8GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer8CustomGpioFeature : TimerFeatureBase,Features... {
    Timer8CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer8GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/TimerInternalClockFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Feature class to configure the timer as using the internal clock as
   * its source.
   */

  template<uint8_t TAPBBusNumber>
  class TimerInternalClockFeature : public TimerFeatureBase {
    public:
      TimerInternalClockFeature(Timer& timer);
  };


  /**
   * Specialisations for APB1 and APB2. The bus prescaler and the not very well documented
   * x2 multiplier that applies when the prescaler is not 1 are taken into account when
   * setting the timer clock.
   *
   * TIM1,8,9,10,11 are on APB2. The remainder are on APB1
   */

  template<>
  inline TimerInternalClockFeature<1>::TimerInternalClockFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    uint32_t timerClock;

    switch(RCC->CFGR & RCC_CFGR_PPRE1) {

      case RCC_CFGR_PPRE1_DIV1:             // additional multiplier = 1
      case RCC_CFGR_PPRE1_DIV2:             // additional multiplier = 2
        timerClock=SystemCoreClock;
        break;

      case RCC_CFGR_PPRE1_DIV4:             // additional multiplier = 2
        timerClock=SystemCoreClock/2;
        break;

      case RCC_CFGR_PPRE1_DIV8:             // additional multiplier = 2
        timerClock=SystemCoreClock/4;
        break;

      case RCC_CFGR_PPRE1_DIV16:            // additional multiplier = 2
      default:
        timerClock=SystemCoreClock/8;
        break;
    }

    // set up the internal clock

    TIM_InternalClockConfig(timer);
    timer.setClock(timerClock);
  }


  template<>
  inline TimerInternalClockFeature<2>::TimerInternalClockFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    uint32_t timerClock;

    switch(RCC->CFGR & RCC_CFGR_PPRE2) {

      case RCC_CFGR_PPRE2_DIV1:             // additional multiplier = 1
      case RCC_CFGR_PPRE2_DIV2:             // additional multiplier = 2
        timerClock=SystemCoreClock;
        break;

      case RCC_CFGR_PPRE2_DIV4:             // additional multiplier = 2
        timerClock=SystemCoreClock/2;
        break;

      case RCC_CFGR_PPRE2_DIV8:             // additional multiplier = 2
        timerClock=SystemCoreClock/4;
        break;

      case RCC_CFGR_PPRE2_DIV16:            // additional multiplier = 2
      default:
        timerClock=SystemCoreClock/8;
        break;
    }

    // set up the internal clock

    TIM_InternalClockConfig(timer);
    timer.setClock(timerClock);
  }

  /*
   * Helpers for easy user access to this class
   */

  typedef TimerInternalClockFeature<2> Timer1InternalClockFeature;
  typedef TimerInternalClockFeature<1> Timer2InternalClockFeature;
  typedef TimerInternalClockFeature<1> Timer3InternalClockFeature;
  typedef TimerInternalClockFeature<1> Timer4InternalClockFeature;
  typedef TimerInternalClockFeature<1> Timer5InternalClockFeature;
  typedef TimerInternalClockFeature<1> Timer6InternalClockFeature;
  typedef TimerInternalClockFeature<1> Timer7InternalClockFeature;
  typedef TimerInternalClockFeature<2> Timer8InternalClockFeature;
  typedef TimerInternalClockFeature<2> Timer9InternalClockFeature;
  typedef TimerInternalClockFeature<2> Timer10InternalClockFeature;
  typedef TimerInternalClockFeature<2> Timer11InternalClockFeature;
  typedef TimerInternalClockFeature<1> Timer12InternalClockFeature;
  typedef TimerInternalClockFeature<1> Timer13InternalClockFeature;
  typedef TimerInternalClockFeature<1> Timer14InternalClockFeature;
}
// END FILE: ../lib/include/timer/features/f4/TimerInternalClockFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer2RemapUsbHighSpeedSofFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Remap USB HS SOF to timer 2 ITR1
   */

  class Timer2RemapUsbHighSpeedSofFeature : public TimerFeatureBase {

    public:
      Timer2RemapUsbHighSpeedSofFeature(Timer& timer);
  };


  /**
   * Constructor
   * @param timer
   */

  inline Timer2RemapUsbHighSpeedSofFeature::Timer2RemapUsbHighSpeedSofFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    TIM_RemapConfig(TIM2,TIM2_USBHS_SOF);
  }
}
// END FILE: ../lib/include/timer/features/f4/Timer2RemapUsbHighSpeedSofFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer2GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM2_PinPackage_Remap_None {
    typedef gpio::PA0 TIM2_ETR_Pin;
    typedef gpio::PA0 TIM2_CH1_Pin;
    typedef gpio::PA1 TIM2_CH2_Pin;
    typedef gpio::PA2 TIM2_CH3_Pin;
    typedef gpio::PA3 TIM2_CH4_Pin;
  };

  struct TIM2_PinPackage_Remap_Partial1 {
    typedef gpio::PA15 TIM2_ETR_Pin;
    typedef gpio::PA15 TIM2_CH1_Pin;
    typedef gpio::PB3 TIM2_CH2_Pin;
    typedef gpio::PA2 TIM2_CH3_Pin;
    typedef gpio::PA3 TIM2_CH4_Pin;
  };

  struct TIM2_PinPackage_Remap_Partial2 {
    typedef gpio::PA0 TIM2_ETR_Pin;
    typedef gpio::PA0 TIM2_CH1_Pin;
    typedef gpio::PA1 TIM2_CH2_Pin;
    typedef gpio::PB10 TIM2_CH3_Pin;
    typedef gpio::PB11 TIM2_CH4_Pin;
  };

  struct TIM2_PinPackage_Remap_Full {
    typedef gpio::PA15 TIM2_ETR_Pin;
    typedef gpio::PA15 TIM2_CH1_Pin;
    typedef gpio::PB3 TIM2_CH2_Pin;
    typedef gpio::PB10 TIM2_CH3_Pin;
    typedef gpio::PB11 TIM2_CH4_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM2_ETR {

    TIM2_ETR() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM2_ETR_Pin::Port),
          TPinPackage::TIM2_ETR_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER2>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER2,
          TPinPackage::TIM2_ETR_Pin::Port,
          TPinPackage::TIM2_ETR_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM2_CH1_IN {

    TIM2_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM2_CH1_Pin::Port),
          TPinPackage::TIM2_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER2>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER2,
          TPinPackage::TIM2_CH1_Pin::Port,
          TPinPackage::TIM2_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM2_CH1_OUT=TIM2_CH1_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM2_CH2_IN {

    TIM2_CH2_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM2_CH2_Pin::Port),
          TPinPackage::TIM2_CH2_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER2>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER2,
          TPinPackage::TIM2_CH2_Pin::Port,
          TPinPackage::TIM2_CH2_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM2_CH2_OUT=TIM2_CH2_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM2_CH3_IN {

    TIM2_CH3_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM2_CH3_Pin::Port),
          TPinPackage::TIM2_CH3_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER2>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER2,
          TPinPackage::TIM2_CH3_Pin::Port,
          TPinPackage::TIM2_CH3_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM2_CH3_OUT=TIM2_CH3_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM2_CH4_IN {

    TIM2_CH4_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM2_CH4_Pin::Port),
          TPinPackage::TIM2_CH4_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER2>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER2,
          TPinPackage::TIM2_CH4_Pin::Port,
          TPinPackage::TIM2_CH4_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM2_CH4_OUT=TIM2_CH4_IN<TPinPackage>;

  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer2GpioFeature<TIMER_REMAP_NONE,TIM2_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer2GpioFeature;

  template<template<typename> class... Features>
  struct Timer2GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM2_PinPackage_Remap_None>... {
    Timer2GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer2GpioFeature<TIMER_REMAP_PARTIAL1,Features...> : TimerFeatureBase,Features<TIM2_PinPackage_Remap_Partial1>... {
    Timer2GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer2GpioFeature<TIMER_REMAP_PARTIAL2,Features...> : TimerFeatureBase,Features<TIM2_PinPackage_Remap_Partial2>... {
    Timer2GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer2GpioFeature<TIMER_REMAP_FULL,Features...> : TimerFeatureBase,Features<TIM2_PinPackage_Remap_Full>... {
    Timer2GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer2CustomGpioFeature : TimerFeatureBase,Features... {
    Timer2CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer2GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer5RemapLseFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Remap LSE output to TIM5 channel 4 input
   */

  class Timer5RemapLseFeature : public TimerFeatureBase {

    public:
      Timer5RemapLseFeature(Timer& timer);
  };


  /**
   * Constructor
   * @param timer
   */

  inline Timer5RemapLseFeature::Timer5RemapLseFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    TIM_RemapConfig(TIM5,TIM5_LSE);
  }
}
// END FILE: ../lib/include/timer/features/f4/Timer5RemapLseFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer14GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM14_PinPackage_Remap_None {
    typedef gpio::PA7 TIM14_CH1_Pin;
  };

  struct TIM14_PinPackage_Remap_Full {
    typedef gpio::PF9 TIM14_CH1_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM14_CH1_IN {

    TIM14_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM14_CH1_Pin::Port),
          TPinPackage::TIM14_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER14>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER14,
          TPinPackage::TIM14_CH1_Pin::Port,
          TPinPackage::TIM14_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM14_CH1_OUT=TIM14_CH1_IN<TPinPackage>;

  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer14GpioFeature<TIMER_REMAP_NONE,TIM14_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer14GpioFeature;

  template<template<typename> class... Features>
  struct Timer14GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM14_PinPackage_Remap_None>... {
    Timer14GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer14GpioFeature<TIMER_REMAP_FULL,Features...> : TimerFeatureBase,Features<TIM14_PinPackage_Remap_Full>... {
    Timer14GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer14CustomGpioFeature : TimerFeatureBase,Features... {
    Timer14CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer14GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer1GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM1_PinPackage_Remap_None {
    typedef gpio::PA12 TIM1_ETR_Pin;
    typedef gpio::PA8 TIM1_CH1_Pin;
    typedef gpio::PA9 TIM1_CH2_Pin;
    typedef gpio::PA10 TIM1_CH3_Pin;
    typedef gpio::PA11 TIM1_CH4_Pin;
    typedef gpio::PB12 TIM1_BKIN_Pin;
    typedef gpio::PB13 TIM1_CH1N_Pin;
    typedef gpio::PB14 TIM1_CH2N_Pin;
    typedef gpio::PB15 TIM1_CH3N_Pin;
  };

  struct TIM1_PinPackage_Remap_Partial1 {
    typedef gpio::PA12 TIM1_ETR_Pin;
    typedef gpio::PA8 TIM1_CH1_Pin;
    typedef gpio::PA9 TIM1_CH2_Pin;
    typedef gpio::PA10 TIM1_CH3_Pin;
    typedef gpio::PA11 TIM1_CH4_Pin;
    typedef gpio::PA6 TIM1_BKIN_Pin;
    typedef gpio::PA7 TIM1_CH1N_Pin;
    typedef gpio::PB0 TIM1_CH2N_Pin;
    typedef gpio::PB1 TIM1_CH3N_Pin;
  };

  struct TIM1_PinPackage_Remap_Full {
    typedef gpio::PE7 TIM1_ETR_Pin;
    typedef gpio::PE9 TIM1_CH1_Pin;
    typedef gpio::PE11 TIM1_CH2_Pin;
    typedef gpio::PE13 TIM1_CH3_Pin;
    typedef gpio::PE14 TIM1_CH4_Pin;
    typedef gpio::PE15 TIM1_BKIN_Pin;
    typedef gpio::PE8 TIM1_CH1N_Pin;
    typedef gpio::PE10 TIM1_CH2N_Pin;
    typedef gpio::PE12 TIM1_CH3N_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM1_ETR {

    TIM1_ETR() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM1_ETR_Pin::Port),
          TPinPackage::TIM1_ETR_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER1>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER1,
          TPinPackage::TIM1_ETR_Pin::Port,
          TPinPackage::TIM1_ETR_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM1_CH1_IN {

    TIM1_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM1_CH1_Pin::Port),
          TPinPackage::TIM1_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER1>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER1,
          TPinPackage::TIM1_CH1_Pin::Port,
          TPinPackage::TIM1_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM1_CH1_OUT=TIM1_CH1_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM1_CH2_IN {

    TIM1_CH2_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM1_CH2_Pin::Port),
          TPinPackage::TIM1_CH2_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER1>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER1,
          TPinPackage::TIM1_CH2_Pin::Port,
          TPinPackage::TIM1_CH2_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM1_CH2_OUT=TIM1_CH2_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM1_CH3_IN {

    TIM1_CH3_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM1_CH3_Pin::Port),
          TPinPackage::TIM1_CH3_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER1>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER1,
          TPinPackage::TIM1_CH3_Pin::Port,
          TPinPackage::TIM1_CH3_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM1_CH3_OUT=TIM1_CH3_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM1_CH4_IN {

    TIM1_CH4_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM1_CH4_Pin::Port),
          TPinPackage::TIM1_CH4_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER1>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER1,
          TPinPackage::TIM1_CH4_Pin::Port,
          TPinPackage::TIM1_CH4_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM1_CH4_OUT=TIM1_CH4_IN<TPinPackage>;

  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM1_BKIN {

    TIM1_BKIN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM1_BKIN_Pin::Port),
          TPinPackage::TIM1_BKIN_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER1>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER1,
          TPinPackage::TIM1_BKIN_Pin::Port,
          TPinPackage::TIM1_BKIN_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM1_CH1N {

    TIM1_CH1N() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM1_CH1N_Pin::Port),
          TPinPackage::TIM1_CH1N_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER1>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER1,
          TPinPackage::TIM1_CH1N_Pin::Port,
          TPinPackage::TIM1_CH1N_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM1_CH2N {

    TIM1_CH2N() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM1_CH2N_Pin::Port),
          TPinPackage::TIM1_CH2N_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER1>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER1,
          TPinPackage::TIM1_CH2N_Pin::Port,
          TPinPackage::TIM1_CH2N_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM1_CH3N {

    TIM1_CH3N() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM1_CH3N_Pin::Port),
          TPinPackage::TIM1_CH3N_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER1>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER1,
          TPinPackage::TIM1_CH3N_Pin::Port,
          TPinPackage::TIM1_CH3N_Pin::Pin>::GPIO_AF);
      }
  };


  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer1GpioFeature<TIMER_REMAP_NONE,TIM1_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer1GpioFeature;

  template<template<typename> class... Features>
  struct Timer1GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM1_PinPackage_Remap_None>... {
    Timer1GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer1GpioFeature<TIMER_REMAP_PARTIAL1,Features...> : TimerFeatureBase,Features<TIM1_PinPackage_Remap_Partial1>... {
    Timer1GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer1GpioFeature<TIMER_REMAP_FULL,Features...> : TimerFeatureBase,Features<TIM1_PinPackage_Remap_Full>... {
    Timer1GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer1CustomGpioFeature : TimerFeatureBase,Features... {
    Timer1CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer1GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer10GpioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 to 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 *
 * THIS IS AN AUTOMATICALLY GENERATED FILE - DO NOT EDIT!
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif

namespace stm32plus {

  struct TIM10_PinPackage_Remap_None {
    typedef gpio::PB8 TIM10_CH1_Pin;
  };

  struct TIM10_PinPackage_Remap_Full {
    typedef gpio::PF6 TIM10_CH1_Pin;
  };


  /**
   * Initialise GPIO pins for this timer GPIO mode
   * @tparam TPinPackage A type containing pin definitions for this timer feature
   */

  template<typename TPinPackage>
  struct TIM10_CH1_IN {

    TIM10_CH1_IN() {
      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TPinPackage::TIM10_CH1_Pin::Port),
          TPinPackage::TIM10_CH1_Pin::Pin,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)PeripheralTraits<PERIPHERAL_TIMER10>::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_TIMER10,
          TPinPackage::TIM10_CH1_Pin::Port,
          TPinPackage::TIM10_CH1_Pin::Pin>::GPIO_AF);
      }
  };

  template<typename TPinPackage> using TIM10_CH1_OUT=TIM10_CH1_IN<TPinPackage>;

  /**
   * Timer feature to enable any number of the GPIO alternate function outputs.
   * All remap levels are supported. An example declaration could be:
   *
   * Timer10GpioFeature<TIMER_REMAP_NONE,TIM10_CH1_OUT>
   */

  template<TimerGpioRemapLevel TRemapLevel,template<typename> class... Features>
  struct Timer10GpioFeature;

  template<template<typename> class... Features>
  struct Timer10GpioFeature<TIMER_REMAP_NONE,Features...> : TimerFeatureBase,Features<TIM10_PinPackage_Remap_None>... {
    Timer10GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  template<template<typename> class... Features>
  struct Timer10GpioFeature<TIMER_REMAP_FULL,Features...> : TimerFeatureBase,Features<TIM10_PinPackage_Remap_Full>... {
    Timer10GpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };

  /**
   * Custom structure to allow any pin mapping.
   *
   * e.g:
   *    Timer14CustomGpioFeature<TIM14_CH1_OUT<Myclass>>
   * and in "MyClass" you would do a public declaration:
   *    typedef gpio::PF9 TIM14_CH1_Pin;
   */

  template<class... Features>
  struct Timer10CustomGpioFeature : TimerFeatureBase,Features... {
    Timer10CustomGpioFeature(Timer& timer) : TimerFeatureBase(timer) {
    }
  };
}
// END FILE: ../lib/include/timer/features/f4/Timer10GpioFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer11RemapHseFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Remap HSE/prescaler to TIM11 channel 1 input
   */

  class Timer11RemapHseFeature : public TimerFeatureBase {

    public:
      Timer11RemapHseFeature(Timer& timer);
  };


  /**
   * Constructor
   * @param timer
   */

  inline Timer11RemapHseFeature::Timer11RemapHseFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    TIM_RemapConfig(TIM11,TIM11_HSE);
  }
}
// END FILE: ../lib/include/timer/features/f4/Timer11RemapHseFeature.h
// START FILE: ../lib/include/timer/features/f4/Timer5RemapRtcFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Remap RTC output to TIM5 channel 4 input
   */

  class Timer5RemapRtcFeature : public TimerFeatureBase {

    public:
      Timer5RemapRtcFeature(Timer& timer);
  };


  /**
   * Constructor
   * @param timer
   */

  inline Timer5RemapRtcFeature::Timer5RemapRtcFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    TIM_RemapConfig(TIM5,TIM5_RTC);
  }
}
// END FILE: ../lib/include/timer/features/f4/Timer5RemapRtcFeature.h
// START FILE: ../lib/include/timer/features/channel/TimerChannelOCPulseFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to set the OC polarity
   */

  template<uint16_t TPulse>
  struct TimerChannelOCPulseFeature {

    /**
     * Constructor, set the flag in the OC struct
     */

    TimerChannelOCPulseFeature(TimerChannelFeatureBase& tcfb) {
      static_cast<TIM_OCInitTypeDef&>(tcfb).TIM_Pulse=TPulse;
    }
  };
}
// END FILE: ../lib/include/timer/features/channel/TimerChannelOCPulseFeature.h
// START FILE: ../lib/include/timer/features/channel/TimerChannelICPolarityFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to set the IC polarity
   */

  template<uint16_t TPolarity>
  struct TimerChannelICPolarityFeature {

    /**
     * Constructor, set the flag in the IC struct
     */

    TimerChannelICPolarityFeature(TimerChannelFeatureBase& tcfb) {
      static_assert(TPolarity==TIM_ICPolarity_Rising || TPolarity==TIM_ICPolarity_Falling || TPolarity==TIM_ICPolarity_BothEdge,"Invalid polarity type");

      TIM_ICInitTypeDef& ici=static_cast<TIM_ICInitTypeDef&>(tcfb);

      ici.TIM_ICPolarity=TPolarity;
    }
  };

  /**
   * Typedefs that avoid the templates
   */

  typedef TimerChannelICPolarityFeature<TIM_ICPolarity_Rising> TimerChannelICRisingEdgeFeature;
  typedef TimerChannelICPolarityFeature<TIM_ICPolarity_Falling> TimerChanneICFallingEdgeFeature;
  typedef TimerChannelICPolarityFeature<TIM_ICPolarity_BothEdge> TimerChannelICBothEdgesFeature;
}
// END FILE: ../lib/include/timer/features/channel/TimerChannelICPolarityFeature.h
// START FILE: ../lib/include/timer/features/channel/TimerChannelOCNIdleStateFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to set the OCN idle state
   */

  template<uint16_t TIdleState>
  struct TimerChannelOCNIdleStateFeature {

    /**
     * Constructor, set the flag in the OC struct
     */

    TimerChannelOCNIdleStateFeature(TimerChannelFeatureBase& tcfb) {
      static_assert(TIdleState==TIM_OCNIdleState_Set || TIdleState==TIM_OCNIdleState_Reset,"Invalid N idle state type");
      static_cast<TIM_OCInitTypeDef&>(tcfb).TIM_OCNIdleState=TIdleState;
    }
  };

  /**
   * Typedefs that avoid the templates
   */

  typedef TimerChannelOCNIdleStateFeature<TIM_OCNIdleState_Set> TimerChannelOCNHighIdleFeature;
  typedef TimerChannelOCNIdleStateFeature<TIM_OCNIdleState_Reset> TimerChannelOCNLowIdleFeature;
}
// END FILE: ../lib/include/timer/features/channel/TimerChannelOCNIdleStateFeature.h
// START FILE: ../lib/include/timer/features/channel/TimerChannelICSelectionFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to set the IC selection (internal connections)
   */

  template<uint16_t TSelection>
  struct TimerChannelICSelectionFeature {

    /**
     * Constructor, set the flag in the IC struct
     */

    TimerChannelICSelectionFeature(TimerChannelFeatureBase& tcfb) {
      static_assert(TSelection==TIM_ICSelection_DirectTI ||
                    TSelection==TIM_ICSelection_IndirectTI ||
                    TSelection==TIM_ICSelection_TRC,"Invalid IC selection type");

      TIM_ICInitTypeDef& ici=static_cast<TIM_ICInitTypeDef&>(tcfb);

      ici.TIM_ICSelection=TSelection;
    }
  };

  /**
   * Typedefs that avoid the templates
   */

  typedef TimerChannelICSelectionFeature<TIM_ICSelection_DirectTI> TimerChannelICDirectTiFeature;
  typedef TimerChannelICSelectionFeature<TIM_ICSelection_IndirectTI> TimerChanneICIndirectTiFeature;
  typedef TimerChannelICSelectionFeature<TIM_ICSelection_TRC> TimerChannelICTrcFeature;
}
// END FILE: ../lib/include/timer/features/channel/TimerChannelICSelectionFeature.h
// START FILE: ../lib/include/timer/features/channel/TimerChannelOCModeFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to enable OC mode
   */

  template<uint16_t TMode>
  struct TimerChannelOCModeFeature {

    /**
     * Constructor, set the flag in the OC struct
     */

    TimerChannelOCModeFeature(TimerChannelFeatureBase& tcfb) {

      static_assert(TMode==TIM_OCMode_Timing ||
                    TMode==TIM_OCMode_Active ||
                    TMode==TIM_OCMode_Inactive ||
                    TMode==TIM_OCMode_Toggle ||
                    TMode==TIM_OCMode_PWM1 ||
                    TMode==TIM_OCMode_PWM2,"Invalid OC mode");

      static_cast<TIM_OCInitTypeDef&>(tcfb).TIM_OCMode=TMode;
    }
  };

  /**
   * Typedefs that avoid the templates
   */

  typedef TimerChannelOCModeFeature<TIM_OCMode_Timing> TimerChannelOCTimingModeFeature;
  typedef TimerChannelOCModeFeature<TIM_OCMode_Active> TimerChannelOCActiveModeFeature;
  typedef TimerChannelOCModeFeature<TIM_OCMode_Inactive> TimerChannelOCInactiveModeFeature;
  typedef TimerChannelOCModeFeature<TIM_OCMode_Toggle> TimerChannelOCToggleModeFeature;
  typedef TimerChannelOCModeFeature<TIM_OCMode_PWM1> TimerChannelOCPWM1ModeFeature;
  typedef TimerChannelOCModeFeature<TIM_OCMode_PWM2> TimerChannelOCPWM2ModeFeature;
}
// END FILE: ../lib/include/timer/features/channel/TimerChannelOCModeFeature.h
// START FILE: ../lib/include/timer/features/channel/TimerChannelOCPolarityFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to set the OC polarity
   */

  template<uint16_t TPolarity>
  struct TimerChannelOCPolarityFeature {

    /**
     * Constructor, set the flag in the OC struct
     */

    TimerChannelOCPolarityFeature(TimerChannelFeatureBase& tcfb) {
      static_assert(TPolarity==TIM_OCPolarity_High || TPolarity==TIM_OCPolarity_Low,"Invalid polarity type");

      TIM_OCInitTypeDef& oci=static_cast<TIM_OCInitTypeDef&>(tcfb);

      oci.TIM_OCPolarity=TPolarity;
      oci.TIM_OutputState=TIM_OutputState_Enable;
    }
  };

  /**
   * Typedefs that avoid the templates
   */

  typedef TimerChannelOCPolarityFeature<TIM_OCPolarity_High> TimerChannelOCHighPolarityFeature;
  typedef TimerChannelOCPolarityFeature<TIM_OCPolarity_Low> TimerChannelOCLowPolarityFeature;
}
// END FILE: ../lib/include/timer/features/channel/TimerChannelOCPolarityFeature.h
// START FILE: ../lib/include/timer/features/channel/TimerChannelOCIdleStateFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to set the OC idle state
   */

  template<uint16_t TIdleState>
  struct TimerChannelOCIdleStateFeature {

    /**
     * Constructor, set the flag in the OC struct
     */

    TimerChannelOCIdleStateFeature(TimerChannelFeatureBase& tcfb) {
      static_assert(TIdleState==TIM_OCIdleState_Set || TIdleState==TIM_OCIdleState_Reset,"Invalid idle state type");
      static_cast<TIM_OCInitTypeDef&>(tcfb).TIM_OCIdleState=TIdleState;
    }
  };

  /**
   * Typedefs that avoid the templates
   */

  typedef TimerChannelOCIdleStateFeature<TIM_OCIdleState_Set> TimerChannelOCHighIdleFeature;
  typedef TimerChannelOCIdleStateFeature<TIM_OCIdleState_Reset> TimerChannelOCLowIdleFeature;
}
// END FILE: ../lib/include/timer/features/channel/TimerChannelOCIdleStateFeature.h
// START FILE: ../lib/include/timer/features/channel/TimerChannelICFilterFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to set the IC filter to a value between 0 and 0xf
   */

  template<uint8_t TFilter>
  struct TimerChannelICFilterFeature {

    /**
     * Constructor, set the value in the IC struct
     */

    TimerChannelICFilterFeature(TimerChannelFeatureBase& tcfb) {
      static_assert(TFilter<=0xf,"Invalid IC filter value");

      TIM_ICInitTypeDef& ici=static_cast<TIM_ICInitTypeDef&>(tcfb);

      ici.TIM_ICFilter=TFilter;
    }
  };
}
// END FILE: ../lib/include/timer/features/channel/TimerChannelICFilterFeature.h
// START FILE: ../lib/include/timer/features/channel/TimerChannelOCNPolarityFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to set the OCN polarity
   */

  template<uint16_t TPolarity>
  struct TimerChannelOCNPolarityFeature {

    /**
     * Constructor, set the flag in the OC struct
     */

    TimerChannelOCNPolarityFeature(TimerChannelFeatureBase& tcfb) {
      static_assert(TPolarity==TIM_OCNPolarity_High || TPolarity==TIM_OCNPolarity_Low,"Invalid polarity type");

      TIM_OCInitTypeDef& oci=static_cast<TIM_OCInitTypeDef&>(tcfb);

      oci.TIM_OCNPolarity=TPolarity;
      oci.TIM_OutputNState=TIM_OutputNState_Enable;
    }
  };

  /**
   * Typedefs that avoid the templates
   */

  typedef TimerChannelOCNPolarityFeature<TIM_OCNPolarity_High> TimerChannelOCNHighPolarityFeature;
  typedef TimerChannelOCNPolarityFeature<TIM_OCNPolarity_Low> TimerChannelOCNLowPolarityFeature;
}
// END FILE: ../lib/include/timer/features/channel/TimerChannelOCNPolarityFeature.h
// START FILE: ../lib/include/timer/features/channel/TimerChannelICPrescalerFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to set the IC prescaler
   */

  template<uint16_t TPrescaler>
  struct TimerChannelICPrescalerFeature {

    /**
     * Constructor, set the flag in the IC struct
     */

    TimerChannelICPrescalerFeature(TimerChannelFeatureBase& tcfb) {
      static_assert(TPrescaler==TIM_ICPSC_DIV1 ||
                    TPrescaler==TIM_ICPSC_DIV2 ||
                    TPrescaler==TIM_ICPSC_DIV4 ||
                    TPrescaler==TIM_ICPSC_DIV8,"Invalid IC prescaler");

      TIM_ICInitTypeDef& ici=static_cast<TIM_ICInitTypeDef&>(tcfb);

      ici.TIM_ICPrescaler=TPrescaler;
    }
  };

  /**
   * Typedefs that avoid the templates
   */

  typedef TimerChannelICPrescalerFeature<TIM_ICPSC_DIV1> TimerChannelICPreScaler1Feature;
  typedef TimerChannelICPrescalerFeature<TIM_ICPSC_DIV2> TimerChannelICPreScaler2Feature;
  typedef TimerChannelICPrescalerFeature<TIM_ICPSC_DIV4> TimerChannelICPreScaler4Feature;
  typedef TimerChannelICPrescalerFeature<TIM_ICPSC_DIV8> TimerChannelICPreScaler8Feature;
}
// END FILE: ../lib/include/timer/features/channel/TimerChannelICPrescalerFeature.h
// START FILE: ../lib/include/timer/features/TimerInternalTriggerClockFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class to configure the timer to use the update or compare event
   * of another timer as its clock.
   * @tparam TTriggerNumber the internal trigger number (0..3)
   */

  template<uint8_t TTriggerNumber>
  class TimerInternalTriggerClockFeature : public TimerFeatureBase {
    public:
      TimerInternalTriggerClockFeature(Timer& timer);
  };


  /**
   * All four possible specialisations for easy use
   */

  typedef TimerInternalTriggerClockFeature<TIM_TS_ITR0> TimerInternalTrigger0ClockFeature;
  typedef TimerInternalTriggerClockFeature<TIM_TS_ITR1> TimerInternalTrigger1ClockFeature;
  typedef TimerInternalTriggerClockFeature<TIM_TS_ITR2> TimerInternalTrigger2ClockFeature;
  typedef TimerInternalTriggerClockFeature<TIM_TS_ITR3> TimerInternalTrigger3ClockFeature;


  /**
   * Constructor, configure this timer with the trigger number
   */

  template<uint8_t TTriggerNumber>
  inline TimerInternalTriggerClockFeature<TTriggerNumber>::TimerInternalTriggerClockFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    TIM_ITRxExternalClockConfig(_timer,TTriggerNumber);
  }
}
// END FILE: ../lib/include/timer/features/TimerInternalTriggerClockFeature.h
// START FILE: ../lib/include/timer/features/TimerInterruptFeatureEnabler.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  /**
   * Helper class to enable only the desired interrupts in the NVIC. This will
   * be fully specialised for each timer
   * @tparam TTimerNumber The number of the timer peripheral
   */

  template<uint8_t TTimerNumber>
  class TimerInterruptFeatureEnabler {

    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR 
      static FPTR _forceLinkage;

    public:
      static void enable(uint16_t interruptMask,uint8_t priority,uint8_t subPriority=0);
  };
  
}
// END FILE: ../lib/include/timer/features/TimerInterruptFeatureEnabler.h
// START FILE: ../lib/include/timer/features/TimerChannel3Feature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class to support the operations available on
   * a specific timer channel
   */

  template<class... Features>
  class TimerChannelFeature<3,Features...> : public TimerChannelFeatureBase,
                                             public Features... {

    public:
      TimerChannelFeature(Timer& timer);

      uint32_t getCapture() const;
      void initCompareForPwmOutput(uint8_t initialDutyCycle=0,uint16_t ocMode=TIM_OCMode_PWM1,uint16_t ocPolarity=TIM_OCPolarity_High);
      void initCompare(uint32_t compareValue,uint16_t ocMode=TIM_OCMode_Toggle,uint16_t polarity=TIM_OCPolarity_Low,uint16_t preload=TIM_OCPreload_Disable);
      void initCapture(uint16_t polarity=TIM_ICPolarity_Rising,uint16_t selection=TIM_ICSelection_DirectTI,uint16_t prescaler=TIM_ICPSC_DIV1,uint16_t filter=0,uint16_t timerPrescaler=1);
      void setCompare(uint32_t compare) const;
      void setDutyCycle(uint8_t dutyCycle);
  };


  /*
   * Typedef for easier access
   */

  template<class... Features>
  using TimerChannel3Feature=TimerChannelFeature<3,Features...>;


  /**
   * Constructor
   * @param timer
   */

  template<class... Features>
  inline TimerChannelFeature<3,Features...>::TimerChannelFeature(Timer& timer)
    : TimerChannelFeatureBase(timer),
      Features(static_cast<TimerChannelFeatureBase&>(*this))... {

    // feature constructors have set up the OC/IC structures, now we can use them

    if(_oci!=nullptr) {
      TIM_OC3Init(_timer,_oci.get());
      _oci.reset(nullptr);
    }
    if(_ici!=nullptr) {
      _ici->TIM_Channel=TIM_Channel_3;
      TIM_ICInit(_timer,_ici.get());
      _ici.reset(nullptr);
    }
  }


  /**
   * Get the capture value for this channel
   */

  template<class... Features>
  inline uint32_t TimerChannelFeature<3,Features...>::getCapture() const {
    return TIM_GetCapture3(_timer);
  }


  /**
   * Set the compare value for this channel
   */

  template<class... Features>
  inline void TimerChannelFeature<3,Features...>::setCompare(uint32_t compareValue) const {
    return TIM_SetCompare3(_timer,compareValue);
  }


  /**
   * Initialise the output compare mode and first value. This is now deprecated in favour
   * of using the channel feature classes.
   * @param compareValue the timer tick value to compare to
   * @param ocMode What to do when matched (default is TIM_OCMode_Toggle)
   * @param polarity value. Default is TIM_OCPolarity_Low
   * @param preload The preload enable/disable flag. Default is TIM_OCPreload_Disable.
   */

  template<class... Features>
  inline void TimerChannelFeature<3,Features...>::initCompare(uint32_t compareValue,uint16_t ocMode,uint16_t polarity,uint16_t preload) {

    TIM_OCInitTypeDef oci;

    // initialise the channel OC

    TIM_OCStructInit(&oci);

    oci.TIM_OCMode=ocMode;
    oci.TIM_OutputState=TIM_OutputState_Enable;
    oci.TIM_Pulse=compareValue;
    oci.TIM_OCPolarity=polarity;

    TIM_OC3Init(_timer,&oci);
    TIM_OC3PreloadConfig(_timer,preload);
    TIM_CtrlPWMOutputs(_timer,ENABLE);
  }


  /**
   * Initialise the channel in PWM output mode.
   * @param initialDutyCycle Default is zero. Duty cycle is a percentage, 0..100
   * @param ocMode Default is TIM_OCMode_PWM1 (edge aligned). Use TIM_OCMode_PWM2 for center aligned.
   * @param ocPolarity Default is TIM_OCPolarity_High
   */

  template<class... Features>
  inline void TimerChannelFeature<3,Features...>::initCompareForPwmOutput(uint8_t initialDutyCycle,uint16_t ocMode,uint16_t ocPolarity) {
    initCompare(0,ocMode,ocPolarity);
    setDutyCycle(initialDutyCycle);
  }


  /**
   * Set the duty cycle for this PWM feature
   * @param dutyCycle The duty cycle as a percentage (0..100)
   */

  template<class... Features>
  inline void TimerChannelFeature<3,Features...>::setDutyCycle(uint8_t dutyCycle) {

    uint32_t compareValue,period;

    // remember the setting

    _dutyCycle=dutyCycle;

    // get the timer period from the base class

    period=_timer.getPeriod()+1;

    // watch out for overflow

    if(period<0xFFFFFFFF/100)
      compareValue=(period*static_cast<uint32_t>(dutyCycle))/100L;
    else
      compareValue=(period/100L)*static_cast<uint32_t>(dutyCycle);

    setCompare(compareValue);
  }


  /**
   *  Initialise the channel in input capture mode. This is now deprecated in favour
   *  of using the channel feature classes.
   *  @param polarity default is TIM_ICPolarity_Rising
   *  @param selection default is TIM_ICSelection_DirectTI
   *  @param prescaler default is TIM_ICPSC_DIV1 (= number of captures to skip)
   *  @param filter default is zero
   *  @param timerPrescaler prescaler for the timer. Default is 1.
   */

  template<class... Features>
  inline void TimerChannelFeature<3,Features...>::initCapture(uint16_t polarity,uint16_t selection,uint16_t prescaler,uint16_t filter,uint16_t timerPrescaler) {

    TIM_ICInitTypeDef init;

    // do the peripheral initialisation

    init.TIM_Channel=TIM_Channel_3;
    init.TIM_ICPolarity=polarity;
    init.TIM_ICSelection=selection;
    init.TIM_ICPrescaler=prescaler;
    init.TIM_ICFilter=filter;

    TIM_ICInit(_timer,&init);
    _timer.setPrescaler(timerPrescaler,TIM_PSCReloadMode_Immediate);
  }
}
// END FILE: ../lib/include/timer/features/TimerChannel3Feature.h
// START FILE: ../lib/include/timer/features/TimerChannel1Feature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class to support the operations available on
   * a specific timer channel
   */

  template<class... Features>
  class TimerChannelFeature<1,Features...> : public TimerChannelFeatureBase,
                                             public Features... {

    public:
      TimerChannelFeature(Timer& timer);

      uint32_t getCapture() const;
      void initCompareForPwmOutput(uint8_t initialDutyCycle=0,uint16_t ocMode=TIM_OCMode_PWM1,uint16_t ocPolarity=TIM_OCPolarity_High);
      void initCompare(uint32_t compareValue,uint16_t ocMode=TIM_OCMode_Toggle,uint16_t polarity=TIM_OCPolarity_Low,uint16_t preload=TIM_OCPreload_Disable);
      void initCapture(uint16_t polarity=TIM_ICPolarity_Rising,uint16_t selection=TIM_ICSelection_DirectTI,uint16_t prescaler=TIM_ICPSC_DIV1,uint16_t filter=0,uint16_t timerPrescaler=1);
      void setCompare(uint32_t compare) const;
      void setDutyCycle(uint8_t dutyCycle);
  };


  /*
   * Typedef for easier access
   */

  template<class... Features>
  using TimerChannel1Feature=TimerChannelFeature<1,Features...>;


  /**
   * Constructor
   * @param timer
   */

  template<class... Features>
  inline TimerChannelFeature<1,Features...>::TimerChannelFeature(Timer& timer)
    : TimerChannelFeatureBase(timer),
      Features(static_cast<TimerChannelFeatureBase&>(*this))... {

    // feature constructors have set up the OC/IC structures, now we can use them
    // and free the memory that they were using

    if(_oci!=nullptr) {
      TIM_OC1Init(_timer,_oci.get());
      _oci.reset(nullptr);
    }

    if(_ici!=nullptr) {
      _ici->TIM_Channel=TIM_Channel_1;
      TIM_ICInit(_timer,_ici.get());
      _ici.reset(nullptr);
    }
  }


  /**
   * Get the capture value for this channel
   */

  template<class... Features>
  inline uint32_t TimerChannelFeature<1,Features...>::getCapture() const {
    return TIM_GetCapture1(_timer);
  }


  /**
   * Set the compare value for this channel
   */

  template<class... Features>
  inline void TimerChannelFeature<1,Features...>::setCompare(uint32_t compareValue) const {
    return TIM_SetCompare1(_timer,compareValue);
  }


  /**
   * Initialise the output compare mode and first value. This is now deprecated in favour
   * of using the channel feature classes.
   * @param compareValue the timer tick value to compare to
   * @param ocMode What to do when matched (default is TIM_OCMode_Toggle)
   * @param polarity value. Default is TIM_OCPolarity_Low
   * @param preload The preload enable/disable flag. Default is TIM_OCPreload_Disable.
   */

  template<class... Features>
  inline void TimerChannelFeature<1,Features...>::initCompare(uint32_t compareValue,uint16_t ocMode,uint16_t polarity,uint16_t preload) {

    TIM_OCInitTypeDef oci;

    // initialise the channel OC

    TIM_OCStructInit(&oci);

    oci.TIM_OCMode=ocMode;
    oci.TIM_OutputState=TIM_OutputState_Enable;
    oci.TIM_Pulse=compareValue;
    oci.TIM_OCPolarity=polarity;

    TIM_OC1Init(_timer,&oci);
    TIM_OC1PreloadConfig(_timer,preload);
    TIM_CtrlPWMOutputs(_timer,ENABLE);
  }


  /**
   * Initialise the channel in PWM output mode.
   * @param initialDutyCycle Default is zero. Duty cycle is a percentage, 0..100
   * @param ocMode Default is TIM_OCMode_PWM1 (edge aligned). Use TIM_OCMode_PWM2 for center aligned.
   * @param ocPolarity Default is TIM_OCPolarity_High
   */

  template<class... Features>
  inline void TimerChannelFeature<1,Features...>::initCompareForPwmOutput(uint8_t initialDutyCycle,uint16_t ocMode,uint16_t ocPolarity) {
    initCompare(0,ocMode,ocPolarity);
    setDutyCycle(initialDutyCycle);
  }


  /**
   * Set the duty cycle for this PWM feature
   * @param dutyCycle The duty cycle as a percentage (0..100)
   */

  template<class... Features>
  inline void TimerChannelFeature<1,Features...>::setDutyCycle(uint8_t dutyCycle) {

    uint32_t compareValue,period;

    // remember the setting

    _dutyCycle=dutyCycle;

    // get the timer period from the base class

    period=_timer.getPeriod()+1;

    // watch out for overflow

    if(period<0xFFFFFFFF/100)
      compareValue=(period*static_cast<uint32_t>(dutyCycle))/100L;
    else
      compareValue=(period/100L)*static_cast<uint32_t>(dutyCycle);

    setCompare(compareValue);
  }


  /**
   *  Initialise the channel in input capture mode. This is now deprecated in favour
   *  of using the channel feature classes.
   *  @param polarity default is TIM_ICPolarity_Rising
   *  @param selection default is TIM_ICSelection_DirectTI
   *  @param prescaler default is TIM_ICPSC_DIV1 (= number of captures to skip)
   *  @param filter default is zero
   *  @param timerPrescaler prescaler for the timer. Default is 1.
   */

  template<class... Features>
  inline void TimerChannelFeature<1,Features...>::initCapture(uint16_t polarity,uint16_t selection,uint16_t prescaler,uint16_t filter,uint16_t timerPrescaler) {

    TIM_ICInitTypeDef init;

    // do the peripheral initialisation

    init.TIM_Channel=TIM_Channel_1;
    init.TIM_ICPolarity=polarity;
    init.TIM_ICSelection=selection;
    init.TIM_ICPrescaler=prescaler;
    init.TIM_ICFilter=filter;

    TIM_ICInit(_timer,&init);
    _timer.setPrescaler(timerPrescaler,TIM_PSCReloadMode_Immediate);
  }
}
// END FILE: ../lib/include/timer/features/TimerChannel1Feature.h
// START FILE: ../lib/include/timer/features/TimerChannel4Feature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class to support the operations available on
   * a specific timer channel
   */

  template<class... Features>
  class TimerChannelFeature<4,Features...> : public TimerChannelFeatureBase,
                                             public Features... {

    public:
      TimerChannelFeature(Timer& timer);

      uint32_t getCapture() const;
      void initCompareForPwmOutput(uint8_t initialDutyCycle=0,uint16_t ocMode=TIM_OCMode_PWM1,uint16_t ocPolarity=TIM_OCPolarity_High);
      void initCompare(uint32_t compareValue,uint16_t ocMode=TIM_OCMode_Toggle,uint16_t polarity=TIM_OCPolarity_Low,uint16_t preload=TIM_OCPreload_Disable);
      void initCapture(uint16_t polarity=TIM_ICPolarity_Rising,uint16_t selection=TIM_ICSelection_DirectTI,uint16_t prescaler=TIM_ICPSC_DIV1,uint16_t filter=0,uint16_t timerPrescaler=1);
      void setCompare(uint32_t compare) const;
      void setDutyCycle(uint8_t dutyCycle);
  };


  /*
   * Typedef for easier access
   */

  template<class... Features>
  using TimerChannel4Feature=TimerChannelFeature<4,Features...>;


  /**
   * Constructor
   * @param timer
   */

  template<class... Features>
  inline TimerChannelFeature<4,Features...>::TimerChannelFeature(Timer& timer)
    : TimerChannelFeatureBase(timer),
      Features(static_cast<TimerChannelFeatureBase&>(*this))... {

    // feature constructors have set up the OC/IC structures, now we can use them

    if(_oci!=nullptr) {
      TIM_OC4Init(_timer,_oci.get());
      _oci.reset(nullptr);
    }
    if(_ici!=nullptr) {
      _ici->TIM_Channel=TIM_Channel_4;
      TIM_ICInit(_timer,_ici.get());
      _ici.reset(nullptr);
    }
  }


  /**
   * Get the capture value for this channel
   */

  template<class... Features>
  inline uint32_t TimerChannelFeature<4,Features...>::getCapture() const {
    return TIM_GetCapture4(_timer);
  }


  /**
   * Set the compare value for this channel
   */

  template<class... Features>
  inline void TimerChannelFeature<4,Features...>::setCompare(uint32_t compareValue) const {
    return TIM_SetCompare4(_timer,compareValue);
  }


  /**
   * Initialise the output compare mode and first value. This is now deprecated in favour
   * of using the channel feature classes.
   * @param compareValue the timer tick value to compare to
   * @param ocMode What to do when matched (default is TIM_OCMode_Toggle)
   * @param polarity value. Default is TIM_OCPolarity_Low
   * @param preload The preload enable/disable flag. Default is TIM_OCPreload_Disable.
   */

  template<class... Features>
  inline void TimerChannelFeature<4,Features...>::initCompare(uint32_t compareValue,uint16_t ocMode,uint16_t polarity,uint16_t preload) {

    TIM_OCInitTypeDef oci;

    // initialise the channel OC

    TIM_OCStructInit(&oci);

    oci.TIM_OCMode=ocMode;
    oci.TIM_OutputState=TIM_OutputState_Enable;
    oci.TIM_Pulse=compareValue;
    oci.TIM_OCPolarity=polarity;

    TIM_OC4Init(_timer,&oci);
    TIM_OC4PreloadConfig(_timer,preload);
    TIM_CtrlPWMOutputs(_timer,ENABLE);
  }


  /**
   * Initialise the channel in PWM output mode.
   * @param initialDutyCycle Default is zero. Duty cycle is a percentage, 0..100
   * @param ocMode Default is TIM_OCMode_PWM1 (edge aligned). Use TIM_OCMode_PWM2 for center aligned.
   * @param ocPolarity Default is TIM_OCPolarity_High
   */

  template<class... Features>
  inline void TimerChannelFeature<4,Features...>::initCompareForPwmOutput(uint8_t initialDutyCycle,uint16_t ocMode,uint16_t ocPolarity) {
    initCompare(0,ocMode,ocPolarity);
    setDutyCycle(initialDutyCycle);
  }


  /**
   * Set the duty cycle for this PWM feature
   * @param dutyCycle The duty cycle as a percentage (0..100)
   */

  template<class... Features>
  inline void TimerChannelFeature<4,Features...>::setDutyCycle(uint8_t dutyCycle) {

    uint32_t compareValue,period;

    // remember the setting

    _dutyCycle=dutyCycle;

    // get the timer period from the base class

    period=_timer.getPeriod()+1;

    // watch out for overflow

    if(period<0xFFFFFFFF/100)
      compareValue=(period*static_cast<uint32_t>(dutyCycle))/100L;
    else
      compareValue=(period/100L)*static_cast<uint32_t>(dutyCycle);

    setCompare(compareValue);
  }


  /**
   *  Initialise the channel in input capture mode. This is now deprecated in favour
   *  of using the channel feature classes.
   *  @param polarity default is TIM_ICPolarity_Rising
   *  @param selection default is TIM_ICSelection_DirectTI
   *  @param prescaler default is TIM_ICPSC_DIV1 (= number of captures to skip)
   *  @param filter default is zero
   *  @param timerPrescaler prescaler for the timer. Default is 1.
   */

  template<class... Features>
  inline void TimerChannelFeature<4,Features...>::initCapture(uint16_t polarity,uint16_t selection,uint16_t prescaler,uint16_t filter,uint16_t timerPrescaler) {

    TIM_ICInitTypeDef init;

    // do the peripheral initialisation

    init.TIM_Channel=TIM_Channel_4;
    init.TIM_ICPolarity=polarity;
    init.TIM_ICSelection=selection;
    init.TIM_ICPrescaler=prescaler;
    init.TIM_ICFilter=filter;

    TIM_ICInit(_timer,&init);
    _timer.setPrescaler(timerPrescaler,TIM_PSCReloadMode_Immediate);
  }
}
// END FILE: ../lib/include/timer/features/TimerChannel4Feature.h
// START FILE: ../lib/include/timer/features/TimerFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for timer features
   */

  class TimerFeatureBase {
    protected:
      Timer& _timer;

    public:
      TimerFeatureBase(Timer& timer);
      operator Timer&();
  };


  /**
   * Constructor
   * @param timer The base timer class reference
   */

  inline TimerFeatureBase::TimerFeatureBase(Timer& timer)
    : _timer(timer) {
  }


  /**
   * Cast to Timer reference
   */

  inline TimerFeatureBase::operator Timer&() {
    return _timer;
  }
}
// END FILE: ../lib/include/timer/features/TimerFeatureBase.h
// START FILE: ../lib/include/timer/features/TimerMasterFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class to configure this timer as a master for one or
   * more slave timers.
   * @tparam TOutputSource one of the TIM_TRGOSource values
   */

  template<uint16_t TOutputSource>
  class TimerMasterFeature : public TimerFeatureBase {
    public:
      TimerMasterFeature(Timer& timer);
      void enableMasterFeature() const;
  };

  /**
   * Constructor. Enable master mode and select the output trigger
   */

  template<uint16_t TOutputSource>
  inline TimerMasterFeature<TOutputSource>::TimerMasterFeature(Timer& timer)
    : TimerFeatureBase(timer) {
  }


  /**
   * The master feature cannot be enabled until the rest of the timer is set up
   * so this cannot be done in the constructor
   */

  template<uint16_t TOutputSource>
  inline void TimerMasterFeature<TOutputSource>::enableMasterFeature() const {

    // select the output source and enable master mode

    TIM_SelectMasterSlaveMode(_timer,TIM_MasterSlaveMode_Enable);
    TIM_SelectOutputTrigger(_timer,TOutputSource);
  }


  /**
   * Typedefs for easy access
   */

  typedef TimerMasterFeature<TIM_TRGOSource_Reset> TimerResetMasterFeature;
  typedef TimerMasterFeature<TIM_TRGOSource_Enable> TimerEnableMasterFeature;
  typedef TimerMasterFeature<TIM_TRGOSource_Update> TimerUpdateMasterFeature;
  typedef TimerMasterFeature<TIM_TRGOSource_OC1> TimerCompareMasterFeature;
  typedef TimerMasterFeature<TIM_TRGOSource_OC1Ref> TimerOutputCompare1MasterFeature;
  typedef TimerMasterFeature<TIM_TRGOSource_OC2Ref> TimerOutputCompare2MasterFeature;
  typedef TimerMasterFeature<TIM_TRGOSource_OC3Ref> TimerOutputCompare3MasterFeature;
  typedef TimerMasterFeature<TIM_TRGOSource_OC4Ref> TimerOutputCompare4MasterFeature;
}
// END FILE: ../lib/include/timer/features/TimerMasterFeature.h
// START FILE: ../lib/include/timer/features/TimerChannel2Feature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class to support the operations available on
   * a specific timer channel
   */

  template<class... Features>
  class TimerChannelFeature<2,Features...> : public TimerChannelFeatureBase,
                                             public Features... {

    public:
      TimerChannelFeature(Timer& timer);

      uint32_t getCapture() const;
      void initCompareForPwmOutput(uint8_t initialDutyCycle=0,uint16_t ocMode=TIM_OCMode_PWM1,uint16_t ocPolarity=TIM_OCPolarity_High);
      void initCompare(uint32_t compareValue,uint16_t ocMode=TIM_OCMode_Toggle,uint16_t polarity=TIM_OCPolarity_Low,uint16_t preload=TIM_OCPreload_Disable);
      void initCapture(uint16_t polarity=TIM_ICPolarity_Rising,uint16_t selection=TIM_ICSelection_DirectTI,uint16_t prescaler=TIM_ICPSC_DIV1,uint16_t filter=0,uint16_t timerPrescaler=1);
      void setCompare(uint32_t compare) const;
      void setDutyCycle(uint8_t dutyCycle);
  };


  /*
   * Typedef for easier access
   */

  template<class... Features>
  using TimerChannel2Feature=TimerChannelFeature<2,Features...>;


  /**
   * Constructor
   * @param timer
   */

  template<class... Features>
  inline TimerChannelFeature<2,Features...>::TimerChannelFeature(Timer& timer)
    : TimerChannelFeatureBase(timer),
      Features(static_cast<TimerChannelFeatureBase&>(*this))... {

    // feature constructors have set up the OC/IC structures, now we can use them

    if(_oci!=nullptr) {
      TIM_OC2Init(_timer,_oci.get());
      _oci.reset(nullptr);
    }
    if(_ici!=nullptr) {
      _ici->TIM_Channel=TIM_Channel_2;
      TIM_ICInit(_timer,_ici.get());
      _ici.reset(nullptr);
    }
  }


  /**
   * Get the capture value for this channel
   */

  template<class... Features>
  inline uint32_t TimerChannelFeature<2,Features...>::getCapture() const {
    return TIM_GetCapture2(_timer);
  }


  /**
   * Set the compare value for this channel
   */

  template<class... Features>
  inline void TimerChannelFeature<2,Features...>::setCompare(uint32_t compareValue) const {
    return TIM_SetCompare2(_timer,compareValue);
  }


  /**
   * Initialise the output compare mode and first value. This is now deprecated in favour
   * of using the channel feature classes.
   * @param compareValue the timer tick value to compare to
   * @param ocMode What to do when matched (default is TIM_OCMode_Toggle)
   * @param polarity value. Default is TIM_OCPolarity_Low
   * @param preload The preload enable/disable flag. Default is TIM_OCPreload_Disable.
   */

  template<class... Features>
  inline void TimerChannelFeature<2,Features...>::initCompare(uint32_t compareValue,uint16_t ocMode,uint16_t polarity,uint16_t preload) {

    TIM_OCInitTypeDef oci;

    // initialise the channel OC

    TIM_OCStructInit(&oci);

    oci.TIM_OCMode=ocMode;
    oci.TIM_OutputState=TIM_OutputState_Enable;
    oci.TIM_Pulse=compareValue;
    oci.TIM_OCPolarity=polarity;

    TIM_OC2Init(_timer,&oci);
    TIM_OC2PreloadConfig(_timer,preload);
    TIM_CtrlPWMOutputs(_timer,ENABLE);
  }


  /**
   * Initialise the channel in PWM output mode.
   * @param initialDutyCycle Default is zero. Duty cycle is a percentage, 0..100
   * @param ocMode Default is TIM_OCMode_PWM1 (edge aligned). Use TIM_OCMode_PWM2 for center aligned.
   * @param ocPolarity Default is TIM_OCPolarity_High
   */

  template<class... Features>
  inline void TimerChannelFeature<2,Features...>::initCompareForPwmOutput(uint8_t initialDutyCycle,uint16_t ocMode,uint16_t ocPolarity) {
    initCompare(0,ocMode,ocPolarity);
    setDutyCycle(initialDutyCycle);
  }


  /**
   * Set the duty cycle for this PWM feature
   * @param dutyCycle The duty cycle as a percentage (0..100)
   */

  template<class... Features>
  inline void TimerChannelFeature<2,Features...>::setDutyCycle(uint8_t dutyCycle) {

    uint32_t compareValue,period;

    // remember the setting

    _dutyCycle=dutyCycle;

    // get the timer period from the base class

    period=_timer.getPeriod()+1;

    // watch out for overflow

    if(period<0xFFFFFFFF/100)
      compareValue=(period*static_cast<uint32_t>(dutyCycle))/100L;
    else
      compareValue=(period/100L)*static_cast<uint32_t>(dutyCycle);

    setCompare(compareValue);
  }


  /**
   *  Initialise the channel in input capture mode. This is now deprecated in favour
   *  of using the channel feature classes.
   *  @param polarity default is TIM_ICPolarity_Rising
   *  @param selection default is TIM_ICSelection_DirectTI
   *  @param prescaler default is TIM_ICPSC_DIV1 (= number of captures to skip)
   *  @param filter default is zero
   *  @param timerPrescaler prescaler for the timer. Default is 1.
   */

  template<class... Features>
  inline void TimerChannelFeature<2,Features...>::initCapture(uint16_t polarity,uint16_t selection,uint16_t prescaler,uint16_t filter,uint16_t timerPrescaler) {

    TIM_ICInitTypeDef init;

    // do the peripheral initialisation

    init.TIM_Channel=TIM_Channel_2;
    init.TIM_ICPolarity=polarity;
    init.TIM_ICSelection=selection;
    init.TIM_ICPrescaler=prescaler;
    init.TIM_ICFilter=filter;

    TIM_ICInit(_timer,&init);
    _timer.setPrescaler(timerPrescaler,TIM_PSCReloadMode_Immediate);
  }
}
// END FILE: ../lib/include/timer/features/TimerChannel2Feature.h
// START FILE: ../lib/include/timer/features/TimerEncoderFeature.h
/*
 * Andy's Workshop Reflow Oven Controller.
 * Copyright (c) 2014 Andy Brown. All rights reserved.
 * Please see website (http://www.andybrown.me.uk) for full details.
 */

#pragma once


namespace stm32plus {


  /**
   * The input whose edge will trigger a count
   */

  enum class EncoderCounterEdge {
    Input1,           ///! TI1 depending on the level of TI2
    Input2,           ///! TI2 depending on the level of TI1
    Inputs1And2       ///! TI1 and TI2 depending on the other level
  };


  /**
   * Encoder edge polarity, i.e. which edge transition triggers a count
   */

  enum class EncoderPolarity {
    Rising,           ///! Rising edge transition
    Falling,          ///! Falling edge transition
    Both              ///! Either edge transition
  };


  /**
   * Provide support for the timer encoder feature. If the optional Exti instance is provided
   * then this feature will subscribe to its interrupt and reset the counter to a known value
   * when the interrupt is triggered.
   */

  template<EncoderCounterEdge TEdge,EncoderPolarity TInput1Polarity,EncoderPolarity TInput2Polarity>
  class TimerEncoderFeature : public TimerFeatureBase {

    protected:
      ExtiPeripheralBase *_managedReset;
      uint32_t _resetValue;

    protected:
      void onExtiInterrupt(uint8_t );

    public:
      TimerEncoderFeature(Timer& timer);
      ~TimerEncoderFeature();

      void initialiseEncoderCounter(uint32_t period);
      void manageEncoderReset(ExtiPeripheralBase& exti,uint32_t resetValue);
  };


  /**
   * Constructor
   */

  template<EncoderCounterEdge TEdge,EncoderPolarity TInput1Polarity,EncoderPolarity TInput2Polarity>
  inline TimerEncoderFeature<TEdge,TInput1Polarity,TInput2Polarity>::TimerEncoderFeature(Timer& timer)
    : TimerFeatureBase(timer),
      _managedReset(nullptr) {

    // static checks

    static_assert(TEdge==EncoderCounterEdge::Input1 || TEdge==EncoderCounterEdge::Input2 || TEdge==EncoderCounterEdge::Inputs1And2,"Invalid counter edge");
    static_assert(TInput1Polarity==EncoderPolarity::Rising || TInput1Polarity==EncoderPolarity::Falling || TInput1Polarity==EncoderPolarity::Both,"Invalid polarity for input 1");
    static_assert(TInput2Polarity==EncoderPolarity::Rising || TInput2Polarity==EncoderPolarity::Falling || TInput1Polarity==EncoderPolarity::Both,"Invalid polarity for input 2");

    // set the encoder mode based on the constant parameters

    TIM_EncoderInterfaceConfig(
        _timer,
        TEdge==EncoderCounterEdge::Input1 ? TIM_EncoderMode_TI1 : TEdge==EncoderCounterEdge::Input2 ? TIM_EncoderMode_TI2 : TIM_EncoderMode_TI12,
        TInput1Polarity==EncoderPolarity::Rising ? TIM_ICPolarity_Rising : TInput1Polarity==EncoderPolarity::Falling ? TIM_ICPolarity_Falling : TIM_ICPolarity_BothEdge,
        TInput2Polarity==EncoderPolarity::Rising ? TIM_ICPolarity_Rising : TInput2Polarity==EncoderPolarity::Falling ? TIM_ICPolarity_Falling : TIM_ICPolarity_BothEdge);
  }


  /**
   * Destructor - unsubscribe to the reset signal if there is one
   */

  template<EncoderCounterEdge TEdge,EncoderPolarity TInput1Polarity,EncoderPolarity TInput2Polarity>
  inline TimerEncoderFeature<TEdge,TInput1Polarity,TInput2Polarity>::~TimerEncoderFeature() {

    if(_managedReset) {
      _managedReset->ExtiInterruptEventSender.removeSubscriber(
        ExtiInterruptEventSourceSlot::bind(this,&TimerEncoderFeature<TEdge,TInput1Polarity,TInput2Polarity>::onExtiInterrupt)
      );
    }
  }


  /**
   * Simple counter initialiser specifically for the encoder feature
   * @param period The up-limit (exclusive)
   */

  template<EncoderCounterEdge TEdge,EncoderPolarity TInput1Polarity,EncoderPolarity TInput2Polarity>
  inline void TimerEncoderFeature<TEdge,TInput1Polarity,TInput2Polarity>::initialiseEncoderCounter(uint32_t period) {
    _timer.initialiseTimeBase(period,0,TIM_CKD_DIV1,TIM_CounterMode_Up);
  }


  /**
   * Manage the automatic encoder reset (the encoder index pin). You must have set up the Exti instance
   * to trigger on the correct edge and pin according to your setup. Don't let the Exti instance go
   * out of scope before this feature class.
   * @param exti The Exti instance that will raise an interrupt when the encoder is to be reset
   * @param resetValue The value to reset the counter to when the interrupt happens.
   */

  template<EncoderCounterEdge TEdge,EncoderPolarity TInput1Polarity,EncoderPolarity TInput2Polarity>
  inline void TimerEncoderFeature<TEdge,TInput1Polarity,TInput2Polarity>::manageEncoderReset(ExtiPeripheralBase& exti,uint32_t resetValue) {

    // store the parameters

    _managedReset=&exti;
    _resetValue=resetValue;

    // subscribe to exti interrupts

    exti.ExtiInterruptEventSender.insertSubscriber(
      ExtiInterruptEventSourceSlot::bind(this,&TimerEncoderFeature<TEdge,TInput1Polarity,TInput2Polarity>::onExtiInterrupt)
    );
  }


  /**
   * Interrupt callback from the EXTI interrupt
   */

  template<EncoderCounterEdge TEdge,EncoderPolarity TInput1Polarity,EncoderPolarity TInput2Polarity>
  inline void TimerEncoderFeature<TEdge,TInput1Polarity,TInput2Polarity>::onExtiInterrupt(uint8_t /* extiLine */) {
    _timer.setCounter(_resetValue);
  }
}
// END FILE: ../lib/include/timer/features/TimerEncoderFeature.h
// START FILE: ../lib/include/timer/features/TimerChannelFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic definition for a timer channel feature
   */

  template<uint8_t TChannelNumber,class... TChannelFeatures>
  class TimerChannelFeature {};
}
// END FILE: ../lib/include/timer/features/TimerChannelFeature.h
// START FILE: ../lib/include/timer/features/TimerBreakFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class to support the break functionality included with the advanced and some of the general purpose
   * timers. This feature supports a 'lock' against accidental software changes. The lock mode can only be set
   * once after reset by a write to the BDTR register. Therefore if you want a lock mode other than OFF then you
   * must simulatenously write all the bits you want as well as the desired lock mode in one write access to the
   * BDTR register.
   *
   * To support that, you can use the template parameters to set a lock mode and a default value for the register.
   * Obviously your choice of lock mode will have an impact on whether you can set any other bits in the BDTR
   * register afterwards.
   *
   * @tparam TInitRegValue The initial value for the BDTR register (including the lock mode)
   */

  template<uint16_t TInitRegValue>
  class TimerBreakFeature : public TimerFeatureBase {

    public:

      enum BreakPolarity {
        BREAK_POLARITY_LOW,
        BREAK_POLARITY_HIGH
      };

    public:
      TimerBreakFeature(Timer& timer);

      void enableMainOutput() const;
      void disableMainOutput() const;

      void enableAutomaticOutput() const;
      void disableAutomaticOutput() const;

      void setBreakPolarity(BreakPolarity polarity) const;

      void enableBreak() const;
      void disableBreak() const;

      void enableRunModeOffState() const;
      void disableRunModeOffState() const;

      void enableIdleModeOffState() const;
      void disableIdleModeOffState() const;

      void setDeadTimeGenerator(uint8_t dtg) const;
  };


  /**
   * Provide a typedef for the default case of the BDTR register being unlocked and having
   * a default value of zero.
   */

  typedef TimerBreakFeature<0> UnlockedTimerBreakFeature;


  /**
   * Constructor
   * @param timer reference to the timer object
   */

  template<uint16_t TInitRegValue>
  TimerBreakFeature<TInitRegValue>::TimerBreakFeature(Timer& timer)
    : TimerFeatureBase(timer) {

    ((TIM_TypeDef *)_timer)->BDTR = TInitRegValue;
  }



  /**
   * Master output enable for OC and OCN
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::enableMainOutput() const {
    TIM_CtrlPWMOutputs(_timer,ENABLE);
  }


  /**
   * Disable OC and OCN for this timer
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::disableMainOutput() const {
    TIM_CtrlPWMOutputs(_timer,DISABLE);
  }


  /**
   * The master output enable can be set by software or automatically at the next update event
   * (if the break input is not be active)
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::enableAutomaticOutput() const {
    ((TIM_TypeDef *)_timer)->BDTR |= TIM_AutomaticOutput_Enable;
  }


  /**
   * The master output enable can only be set by software
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::disableAutomaticOutput() const {
    ((TIM_TypeDef *)_timer)->BDTR &= ~TIM_AutomaticOutput_Enable;
  }


  /**
   * Set the polarity of the break input
   * @param polarity BREAK_POLARITY_LOW or BREAK_POLARITY_HIGH
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::setBreakPolarity(BreakPolarity polarity) const {

    if(polarity==BREAK_POLARITY_LOW)
      ((TIM_TypeDef *)_timer)->BDTR &= ~TIM_BreakPolarity_High;
    else
      ((TIM_TypeDef *)_timer)->BDTR |= TIM_BreakPolarity_High;
  }


  /**
   * Break inputs (BRK and CSS clock failure event) enabled
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::enableBreak() const {
    ((TIM_TypeDef *)_timer)->BDTR |= TIM_Break_Enable;
  }


  /**
   * Break inputs (BRK and CSS clock failure event) disabled
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::disableBreak() const {
    ((TIM_TypeDef *)_timer)->BDTR &= ~TIM_Break_Enable;
  }


  /**
   * When inactive, OC/OCN outputs are enabled with their inactive level as soon as CCxE=1
   * or CCxNE=1. Then, OC/OCN enable output signal=1
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::enableRunModeOffState() const {
    ((TIM_TypeDef *)_timer)->BDTR |= TIM_OSSRState_Enable;
  }


  /**
   * When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::disableRunModeOffState() const {
    ((TIM_TypeDef *)_timer)->BDTR &= ~TIM_OSSRState_Enable;
  }


  /**
   * When inactive, OC/OCN outputs are forced first with their idle level as soon as CCxE=1 or
   * CCxNE=1. OC/OCN enable output signal=1)
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::enableIdleModeOffState() const {
    ((TIM_TypeDef *)_timer)->BDTR |= TIM_OSSIState_Enable;
  }


  /**
   * When inactive, OC/OCN outputs are disabled (OC/OCN enable output signal=0)
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::disableIdleModeOffState() const {
    ((TIM_TypeDef *)_timer)->BDTR &= ~TIM_OSSIState_Enable;
  }


  /**
   * Setup the deadtime generator. This value encodes both the resolution of the dead time generator and
   * the value itself. See the documentation in the reference manual for the DTG[7:0] bits in the
   * TIMx_BDTR register for details. LockMode must not be set to any level for this to work.
   * @param dtg The value encoding the resolution and dead time
   */

  template<uint16_t TInitRegValue>
  inline void TimerBreakFeature<TInitRegValue>::setDeadTimeGenerator(uint8_t dtg) const {
    ((TIM_TypeDef *)_timer)->BDTR = (((TIM_TypeDef *)_timer)->BDTR & ~ 0xff) | dtg;
  }
}
// END FILE: ../lib/include/timer/features/TimerBreakFeature.h
// START FILE: ../lib/include/timer/features/TimerExternalMode1ClockFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * feature class to configure the timer as using an external clock as
   * a trigger. The counter can count at each rising or falling edge on
   * a selected input.
   *
   * The user must call setClock() on the the timer object.
   *
   * @tparam TTriggerSource TIM_TS_ITR0..3
   */

  template<uint16_t TTriggerSource>
  class TimerExternalMode1ClockFeature : public TimerFeatureBase {
    public:
      TimerExternalMode1ClockFeature(Timer& timer);
  };


  /**
   * Constructor. Calls TIM_ITRxExternalClockConfig for this timer
   */

  template<uint16_t TTriggerSource>
  inline TimerExternalMode1ClockFeature<TTriggerSource>::TimerExternalMode1ClockFeature(Timer& timer)
    : TimerFeatureBase(timer) {
    TIM_ITRxExternalClockConfig(timer,TTriggerSource);
  }
}
// END FILE: ../lib/include/timer/features/TimerExternalMode1ClockFeature.h
// START FILE: ../lib/include/timer/features/TimerSlaveFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to configure this timer as a slave for another timer. The
   * slave mode and input trigger (0..3) are configurable.
   * @tparam TInputTrigger one of TIM_InputTriggerSource
   * @tparam TSlaveMode one of TIM_SlaveMode
   */

  template<uint16_t TInputTrigger,uint16_t TSlaveMode>
  class TimerSlaveFeature : public TimerFeatureBase {
    public:
      TimerSlaveFeature(Timer& timer);
      void enableSlaveFeature() const;
  };

  /**
   * Constructor. Enable slave mode and select the input trigger
   */

  template<uint16_t TInputTrigger,uint16_t TSlaveMode>
  inline TimerSlaveFeature<TInputTrigger,TSlaveMode>::TimerSlaveFeature(Timer& timer)
    : TimerFeatureBase(timer) {
  }


  /**
   * Master/slave configuration must come after the rest of the timer has been
   * set up, including channel output compare so this cannot be done in the
   * constructor
   */

  template<uint16_t TInputTrigger,uint16_t TSlaveMode>
  inline void TimerSlaveFeature<TInputTrigger,TSlaveMode>::enableSlaveFeature() const {

    // select the input source and enable slave mode

    TIM_SelectSlaveMode(_timer,TSlaveMode);
    TIM_SelectInputTrigger(_timer,TInputTrigger);
  }


  /**
   * types for the four numbered input triggers
   * See Tables 80,84, in RM0008 for the ITRx to master/slave mappings
   *
   * Table 84 configurations:
   */

  template<uint16_t TSlaveMode> using Timer1MasterTimer2SlaveFeature = TimerSlaveFeature<TIM_TS_ITR0,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer1MasterTimer3SlaveFeature = TimerSlaveFeature<TIM_TS_ITR0,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer1MasterTimer4SlaveFeature = TimerSlaveFeature<TIM_TS_ITR0,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer2MasterTimer5SlaveFeature = TimerSlaveFeature<TIM_TS_ITR0,TSlaveMode>;

  template<uint16_t TSlaveMode> using Timer8MasterTimer2SlaveFeature = TimerSlaveFeature<TIM_TS_ITR1,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer2MasterTimer3SlaveFeature = TimerSlaveFeature<TIM_TS_ITR1,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer2MasterTimer4SlaveFeature = TimerSlaveFeature<TIM_TS_ITR1,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer3MasterTimer5SlaveFeature = TimerSlaveFeature<TIM_TS_ITR1,TSlaveMode>;

  template<uint16_t TSlaveMode> using Timer3MasterTimer2SlaveFeature = TimerSlaveFeature<TIM_TS_ITR2,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer5MasterTimer3SlaveFeature = TimerSlaveFeature<TIM_TS_ITR2,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer3MasterTimer4SlaveFeature = TimerSlaveFeature<TIM_TS_ITR2,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer4MasterTimer5SlaveFeature = TimerSlaveFeature<TIM_TS_ITR2,TSlaveMode>;

  template<uint16_t TSlaveMode> using Timer4MasterTimer2SlaveFeature = TimerSlaveFeature<TIM_TS_ITR3,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer4MasterTimer3SlaveFeature = TimerSlaveFeature<TIM_TS_ITR3,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer8MasterTimer4SlaveFeature = TimerSlaveFeature<TIM_TS_ITR3,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer8MasterTimer5SlaveFeature = TimerSlaveFeature<TIM_TS_ITR3,TSlaveMode>;

  /**
   * RM0008 Table 80 configurations.
   */

  template<uint16_t TSlaveMode> using Timer5MasterTimer1SlaveFeature = TimerSlaveFeature<TIM_TS_ITR0,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer1MasterTimer8SlaveFeature = TimerSlaveFeature<TIM_TS_ITR0,TSlaveMode>;

  template<uint16_t TSlaveMode> using Timer2MasterTimer1SlaveFeature = TimerSlaveFeature<TIM_TS_ITR1,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer2MasterTimer8SlaveFeature = TimerSlaveFeature<TIM_TS_ITR1,TSlaveMode>;

  template<uint16_t TSlaveMode> using Timer3MasterTimer1SlaveFeature = TimerSlaveFeature<TIM_TS_ITR2,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer4MasterTimer8SlaveFeature = TimerSlaveFeature<TIM_TS_ITR2,TSlaveMode>;

  template<uint16_t TSlaveMode> using Timer4MasterTimer1SlaveFeature = TimerSlaveFeature<TIM_TS_ITR3,TSlaveMode>;
  template<uint16_t TSlaveMode> using Timer5MasterTimer8SlaveFeature = TimerSlaveFeature<TIM_TS_ITR3,TSlaveMode>;
}
// END FILE: ../lib/include/timer/features/TimerSlaveFeature.h
// START FILE: ../lib/include/timer/features/TimerChannelFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Common functionality for all timer channels
   */

  class TimerChannelFeatureBase : public TimerFeatureBase {

    protected:
      uint8_t _dutyCycle;
      scoped_ptr<TIM_OCInitTypeDef> _oci;
      scoped_ptr<TIM_ICInitTypeDef> _ici;

    public:
      TimerChannelFeatureBase(Timer& timer);

      void initialise();

      uint32_t calculateFrequency(uint32_t capture1,uint32_t capture2) const;

      operator TIM_OCInitTypeDef&();
      operator TIM_ICInitTypeDef&();
  };


  /**
   * Constructor
   * @param timer
   */

  inline TimerChannelFeatureBase::TimerChannelFeatureBase(Timer& timer)
    : TimerFeatureBase(timer) {
  }


  /**
   * Provide access to the OC structure, creating it where required - this means that
   * classes not using the OC features won't incur the overhead of the structure.
   */

  inline TimerChannelFeatureBase::operator TIM_OCInitTypeDef&() {

    // create if it doesn't exist

    if(_oci==nullptr) {
      _oci.reset(new TIM_OCInitTypeDef);
      TIM_OCStructInit(_oci.get());
    }

    return *_oci.get();
  }


  /**
   * Provide access to the IC structure, creating it where required - this means that
   * classes not using the IC features won't incur the overhead of the structure.
   */

  inline TimerChannelFeatureBase::operator TIM_ICInitTypeDef&() {

    // create if it doesn't exist

    if(_ici==nullptr) {
      _ici.reset(new TIM_ICInitTypeDef);
      TIM_ICStructInit(_ici.get());
    }

    return *_ici.get();
  }


  /**
   * Calculate the frequency equivalent to 2 captured values
   * @param capture1
   * @param capture2
   * @return The calculated frequency. Note that it my need to be divided by 2 depending on the value of your APB prescaler.
   */

  inline uint32_t TimerChannelFeatureBase::calculateFrequency(uint32_t capture1,uint32_t capture2) const {

    uint32_t frequency;

    if(capture2>capture1)
      frequency=_timer.getClock()/(capture2-capture1);
    else
      frequency=_timer.getClock()/(_timer.getCounterMax()-capture1+capture2);

    return frequency;
  }
}
// END FILE: ../lib/include/timer/features/TimerChannelFeatureBase.h
// START FILE: ../lib/include/timer/Timer1.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Timer1 is an advanced control timer. The template parameters can be used to specify a list
   * of timer features that you want to use.
   */

  template<class... Features>
  class Timer1 : public AdvancedControlTimer<Timer1<Features...>,PERIPHERAL_TIMER1>,
                 public Features... {

    public:

      /**
       * Helper typedef to get at this type
       */

      typedef Timer1<Features...> TimerType;

      /**
       * Constructor. Start the clocks
       */

      Timer1()
        : AdvancedControlTimer<TimerType,PERIPHERAL_TIMER1>(TIM1),
          Features(static_cast<Timer&>(*this))... {
      }
  };
}
// END FILE: ../lib/include/timer/Timer1.h
// START FILE: ../lib/include/net/EtherType.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Known EtherType values used in this implementation
     */

    enum class EtherType : uint16_t {

      IP = 0x0800,          ///< Internet protocol v4
      ARP = 0x0806          ///< Address resolution protocol
    };
  }
}
// END FILE: ../lib/include/net/EtherType.h
// START FILE: ../lib/include/net/NetUtil.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {
    namespace NetUtil {


      /**
       * Reverse the bytes in the parameter. We can do this in a single instruction
       * @param data
       * @return The parameter, with bits reversed
       */

      __attribute__((always_inline)) inline static uint16_t ntohs(uint16_t data) {

        uint16_t result;

        asm volatile( "rev16 %0, %1" : "=&r" (result) : "r" (data) );
        return result;
      }


      /**
       * Reverse the bytes in the parameter. We can do this in a single instruction
       * @param data
       * @return The parameter, with bits reversed
       */

      __attribute__((always_inline)) inline static uint32_t ntohl(uint32_t data) {

        uint32_t result;

        asm volatile( "rev %0, %1" : "=&r" (result) : "r" (data) );
        return result;
      }


      /**
       * Reverse the bytes in the parameter. We can do this in a single instruction
       * @param data
       * @return The parameter, with bits reversed
       */

      __attribute__((always_inline)) inline static uint16_t htons(uint16_t data) {

        uint16_t result;

        asm volatile( "rev16 %0, %1" : "=&r" (result) : "r" (data) );
        return result;
      }


      /**
       * Reverse the bytes in the parameter. We can do this in a single instruction
       * @param data
       * @return The parameter, with bits reversed
       */

      __attribute__((always_inline)) inline static uint32_t htonl(uint32_t data) {

        uint32_t result;

        asm volatile( "rev %0, %1" : "=&r" (result) : "r" (data) );
        return result;
      }
    }
  }
}
// END FILE: ../lib/include/net/NetUtil.h
// START FILE: ../lib/include/net/NetworkDebugEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for a debug message.
     */

    struct NetworkDebugEvent : NetEventDescriptor {

      const char *message;

      /**
       * Constructor
       * @param msg Message to send
       */

      NetworkDebugEvent(const char *msg)
        : NetEventDescriptor(NetEventDescriptor::NetEventType::DEBUG_MESSAGE),
          message(msg) {
      }
    };
  }
}
// END FILE: ../lib/include/net/NetworkDebugEvent.h
// START FILE: ../lib/include/net/physical/ksz8091rna/KSZ8091RNA.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Class for the KSZ8091RNA PHY. Contains additional register definitions
     * that describe the additional features of this PHY. This is an RMII PHY.
     */

    class KSZ8091RNA : public PhyBase {

      public:

        /**
         * Custom registers for this PHY
         */

        enum {
          AFE_CONTROL_1                   = 0x11,   //!< AFE_CONTROL_1
          AFE_CONTROL_4                   = 0x13,   //!< AFE_CONTROL_4
          RXER_COUNTER                    = 0x15,   //!< RXER_COUNTER
          OPERATION_MODE_STRAP_OVERRIDE   = 0x16,   //!< OPERATION_MODE_STRAP_OVERRIDE
          OPERATION_MODE_STRAP_STATUS     = 0x17,   //!< OPERATION_MODE_STRAP_STATUS
          EXPANDED_CONTROL                = 0x18,   //!< EXPANDED_CONTROL
          INTERRUPT_CONTROL_STATUS        = 0x1b,   //!< INTERRUPT_CONTROL_STATUS
          LINKMD_CABLE_DIAGNOSTIC         = 0x1d,   //!< LINKMD_CABLE_DIAGNOSTIC
          PHY_CONTROL_1                   = 0x1e,   //!< PHY_CONTROL_1
          PHY_CONTROL_2                   = 0x1f    //!< PHY_CONTROL_2
        };

        /**
         * Interrupt bits
         */

        enum {
          INTERRUPT_JABBER                   = 0x80,  //!< INTERRUPT_JABBER
          INTERRUPT_RECEIVE_ERROR            = 0x40,  //!< INTERRUPT_RECEIVE_ERROR
          INTERRUPT_PAGE_RECEIVED            = 0x20,  //!< INTERRUPT_PAGE_RECEIVED
          INTERRUPT_PARALLEL_DETECT_FAULT    = 0x10,  //!< INTERRUPT_PARALLEL_DETECT_FAULT
          INTERRUPT_LINK_PARTNER_ACKNOWLEDGE = 0x8,   //!< INTERRUPT_LINK_PARTNER_ACKNOWLEDGE
          INTERRUPT_LINK_DOWN                = 0x4,   //!< INTERRUPT_LINK_DOWN
          INTERRUPT_REMOTE_FAULT             = 0x2,   //!< INTERRUPT_REMOTE_FAULT
          INTERRUPT_LINK_UP                  = 0x1,   //!< INTERRUPT_LINK_UP
          INTERRUPT_ALL                      = 0xff   //!< INTERRUPT_ALL
        };


        /**
         * Configuration parameters for the KSZ80511MLL
         */

        struct Parameters : virtual PhyBase::Parameters {

          /**
           * Constructor: set defaults
           */

          Parameters() {
            phy_resetDelay      = 100;      // wait 100ms after reset is asserted
            phy_speedStatusBit  = 0x0002;   // link speed bit in status word
            phy_duplexStatusBit = 0x0004;   // full duplex bit in status word
          }
        };

        bool phyEnableInterrupts(uint8_t interruptMask) const;
        bool phyDisableInterrupts(uint8_t interruptMask) const;
        bool phyClearPendingInterrupts() const;

        bool phyIs100M(bool& is100) const;
        bool phyIsFullDuplex(bool& isFull) const;

        // hard reset is supported through the PhyHardReset feature class

        void phyHardReset(GpioPinRef& pin) const;

        bool initialise(Parameters& params,NetworkUtilityObjects& netutils);
        bool startup();
    };


    /**
     * Initialise
     * @param params
     * @return
     */

    inline bool KSZ8091RNA::initialise(Parameters& params,NetworkUtilityObjects& netutils) {
      return PhyBase::initialise(params,netutils);
    }


    /**
     * Startup
     * @return
     */

    inline bool KSZ8091RNA::startup() {
      return PhyBase::startup();
    }


    /**
     * Check if we are linked at 100Mb/s
     * @param is100 true if we are at 100Mb/s
     * @return true if it worked
     */

    inline bool KSZ8091RNA::phyIs100M(bool& is100) const {

      uint16_t value;

      if(!phyReadRegister(PHY_CONTROL_1,value))
        return false;

      value&=7;
      is100=value==2 || value==6;     // 010 or 110

      return true;
    }


    /**
     * Check if we are linked at full duplex
     * @param is100 true if we are at 100Mb/s
     * @return true if it worked
     */

    inline bool KSZ8091RNA::phyIsFullDuplex(bool& isFull) const {

      uint16_t value;

      if(!phyReadRegister(PHY_CONTROL_1,value))
        return false;

      value&=7;
      isFull=value==5 || value==6;

      return true;
    }


    /**
     * Enable interrupts to be received on the Observable interface. This function merges
     * the bits in interrupt mask into the register
     * @param interruptMask The interrupts to enable (INTERRUPT_*)
     * @return true if it worked
     */

    inline bool KSZ8091RNA::phyEnableInterrupts(uint8_t interruptMask) const {
      return phySetRegisterBits(INTERRUPT_CONTROL_STATUS,static_cast<uint16_t>(interruptMask) << 8);
    }


    /**
     * Disable interrupts to be received on the subscription callback. This function masks out
     * the bits in interrupt mask into the register
     * @param interruptMask The interrupts to enable (INTERRUPT_*)
     * @return true if it worked
     */

    inline bool KSZ8091RNA::phyDisableInterrupts(uint8_t interruptMask) const {
      return phyClearRegisterBits(INTERRUPT_CONTROL_STATUS,static_cast<uint16_t>(interruptMask) << 8);
    }


    /**
     * Clear pending interrupt flags. On the KSZ8091RNA reading the INTERRUPT_CONTROL_STATUS register
     * clears the pending interrupt flags
     * @return true if it worked
     */

    inline bool KSZ8091RNA::phyClearPendingInterrupts() const {
      uint16_t value;
      return phyReadRegister(INTERRUPT_CONTROL_STATUS,value);
    }


    /**
     * Hard-reset the KSZ8091RNA by pulling the RESET pin low for 20ms. The datasheet
     * indicates that 10ms is the minimum between stable power and rising reset so
     * we're playing safe.
     * @param pin
     */

    inline void KSZ8091RNA::phyHardReset(GpioPinRef& pin) const {
      pin.reset();
      MillisecondTimer::delay(20);
      pin.set();
    }
  }
}
// END FILE: ../lib/include/net/physical/ksz8091rna/KSZ8091RNA.h
// START FILE: ../lib/include/net/physical/PhyBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Base class for all PHY features.
     */

    class PhyBase {

      public:

        /**
         * Error codes
         */

        enum {
          E_PHY_WAIT_TIMEOUT = 1  //!< timed out waiting for a status change
        };


        /**
         * Standardised PHY registers
         */

        enum {
          BASIC_MODE_CONFIGURATION        = 0x00,   //!< BASIC_MODE_CONFIGURATION
          STATUS_WORD                     = 0x01,   //!< STATUS_WORD
          PHY_IDENTIFICATION_1            = 0x02,   //!< PHY_IDENTIFICATION_1
          PHY_IDENTIFICATION_2            = 0x03,   //!< PHY_IDENTIFICATION_2
          ABILITY_ADVERTISEMENT           = 0x04,   //!< ABILITY_ADVERTISEMENT
          LINK_PARTNER_ABILITY            = 0x05,   //!< LINK_PARTNER_ABILITY
          AUTO_NEGOTIATION_EXPANSION      = 0x06,   //!< AUTO_NEGOTIATION_EXPANSION
          AUTO_NEGOTIATION_NEXT_PAGE      = 0x07,   //!< AUTO_NEGOTIATION_NEXT_PAGE
          LINK_PARTNER_NEXT_PAGE_ABILITY  = 0x08    //!< LINK_PARTNER_NEXT_PAGE_ABILITY
        };


        /**
         * Standardised PHY register bits
         */

        enum {
          RESET_BIT                     = 0x8000,
          AUTO_NEGOTIATION_BIT          = 0x1000,
          LINKED_STATUS_BIT             = 0x4,
          AUTO_NEGOTIATION_COMPLETE_BIT = 0x20,
          LOOPBACK_BIT                  = 0x4000,
          SPEED_100M_BIT                = 0x2000,
          FULL_DUPLEX_BIT               = 0x100
        };


        /**
         * Configuration parameters for any PHY
         */

        struct Parameters {

          uint16_t phy_address;                 //!< station address
          uint16_t phy_readTimeout;             //!< read timeout in ms
          uint16_t phy_writeTimeout;            //!< write timeout in ms
          uint16_t phy_resetDelay;              //!< time to delay after reset in ms
          uint16_t phy_linkTimeout;             //!< time to wait for a link in ms
          uint16_t phy_autoNegotiationTimeout;  //!< time to wait for auto negotiation in ms
          uint16_t phy_duplexStatusBit;         //!< bit mask for full duplex
          uint16_t phy_speedStatusBit;          //!< bit mask for 10M speed
          uint16_t phy_postConfigurationDelay;  //!< time to wait after manual config is complete


          /**
           * Constructor: set defaults
           */

          Parameters() {
            phy_address=1;                    // station address #1
            phy_readTimeout=5000;             // 5s read timeout
            phy_writeTimeout=5000;            // 5s write timeout
            phy_linkTimeout=5000;             // 5s link timeout
            phy_autoNegotiationTimeout=5000;  // 5s auto-negotiation timeout
            phy_postConfigurationDelay=10;    // 10ms delay after configuration is set
          }
        };

      protected:
        Parameters _params;
        NetworkUtilityObjects *_utilityObjects;

      public:
        bool initialise(const Parameters& params,NetworkUtilityObjects& netutils);
        bool startup();

        const Parameters& getParameters() const;

        bool phyReadRegister(uint16_t regNumber,uint16_t& value) const;
        bool phyWriteRegister(uint16_t regNumber,uint16_t value) const;

        bool phyWaitForStatusRegisterBit(uint16_t bit,uint16_t timeout) const;
        bool phySetRegisterBits(uint16_t regNumber,uint16_t bits) const;
        bool phyClearRegisterBits(uint16_t regNumber,uint16_t bits) const;

        bool phySoftReset() const;
        void phyPostConfigurationDelay() const;

        bool phyWaitForLink() const;
        bool phyEnableAutoNegotiation() const;
        bool phyWaitForAutoNegotiationComplete() const;

        bool phyIs100M(uint16_t statusWord) const;
        bool phyIsFullDuplex(uint16_t statusWord) const;
        bool phyIsLinked(bool& islinked) const;
        bool phyEnableLoopback() const;
        bool phyDisableLoopback() const;
        bool phySet100M() const;
        bool phySet10M() const;
        bool phySetFullDuplex() const;
        bool phySetHalfDuplex() const;
    };


    /**
     * Initialise. save configuration values.
     * @return true always
     */

    inline bool PhyBase::initialise(const Parameters& params,NetworkUtilityObjects& netutils) {

      // save configuration values

      _params=params;
      _utilityObjects=&netutils;

      return true;
    }


    /**
     * Startup
     */

    inline bool PhyBase::startup() {
      return true;
    }


    /**
     * Get the PHY configuration parameters
     * @return the parameters class
     */

    inline const typename PhyBase::Parameters& PhyBase::getParameters() const {
      return _params;
    }


    /**
     * Reset the PHY
     * @return true if it worked
     */

    inline bool PhyBase::phySoftReset() const {

      // write the reset bit

      if(!phyWriteRegister(BASIC_MODE_CONFIGURATION,RESET_BIT))
        return false;

      // delay until it's done

      MillisecondTimer::delay(_params.phy_resetDelay);
      return true;
    }


    /**
     * Read a PHY register. Raise an event for the MAC to actually do it
     * @param regNumber The register to read
     * @param value The value read back
     * @return true if it worked
     */

    inline bool PhyBase::phyReadRegister(uint16_t regNumber,uint16_t& value) const {

      PhyReadRequestEvent event(_params.phy_address,regNumber,_params.phy_readTimeout);

      _utilityObjects->NetworkNotificationEventSender.raiseEvent(event);
      value=event.result;

      return event.succeeded;
    }


    /**
     * Write a PHY register. Raise an event for the MAC to actually do it
     * @param regNumber The register to write
     * @param value The value to write
     * @return true if it worked
     */

    inline bool PhyBase::phyWriteRegister(uint16_t regNumber,uint16_t value) const {

      PhyWriteRequestEvent event(_params.phy_address,regNumber,value,_params.phy_readTimeout);

      _utilityObjects->NetworkNotificationEventSender.raiseEvent(event);
      return event.succeeded;
    }


    /**
     * wait for the link status bit to be set
     * @param timeoutMillis how long to wait until we give up
     * @return true if it worked, false on error or timeout
     */

    inline bool PhyBase::phyWaitForLink() const {
      return phyWaitForStatusRegisterBit(LINKED_STATUS_BIT,_params.phy_linkTimeout);
    }


    /**
     * Wait for a status register bit to be set
     * @param timeout How long to wait in millis
     * @return true if it worked
     */

    inline bool PhyBase::phyWaitForStatusRegisterBit(uint16_t bit,uint16_t timeout) const {

      uint16_t value;
      uint32_t start;

      // clear the timer

      start=MillisecondTimer::millis();

      do {

        // check for timeout

        if(MillisecondTimer::hasTimedOut(start,timeout))
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_PHY,E_PHY_WAIT_TIMEOUT);

        // read the status register

        if(!phyReadRegister(STATUS_WORD,value))
          return false;

        // continue while not set

      } while((value & bit)==0);

      return true;
    }


    /**
     * Set 1 or more bits in a register
     * @param regNumber the register to write to
     * @param bits the bitmask of bits to set
     * @return true if it worked
     */

    inline bool PhyBase::phySetRegisterBits(uint16_t regNumber,uint16_t bits) const {

      uint16_t value;

      // read old value

      if(!phyReadRegister(regNumber,value))
        return false;

      // merge in bits and write back

      value|=bits;
      return phyWriteRegister(regNumber,value);
    }


    /**
     * Clear one or more bits in a register
     * @param regNumber the register to write to
     * @param bits the bitmask of bits to reset
     * @return true if it worked
     */

    inline bool PhyBase::phyClearRegisterBits(uint16_t regNumber,uint16_t bits) const {

      uint16_t value;

      // read old value

      if(!phyReadRegister(regNumber,value))
        return false;

      // mask off bits and write back

      value&=~bits;
      return phyWriteRegister(regNumber,value);
    }


    /**
     * Wait for the configured number of milliseconds after manual configuration
     * of speed and duplex mode.
     */

    inline void PhyBase::phyPostConfigurationDelay() const {
      MillisecondTimer::delay(_params.phy_postConfigurationDelay);
    }


    /**
     * Enable the auto-negotiation feature
     * @return true if it worked
     */

    inline bool PhyBase::phyEnableAutoNegotiation() const {
      return phyWriteRegister(BASIC_MODE_CONFIGURATION,AUTO_NEGOTIATION_BIT);
    }


    /**
     * Wait for auto-negotiation to be complete
     * @return true if it did not timeout and there was no error
     */

    inline bool PhyBase::phyWaitForAutoNegotiationComplete() const {
      return phyWaitForStatusRegisterBit(AUTO_NEGOTIATION_COMPLETE_BIT,_params.phy_autoNegotiationTimeout);
    }


    /**
     * return true if the status word indicates a 100M link
     * @param statusWord The status word
     * @return true if it's 100Mb, false if it's 10Mb
     */

    inline bool PhyBase::phyIs100M(uint16_t statusWord) const {
      return (statusWord & _params.phy_speedStatusBit)==0;
    }


    /**
     * return true if this is a full duplex link
     * @param statusWord The status word
     * @return true if it's full duplex, false if half duplex
     */

    inline bool PhyBase::phyIsFullDuplex(uint16_t statusWord) const {
      return (statusWord & _params.phy_duplexStatusBit)!=0;
    }


    /**
     * Enable the PHY loopback mode
     * @return true if it succeeds
     */

    inline bool PhyBase::phyEnableLoopback() const {
      return phySetRegisterBits(BASIC_MODE_CONFIGURATION,LOOPBACK_BIT);
    }


    /**
     * Disable the PHY loopback mode
     * @return true if it succeeds
     */

    inline bool PhyBase::phyDisableLoopback() const {
      return phyClearRegisterBits(BASIC_MODE_CONFIGURATION,LOOPBACK_BIT);
    }


    /**
     * Set the link speed to 100Mb/s
     * @return true if it worked
     */

    inline bool PhyBase::phySet100M() const {
      return phySetRegisterBits(BASIC_MODE_CONFIGURATION,SPEED_100M_BIT);
    }


    /**
     * Set the link speed to 10Mb/s
     * @return true if it worked
     */

    inline bool PhyBase::phySet10M() const {
      return phyClearRegisterBits(BASIC_MODE_CONFIGURATION,SPEED_100M_BIT);
    }


    /**
     * Set the duplex mode to FULL
     * @return true if it worked
     */

    inline bool PhyBase::phySetFullDuplex() const {
      return phySetRegisterBits(BASIC_MODE_CONFIGURATION,FULL_DUPLEX_BIT);
    }


    /**
     * Set the duplex mode to HALF
     * @return true if it worked
     */

    inline bool PhyBase::phySetHalfDuplex() const {
      return phyClearRegisterBits(BASIC_MODE_CONFIGURATION,FULL_DUPLEX_BIT);
    }


    /**
     * Check if the PHY is linked
     * @param[out] islinked true if linked
     * @return true if it worked
     */

    inline bool PhyBase::phyIsLinked(bool& islinked) const {

      uint16_t value;

      if(!phyReadRegister(STATUS_WORD,value))
        return false;

      islinked=(value & LINKED_STATUS_BIT)!=0;
      return true;
    }
  }
}
// END FILE: ../lib/include/net/physical/PhyBase.h
// START FILE: ../lib/include/net/physical/PhyHardReset.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /*
     * Provides optional support for issuing a hard reset to the PHY via its own active-low
     * reset pin. This is the most reliable method of resetting the PHY even if it's hung hard.
     *
     * Here's an example of how to include this feature in the physical layer of your network
     * stack. In this example PB14 is connected to the PHY reset pin.
     *
     * template<class TPhy> using MyPhyHardReset=PhyHardReset<TPhy,gpio::PB14>;
     * typedef PhysicalLayer<DP83848C,MyPhyHardReset> MyPhysicalLayer;
     */

    template<class TPhy,class TResetGpio>
    class PhyHardReset {

      public:
        struct Parameters {   ///<! required by the initialise() contract but not used
        };

      public:
        bool initialise(Parameters& params,NetworkUtilityObjects& netutils,TPhy& phy);
        bool startup();
    };


    /**
     * Initialise the class
     * @return true
     */

    template<class TPhy,class TResetGpio>
    inline bool PhyHardReset<TPhy,TResetGpio>::initialise(Parameters& /* params */,NetworkUtilityObjects& /* netutils */,TPhy& phy) {

      // initialise the reset pin for output

      GpioPinInitialiser::initialise(
          reinterpret_cast<GPIO_TypeDef *>(TResetGpio::Port),
          TResetGpio::Pin,
          Gpio::OUTPUT);

      // set up a pinref

      GpioPinRef resetPin(
          reinterpret_cast<GPIO_TypeDef *>(TResetGpio::Port),
          TResetGpio::Pin
        );

      // ask the PHY to do the reset. the PHY needs to do it because we
      // don't know the correct up/down/wait sequence

      phy.phyHardReset(resetPin);
      return true;
    }


    /**
     * Startup, nothing to do
     * @return true
     */

    template<class TPhy,class TResetGpio>
    inline bool PhyHardReset<TPhy,TResetGpio>::startup() {
      return true;
    }
  }
}
// END FILE: ../lib/include/net/physical/PhyHardReset.h
// START FILE: ../lib/include/net/physical/ksz8051mll/KSZ8051MLL.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Class for the KSZ8051MLL PHY. Contains additional register definitions
     * that describe the additional features of this PHY. This is an MII PHY.
     */

    class KSZ8051MLL : public PhyBase {

      public:

        /**
         * Custom registers for this PHY
         */

        enum {
          AFE_CONTROL                     = 0x11,   //!< AFE_CONTROL
          RXER_COUNTER                    = 0x15,   //!< RXER_COUNTER
          OPERATION_MODE_STRAP_OVERRIDE   = 0x16,   //!< OPERATION_MODE_STRAP_OVERRIDE
          OPERATION_MODE_STRAP_STATUS     = 0x17,   //!< OPERATION_MODE_STRAP_STATUS
          EXPANDED_CONTROL                = 0x18,   //!< EXPANDED_CONTROL
          INTERRUPT_CONTROL_STATUS        = 0x1b,   //!< INTERRUPT_CONTROL_STATUS
          LINKMD_CONTROL_STATUS           = 0x1d,   //!< LINKMD_CONTROL_STATUS
          PHY_CONTROL_1                   = 0x1e,   //!< PHY_CONTROL_1
          PHY_CONTROL_2                   = 0x1f    //!< PHY_CONTROL_2
        };

        /**
         * Interrupt bits
         */

        enum {
          INTERRUPT_JABBER                   = 0x80,  //!< INTERRUPT_JABBER
          INTERRUPT_RECEIVE_ERROR            = 0x40,  //!< INTERRUPT_RECEIVE_ERROR
          INTERRUPT_PAGE_RECEIVED            = 0x20,  //!< INTERRUPT_PAGE_RECEIVED
          INTERRUPT_PARALLEL_DETECT_FAULT    = 0x10,  //!< INTERRUPT_PARALLEL_DETECT_FAULT
          INTERRUPT_LINK_PARTNER_ACKNOWLEDGE = 0x8,   //!< INTERRUPT_LINK_PARTNER_ACKNOWLEDGE
          INTERRUPT_LINK_DOWN                = 0x4,   //!< INTERRUPT_LINK_DOWN
          INTERRUPT_REMOTE_FAULT             = 0x2,   //!< INTERRUPT_REMOTE_FAULT
          INTERRUPT_LINK_UP                  = 0x1,   //!< INTERRUPT_LINK_UP
          INTERRUPT_ALL                      = 0xff   //!< INTERRUPT_ALL
        };


        /**
         * Configuration parameters for the KSZ80511MLL
         */

        struct Parameters : virtual PhyBase::Parameters {

          /**
           * Constructor: set defaults
           */

          Parameters() {
            phy_resetDelay      = 2;        // wait 2ms after reset is asserted
            phy_speedStatusBit  = 0x0002;   // link speed bit in status word
            phy_duplexStatusBit = 0x0004;   // full duplex bit in status word
          }
        };

        bool phyEnableInterrupts(uint8_t interruptMask) const;
        bool phyDisableInterrupts(uint8_t interruptMask) const;
        bool phyClearPendingInterrupts() const;

        bool phyIs100M(bool& is100) const;
        bool phyIsFullDuplex(bool& isFull) const;

        // hard reset is supported through the PhyHardReset feature class

        void phyHardReset(GpioPinRef& pin) const;

        bool initialise(Parameters& params,NetworkUtilityObjects& netutils);
        bool startup();
    };


    /**
     * Initialise
     * @param params
     * @return
     */

    inline bool KSZ8051MLL::initialise(Parameters& params,NetworkUtilityObjects& netutils) {
      return PhyBase::initialise(params,netutils);
    }


    /**
     * Startup
     * @return
     */

    inline bool KSZ8051MLL::startup() {
      return PhyBase::startup();
    }


    /**
     * Check if we are linked at 100Mb/s
     * @param is100 true if we are at 100Mb/s
     * @return true if it worked
     */

    inline bool KSZ8051MLL::phyIs100M(bool& is100) const {

      uint16_t value;

      if(!phyReadRegister(PHY_CONTROL_1,value))
        return false;

      is100=(value & 0x0001)==0;
      return true;
    }


    /**
     * Check if we are linked at full duplex
     * @param is100 true if we are at 100Mb/s
     * @return true if it worked
     */

    inline bool KSZ8051MLL::phyIsFullDuplex(bool& isFull) const {

      uint16_t value;

      if(!phyReadRegister(PHY_CONTROL_1,value))
        return false;

      isFull=(value & 0x0004)!=0;
      return true;
    }


    /**
     * Enable interrupts to be received on the Observable interface. This function merges
     * the bits in interrupt mask into the register
     * @param interruptMask The interrupts to enable (INTERRUPT_*)
     * @return true if it worked
     */

    inline bool KSZ8051MLL::phyEnableInterrupts(uint8_t interruptMask) const {
      return phySetRegisterBits(INTERRUPT_CONTROL_STATUS,static_cast<uint16_t>(interruptMask) << 8);
    }


    /**
     * Disable interrupts to be received on the subscription callback. This function masks out
     * the bits in interrupt mask into the register
     * @param interruptMask The interrupts to enable (INTERRUPT_*)
     * @return true if it worked
     */

    inline bool KSZ8051MLL::phyDisableInterrupts(uint8_t interruptMask) const {
      return phyClearRegisterBits(INTERRUPT_CONTROL_STATUS,static_cast<uint16_t>(interruptMask) << 8);
    }


    /**
     * Clear pending interrupt flags. On the KSZ8051MLL reading the INTERRUPT_CONTROL_STATUS register
     * clears the pending interrupt flags
     * @return true if it worked
     */

    inline bool KSZ8051MLL::phyClearPendingInterrupts() const {
      uint16_t value;
      return phyReadRegister(INTERRUPT_CONTROL_STATUS,value);
    }


    /**
     * Hard-reset the PHY by pulling the RESET pin low for 20ms. The datasheet
     * indicates that 10ms is the minimum between stable power and rising reset so
     * we're playing safe.
     * @param pin
     */

    inline void KSZ8051MLL::phyHardReset(GpioPinRef& pin) const {
      pin.reset();
      MillisecondTimer::delay(20);
      pin.set();
    }
  }
}
// END FILE: ../lib/include/net/physical/ksz8051mll/KSZ8051MLL.h
// START FILE: ../lib/include/net/physical/PhyReadRequestEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"


namespace stm32plus {
  namespace net {


    /**
     * Read event for a PHY. Sent as a notification by the physical layer PHY and
     * actioned in the datalink layer by the MAC. The interface to a PHY is via
     * 16-bit registers.
     */

    struct PhyReadRequestEvent : NetEventDescriptor {

      uint16_t phyAddress;          ///< The station id of the PHY
      uint16_t regNumber;           ///< The register number to read
      uint32_t timeoutMillis;       ///< How long to wait in ms

      bool succeeded;               ///< set by the link layer to true if able to read
      uint16_t result;              ///< the result of the read if it was successful


      /**
       * Constructor
       */

      PhyReadRequestEvent(uint16_t address,uint16_t rnum,uint32_t timeout)
        : NetEventDescriptor(NetEventType::PHY_READ_REQUEST),
          phyAddress(address),
          regNumber(rnum),
          timeoutMillis(timeout) {

        succeeded=false;
      }
    };
  }
}
// END FILE: ../lib/include/net/physical/PhyReadRequestEvent.h
// START FILE: ../lib/include/net/physical/lan8710a/LAN8710A.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

namespace stm32plus {
  namespace net {

    /**
     * Class for the LAN8710a PHY. Contains additional register definitions
     * that describe the additional features of this PHY. This is an MII/RMII PHY.
     */

    class LAN8710A : public PhyBase {

      public:

        /**
         * Custom registers for this PHY
         */

        enum {
          PHY_BasicControl=0,
          PHY_BasicStatus=1,
          PHY_Identifier1=2,
          PHY_Identifier2=3,
          PHY_AutoNegotiationAdvertisement=4,
          PHY_AutoNegotiationLinkPartnerAbility=5,
          PHY_AutoNegotiationExpansion=6,
          PHY_ModeControlStatus=17,
          PHY_SpecialModes=18,
          PHY_SymbolErrorCounter=26,
          PHY_ControlStatusIndication=27,
          PHY_InterruptSource=29,
          PHY_InterruptMask=30,
          PHY_SpecialControlStatus=31
        };


        /**
         * Interrupt bits
         */

        enum {
          INTERRUPT_ENERGYON=0x80,
          INTERRUPT_AUTO_NEGOTIATION=0x40,
          INTERRUPT_REMOTE_FAULT=0x20,
          INTERRUPT_LINK_DOWN=0x10,
          INTERRUPT_AUTO_NEGOTIATION_LP_ACK=0x8,
          INTERRUPT_PARALLEL_FAULT=0x4,
          INTERRUPT_AUTO_NEGOTIATION_PAGE_RX=0x2,
          INTERRUPT_ALL=0xf7
        };


        /**
         * Configuration parameters for the LAN8710A
         */

        struct Parameters : virtual PhyBase::Parameters {

            /**
             * Constructor: set defaults
             */

            Parameters() {

              phy_resetDelay=2;           // wait 2ms after reset is asserted
              phy_speedStatusBit=0x0002;  // link speed bit in status word
              phy_duplexStatusBit=0x0004; // full duplex bit in status word
            }
        };

        bool phyEnableInterrupts(uint8_t interruptMask) const;
        bool phyDisableInterrupts(uint8_t interruptMask) const;

        bool phyIs100M(bool& is100) const;
        bool phyIsFullDuplex(bool& isFull) const;
        bool phyClearPendingInterrupts() const;
        bool phyGetPendingInterrupts(uint16_t& interrupts) const;

        // hard reset is supported through the PhyHardReset feature class

        void phyHardReset(GpioPinRef& pin) const;

        bool initialise(Parameters& params,NetworkUtilityObjects& netutils);
        bool startup();
    };


    /**
     * Initialise the PHY class
     * @param params The parameters class
     * @param netutils The network utilities
     * @return true if it worked
     */

    inline bool LAN8710A::initialise(Parameters& params,NetworkUtilityObjects& netutils) {
      return PhyBase::initialise(params,netutils);
    }


    /**
     * Startup
     * @return true if it worked
     */

    inline bool LAN8710A::startup() {
      return PhyBase::startup();
    }


    /**
     * Check if we are linked at 100Mb/s
     * @param is100 true if we are at 100Mb/s
     * @return true if it worked
     */

    inline bool LAN8710A::phyIs100M(bool& is100) const {

      uint16_t value;

      if(!phyReadRegister(PHY_BasicStatus,value))
        return false;

      is100=(value & 0xE600)!=0;    // bits 15,14,13,10,9
      return true;
    }


    /**
     * Check if we are linked at full duplex
     * @param is100 true if we are at 100Mb/s
     * @return true if it worked
     */

    inline bool LAN8710A::phyIsFullDuplex(bool& isFull) const {

      uint16_t value;

      if(!phyReadRegister(PHY_BasicStatus,value))
        return false;

      isFull=(value & 0x5400)!=0;   // bits 14,12,10
      return true;
    }


    /**
     * Clear pending interrupt flags. On the LAN8710A reading the MISR register
     * clears the pending interrupt flags
     * @return true if it worked
     */

    inline bool LAN8710A::phyClearPendingInterrupts() const {
      uint16_t value;
      return phyReadRegister(PHY_InterruptSource,value);
    }


    /**
     * Read the pending interrupts register to determine which ones have fired
     * @param[out] interrupts The interrupt bitmask. Can be AND'ed with INTERRUPT_ values
     * @return true if it worked
     */

    inline bool LAN8710A::phyGetPendingInterrupts(uint16_t& interrupts) const {
      return phyReadRegister(PHY_InterruptSource,interrupts);
    }


    /**
     * Enable interrupts to be received on the Observable interface. This function merges
     * the bits in interrupt mask into the register
     * @param interruptMask The interrupts to enable (INTERRUPT_*)
     * @return true if it worked
     */

    inline bool LAN8710A::phyEnableInterrupts(uint8_t interruptMask) const {
      return phySetRegisterBits(PHY_InterruptMask,interruptMask);
    }


    /**
     * Disable interrupts to be received on the Observable interface. This function masks out
     * the bits in interrupt mask into the register
     * @param interruptMask The interrupts to enable (INTERRUPT_*)
     * @return true if it worked
     */

    inline bool LAN8710A::phyDisableInterrupts(uint8_t interruptMask) const {
      return phyClearRegisterBits(PHY_InterruptMask,interruptMask);
    }


    /**
     * Hard-reset the PHY by pulling the RESET pin low for 5ms. The datasheet
     * indicates that 1us is the minimum between stable power and rising reset so
     * we're playing safe.
     * @param pin
     */

    inline void LAN8710A::phyHardReset(GpioPinRef& pin) const {
      pin.reset();
      MillisecondTimer::delay(5);
      pin.set();
    }
  }
}
// END FILE: ../lib/include/net/physical/lan8710a/LAN8710A.h
// START FILE: ../lib/include/net/physical/PhyWriteRequestEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"


namespace stm32plus {
  namespace net {


    /**
     * Write event for a PHY. Sent as a notification by the physical layer PHY and
     * actioned in the datalink layer by the MAC. The interface to a PHY is via
     * 16-bit registers.
     */

    struct PhyWriteRequestEvent : NetEventDescriptor {

      uint16_t phyAddress;          ///< The station id of the PHY
      uint16_t regNumber;           ///< The register number to read
      uint16_t regValue;            ///< The value to write
      uint32_t timeoutMillis;       ///< How long to wait in ms

      bool succeeded;               ///< set by the link layer to true if able to read


      /**
       * Constructor
       */

      PhyWriteRequestEvent(uint16_t address,uint16_t rnum,uint16_t rvalue,uint32_t timeout)
        : NetEventDescriptor(NetEventType::PHY_WRITE_REQUEST),
          phyAddress(address),
          regNumber(rnum),
          regValue(rvalue),
          timeoutMillis(timeout) {

        succeeded=false;
      }
    };
  }
}
// END FILE: ../lib/include/net/physical/PhyWriteRequestEvent.h
// START FILE: ../lib/include/net/physical/PhysicalLayer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Template feature-holder for features that live in the physical network layer, e.g. PHY.
     * The physical layer is the lowest level of the layers that we support. There is nothing
     * below it and the level above is the datalink layer. A PHY class implementation is required
     * and all the features are implemented as templates parameterised with the PHY type and receiving
     * a reference to the PHY as a parameter to initialise()
     */

    template<class TPhy,template <class> class... Features>
    class PhysicalLayer : public TPhy,
                          public Features<TPhy>...,
                          public virtual NetworkUtilityObjects {
      public:

        /**
         * Base parameters collection-class for physical layer features
         */

        struct Parameters : TPhy::Parameters,
                            Features<TPhy>::Parameters...,
                            NetworkIntervalTicker::Parameters {
        };

      public:
        bool initialise(Parameters& params);
        bool startup();
    };


    /**
     * Initialise the features
     * @param params The parameters class to initialise the layer features
     * @return true if it worked
     */

    template<class TPhy,template <class> class... Features>
    bool PhysicalLayer<TPhy,Features...>::initialise(Parameters& params) {

      // initialise the interval ticker

      if(!NetworkIntervalTicker::initialise(params))
        return false;

      // initialise the PHY

      if(!TPhy::initialise(params,*this))
        return false;

      // recursively initialise the features

      return RecursivePhysicalLayerInit<PhysicalLayer,TPhy,Features<TPhy>...>::tinit(this,params,*this,*this);
    }


    /**
     * Startup the components in this layer
     * @return
     */

    template<class TPhy,template <class> class... Features>
    bool PhysicalLayer<TPhy,Features...>::startup() {

      // startup the interval ticker

      if(!NetworkIntervalTicker::startup())
        return false;

      // startup the PHY

      if(!TPhy::startup())
        return false;

      // recursively startup the features

      return RecursiveBoolStartup<PhysicalLayer,TPhy,Features<TPhy>...>::tstartup(this);
    }
  }
}
// END FILE: ../lib/include/net/physical/PhysicalLayer.h
// START FILE: ../lib/include/net/physical/dp83848c/DP83848C.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Class for the Texas Instruments DP83848C PHY. Contains additional
     * register definitions that describe the additional features of this PHY.
     */

    class DP83848C : public PhyBase {

      public:

        /**
         * Custom registers for this PHY
         */

        enum {
          PHY_STATUS                      = 0x10,   //!< PHY_STATUS
          INTERRUPT_CONTROL               = 0x11,   //!< INTERRUPT_CONTROL
          INTERRUPT_STATUS                = 0x12,   //!< INTERRUPT_STATUS
          FALSE_CARRIER_SENSE_COUNTER     = 0x14,   //!< FALSE_CARRIER_SENSE_COUNTER
          RXER_COUNTER                    = 0x15,   //!< RXER_COUNTER
          PCS_CONFIG_STATUS_100           = 0x16,   //!< PCS_CONFIG_STATUS_100
          RMII_AND_BYPASS                 = 0x17,   //!< RMII_AND_BYPASS
          LED_DIRECT_CONTROL              = 0x18,   //!< LED_DIRECT_CONTROL
          PHY_CONTROL                     = 0x19,   //!< PHY_CONTROL
          STATUS_CONTROL_10BASET          = 0x1a,   //!< STATUS_CONTROL_10BASET
          CD_TEST_BIST                    = 0x1b,   //!< CD_TEST_BIST
          ENERGY_DETECT_CONTROL           = 0x1d    //!< ENERGY_DETECT_CONTROL
        };

        /**
         * Interrupt bits
         */

        enum {
          INTERRUPT_ENERGY_DETECT             = 0x40, //!< INTERRUPT_ENERGY_DETECT
          INTERRUPT_LINK_STATUS_CHANGE        = 0x20, //!< INTERRUPT_LINK_STATUS_CHANGE
          INTERRUPT_SPEED_STATUS_CHANGE       = 0x10, //!< INTERRUPT_SPEED_STATUS_CHANGE
          INTERRUPT_DUPLEX_STATUS_CHANGE      = 0x8,  //!< INTERRUPT_DUPLEX_STATUS_CHANGE
          INTERRUPT_AUTO_NEGOTIATION_COMPLETE = 0x4,  //!< INTERRUPT_AUTO_NEGOTIATION_COMPLETE
          INTERRUPT_FCC_HALF_FULL             = 0x2,  //!< INTERRUPT_FCC_HALF_FULL
          INTERRUPT_RXER_HALF_FULL            = 0x1,  //!< INTERRUPT_RXER_HALF_FULL
          INTERRUPT_ALL                       = 0x7f  //!< INTERRUPT_ALL
        };


        /**
         * Configuration parameters for the DP83848C
         */

        struct Parameters : virtual PhyBase::Parameters {

          /**
           * Constructor: set defaults
           */

          Parameters() {
            phy_resetDelay      = 2;        // wait 2ms after reset is asserted
            phy_speedStatusBit  = 0x0002;   // link speed bit in status word
            phy_duplexStatusBit = 0x0004;   // full duplex bit in status word
          }
        };

        bool phyEnableInterrupts(uint8_t interruptMask) const;
        bool phyDisableInterrupts(uint8_t interruptMask) const;

        bool phyIs100M(bool& is100) const;
        bool phyIsFullDuplex(bool& isFull) const;
        bool phyClearPendingInterrupts() const;
        bool phyGetPendingInterrupts(uint16_t& interrupts) const;

        // hard reset is supported through the PhyHardReset feature class

        void phyHardReset(GpioPinRef& pin) const;

        bool initialise(Parameters& params,NetworkUtilityObjects& netutils);
        bool startup();
    };


    /**
     * Initialise the PHY class
     * @param params The parameters class
     * @param netutils The network utilities
     * @return true if it worked
     */

    inline bool DP83848C::initialise(Parameters& params,NetworkUtilityObjects& netutils) {
      return PhyBase::initialise(params,netutils);
    }


    /**
     * Startup
     * @return true if it worked
     */

    inline bool DP83848C::startup() {
      return PhyBase::startup();
    }


    /**
     * Check if we are linked at 100Mb/s
     * @param is100 true if we are at 100Mb/s
     * @return true if it worked
     */

    inline bool DP83848C::phyIs100M(bool& is100) const {

      uint16_t value;

      if(!phyReadRegister(PHY_STATUS,value))
        return false;

      is100=(value & 0x0002)==0;
      return true;
    }


    /**
     * Check if we are linked at full duplex
     * @param is100 true if we are at 100Mb/s
     * @return true if it worked
     */

    inline bool DP83848C::phyIsFullDuplex(bool& isFull) const {

      uint16_t value;

      if(!phyReadRegister(PHY_STATUS,value))
        return false;

      isFull=(value & 0x0004)!=0;
      return true;
    }


    /**
     * Clear pending interrupt flags. On the DP83848C reading the MISR register
     * clears the pending interrupt flags
     * @return true if it worked
     */

    inline bool DP83848C::phyClearPendingInterrupts() const {
      uint16_t value;
      return phyReadRegister(INTERRUPT_STATUS,value);
    }


    /**
     * Read the pending interrupts register to determine which ones have fired
     * @param[out] interrupts The interrupt bitmask. Can be AND'ed with INTERRUPT_ values
     * @return true if it worked
     */

    inline bool DP83848C::phyGetPendingInterrupts(uint16_t& interrupts) const {

      if(!phyReadRegister(INTERRUPT_STATUS,interrupts))
        return false;

      // pending bits are in the upper byte, shift them down so that the INTERRUPT_* masks apply

      interrupts>>=8;
      return true;
    }


    /**
     * Enable interrupts to be received on the Observable interface. This function merges
     * the bits in interrupt mask into the register
     * @param interruptMask The interrupts to enable (INTERRUPT_*)
     * @return true if it worked
     */

    inline bool DP83848C::phyEnableInterrupts(uint8_t interruptMask) const {
      return
          phySetRegisterBits(INTERRUPT_CONTROL,0x3) &&        // INT(pin-7) + INTEN
          phySetRegisterBits(INTERRUPT_STATUS,interruptMask);
    }


    /**
     * Disable interrupts to be received on the Observable interface. This function masks out
     * the bits in interrupt mask into the register
     * @param interruptMask The interrupts to enable (INTERRUPT_*)
     * @return true if it worked
     */

    inline bool DP83848C::phyDisableInterrupts(uint8_t interruptMask) const {
      return phyClearRegisterBits(INTERRUPT_STATUS,interruptMask);
    }


    /**
     * Hard-reset the PHY by pulling the RESET pin low for 5ms. The datasheet
     * indicates that 1us is the minimum between stable power and rising reset so
     * we're playing safe.
     * @param pin
     */

    inline void DP83848C::phyHardReset(GpioPinRef& pin) const {
      pin.reset();
      MillisecondTimer::delay(5);
      pin.set();
    }
  }
}
// END FILE: ../lib/include/net/physical/dp83848c/DP83848C.h
// START FILE: ../lib/include/net/network/IpProtocol.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * IP protocol numbers. Not all of them.
     */

    enum class IpProtocol : uint8_t {
      ICMP = 0x01,
      TCP   = 0x06,
      UDP   = 0x11
    };
  }
}

// END FILE: ../lib/include/net/network/IpProtocol.h
// START FILE: ../lib/include/net/network/ip/InternetChecksum.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Utility class to do the IP checksum algorithm
     */

    class InternetChecksum {

      protected:

        struct PseudoHeader {
          IpAddress sourceAddress;
          IpAddress destinationAddress;
          uint8_t zero;
          IpProtocol protocol;
          uint16_t length;
        };

      protected:
        static void sumit(const void *vptr,uint16_t length,uint32_t& sum);

      public:
        static void calculate(const IpAddress& sourceAddress,const IpAddress& destinationAddress,NetBuffer& nb);
    };
  }
}
// END FILE: ../lib/include/net/network/ip/InternetChecksum.h
// START FILE: ../lib/include/net/network/ip/IpAddress.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * IP address structure
     */

    struct IpAddress {
      union {
        uint32_t ipAddress;               // big-endian. 192.0.2.235 = 0xC00002EB
        uint8_t ipAddressBytes[4];        // e.g. 0xC0 0x00 0x02 0xEB
      };


      /**
       * Constructor, ensure address is zero when we start up
       */

      IpAddress() : ipAddress(0) {
      }


      /**
       * Copy constructor - ensure this gets done with a single word copy
       * @param src
       */

      IpAddress(const IpAddress& src) {
        ipAddress=src.ipAddress;
      }


      /**
       * Construct from a dotted IP address
       * @param dottedIp The a.b.c.d address
       */

      IpAddress(const char *dottedIp) {
        operator=(dottedIp);
      }


      /**
       * Check if this is a valid (non-zero) address
       */

      bool isValid() const {
        return ipAddress!=0;
      }


      /**
       * Check if this is the broadcast address 255.255.255.255
       * @return true if it is the broadcast address
       */

      bool isBroadcast() const {
        return ipAddress==0xFFFFFFFF;
      }


      /**
       * Check if this is the all-hosts multicast group (224.0.0.1)
       * @return true if it matches
       */

      bool isAllHostsMulticastGroup() const {
        return ipAddress==0x010000E0;
      }


      /**
       * Check if this is an address in any of the host groups
       */

      bool isMulticastGroup() const {
        return NetUtil::ntohl(ipAddress)>=0xE0000001 && NetUtil::ntohl(ipAddress)<=0xEFFFFFFF;
      }


      /**
       * Invalidate this address
       */

      void invalidate() {
        ipAddress=0;
      }


      /**
       * Equality operator
       */

      bool operator==(const IpAddress& rhs) const {
        return ipAddress==rhs.ipAddress;
      }
      bool operator!=(const IpAddress& rhs) const {
        return !operator==(rhs);
      }


      /**
       * Set up from a dotted quad "a.b.c.d". The format is not error checked.
       * @param addr The dotted quad address
       * @return a self reference
       */

      IpAddress& operator=(const char *addr) {

        uint8_t *ptr,index;

        index=0;
        ptr=ipAddressBytes;
        *ptr=0;

        while(index<4 && *addr) {

          if(isdigit(*addr))
            *ptr=(*ptr*10)+(*addr)-'0';
          else if(*addr=='.') {
            ptr++;
            *ptr=0;
          }

          addr++;
        }

        return *this;
      }


      /**
       * Assignment
       * @param rhs Copy source
       * @return self reference
       */

      IpAddress& operator=(const IpAddress& rhs) {
        ipAddress=rhs.ipAddress;
        return *this;
      }

      /**
       * Returning a reference causes gcc to emit a bogus warning
       * @param rhs
       */

      void operator=(const volatile IpAddress& rhs) volatile {
        ipAddress=rhs.ipAddress;
      }


      /**
       * Assign 127.0.0.1 to this address
       */

      void setLocalhost() {
        ipAddress=0x7f000001;
      }


      /**
       * Check if this IP address is localhost
       * @return true if it is localhost
       */

      bool isLocalhost() const {
        return ipAddress==0x7f000001;
      }


      /**
       * Check if this IP address is on the local class A network (127.X.X.X)
       * @return true if it's on the local net
       */

      bool isLocalNetwork() const {
        return ipAddressBytes[0]==127;
      }


      /**
       * Write to a user-supplied buffer as A.B.C.D
       * @param buffer Where to write
       */

      void toString(char *buffer) const {

        uint8_t i;

        for(i=0;i<4;i++) {

          StringUtil::modp_uitoa10(ipAddressBytes[i],buffer);
          buffer+=strlen(buffer);

          if(i!=3)
            *buffer++='.';
        }
      }

    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/network/ip/IpAddress.h
// START FILE: ../lib/include/net/network/ip/IpPacketEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for an IP packet arrival
     */

    struct IpPacketEvent : NetEventDescriptor {

      /**
       * The IP packet reference
       */

      IpPacket& ipPacket;


      /**
       * Constructor
       * @param frame
       */

      IpPacketEvent(IpPacket& packet)
        : NetEventDescriptor(NetEventType::IP_PACKET),
          ipPacket(packet) {
      }
    };
  }
}
// END FILE: ../lib/include/net/network/ip/IpPacketEvent.h
// START FILE: ../lib/include/net/network/ip/IpPacketHeader.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Header of an IPv4 packet. Not documented here, documentation abounds on the internet.
     */

    struct IpPacketHeader {

      uint8_t ip_hdr_version;
      uint8_t ip_hdr_typeOfService;
      uint16_t ip_hdr_length;
      uint16_t ip_hdr_identification;
      uint16_t ip_hdr_flagsAndOffset;
      uint8_t ip_hdr_ttl;
      IpProtocol ip_hdr_protocol;
      uint16_t ip_hdr_checksum;

      IpAddress ip_sourceAddress;
      IpAddress ip_destinationAddress;

      /**
       * Get the size of an IP header with no options
       */

      constexpr static uint16_t getNoOptionsHeaderSize() {
        return 20;
      }
    } __attribute__((packed));      // 20 bytes.
  }
}
// END FILE: ../lib/include/net/network/ip/IpPacketHeader.h
// START FILE: ../lib/include/net/network/ip/Ip.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Network layer feature that implements IP version 4.
     */

    DECLARE_EVENT_SIGNATURE(IpReceive,void (IpPacketEvent&));

    template<class TDatalinkLayer,class... Features>
    class Ip : public virtual TDatalinkLayer,
               public IpPorts,
               public Features... {

      public:

        /**
         * Error codes
         */

        enum {
          E_REASSEMBLY_FAILURE = 1,
          E_FRAGMENTATION_FAILED,
          E_ARP_LOOKUP_FAILED,
          E_OUT_OF_MEMORY,
          E_UNCONFIGURED
        };

        DECLARE_EVENT_SOURCE(IpReceive);

        /**
         * Parameters for tuning the IP protocol handler
         */

        struct Parameters : IpPorts::Parameters,
                            Features::Parameters... {

          uint8_t ip_initialTtl;                    ///< TTL value inserted into new IP packets. The default is 64.

          /**
           * Constructor, set up parameters
           */

          Parameters() {
            ip_initialTtl=64;
          }
        };

      protected:
        IpAddress _myIpAddress;
        IpSubnetMask _mySubnetMask;
        MacAddress _myMacAddress;
        uint8_t _initialTtl;

      protected:
        void handleAddressMappingEvent(const MacAddress& mac,const IpAddress& ipAddress);
        bool canAcceptPacket(const IpAddress& destinationAddress) const;

        void onReceive(NetEventDescriptor& ned);
        void onSend(NetEventDescriptor& ned);
        void onNotification(NetEventDescriptor& ned);

        void setCommonTransmitHeaderValues(IpPacketHeader& header,IpTransmitRequestEvent& txevent);
        void sendToLocalhost(IpTransmitRequestEvent& txevent);

      public:
        bool initialise(Parameters&);
        bool startup();

        const IpAddress& getIpAddress() const;
        constexpr uint32_t getIpTransmitHeaderSize() const;
    };


    /**
     * Define a type for the common case of not requiring support for packet
     * fragmentation and reassembly
     */

    template<class TDatalinkLayer>
    using DefaultIp=Ip<TDatalinkLayer,IpDisablePacketFragmentFeature,IpDisablePacketReassemblerFeature>;


    /**
     * Define types for the less usual cases of packet fragmentation, reassembly and both
     */

    template<class TDatalinkLayer>
    using IpWithOutboundFragmentation=Ip<TDatalinkLayer,IpPacketFragmentFeature,IpDisablePacketReassemblerFeature>;

    template<class TDatalinkLayer>
    using IpWithInboundReassembly=Ip<TDatalinkLayer,IpDisablePacketFragmentFeature,IpPacketReassemblerFeature>;

    template<class TDatalinkLayer>
    using IpWithFragmentationAndReassembly=Ip<TDatalinkLayer,IpPacketFragmentFeature,IpPacketReassemblerFeature>;


    /**
     * Initialise the protocol.
     * @param params The parameters
     * @return true if it worked
     */

    template<class TDatalinkLayer,class... Features>
    inline bool Ip<TDatalinkLayer,Features...>::initialise(Parameters& params) {

      // initialise the ports class

      if(!IpPorts::initialise(params,*this))
        return false;

      // initialise the features list

      if(!RecursiveBoolInitWithParamsAndNetworkUtilityObjects<Ip,Features...>::tinit(this,params,*this))
        return false;

      // remember parameters

      _initialTtl=params.ip_initialTtl;

      // subscribe to send/receive/notify events from the network

      this->NetworkReceiveEventSender.insertSubscriber(NetworkReceiveEventSourceSlot::bind(this,&Ip<TDatalinkLayer,Features...>::onReceive));
      this->NetworkSendEventSender.insertSubscriber(NetworkSendEventSourceSlot::bind(this,&Ip<TDatalinkLayer,Features...>::onSend));
      this->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&Ip<TDatalinkLayer,Features...>::onNotification));

      return true;
    }


    /**
     * Startup the class.
     * @param params The parameters
     * @return true if it worked
     */

    template<class TDatalinkLayer,class... Features>
    inline bool Ip<TDatalinkLayer,Features...>::startup() {

      // startup the features list

      return RecursiveBoolStartup<Ip,Features...>::tstartup(this);;
    }


    /**
     * Get the size of the Tx header
     * @return 20 bytes. We don't set extended options.
     */

    template<class TDatalinkLayer,class... Features>
    inline constexpr uint32_t Ip<TDatalinkLayer,Features...>::getIpTransmitHeaderSize() const {
      return IpPacketHeader::getNoOptionsHeaderSize();
    }


    /**
     * Notification from our subscription to notification events
     * @param ned The event descriptor
     */

    template<class TDatalinkLayer,class... Features>
    inline void Ip<TDatalinkLayer,Features...>::onNotification(NetEventDescriptor& ned) {

      // if it's a new IP address then we are interested

      if(ned.eventType==NetEventDescriptor::NetEventType::IP_ADDRESS_ANNOUNCEMENT)
        _myIpAddress=static_cast<IpAddressAnnouncementEvent&>(ned).ipAddress;
      else if(ned.eventType==NetEventDescriptor::NetEventType::MAC_ADDRESS_ANNOUNCEMENT)
        _myMacAddress=static_cast<MacAddressAnnouncementEvent&>(ned).macAddress;
      else if(ned.eventType==NetEventDescriptor::NetEventType::SUBNET_MASK_ANNOUNCEMENT)
        _mySubnetMask=static_cast<IpSubnetMaskAnnouncementEvent&>(ned).subnetMask;
    }


    /**
     * Notification from our subscription to the datalink layer's receive events. This is IRQ code.
     * @param ned The event descriptor
     */

    template<class TDatalinkLayer,class... Features>
    inline void Ip<TDatalinkLayer,Features...>::onReceive(NetEventDescriptor& ned) {

      IpPacketHeader *header;

      // check if it's for us

      if(ned.eventType!=NetEventDescriptor::NetEventType::DATALINK_FRAME)
        return;

      DatalinkFrame& frame=static_cast<DatalinkFrameEvent&>(ned).datalinkFrame;

      // must be an IP frame

      if(frame.protocol!=static_cast<uint16_t>(EtherType::IP))
        return;

      // IP packets cannot be shorter than 20 bytes

      if(frame.payloadLength<20)
        return;

      // quickly check the version and get out if it's not IP

      header=reinterpret_cast<IpPacketHeader *>(frame.payload);
      if((header->ip_hdr_version & 0xf0)!=0x40)
        return;

      // we accept the packet if the destination address...
      // 1. Is our unicast address
      // 2. Is the global broadcast address
      // 3. Is the local subnet broadcast address
      // 4. Is a multicast group to which we are subscribed

      if(!canAcceptPacket(header->ip_destinationAddress))
        return;

      // now construct the packet structure

      IpPacket packet;

      // for performance reasons the header fields are not deconstructed here. they can
      // be fetched on demand for anything that needs them.

      packet.headerLength=(header->ip_hdr_version & 0x0f)*4;
      packet.header=header;
      packet.payload=reinterpret_cast<uint8_t *>(((uint32_t)header)+packet.headerLength);
      packet.payloadLength=NetUtil::ntohs(header->ip_hdr_length)-packet.headerLength;

      // if the packet came from ethernet then we notify that there is a potentially
      // new address mapping that can be cached

      if(frame.frameSource==DatalinkFrame::FrameSource::ETHERNET_FRAME)
        handleAddressMappingEvent(*static_cast<EthernetFrame&>(frame).sourceMac,packet.header->ip_sourceAddress);

      // if the packet is fragmented, handle it

      if(packet.isFragmented()) {

        IpFragmentedPacket *fp;

        if(!this->ip_handleFragment(packet,fp)) {

          // there was a failure to handle the packet fragment, notify observers and finish

          this->setError(errorProvider.getProvider(),errorProvider.getCode(),errorProvider.getCause());
          return;
        }

        // if this is the last fragment then the reassembled packet is the one to use and it can be free'd
        // after we've notified upwards

        if(fp->isComplete()) {

          // the header on the this incoming packet is fine but the payload is the reassembled packet

          packet.payload=fp->packet;
          packet.payloadLength=fp->packetLength;

          // notify and free

          IpReceiveEventSender.raiseEvent(IpPacketEvent(packet));
          this->ip_freePacket(fp);
        }
      }
      else {

        // notify the observers of the incoming packet

        IpReceiveEventSender.raiseEvent(IpPacketEvent(packet));
      }
    }


    /**
     * Check if we can accept this packet
     * @param destinationAddress Where the packet was addressed to
     * @return true if we can accept it
     */

    template<class TDatalinkLayer,class... Features>
    inline bool Ip<TDatalinkLayer,Features...>::canAcceptPacket(const IpAddress& destinationAddress) const {

      // must check this first because DHCP replies come back as broadcasts at startup
      // while we are unconfigured

      if(destinationAddress.isBroadcast() || destinationAddress.isAllHostsMulticastGroup())
        return true;

      // further checks need our address

      if(!_myIpAddress.isValid())
        return false;

      // if it's our address then OK

      if(destinationAddress==_myIpAddress)
        return true;

      // further checks need our subnet mask

      if(!_mySubnetMask.isValid())
        return false;

      // check for the local broadcast address

      if(_mySubnetMask.isBroadcastAddress(_myIpAddress))
        return true;

      // TODO: support user-joined multicast groups

      return false;
    }


    /**
     * Notification from our subscription to the network's send event
     * @param ned The event descriptor
     */

    template<class TDatalinkLayer,class... Features>
    inline void Ip<TDatalinkLayer,Features...>::onSend(NetEventDescriptor& ned) {

      uint16_t packetSize;

      // must be a send event

      if(ned.eventType!=NetEventDescriptor::NetEventType::IP_TRANSMIT_REQUEST)
        return;

      IpTransmitRequestEvent& txevent(static_cast<IpTransmitRequestEvent&>(ned));

      // special case for the local class A network

      if(txevent.destinationIpAddress.isLocalNetwork()) {
        sendToLocalhost(txevent);
        txevent.succeeded=true;
        return;
      }

      // we can't do anything without a MAC.

      if(!_myMacAddress.isValid()) {
        this->setError(ErrorProvider::ERROR_PROVIDER_NET_IP,E_UNCONFIGURED);
        return;
      }

      // we can only do without an IP address if the destination is 255.255.255.255
      // because it's going to be the DHCP client

      if(!_myIpAddress.isValid() && !txevent.destinationIpAddress.isBroadcast()) {
        this->setError(ErrorProvider::ERROR_PROVIDER_NET_IP,E_UNCONFIGURED);
        return;
      }

      // we need the MAC address of the destination. if we came here from an IRQ (a received frame)
      // then it will already have been put into the ARP cache on the way up the stack. as well as
      // being efficient this is necessary because we cannot do tx-wait-rx while in an ethernet rx IRQ.

      ArpMappingRequestEvent arpRequest(txevent.destinationIpAddress);

      this->NetworkNotificationEventSender.raiseEvent(arpRequest);

      // did it work?

      if(!arpRequest.found) {
        this->setError(ErrorProvider::ERROR_PROVIDER_NET_IP,E_ARP_LOOKUP_FAILED);
        return;
      }

      // get the total IP packet size and check if we must fragment

      packetSize=getIpTransmitHeaderSize()+txevent.networkBuffer->getSizeFromWritePointerToEnd()+txevent.networkBuffer->getUserBufferSize();
      if(packetSize>this->getDatalinkMtuSize()) {

        NetBuffer **outputBuffers;
        uint16_t i,outputBufferCount;

        // create fragments

        if(!this->ip_createFragments(txevent.protocol,
                                      _myIpAddress,
                                      txevent.destinationIpAddress,
                                      this->getDatalinkMtuSize(),
                                      this->getDatalinkTransmitHeaderSize(),
                                      txevent.networkBuffer,
                                      outputBuffers,
                                      outputBufferCount)) {

          this->setError(ErrorProvider::ERROR_PROVIDER_NET_IP,E_FRAGMENTATION_FAILED);
          return;
        }

        // send the fragments

        for(i=0;i<outputBufferCount;i++) {

          setCommonTransmitHeaderValues(
              *reinterpret_cast<IpPacketHeader *>(outputBuffers[i]->getWritePointer()),
              txevent);

          // send the fragment. fragmented packets cannot have auto protocol checksum calculation because
          // they are incomplete.

          EthernetTransmitRequestEvent etre(outputBuffers[i],
                                            arpRequest.macAddress,
                                            EtherType::IP,
                                            DatalinkChecksum::IP_HEADER);

          // raise the event and fail if it failed (the link layer will already have set an error)

          this->NetworkSendEventSender.raiseEvent(etre);
          if(!etre.succeeded) {
            free(outputBuffers);
            return;
          }
        }

        // free memory used to hold the array of netbuffers who's ownership is now transferred to
        // the link layer

        free(outputBuffers);
      }
      else {

        // create the IP header in the netbuffer

        IpPacketHeader *header=reinterpret_cast<IpPacketHeader *>(txevent.networkBuffer->moveWritePointerBack(getIpTransmitHeaderSize()));

        setCommonTransmitHeaderValues(*header,txevent);

        // these values are not common between fragmented and non-fragmented

        header->ip_hdr_length=NetUtil::htons(static_cast<uint16_t>(txevent.networkBuffer->getSizeFromWritePointerToEnd()+txevent.networkBuffer->getUserBufferSize()));
        header->ip_hdr_identification=0;
        header->ip_hdr_flagsAndOffset=0;                                  // we will not fragment

        // cool, now we have enough info to ask the datalink layer to send the packet

        EthernetTransmitRequestEvent etre(txevent.networkBuffer,
                                          arpRequest.macAddress,
                                          EtherType::IP,
                                          DatalinkChecksum::IP_HEADER_AND_PROTOCOL);

        // raise the event

        this->NetworkSendEventSender.raiseEvent(etre);
        if(!etre.succeeded)
          return;             // error code already set by link layer
      }

      // it worked

      txevent.succeeded=true;
    }


    /**
     * Send this event to the localhost. i.e. don't send it at all, just raise a
     * receive event for the NetBuffer then clean it up afterwards. This has the side effect
     * that the receive event is called on the main thread and not an IRQ. That should not
     * make any difference to user code.
     * @param txevent The transmit event
     */

    template<class TDatalinkLayer,class... Features>
    inline void Ip<TDatalinkLayer,Features...>::sendToLocalhost(IpTransmitRequestEvent& txevent) {

      IpPacketHeader header;
      IpPacket packet;
      scoped_array<uint8_t> buffer;
      uint32_t bufferSize;

      // set up the header

      setCommonTransmitHeaderValues(header,txevent);
      packet.header=&header;
      packet.headerLength=IpPacketHeader::getNoOptionsHeaderSize();

      // if the TX payload is in just one of the netbuffer buffers then we can use it
      // without copying it out

      if(txevent.networkBuffer->getInternalBufferSize()!=0 && txevent.networkBuffer->getUserBufferSize()!=0) {

        bufferSize=txevent.networkBuffer->getInternalBufferSize()+txevent.networkBuffer->getUserBufferSize();
        buffer.reset(new uint8_t[bufferSize]);

        if(buffer.get()==nullptr) {
          this->setError(ErrorProvider::ERROR_PROVIDER_NET_IP,E_OUT_OF_MEMORY);
          return;
        }

        // copy the buffers out to a linear memory space

        memcpy(buffer.get(),txevent.networkBuffer->getInternalBuffer(),txevent.networkBuffer->getInternalBufferSize());
        memcpy(buffer.get()+txevent.networkBuffer->getInternalBufferSize(),txevent.networkBuffer->getUserBuffer(),txevent.networkBuffer->getUserBufferSize());

        packet.payload=buffer.get();
        packet.payloadLength=bufferSize;
      }
      else if(txevent.networkBuffer->getUserBufferSize()==0) {

        // only internal buffer is present, reference it directly

        packet.payload=reinterpret_cast<uint8_t *>(txevent.networkBuffer->getInternalBuffer());
        packet.payloadLength=txevent.networkBuffer->getInternalBufferSize();
      }
      else {

        // only user buffer is present (not likely), reference it directly

        packet.payload=(uint8_t *)txevent.networkBuffer->getUserBuffer();
        packet.payloadLength=txevent.networkBuffer->getUserBufferSize();
      }

      // raise the event

      this->NetworkReceiveEventSender.raiseEvent(IpPacketEvent(packet));

      // the txevent netbuffer is dead

      delete txevent.networkBuffer;
    }


    /**
     * Set the common values in the IP header for a transmitted packet. Common means common to fragmented
     * and non-fragmented packets
     * @param header The header structure
     * @param txevent The transmit event
     */

    template<class TDatalinkLayer,class... Features>
    inline void Ip<TDatalinkLayer,Features...>::setCommonTransmitHeaderValues(IpPacketHeader& header,IpTransmitRequestEvent& txevent) {

      header.ip_hdr_version=0x45;                                     // uint8_t
      header.ip_hdr_typeOfService=0;
      header.ip_hdr_ttl=txevent.ttl ? txevent.ttl : _initialTtl;        // uint8_t
      header.ip_hdr_protocol=txevent.protocol;                          // uint8_t
      header.ip_hdr_checksum=0;                                       // MAC will calculate this
      header.ip_sourceAddress=_myIpAddress;
      header.ip_destinationAddress=txevent.destinationIpAddress;
    }


    /**
     * When a frame has been identified as coming from ethernet we notify that address
     * association so that the ARP cache can get updated. This means that'll be ready
     * when a response is needed. This is IRQ code.
     * @param mac The mac address
     * @param ipAddress The IP address
     */

    template<class TDatalinkLayer,class... Features>
    inline void Ip<TDatalinkLayer,Features...>::handleAddressMappingEvent(const MacAddress& mac,const IpAddress& ipAddress) {
      this->NetworkNotificationEventSender.raiseEvent(IpAddressMappingEvent(mac,ipAddress));
    }


    /**
     * Get my IP address
     * @return My IP address
     */

    template<class TDatalinkLayer,class... Features>
    inline const IpAddress& Ip<TDatalinkLayer,Features...>::getIpAddress() const {
      return _myIpAddress;
    }
  }
}
// END FILE: ../lib/include/net/network/ip/Ip.h
// START FILE: ../lib/include/net/network/ip/IpTransmitRequestEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Transmit request event to the IP layer
     */

    struct IpTransmitRequestEvent  : NetEventDescriptor {

      NetBuffer *networkBuffer;                   ///< buffer to send
      const IpAddress& destinationIpAddress;      ///< destination IP address (will be copied out)
      IpProtocol protocol;                        ///< protocol number for the request
      uint8_t ttl;                                ///< The ttl if to be overriden

      bool succeeded;                             ///< set to true if the send succeeded

      /**
       * Constructor
       * @param nb The buffer pointer to send (the receive owns it)
       * @param address The destination address
       * @param proto The IP protocol encapsulated here
       * @param overrideTtl The TTL for the packet if it is to be overridden. The default of zero means
       * use the value configured in the initialisation parameters.
       */

      IpTransmitRequestEvent(NetBuffer *nb,const IpAddress& address,IpProtocol proto,uint8_t overrideTtl=0)
        : NetEventDescriptor(NetEventType::IP_TRANSMIT_REQUEST),
          networkBuffer(nb),
          destinationIpAddress(address),
          protocol(proto),
          ttl(overrideTtl),
          succeeded(false) {
      }
    };
  }
}
// END FILE: ../lib/include/net/network/ip/IpTransmitRequestEvent.h
// START FILE: ../lib/include/net/network/ip/IpAddressMappingEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Notify about an association between a MAC and an IP
     */

    struct IpAddressMappingEvent : NetEventDescriptor {

      const MacAddress& macAddress;
      const IpAddress& ipAddress;

      IpAddressMappingEvent(const MacAddress& mac,const IpAddress& ip)
        : NetEventDescriptor(NetEventType::IP_ADDRESS_MAPPING),
          macAddress(mac),
          ipAddress(ip) {
      }
    };
  }
}
// END FILE: ../lib/include/net/network/ip/IpAddressMappingEvent.h
// START FILE: ../lib/include/net/network/ip/features/IpFragmentedPacket.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Linked list entry for a fragmented packet
     */

    struct IpFragmentedPacket {

      /**
       * Identifying information for a packet
       */

      struct PacketId {

        uint16_t identification;
        IpAddress sourceAddress;
        IpAddress destinationAddress;
        IpProtocol protocol;

        bool operator==(const PacketId& src) const {
          return identification==src.identification &&
                 destinationAddress==src.destinationAddress &&
                 sourceAddress==src.sourceAddress &&
                 protocol==src.protocol;
        }

        bool operator!=(const PacketId& src) const {
          return !operator==(src);
        }
      } __attribute__((packed));


      /**
       * The hole structure identifies the size and position of the hole and
       * the offset from the beginning of the packet buffer of the next and
       * previous hole. UINT16_T_MAX == no previous or next. This is safe because
       * the data-block size of 8 bytes means that nothing can start at 0xffff.
       *
       * This structure MUST NOT exceed 8 bytes.
       */

      struct Hole {
        uint16_t first;
        uint16_t last;
        uint16_t next_hole;

        static Hole *getPointer(uint8_t *base,uint16_t offset) {
          return offset==UINT16_MAX ? nullptr : reinterpret_cast<Hole *>(&base[offset]);
        }

        static uint16_t getOffset(uint8_t *base,Hole *hole) {
          return reinterpret_cast<uint8_t *>(hole)-base;
        }

      } __attribute__((packed));

      PacketId identifier;

      uint16_t packetLength;
      uint8_t *packet;
      uint16_t firstHole;
      uint32_t expiryTime;

      IpFragmentedPacket(PacketId pid);
      ~IpFragmentedPacket();

      void handleHoleList(const IpPacket& packet);
      void createHole(uint16_t first,uint16_t last);
      void unlinkHole(uint16_t holeToUnlink);
      bool isComplete() const;
    };


    /**
     * Fragmented packet: constructor
     * Set the identifier and set up the first hole in a buffer 8 bytes long
     */

    inline IpFragmentedPacket::IpFragmentedPacket(PacketId pid) {

      Hole *ptr;

      identifier=pid;
      packetLength=8;
      packet=reinterpret_cast<uint8_t *>(malloc(8));

      firstHole=0;
      ptr=Hole::getPointer(packet,0);

      ptr->first=0;
      ptr->last=UINT16_MAX;
      ptr->next_hole=UINT16_MAX;
    }

    /**
     * FragmentedPacket: destructor
     */

    inline IpFragmentedPacket::~IpFragmentedPacket() {
      free(packet);
    }


    /**
     * Create a new hole and link it in. The hole actually lives in the packet data space
     * starting at the address of 'first'
     * @param first
     * @param last
     */

    inline void IpFragmentedPacket::createHole(uint16_t first,uint16_t last) {

      Hole *hole;

      // create the hole descriptor and link it in at the start

      hole=reinterpret_cast<Hole *>(&packet[first]);
      hole->first=first;
      hole->last=last;
      hole->next_hole=firstHole;

      firstHole=first;
    }


    /**
     * Unlink this hole from the list
     * @param holeToUnlink
     */

    inline void IpFragmentedPacket::unlinkHole(uint16_t holeToUnlink) {

      Hole *holeptr,*previousptr,*firstptr,*unlinkptr;

      firstptr=Hole::getPointer(packet,firstHole);
      unlinkptr=Hole::getPointer(packet,holeToUnlink);

      if(firstHole==holeToUnlink) {
        firstHole=firstptr->next_hole;
        return;
      }

      previousptr=firstptr;
      holeptr=Hole::getPointer(packet,firstptr->next_hole);

      while(holeptr) {

        if(holeptr==unlinkptr) {

          previousptr->next_hole=holeptr->next_hole;
          return;
        }

        previousptr=holeptr;
        holeptr=Hole::getPointer(packet,holeptr->next_hole);
      }
    }


    /**
     * Check if the reassembly is complete
     * @return true if it's complete
     */

    inline bool IpFragmentedPacket::isComplete() const {
      return firstHole==UINT16_MAX;
    }


    /**
     * Updates holes to handle this packet
     * @param fp The fragmented packet that we are filling in
     * @param packet The new packet fragment
     */

    inline void IpFragmentedPacket::handleHoleList(const IpPacket& ipPacket) {

      Hole *hole;
      uint16_t fragmentFirst,fragmentLast,holeFirst,holeLast,holeNext;

      fragmentFirst=ipPacket.getFragmentOffset();
      fragmentLast=fragmentFirst+ipPacket.payloadLength-1;

      hole=nullptr;

      for(;;) {

        // advance to next (or first): RFC815 #1

        if(hole)
          hole=Hole::getPointer(packet,holeNext);
        else
          hole=Hole::getPointer(packet,firstHole);

        if(hole==nullptr)
          return;

        holeFirst=hole->first;
        holeLast=hole->last;
        holeNext=hole->next_hole;

        // RFC815 steps #2,3

        if(fragmentFirst>holeLast || fragmentLast<holeFirst)
          continue;

        // delete this entry from the descriptor list. RFC815 step #4

        unlinkHole(Hole::getOffset(packet,hole));

        // RFC815 step #5

        if(fragmentFirst>holeFirst)
          createHole(holeFirst,fragmentFirst-1);

        // RFC815 step #6

        if(fragmentLast<holeLast && ipPacket.hasMoreFragments())
          createHole(fragmentLast+1,holeLast);
      }
    }
  }
}
// END FILE: ../lib/include/net/network/ip/features/IpFragmentedPacket.h
// START FILE: ../lib/include/net/network/ip/features/IpPacketFragmentFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Class to take a netbuffer and generate collection of other netbuffers
     * that contain the input data fragmented into parts small enough to
     * fit into the link layer's max MTU size.
     *
     * The original netbuffer's data is referenced by pointers in the fragment
     * buffers so very little additional memory is required. The original netbuffer
     * is added as a reference to the last fragmentso that any higher layer that
     * is tracking outgoing packets by waiting for a netbuffer they created
     * to be sent will function correctly.
     */

    class IpPacketFragmentFeature {

      protected:

        /**
         * Flags
         */

        enum {
          MORE_FRAGMENTS = 0x2000
        };

        /**
         * Parameters class
         */

        struct Parameters {
          bool ip_checksumOnLargeUdpPackets;      ///< true if we manually calculate checksums on large UDP packets. default is true.

          /**
           * Constructor
           */

          Parameters() {
            ip_checksumOnLargeUdpPackets=true;
          }
        };

        Parameters _params;
        uint16_t _mtu;
        uint16_t _linkHeaderSize;
        uint16_t _identification;

      private:
        uint32_t fragmentsRequired(uint16_t size);

        bool internalCreateFragments(NetBuffer *inputBuffer,
                                     NetBuffer **&outputBuffers);

        bool createFragmentsFrom(NetBuffer *inputBuffer,
                                 const void *sourceData,
                                 uint16_t sourceDataSize,
                                 NetBuffer **outputBuffers,
                                 uint16_t firstOutputBuffer,
                                 bool lastFragmentIsHere,
                                 uint16_t& offset);

      public:
        bool initialise(const Parameters& params,NetworkUtilityObjects&);
        bool startup();

        bool ip_createFragments(IpProtocol protocol,
                                 const IpAddress& myIpAddress,
                                 const IpAddress& destinationIpAddress,
                                 uint16_t mtu,
                                 uint16_t linkHeaderSize,
                                 NetBuffer *inputBuffer,
                                 NetBuffer **&outputBuffers,
                                 uint16_t& outputBufferCount);
    };


    /**
     * Initialise the feature
     */

    inline bool IpPacketFragmentFeature::initialise(const Parameters& params,NetworkUtilityObjects&) {
      _params=params;
      _identification=0;
      return true;
    }


    /**
     * startup the feature
     */

    inline bool IpPacketFragmentFeature::startup() {
      return true;
    }
  }
}
// END FILE: ../lib/include/net/network/ip/features/IpPacketFragmentFeature.h
// START FILE: ../lib/include/net/network/ip/features/IpDisablePacketReassemblerFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Disable the packet reassembler feature with stub methods
     */

    class IpDisablePacketReassemblerFeature {

      public:
        enum {
          E_FEATURE_DISABLED = 1
        };

      public:
        struct Parameters {
        };

        NetworkUtilityObjects *_networkUtilityObjects;

      public:

        bool initialise(const Parameters&,NetworkUtilityObjects& networkUtilityObjects) {
          _networkUtilityObjects=&networkUtilityObjects;
          return true;
        }

        bool startup() {
          return true;
        }

        bool ip_handleFragment(const IpPacket& /* packet */,IpFragmentedPacket*& fp) {
          fp=nullptr;
          return _networkUtilityObjects->setError(ErrorProvider::ERROR_PROVIDER_NET_IP_DISABLED_PACKET_REASSEMBLER_FEATURE,E_FEATURE_DISABLED);
        }

        void ip_freePacket(IpFragmentedPacket * /* packetToFree */ ) {
        }
    };
  }
}
// END FILE: ../lib/include/net/network/ip/features/IpDisablePacketReassemblerFeature.h
// START FILE: ../lib/include/net/network/ip/features/IpPacketReassemblerFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Handler for fragmented IPv4 packets. Fragmented packets are held in a linked list until either
     * the full packet arrives or one of the parameterised limits is hit. Management of the incoming
     * packets is done according to the algorithm described in RFC815 with the 'hole' descriptors
     * existing inside the holes themselves.
     */

    class IpPacketReassemblerFeature {

      public:

        /**
         * Error codes
         */

        enum {
          E_TOO_MANY_FRAGMENTED_PACKETS = 1,
          E_PACKET_TOO_BIG,
          E_MEMORY_LIMIT_EXCEEDED,
          E_OUT_OF_MEMORY
        };

        struct Parameters {

          uint16_t ip_maxPacketLength;                    //<! max length of any packet. default is 2048 bytes
          uint16_t ip_maxInProgressFragmentedPackets;   //<! max incoming packets that can be fragmented and incompletely assembled in memory. The default is 2.
          uint32_t ip_maxFragmentedPacketMemoryUsage;   //<! similar to ip_maxInProgressFragmentedPackets, but restricts overall memory usage of the fragment reassembler. The default is 4096.
          uint8_t ip_fragmentExpirySeconds;             //<! seconds after which partially reassembled packets are dropped (default is 15)
          uint8_t ip_fragmentExpiryIntervalCheckSeconds;  //<! how often to wake up and check for expired fragments

          /**
           * Constructor, set the default parameters
           */

          Parameters() {
            ip_maxPacketLength=2048;
            ip_maxInProgressFragmentedPackets=2;
            ip_maxFragmentedPacketMemoryUsage=4096;
            ip_fragmentExpirySeconds=15;
            ip_fragmentExpiryIntervalCheckSeconds=23;
          }
        };

      private:
        Parameters _params;
        std::slist<IpFragmentedPacket *> _frags;
        uint32_t _totalFragmentSize;
        uint32_t _inFlightPacketCount;
        NetworkUtilityObjects *_utilityObjects;

      private:
        bool internalHandleFragment(const IpPacket& packet,IpFragmentedPacket*& fp);
        IpFragmentedPacket *findFragment(const IpFragmentedPacket::PacketId& pid) const;
        bool createNewFragment(IpFragmentedPacket::PacketId pid,IpFragmentedPacket *&fp);
        void expireOldEntries(NetworkIntervalTickData& nitd);

      public:
        ~IpPacketReassemblerFeature();

        bool initialise(const Parameters& params,NetworkUtilityObjects& utilityObjects);
        bool startup();

        bool ip_handleFragment(const IpPacket& packet,IpFragmentedPacket*& fp);
        void ip_freePacket(IpFragmentedPacket *packetToFree);
    };
  }
}
// END FILE: ../lib/include/net/network/ip/features/IpPacketReassemblerFeature.h
// START FILE: ../lib/include/net/network/ip/features/IpDisablePacketFragmentFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Stub class to disable ip packet fragmentation and prevent any linking of
     * the associated code paths.
     */

    class IpDisablePacketFragmentFeature {

      public:
        enum {
          E_FEATURE_DISABLED = 1
        };

      protected:
        struct Parameters {
        };

        NetworkUtilityObjects *_networkUtilityObjects;

      public:
        bool initialise(const Parameters&,NetworkUtilityObjects& networkUtilityObjects) {
          _networkUtilityObjects=&networkUtilityObjects;
          return true;
        }

        bool startup() {
          return true;
        }

        bool ip_createFragments(IpProtocol /* protocol */,
                                const IpAddress& /* myIpAddress */,
                                const IpAddress& /* destinationIpAddress */,
                                uint16_t /* mtu */,
                                uint16_t /* linkHeaderSize */,
                                NetBuffer * /* inputBuffer */,
                                NetBuffer **& outputBuffers,
                                uint16_t& outputBufferCount) {

        outputBuffers=nullptr;
        outputBufferCount=0;
        return _networkUtilityObjects->setError(ErrorProvider::ERROR_PROVIDER_NET_IP_DISABLED_PACKET_FRAGMENT_FEATURE,E_FEATURE_DISABLED);
      }
    };
  }
}
// END FILE: ../lib/include/net/network/ip/features/IpDisablePacketFragmentFeature.h
// START FILE: ../lib/include/net/network/ip/IpPorts.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Base class for anything that needs to use the shared port ranges. This class manages
     * handing out Ephemeral ports. Ephemeral ports are in the 61440-65535 (4K) range. This is significantly
     * less than the 16K ports you get with a typical PC stack but in this MCU we do not have the resources
     * to handle 16K simultaneous ports.
     *
     * This class requires 512 bytes of SRAM for the port bitmap.
     *
     * You can customise the above numbers using the ip_ephemeralPortCount variable in the parameters class.
     */

    class IpPorts {

      public:

        enum  {
          PORT_DNS_REQUEST   = 53,
          PORT_DHCP_REQUEST  = 67,
          PORT_DHCP_RESPONSE = 68
        };

        /**
         * Error codes
         */

        enum {
          E_OUT_OF_MEMORY = 1,
          E_ALL_PORTS_IN_USE
        };


        /**
         * Parameters to the class
         */

        struct Parameters {

          uint16_t ip_firstEphemeralPort;         ///< The first ephemeral port
          uint16_t ip_lastEphemeralPort;          ///< The last ephemeral port.

          Parameters() {
            ip_firstEphemeralPort=49152;
            ip_lastEphemeralPort=65535;
          }
        };


      private:
        Parameters _params;

        std::vector<uint16_t> _ephemeralPortsInUse;
        std::vector<uint16_t> _definedPortsInUse;
        uint16_t _nextEphemeralPort;

      protected:
        void incrementNextEphemeralPort();

      public:
        bool initialise(const Parameters& params,NetworkUtilityObjects& networkUtilityObjects);

        bool ip_acquireEphemeralPort(uint16_t& portNumber);
        bool ip_releaseEphemeralPort(uint16_t portNumber);
        bool ip_isEphemeralPortInUse(uint16_t portNumber) const;

        bool ip_acquireDefinedPort(uint16_t portNumber);
        bool ip_releaseDefinedPort(uint16_t portNumber);
        bool ip_isDefinedPortInUse(uint16_t portNumber) const;
    };


    /**
     * Initialise the class
     * @return true if it worked
     */

    inline bool IpPorts::initialise(const Parameters& params,NetworkUtilityObjects& networkUtilityObjects) {

      uint32_t rnd;

      // store params

      _params=params;

      // start the ephemeral port issuer at a random place

      networkUtilityObjects.nextRandom(rnd);
      _nextEphemeralPort=params.ip_firstEphemeralPort+rnd % (params.ip_lastEphemeralPort-params.ip_firstEphemeralPort);

      return true;
    }


    /**
     * Increment the next ephemeral port
     */

    inline void IpPorts::incrementNextEphemeralPort() {

      if(_nextEphemeralPort==_params.ip_lastEphemeralPort)
        _nextEphemeralPort=_params.ip_firstEphemeralPort;
      else
        _nextEphemeralPort++;
    }


    /**
     * Acquire a free ephemeral port
     * @param[out] portNumber The new port number
     * @return true if it worked
     */

    inline bool IpPorts::ip_acquireEphemeralPort(uint16_t& portNumber) {

      uint16_t end;

      // got to stop if we come back here

      end=_nextEphemeralPort;

      // try to find a port. this is not an efficient search method if the number of ephemeral
      // ports is high. speed is traded for space.

      while(ip_isEphemeralPortInUse(_nextEphemeralPort)) {

        incrementNextEphemeralPort();

        if(end==_nextEphemeralPort)
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_IPPORTS,E_ALL_PORTS_IN_USE);
      }

      // found one

      portNumber=_nextEphemeralPort;
      _ephemeralPortsInUse.push_back(portNumber);
      incrementNextEphemeralPort();

      return true;
    }


    /**
     * Release an ephemeral port
     * @param portNumber The port to release
     * @return true if it was released
     */

    inline bool IpPorts::ip_releaseEphemeralPort(uint16_t portNumber) {

      std::vector<uint16_t>::iterator it;

      if((it=std::find(_ephemeralPortsInUse.begin(),_ephemeralPortsInUse.end(),portNumber))!=_ephemeralPortsInUse.end()) {
        _ephemeralPortsInUse.erase(it);
        return true;
      }

      return false;
    }


    /**
     * Check if the given ephemeral port is in use
     * @param portNumber the port to check
     * @return true if in use
     */

    inline bool IpPorts::ip_isEphemeralPortInUse(uint16_t portNumber) const {
      return std::find(_ephemeralPortsInUse.begin(),_ephemeralPortsInUse.end(),portNumber)!=_ephemeralPortsInUse.end();
    }


    /**
     * Acquire a defined port
     * @param portNumber The port number to try to acquire
     * @return true if it worked
     */

    inline bool IpPorts::ip_acquireDefinedPort(uint16_t portNumber) {

      if(ip_isDefinedPortInUse(portNumber))
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_IPPORTS,E_ALL_PORTS_IN_USE);

      _definedPortsInUse.push_back(portNumber);
      return true;
    }


    /**
     * Release a defined port
     * @param portNumber The port to release
     * @return true if it was released
     */

    inline bool IpPorts::ip_releaseDefinedPort(uint16_t portNumber) {

      std::vector<uint16_t>::iterator it;

      if((it=std::find(_definedPortsInUse.begin(),_definedPortsInUse.end(),portNumber))!=_definedPortsInUse.end()) {
        _definedPortsInUse.erase(it);
        return true;
      }
      return false;
    }


    /**
     * Check if the given defined port is in use
     * @param portNumber the port to check
     * @return true if in use
     */

    inline bool IpPorts::ip_isDefinedPortInUse(uint16_t portNumber) const {
      return std::find(_definedPortsInUse.begin(),_definedPortsInUse.end(),portNumber)!=_definedPortsInUse.end();
    }
  }
}
// END FILE: ../lib/include/net/network/ip/IpPorts.h
// START FILE: ../lib/include/net/network/ip/IpSubnetMask.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * IP subnet mask structure. Same core a.b.c.d structure as an IP address
     * but it has special interpretation as a bitmask
     */

    struct IpSubnetMask : IpAddress {

      /**
       * Default constructor
       */

      IpSubnetMask() {
      }


      /**
       * Copy constructor - ensure this gets done with a single word copy
       * @param src
       */

      IpSubnetMask(const IpSubnetMask& src)
        : IpAddress(src) {
      }


      /**
       * Construct from a dotted IP address
       * @param dottedIp The a.b.c.d address
       */

      IpSubnetMask(const char *dottedIp) {
        IpAddress::operator=(dottedIp);
      }


      /**
       * Check if this IP address is contained within the subnet managed by the
       * provided gateway. Basically they must be on the same network
       * @param ipAddress
       * @return
       */

      bool matches(const IpAddress& addr,const IpAddress& gway) const {
        return (addr.ipAddress & ipAddress)==(gway.ipAddress & ipAddress);
      }


      /**
       * Check if this is the broadcast address for this subnet. The broadcast address is found
       * by taking the network address (found by masking the incoming ip address with the subnet)
       * and or-ing it with the compliment of the subnet mask.
       * @param addr The address to be tested
       * @return true if it is
       */

      bool isBroadcastAddress(const IpAddress& addr) const {
        return ((addr.ipAddress & ipAddress) | ~ipAddress)==addr.ipAddress;
      }


      /**
       * Assignment operator
       * @param addr
       * @return self-reference
       */

      IpSubnetMask& operator=(const char *addr) {
        IpAddress::operator=(addr);
        return *this;
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/network/ip/IpSubnetMask.h
// START FILE: ../lib/include/net/network/ip/IpPacket.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * IP packet information
     */

    struct IpPacket {

      /*
       * Pointers directly into the frame data
       */

      IpPacketHeader *header;           // pointer to the header
      uint32_t headerLength;              // total bytes in the header
      uint8_t *payload;                   // pointer to the payload
      uint16_t payloadLength;             // the size of the payload


      /**
       * Check if this IP packet is fragmented. The packet is fragmented if the
       * MF (more fragments) bit is set in the flags or the fragment offset is
       * non-zero.
       */

      bool isFragmented() const {

        uint16_t flagsAndOffset;

        flagsAndOffset=NetUtil::ntohs(header->ip_hdr_flagsAndOffset);
        return (flagsAndOffset & 0x1fff)!=0 || (flagsAndOffset & 0x2000)!=0;
      }


      /**
       * Check if this is the last of a fragmented sequence. The last fragment has
       * MF == 0 and a non-zero offset
       * @return true if it's the last
       */

      bool isLastFragment() const {

        uint16_t flagsAndOffset;

        flagsAndOffset=NetUtil::ntohs(header->ip_hdr_flagsAndOffset);
        return (flagsAndOffset & 0x1fff)!=0 && (flagsAndOffset & 0x2000)==0;
      }


      /**
       * Check if this packet has the MF flag set
       * @return true if it has MF set
       */

      bool hasMoreFragments() const {

        uint16_t flagsAndOffset;

        flagsAndOffset=NetUtil::ntohs(header->ip_hdr_flagsAndOffset);
        return (flagsAndOffset & 0x2000)!=0;
      }


      /**
       * Get the 16-bit id field used to correlate fragmented packets
       * @return The identifier
       */

      uint16_t getIdentifier() const {
        return NetUtil::ntohs(header->ip_hdr_identification);
      }


      /**
       * Get the offset of this fragmented packet's payload
       * @return The payload offset
       */

      uint16_t getFragmentOffset() const {

        uint16_t headerOffset;

        headerOffset=NetUtil::ntohs(header->ip_hdr_flagsAndOffset) & 0x1FFF;
        headerOffset*=8;

        return headerOffset;
      }
    };
  }
}
// END FILE: ../lib/include/net/network/ip/IpPacket.h
// START FILE: ../lib/include/net/network/arp/Arp.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    DECLARE_EVENT_SIGNATURE(ArpReceive,void (ArpReceiveEvent&));

    /**
     * Network layer feature that implements the Address Resolution Protocol (ARP)
     * ARP is used as to convert one address form into another. In our implementation
     * we will support converting MAC addresses into IP addresses.
     */

    template<class TDatalinkLayer>
    class Arp : public virtual TDatalinkLayer {

      public:

      /**
       * Error codes
       */

        enum {
          E_INVALID_OPERATION = 1,      ///< not a request or a reply
          E_CANNOT_REPLY,               ///< E_CANNOT_REPLY
          E_UNCONFIGURED,               ///< Our MAC/IP are not configured
          E_REQUEST_NOT_PERMITTED,      ///< not permitted to do a request due to IRQ context
          E_IP_ADDRESS_CLASH,           ///< Another station on the net has our IP address
          E_TIMED_OUT                   ///< timed out waiting for a response
        };

        /**
         * Parameters class
         */

        struct Parameters {

          bool arp_startupBroadcast;        ///< true if we broadcast our own address on startup, default is true
          uint16_t arp_cacheSize;           ///< number of entries to include in the ARP cache, default is 10
          uint32_t arp_cacheExpirySeconds;  ///< The max seconds to keep an ARP cache entry, default is 600
          uint32_t arp_replyTimeout;        ///< how long in ms to wait for an ARP reply, default is 5000
          uint8_t arp_retries;              ///< number of times to retry, default is 5

          Parameters() {
            arp_startupBroadcast=true;
            arp_cacheSize=10;               ///< 10 bytes/entry, 10 entries = 100 bytes.
            arp_replyTimeout=5000;          ///< 5 seconds for an ARP timeout
            arp_cacheExpirySeconds=600;     ///< 10 minute default cache lifetime
            arp_retries=5;                  ///< 5 times to retry
          }
        };

        DECLARE_EVENT_SOURCE(ArpReceive);

      protected:
        Parameters _params;
        IpAddress _myIpAddress;
        IpAddress _defaultGatewayAddress;
        IpSubnetMask _mySubnetMask;
        MacAddress _myMacAddress;
        ArpCache _arpCache;

      protected:
        void handleIpAddressAnnouncement(IpAddressAnnouncementEvent& event);
        void handleMacAddressAnnouncement(MacAddressAnnouncementEvent& event);
        void handleSubnetMaskAnnouncement(IpSubnetMaskAnnouncementEvent& event);
        void handleDefaultGatewayAnnouncement(IpDefaultGatewayAnnouncementEvent& event);
        void handleNewAddressMapping(IpAddressMappingEvent& event);
        bool handleAddressMappingRequest(ArpMappingRequestEvent& event);
        bool handleIncomingFrame(const DatalinkFrame& frame);

        void onReceive(NetEventDescriptor& ned);
        void onNotification(NetEventDescriptor& ned);

      public:
        bool initialise(const Parameters&);
        bool startup();

        void arpBroadcastMyAddress();
        void arpSendRequest(IpAddress& ipaddress);
        void arpSendProbe(IpAddress& ipaddress);
    };


    /**
     * Initialise the class
     * @param params The parameters class
     * @return always true
     */

    template<class TDatalinkLayer>
    inline bool Arp<TDatalinkLayer>::initialise(const Parameters& params) {

      // save the parameters

      _params=params;

      // initialise the cache

      _arpCache.initialise(params.arp_cacheSize,params.arp_cacheExpirySeconds,this->_rtc);

      // subscribe to receive notification and receive events

      this->NetworkReceiveEventSender.insertSubscriber(NetworkReceiveEventSourceSlot::bind(this,&Arp<TDatalinkLayer>::onReceive));
      this->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&Arp<TDatalinkLayer>::onNotification));

      return true;
    }


    /**
     * Startup the feature
     * @return
     */

    template<class TDatalinkLayer>
    inline bool Arp<TDatalinkLayer>::startup() {
      return true;
    }


    /**
     * Notification from our subscription to receive events
     * @param ned The event descriptor
     */

    template<class TDatalinkLayer>
    inline void Arp<TDatalinkLayer>::onReceive(NetEventDescriptor& ned) {

      // check if it's a datalink frame event

      if(ned.eventType==NetEventDescriptor::NetEventType::DATALINK_FRAME) {

        const DatalinkFrame& frame=static_cast<DatalinkFrameEvent&>(ned).datalinkFrame;

        if(frame.protocol==static_cast<uint16_t>(EtherType::ARP))
          handleIncomingFrame(frame);
      }
    }


    /**
     * Notification from our subscription to notification events
     * @param ned The event descriptor
     */

    template<class TDatalinkLayer>
    inline void Arp<TDatalinkLayer>::onNotification(NetEventDescriptor& ned) {

      // if it's a new IP address/mask then we are interested

      if(ned.eventType==NetEventDescriptor::NetEventType::ARP_MAPPING_REQUEST)
        handleAddressMappingRequest(static_cast<ArpMappingRequestEvent&>(ned));

      else if(ned.eventType==NetEventDescriptor::NetEventType::IP_ADDRESS_ANNOUNCEMENT)
        handleIpAddressAnnouncement(static_cast<IpAddressAnnouncementEvent&>(ned));

      else if(ned.eventType==NetEventDescriptor::NetEventType::SUBNET_MASK_ANNOUNCEMENT)
        handleSubnetMaskAnnouncement(static_cast<IpSubnetMaskAnnouncementEvent&>(ned));

      else if(ned.eventType==NetEventDescriptor::NetEventType::DEFAULT_GATEWAY_ANNOUNCEMENT)
        handleDefaultGatewayAnnouncement(static_cast<IpDefaultGatewayAnnouncementEvent&>(ned));

      else if(ned.eventType==NetEventDescriptor::NetEventType::MAC_ADDRESS_ANNOUNCEMENT)
        handleMacAddressAnnouncement(static_cast<MacAddressAnnouncementEvent&>(ned));

      else if(ned.eventType==NetEventDescriptor::NetEventType::IP_ADDRESS_MAPPING)
        handleNewAddressMapping(static_cast<IpAddressMappingEvent&>(ned));
    }


    /**
     * Handle an incoming frame event. It's already confirmed to be ARP. This is IRQ code.
     * @param frame the incoming frame
     */

    template<class TDatalinkLayer>
    inline bool Arp<TDatalinkLayer>::handleIncomingFrame(const DatalinkFrame& frame) {

      ArpFrameData *afd,*reply;
      NetBuffer *nb;

      afd=reinterpret_cast<ArpFrameData *>(frame.payload);

      // we respond to ARP requests (code 1)

      if(afd->arp_operation==ArpOperation::REQUEST) {

        // are they asking for our MAC address?

        if(_myIpAddress!=afd->arp_targetProtocolAddress)
          return true;      // not an error

        // we have to drop the request if nobody has told us what our address and IP are

        if(!_myMacAddress.isValid() || !_myIpAddress.isValid())
          return this->setError(ErrorProvider::ERROR_PROVIDER_NET_ARP,E_UNCONFIGURED);

        // create a net buffer for the response
        // ARP responses are generated automatically in response to an IRQ

        nb=new NetBuffer(
            this->getDatalinkTransmitHeaderSize(),
            sizeof(ArpFrameData),
            nullptr);

        // the ARP frame data is the last in the buffer, and therefore the first
        // to be written to

        reply=reinterpret_cast<ArpFrameData *>(nb->moveWritePointerBack(sizeof(ArpFrameData)));
        reply->initialise();
        reply->createReply(*afd,_myMacAddress,_myIpAddress);

        // raise a transmit event for the datalink layer to pick up

        this->NetworkSendEventSender.raiseEvent(
              EthernetTransmitRequestEvent(nb,reply->arp_targetHardwareAddress,EtherType::ARP,DatalinkChecksum::IP_HEADER_AND_PROTOCOL));
      }
      else if(afd->arp_operation==ArpOperation::REPLY) {

        // it's a reply, verify that someone is not claiming to own our address

        if(afd->arp_senderProtocolAddress==_myIpAddress)
          return this->setError(ErrorProvider::ERROR_PROVIDER_NET_ARP,E_IP_ADDRESS_CLASH);
        else
          _arpCache.insert(afd->arp_senderHardwareAddress,afd->arp_senderProtocolAddress);
      }

      // send an event to anyone that's interested

      ArpReceiveEventSender.raiseEvent(ArpReceiveEvent(*afd));
      return true;
    }


    /**
     * Handle a IP address announcement
     * @param event The event structure
     */

    template<class TDatalinkLayer>
    inline void Arp<TDatalinkLayer>::handleIpAddressAnnouncement(IpAddressAnnouncementEvent& event) {

      // remember the address

      _myIpAddress=event.ipAddress;

      // are we configured to broadcast on startup?

      if(_params.arp_startupBroadcast)
        arpBroadcastMyAddress();
    }


    /**
     * Handle a subnet mask announcement
     * @param event The event structure
     */

    template<class TDatalinkLayer>
    inline void Arp<TDatalinkLayer>::handleSubnetMaskAnnouncement(IpSubnetMaskAnnouncementEvent& event) {

      // remember the mask

      _mySubnetMask=event.subnetMask;
    }


    /**
     * Handle a default gateway announcement
     * @param event The event structure
     */

    template<class TDatalinkLayer>
    inline void Arp<TDatalinkLayer>::handleDefaultGatewayAnnouncement(IpDefaultGatewayAnnouncementEvent& event) {

      // remember the mask

      _defaultGatewayAddress=event.defaultGateway;
    }


    /**
     * Handle a new client MAC address event
     * @param event The event structure
     */

    template<class TDatalinkLayer>
    inline void Arp<TDatalinkLayer>::handleMacAddressAnnouncement(MacAddressAnnouncementEvent& event) {

      // remember the address

      _myMacAddress=event.macAddress;

      // are we configured to broadcast on startup?

      if(_params.arp_startupBroadcast)
        arpBroadcastMyAddress();
    }


    /**
     * Handle an ARP mapping request. If the requested IP address is covered by the subnet mask
     * then that's the MAC address we'll be looking for, otherwise we'll be trying to find the
     * MAC address of the default gateway.
     * @param event The event that describes the request
     */

    template<class TDatalinkLayer>
    inline bool Arp<TDatalinkLayer>::handleAddressMappingRequest(ArpMappingRequestEvent& event) {

      IpAddress ip;
      uint8_t retry;

      // can handle requests for 255.255.255.255 with no configuration information

      if(event.ipAddress.isBroadcast()) {
        event.macAddress=MacAddress::createBroadcastAddress();
        event.found=true;
        return true;
      }

      // we can handle requests for a multicast MAC with no configuration information
      // this gives us level 1 (tx only) conformance with RFC1112

      if(event.ipAddress.isMulticastGroup()) {
        event.macAddress.createMulticastAddress(event.ipAddress.ipAddressBytes);
        event.found=true;
        return true;
      }

      // must be configured with a subnet mask and gateway

      if(!_mySubnetMask.isValid() || !_defaultGatewayAddress.isValid())
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_ARP,E_UNCONFIGURED);

      // use the event IP address or the gateway as the lookup

      if(_mySubnetMask.matches(event.ipAddress,_defaultGatewayAddress)) {

        // is the IP address the broadcast address for this subnet?

        if(_mySubnetMask.isBroadcastAddress(event.ipAddress)) {
          event.macAddress=MacAddress::createBroadcastAddress();
          event.found=true;
          return true;
        }
        else
          ip=event.ipAddress;           // a local IP address
      }
      else
        ip=_defaultGatewayAddress;      // a remote IP address

      // first check the cache and return if found or we cannot do a lookup

      if((event.found=_arpCache.findMacAddress(ip,event.macAddress)))
        return true;

      // if we're in an IRQ then we can't continue because we'd need to do a tx/rx

      if(Nvic::isAnyIrqActive())
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_ARP,E_REQUEST_NOT_PERMITTED);

      for(retry=0;retry<_params.arp_retries;retry++) {

        _arpCache.setWatchIp(ip,&event.macAddress);

        // send off the query

        arpSendRequest(ip);

        // wait for our watcher to be triggered, or a timeout

        if((event.found=_arpCache.waitForWatch(_params.arp_replyTimeout)))
          return true;
      }

      return this->setError(ErrorProvider::ERROR_PROVIDER_NET_ARP,E_TIMED_OUT);
    }


    /**
     * Send an ARP request.
     * @param ipaddress the IP address to include in the query
     */

    template<class TDatalinkLayer>
    inline void Arp<TDatalinkLayer>::arpSendRequest(IpAddress& ipaddress) {

      NetBuffer *nb;
      ArpFrameData *afd;

      // create the packet. we need space for the datalink
      // layer tx header size plus the size of an ARP frame

      nb=new NetBuffer(
          this->getDatalinkTransmitHeaderSize(),
          sizeof(ArpFrameData),
          nullptr);

      // the ARP frame data is the last in the buffer, and therefore the first
      // to be written to

      afd=reinterpret_cast<ArpFrameData *>(nb->moveWritePointerBack(sizeof(ArpFrameData)));
      afd->initialise();
      afd->createRequest(ipaddress,_myMacAddress,_myIpAddress);

      // raise a transmit event for the datalink layer to pick up

      this->NetworkSendEventSender.raiseEvent(
            EthernetTransmitRequestEvent(nb,MacAddress::createBroadcastAddress(),EtherType::ARP,DatalinkChecksum::IP_HEADER_AND_PROTOCOL));
    }


    /**
     * Send an ARP probe. Sender IP = 0, target IP = ipaddress, sender mac=mymac, target mac=null
     * @param ipaddress the IP address to probe for
     */

    template<class TDatalinkLayer>
    inline void Arp<TDatalinkLayer>::arpSendProbe(IpAddress& ipaddress) {

      NetBuffer *nb;
      ArpFrameData *afd;

      // create the packet. we need space for the datalink
      // layer tx header size plus the size of an ARP frame

      nb=new NetBuffer(
          this->getDatalinkTransmitHeaderSize(),
          sizeof(ArpFrameData),
          nullptr);

      // the ARP frame data is the last in the buffer, and therefore the first
      // to be written to

      afd=reinterpret_cast<ArpFrameData *>(nb->moveWritePointerBack(sizeof(ArpFrameData)));
      afd->initialise();
      afd->createRequest(ipaddress,_myMacAddress,IpAddress());

      // raise a transmit event for the datalink layer to pick up

      this->NetworkSendEventSender.raiseEvent(
            EthernetTransmitRequestEvent(nb,MacAddress::createBroadcastAddress(),EtherType::ARP,DatalinkChecksum::IP_HEADER_AND_PROTOCOL));
    }


    /**
     * Handle a new address mapping event (MAC <-> association)
     * @param event The address mapping event
     */

    template<class TDatalinkLayer>
    inline void Arp<TDatalinkLayer>::handleNewAddressMapping(IpAddressMappingEvent& event) {

      if(_mySubnetMask.isValid() && _defaultGatewayAddress.isValid()) {

        // insert the association 'as reported' if the host is on this subnet
        // otherwise the association is between the default gateway and this IP address

        if(_mySubnetMask.matches(event.ipAddress,_defaultGatewayAddress))
          _arpCache.insert(event.macAddress,event.ipAddress);
        else
          _arpCache.insert(event.macAddress,_defaultGatewayAddress);
      }
    }


    /**
     * Broadcast my IP address/MAC address to all and sundry
     */

    template<class TDatalinkLayer>
    inline void Arp<TDatalinkLayer>::arpBroadcastMyAddress() {

      ArpFrameData *afd;
      NetBuffer *nb;

      // can only broadcast if we have a mac and ip

      if(!_myMacAddress.isValid() || !_myIpAddress.isValid())
        return;

      // create the broadcast packet. we need space for the datalink
      // layer tx header size plus the size of an ARP frame

      nb=new NetBuffer(
          this->getDatalinkTransmitHeaderSize(),
          sizeof(ArpFrameData),
          nullptr);

      // the ARP frame data is the last in the buffer, and therefore the first
      // to be written to

      afd=reinterpret_cast<ArpFrameData *>(nb->moveWritePointerBack(sizeof(ArpFrameData)));
      afd->initialise();
      afd->createGratuitous(_myMacAddress,_myIpAddress);

      // raise a transmit event for the datalink layer to pick up

      this->NetworkSendEventSender.raiseEvent(
            EthernetTransmitRequestEvent(nb,MacAddress::createBroadcastAddress(),EtherType::ARP,DatalinkChecksum::IP_HEADER_AND_PROTOCOL));
    }
  }
}
// END FILE: ../lib/include/net/network/arp/Arp.h
// START FILE: ../lib/include/net/network/arp/ArpFrameData.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"


namespace stm32plus {
  namespace net {


    /**
     * ARP frame data, this can be cast on to a frame in memory. 28 byte packets.
     */

    struct ArpFrameData {

      uint16_t arp_hardwareType;
      uint16_t arp_protocolType;
      uint8_t arp_hardwareAddressLength;
      uint8_t arp_protocolAddressLength;
      ArpOperation arp_operation;
      MacAddress arp_senderHardwareAddress;
      IpAddress arp_senderProtocolAddress;
      MacAddress arp_targetHardwareAddress;
      IpAddress arp_targetProtocolAddress;


      /**
       * Constructor: create constant parts
       */

      ArpFrameData() {
        initialise();
      }


      /**
       * Set up the constant parts
       */

      void initialise() {
        arp_hardwareType=NetUtil::htons(1);         // 1 = ethernet
        arp_protocolType=NetUtil::htons(0x0800);      // 0x8000 = IP
        arp_hardwareAddressLength=6;                  // 48 bit MACs
        arp_protocolAddressLength=4;                  // 32 bit IP addresses
      }


      /**
       * Create a gratuitous ARP message (announcement)
       */

      void createGratuitous(const MacAddress& mac,const IpAddress& ip) {
        createMessage(mac,MacAddress::createBroadcastAddress(),ip,ip);
        arp_operation=ArpOperation::REQUEST;
      }


      /**
       * Create a reply message
       * @param request The request
       * @param replyMac The reply mac address
       * @param replyIp The reply IP address
       */

      void createReply(const ArpFrameData& request,const MacAddress& replyMac,const IpAddress& replyIp) {
        createMessage(replyMac,request.arp_senderHardwareAddress,replyIp,request.arp_senderProtocolAddress);
        arp_operation=ArpOperation::REPLY;
      }


      /**
       * Create a an ARP request message.
       * @param requestedIp The IP that we want to look up
       * @param myMacAddress our own MAC address
       * @param myIpAddress our own IP address
       */

      void createRequest(const IpAddress& requestedIp,const MacAddress& myMacAddress,const IpAddress& myIpAddress) {
        createMessage(myMacAddress,MacAddress(),myIpAddress,requestedIp);
        arp_operation=ArpOperation::REQUEST;
      }


      /**
       * Create an ARP message from parameters
       */

      void createMessage(const MacAddress& senderMac,const MacAddress& targetMac,
                         const IpAddress& senderIp,const IpAddress& targetIp) {

        arp_senderHardwareAddress=senderMac;
        arp_senderProtocolAddress=senderIp;
        arp_targetHardwareAddress=targetMac;
        arp_targetProtocolAddress=targetIp;
      }

    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/network/arp/ArpFrameData.h
// START FILE: ../lib/include/net/network/arp/ArpOperation.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * ARP operation codes - always big-endian
     */

    enum class ArpOperation : uint16_t {
      REQUEST = 0x0100,       //!< REQUEST
      REPLY   = 0x0200,       //!< REPLY
    };
  }
}
// END FILE: ../lib/include/net/network/arp/ArpOperation.h
// START FILE: ../lib/include/net/network/arp/ArpReceiveEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * ARP receive frame event
     */

    struct ArpReceiveEvent : NetEventDescriptor {

      /**
       * The ARP frame that arrived
       */

      const ArpFrameData& arpFrameData;


      /**
       * Constructor
       */

      ArpReceiveEvent(const ArpFrameData& afd)
        : NetEventDescriptor(NetEventType::ARP_FRAME),
          arpFrameData(afd) {
      }
    };
  }
}
// END FILE: ../lib/include/net/network/arp/ArpReceiveEvent.h
// START FILE: ../lib/include/net/network/arp/ArpMappingRequestEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Request an ARP mapping (get MAC from IP)
     */

    struct ArpMappingRequestEvent : NetEventDescriptor {

      const IpAddress& ipAddress;       ///< the address to lookup

      MacAddress macAddress;              ///< the returned MAC or nullptr
      bool found;

      ArpMappingRequestEvent(const IpAddress& address)
        : NetEventDescriptor(NetEventType::ARP_MAPPING_REQUEST),
          ipAddress(address),
          found(false) {
      }
    };
  }
}
// END FILE: ../lib/include/net/network/arp/ArpMappingRequestEvent.h
// START FILE: ../lib/include/net/network/arp/ArpCache.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Simple LRU cache for an ARP mapping of IP address to MAC address. Implemented as
     * a compact doubly linked list with a fixed maximum number of entries. The list
     * entry overhead is just 2 bytes and no dynamic memory allocation is required after
     * initialisation. Searching is a linear operation from the MRU to the LRU so the
     * number of entries should be kept low. The maximum number of entries is 255.
     * Index #255 is reserved.
     */

    class ArpCache {

      protected:

        /**
         * Constant for no entry at this position
         */

        enum {
          NO_ENTRY = 0xff                 ///< used as a next/prev marker to say 'none'
        };

        struct CacheEntry {
          uint8_t next;                   ///< next index in the list (or NO_ENTRY)
          uint8_t previous;               ///< previous index in the list (or NO_ENTRY)
          MacAddress macAddress;          ///< mac address held here
          IpAddress ipAddress;            ///< ip address held here
          uint32_t expiryTime;            ///< RTC time after which this entry is invalid
        } __attribute__((packed));

        uint8_t _first;                   ///< first index in the list (or NO_ENTRY if empty)
        uint8_t _last;                    ///< last index in the list (or NO_ENTRY if empty)
        uint8_t _insertionPoint;          ///< next free array slot for new entries (or _maxEntries-1 if full)
        uint8_t _maxEntries;              ///< total entries allowed
        uint32_t _expirySeconds;          ///< seconds to keep in a cache
        RtcBase *_rtc;                    ///< Pointer to the RTC

        scoped_array<CacheEntry> _array;  ///< the array of CacheEntry structures

        volatile bool _watchFlag;         ///< set to true when _watchIp is inserted
        IpAddress _watchIp;             ///< an IP to watch for
        MacAddress *_foundMac;            ///< MAC address found for the watcher

      protected:
        void internalInsert(const MacAddress& mac,const IpAddress& ip);
        void unlink(uint8_t index);
        void insertFront(uint8_t index);
        bool hasExpired(uint8_t index) const;

      public:
        bool initialise(uint8_t numEntries,uint32_t expirySeconds,RtcBase *rtc);

        void insert(const MacAddress& mac,const IpAddress& ip);
        bool findMacAddress(const IpAddress& ip,MacAddress& found);

        void setWatchIp(const IpAddress& ip,MacAddress *foundMac);
        bool waitForWatch(uint32_t timeout);
    };


    /**
     * Initialise the cache. Memory is created for the array of entries
     * up front to avoid churn of the heap that may occur during activity
     * if entries were dynamically allocated.
     * @param numEntries The maximum number of entries
     * @param expirySeconds Max time to keep an entry in the cache. An entry will still be
     *   evicted if it's the LRU and a new entry comes in to a full cache.
     * @param rtc A pointer to the RTC used to get the current time
     * @return true if it works
     */

    inline bool ArpCache::initialise(uint8_t numEntries,uint32_t expirySeconds,RtcBase *rtc) {

      _array.reset(new CacheEntry[numEntries]);

      // initialise internal variables

      _first=_last=NO_ENTRY;
      _insertionPoint=0;
      _maxEntries=numEntries;
      _expirySeconds=expirySeconds;
      _rtc=rtc;
      _watchFlag=false;

      return _array.get()!=nullptr;
    }


    /**
     * Insert a new entry or update an old one. This is IRQ-safe
     * @param mac The MAC address to insert
     * @param ip The associated IP address
     */

    inline void ArpCache::insert(const MacAddress& mac,const IpAddress& ip) {

      // protect ourselves from re-entrancy while we do the insert

      IrqSuspend suspender;
      internalInsert(mac,ip);
    }

    inline void ArpCache::internalInsert(const MacAddress& mac,const IpAddress& ip) {

      uint8_t i,found,unused;
      uint32_t timeNow;
      CacheEntry *ptr;

      // can we release a watcher when this IRQ finishes?

      if(_watchFlag && _watchIp==ip) {
        *_foundMac=mac;
        _watchFlag=false;
      }

      // don't care for the link order here, just walk the array. If a matching
      // cache entry is found then get out right away. We also need to take care
      // of a change of association so we also try to find matches by IP and MAC
      // but not both

      ptr=_array.get();
      found=unused=NO_ENTRY;
      timeNow=_rtc->getTick();

      for(i=0;i<_insertionPoint;i++) {

        if(ptr->next==NO_ENTRY && ptr->previous==NO_ENTRY && i!=_first)
          unused=i;
        else {

          // if expired then remove it

          if(timeNow>ptr->expiryTime) {
            unlink(i);
            unused=i;
          }
          else if(ptr->ipAddress==ip) {

            if(ptr->macAddress==mac)
              found=i;        // found an exact match that hasn't expired
            else {

              // IP address is cached but has been assigned to another MAC
              // this cache entry must be expunged

              unlink(i);
              unused=i;
            }
          }
          else if(ptr->macAddress==mac) {

            // MAC address is in the cache but has a different IP address
            // the cache entry is not valid any more

            unlink(i);
            unused=i;
          }
        }
        ptr++;
      }

      // so what happened? if an unexpired match was found then it needs to come to the front

      if(found!=NO_ENTRY) {

        // take the entry out of the list and put it back at the front

        unlink(found);
        insertFront(found);

        return;
      }

      // a new entry needs to be created. can we place it in a previously
      // used position?

      if(unused!=NO_ENTRY)
        i=unused;
      else if(_insertionPoint!=_maxEntries) {

        // there is space to put it on the end

        i=_insertionPoint;
        _insertionPoint++;
      }
      else {

        // there is no space, evict the LRU entry at the end of the cache

        i=_last;
        unlink(_last);
      }

      // enter our details

      ptr=&_array[i];
      ptr->macAddress=mac;
      ptr->ipAddress=ip;
      ptr->expiryTime=_rtc->getTick()+_expirySeconds;

      // we are the most recent, insert at front

      insertFront(i);
    }


    /**
     * Find the MAC address given an IP address. The cached address must not have
     * expired. Expired entries are intentionally not cleaned here to keep the
     * performance to a maximum. Expired entries are detected and recycled in the
     * insert() method.
     * @param ip The IP address to find
     * @param found The found mac address
     * @return true if found
     */

    inline bool ArpCache::findMacAddress(const IpAddress& ip,MacAddress& found) {

      uint8_t i;
      bool ret;

      ret=false;

      // protect ourselves from re-entrancy

      IrqSuspend suspender;

      for(i=_first;i!=NO_ENTRY;i=_array[i].next) {
        if(_array[i].ipAddress==ip && !hasExpired(i)) {
          found=_array[i].macAddress;
          ret=true;
          break;
        }
      }

      return ret;
    }


    /**
     * Check if this ARP cache entry has expired
     * @param index The index to check
     * @return true if it's expired
     */

    inline bool ArpCache::hasExpired(uint8_t index) const {
      return _rtc->getTick()>_array[index].expiryTime;
    }


    /**
     * Set a watch IP address (will be triggered when inserted)
     * @param ip The IP address to watch for
     * @param foundMac Where to store the found MAC result
     */

    inline void ArpCache::setWatchIp(const IpAddress& ip,MacAddress *foundMac) {
      _foundMac=foundMac;
      _watchIp=ip;
      _watchFlag=true;
    }


    /**
     * Wait for a configurable time for a watch ip to be triggered. The idea is that an ARP
     * frame is received over an IRQ and added to the cache, releasing the main CPU that is
     * waiting on the watch flag.
     * @param timeout The timeout value in ms
     * @return true if found in time
     */

    inline bool ArpCache::waitForWatch(uint32_t timeout) {

      uint32_t now;

      now=MillisecondTimer::millis();

      while(_watchFlag)
        if(MillisecondTimer::hasTimedOut(now,timeout))
          return false;

      return true;
    }


    /**
     * Unlink an entry from the list
     * @param index The entry to unlink
     */

    inline void ArpCache::unlink(uint8_t index) {

      CacheEntry *ptr;

      ptr=&_array[index];

      if(_first==index)
        _first=ptr->next;

      if(_last==index)
        _last=ptr->previous;

      if(ptr->previous!=NO_ENTRY)
        _array[ptr->previous].next=ptr->next;

      if(ptr->next!=NO_ENTRY)
        _array[ptr->next].previous=ptr->previous;

      ptr->next=NO_ENTRY;
      ptr->previous=NO_ENTRY;
    }


    /**
     * Link an entry into the front of the list
     * @param index The index to link in
     */

    inline void ArpCache::insertFront(uint8_t index) {

      // if there is already a first then it's now the second

      if(_first!=NO_ENTRY)
        _array[_first].previous=index;

      // set up our links

      _array[index].previous=NO_ENTRY;
      _array[index].next=_first;

      // if there was no last then there is now

      if(_last==NO_ENTRY)
        _last=index;

      // we are the new first

      _first=index;
    }
  }
}
// END FILE: ../lib/include/net/network/arp/ArpCache.h
// START FILE: ../lib/include/net/network/NetworkLayer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Template feature-holder for features that live in the network
     * layer of the stack, e.g. the IP and ICMP protocols. The next level down is the
     * data link layer and the next level up is the transport layer. The features
     * must themselves be templated on, and virtually inherit from TDatalinkLayer so
     * that the stack is correctly formed.
     */

    template<class TDatalinkLayer,template<class> class... Features>
    class NetworkLayer : public virtual TDatalinkLayer,
                         public Features<TDatalinkLayer>... {

      public:

        /**
         * Base parameters collection-class for network features
         */

        struct Parameters : TDatalinkLayer::Parameters,
                            Features<TDatalinkLayer>::Parameters... {
        };


      public:
        bool startup();
        bool initialise(Parameters& params);
    };


    /**
     * Initialise the features after initialising upwards first
     * @param params The parameters class to initialise the layer features
     * @return true if it worked
     */

    template<class TDatalinkLayer,template<class> class... Features>
    bool NetworkLayer<TDatalinkLayer,Features...>::initialise(Parameters& params) {
      return TDatalinkLayer::initialise(params) &&
             RecursiveBoolInitWithParams<NetworkLayer,Features<TDatalinkLayer>...>::tinit(this,params);
    }


    /**
     * Startup the components in this layer
     * @return
     */

    template<class TDatalinkLayer,template<class> class... Features>
    bool NetworkLayer<TDatalinkLayer,Features...>::startup() {
      return TDatalinkLayer::startup() &&
             RecursiveBoolStartup<NetworkLayer,Features<TDatalinkLayer>...>::tstartup(this);
    }
  }
}
// END FILE: ../lib/include/net/network/NetworkLayer.h
// START FILE: ../lib/include/net/datalink/EthernetFrame.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Ethernet frame information
     */

    struct EthernetFrame : DatalinkFrame {

      /**
       * Posible values for the flags
       */

      enum {
        FLAG_IP  = 0x1,     //!< FLAG_IP
        FLAG_IP6  = 0x2,    //!< FLAG_IP6
        FLAG_UDP  = 0x4,    //!< FLAG_UDP
        FLAG_TCP  = 0x8,    //!< FLAG_TCP
        FLAG_ICMP = 0x10    //!< FLAG_ICMP
      };

      uint32_t flags;               //!< misc flags about the frame detected by the ST MAC
      MacAddress *sourceMac;        // source MAC address
      MacAddress *destinationMac;   // destination MAC address

      /**
       * Constructor, reset the flags
       */

      EthernetFrame() :
        flags(0) {
      }
    };
  }
}
// END FILE: ../lib/include/net/datalink/EthernetFrame.h
// START FILE: ../lib/include/net/datalink/mac/f4/RmiiInterface.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {
  namespace net {

    /**
     * Class for use of the MAC in RMII mode on the F4.
     * @tparam TPinPackage The type containing the enumeration of pins that we are
     * to use for RMII. e.g. MacDefaultPinPackage
     */

    template<class TPhysicalLayer,class TPinPackage>
    class RmiiInterface : public virtual TPhysicalLayer {

      public:
        struct Parameters {
        };

      protected:
        void initPins() const;

      public:
        bool initialise(const Parameters&) const;
        bool startup();
    };


    /**
     * Template alias for the common use case
     */

    template<class TPhysicalLayer>
    using DefaultRmiiInterface=RmiiInterface<TPhysicalLayer,MacDefaultPinPackage>;

    template<class TPhysicalLayer>
    using RemapRmiiInterface=RmiiInterface<TPhysicalLayer,MacRemapPinPackage>;


    /**
     * Initialise the class
     * @return always true
     */

    template<class TPhysicalLayer,class TPinPackage>
    inline bool RmiiInterface<TPhysicalLayer,TPinPackage>::initialise(const Parameters&) const {

      // configure in RMII mode

      ClockControl<PERIPHERAL_SYSCFG>::On();

      ClockControl<static_cast<PeripheralName>(TPinPackage::Mac_Peripheral)>::Off();
      SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_RMII);
      ClockControl<static_cast<PeripheralName>(TPinPackage::Mac_Peripheral)>::On();

      // initialise the pins

      initPins();
      return true;
    }


    /**
     * Startup the class
     * @return always true
     */

    template<class TPhysicalLayer,class TPinPackage>
    inline bool RmiiInterface<TPhysicalLayer,TPinPackage>::startup() {
      return true;
    }


    /**
     * Initialise the RMII pins
     */

    template<class TPhysicalLayer,class TPinPackage>
    inline void RmiiInterface<TPhysicalLayer,TPinPackage>::initPins() const {

       // RMII pins

       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::RMII_TXD0::Port,TPinPackage::RMII_TXD0::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::RMII_TXD1::Port,TPinPackage::RMII_TXD1::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::RMII_TXEN::Port,TPinPackage::RMII_TXEN::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::RMII_RXD0::Port,TPinPackage::RMII_RXD0::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::RMII_RXD1::Port,TPinPackage::RMII_RXD1::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::RMII_CRSDV::Port,TPinPackage::RMII_CRSDV::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::RMII_REFCLK::Port,TPinPackage::RMII_REFCLK::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);

       // PHY pins

       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MDC::Port,TPinPackage::MDC::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MDIO::Port,TPinPackage::MDIO::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
    }
  }
}
// END FILE: ../lib/include/net/datalink/mac/f4/RmiiInterface.h
// START FILE: ../lib/include/net/datalink/mac/f4/MacRemapPinPackage.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {
  namespace net {


    /**
     * MacDefaultPinPackage favours the lower ports and matches the STM32F107 pin-for-pin
     * in MII mode. RMII mode moves TXEN/TXD0/TXD1 to port G
     */

    struct MacRemapPinPackage {

      enum {
        Mac_Peripheral = PeripheralName::PERIPHERAL_MAC_REMAP,
      };

      // MII ports/pins

      typedef gpio::PC3 MII_TXCLK;
      typedef gpio::PB12 MII_TXD0;
      typedef gpio::PB13 MII_TXD1;
      typedef gpio::PC2 MII_TXD2;
      typedef gpio::PB8 MII_TXD3;
      typedef gpio::PB11 MII_TXEN;
      typedef gpio::PA1 MII_RXCLK;
      typedef gpio::PD9 MII_RXD0;
      typedef gpio::PD10 MII_RXD1;
      typedef gpio::PD11 MII_RXD2;
      typedef gpio::PD12 MII_RXD3;
      typedef gpio::PB10 MII_RXER;
      typedef gpio::PD8 MII_RXDV;
      typedef gpio::PA0 MII_CRS;
      typedef gpio::PA3 MII_COL;

      // RMII ports/pins

      typedef gpio::PA1 RMII_REFCLK;
      typedef gpio::PA7 RMII_CRSDV;
      typedef gpio::PC4 RMII_RXD0;
      typedef gpio::PC5 RMII_RXD1;
      typedef gpio::PG11 RMII_TXEN;
      typedef gpio::PG13 RMII_TXD0;
      typedef gpio::PG14 RMII_TXD1;

      // PHY ports/pins

      typedef gpio::PC1 MDC;
      typedef gpio::PA2 MDIO;
    };
  }
}
// END FILE: ../lib/include/net/datalink/mac/f4/MacRemapPinPackage.h
// START FILE: ../lib/include/net/datalink/mac/f4/MiiInterface.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {
  namespace net {

    /**
     * Class for use of the MAC in MII mode on the F4.
     * @tparam TPinPackage The type containing the enumeration of pins that we are
     * to use for RMII. e.g. MacDefaultPinPackage
     */

    template<class TPhysicalLayer,class TPinPackage>
    class MiiInterface : public virtual TPhysicalLayer {

      public:
        struct Parameters {
        };

      protected:
        void initPins() const;

      public:
        bool initialise(const Parameters&) const;
        bool startup();
        void outputClockOnMCO() const;
    };


    /**
     * Template alias for the common use case
     */

    template<class TPhysicalLayer>
    using DefaultMiiInterface=MiiInterface<TPhysicalLayer,MacDefaultPinPackage>;

    template<class TPhysicalLayer>
    using RemapMiiInterface=MiiInterface<TPhysicalLayer,MacRemapPinPackage>;


    /**
     * Startup the class
     * @return always true
     */

    template<class TPhysicalLayer,class TPinPackage>
    inline bool MiiInterface<TPhysicalLayer,TPinPackage>::startup() {
      return true;
    }


    /**
     * Initialise the ethernet clock.
     * @return always true
     */

    template<class TPhysicalLayer,class TPinPackage>
    inline bool MiiInterface<TPhysicalLayer,TPinPackage>::initialise(const Parameters&) const {

      // configure in MII mode

      ClockControl<PERIPHERAL_SYSCFG>::On();

      ClockControl<static_cast<PeripheralName>(TPinPackage::Mac_Peripheral)>::Off();
      SYSCFG_ETH_MediaInterfaceConfig(SYSCFG_ETH_MediaInterface_MII);
      ClockControl<static_cast<PeripheralName>(TPinPackage::Mac_Peripheral)>::On();

      // initialise the pins

      initPins();
      return true;
    }


    /**
     * Enable output of a 25Mhz clock on the MCO pin for clocking the PHY. This requires that the
     * STM32 is being clocked from a 25Mhz HSE
     */

    template<class TPhysicalLayer,class TPinPackage>
    void MiiInterface<TPhysicalLayer,TPinPackage>::outputClockOnMCO() const {
      RCC_MCO1Config(RCC_MCO1Source_HSE,RCC_MCO1Div_1);
    }


    /**
     * Initialise the RMII pins
     */

    template<class TPhysicalLayer,class TPinPackage>
    inline void MiiInterface<TPhysicalLayer,TPinPackage>::initPins() const {

       // MII pins

       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_TXCLK::Port,TPinPackage::MII_TXCLK::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_TXD0::Port,TPinPackage::MII_TXD0::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_TXD1::Port,TPinPackage::MII_TXD1::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_TXD2::Port,TPinPackage::MII_TXD2::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_TXD3::Port,TPinPackage::MII_TXD3::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_TXEN::Port,TPinPackage::MII_TXEN::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_RXCLK::Port,TPinPackage::MII_RXCLK::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_RXD0::Port,TPinPackage::MII_RXD0::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_RXD1::Port,TPinPackage::MII_RXD1::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_RXD2::Port,TPinPackage::MII_RXD2::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_RXD3::Port,TPinPackage::MII_RXD3::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_RXER::Port,TPinPackage::MII_RXER::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_RXDV::Port,TPinPackage::MII_RXDV::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_CRS::Port,TPinPackage::MII_CRS::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MII_COL::Port,TPinPackage::MII_COL::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);

       // PHY pins

       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MDC::Port,TPinPackage::MDC::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
       GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::MDIO::Port,TPinPackage::MDIO::Pin,Gpio::ALTERNATE_FUNCTION,(GPIOSpeed_TypeDef)MacPeripheralTraits::GPIO_SPEED,Gpio::PUPD_NONE,Gpio::PUSH_PULL,GPIO_AF_ETH);
    }
  }
}
// END FILE: ../lib/include/net/datalink/mac/f4/MiiInterface.h
// START FILE: ../lib/include/net/datalink/mac/MacDefaultPinPackage.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * MacDefaultPinPackage favours the lower ports and matches the STM32F107 pin-for-pin.
     */

    struct MacDefaultPinPackage {

      enum {
        Mac_Peripheral = PeripheralName::PERIPHERAL_MAC
      };

      // MII ports/pins

      typedef gpio::PC3 MII_TXCLK;
      typedef gpio::PB12 MII_TXD0;
      typedef gpio::PB13 MII_TXD1;
      typedef gpio::PC2 MII_TXD2;
      typedef gpio::PB8 MII_TXD3;
      typedef gpio::PB11 MII_TXEN;
      typedef gpio::PA1 MII_RXCLK;
      typedef gpio::PC4 MII_RXD0;
      typedef gpio::PC5 MII_RXD1;
      typedef gpio::PB0 MII_RXD2;
      typedef gpio::PB1 MII_RXD3;
      typedef gpio::PB10 MII_RXER;
      typedef gpio::PA7 MII_RXDV;
      typedef gpio::PA0 MII_CRS;
      typedef gpio::PA3 MII_COL;

      // RMII ports/pins

      typedef gpio::PB12 RMII_TXD0;
      typedef gpio::PB13 RMII_TXD1;
      typedef gpio::PB11 RMII_TXEN;
      typedef gpio::PC4 RMII_RXD0;
      typedef gpio::PC5 RMII_RXD1;
      typedef gpio::PA7 RMII_CRSDV;
      typedef gpio::PA1 RMII_REFCLK;

      // PHY ports/pins

      typedef gpio::PC1 MDC;
      typedef gpio::PA2 MDIO;
    };
  }
}
// END FILE: ../lib/include/net/datalink/mac/MacDefaultPinPackage.h
// START FILE: ../lib/include/net/datalink/mac/Mac.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Template class for the MAC. Although the PHY is generally considered to be in
     * the same network layer (#2, datalink) as the MAC they are not independent devices.
     * The MAC is wholly dependent on, and strongly linked to its PHY. Therefore we implement
     * the PHY as a base of the MAC.
     * @tparam TPhy The type of PHY, e.g. KSZ8051MLL
     * @tparam TInterfaceMode The type of interface MiiInterface or RmiiInterface
     */

    template<class TPhysicalLayer>
    class Mac : public virtual TPhysicalLayer,
                public MacBase {

      public:

        /**
         * Parameters class for this MAC. This inherits from the base parameters so we can
         * pass them upwards. We also inherit from the stdperiph ETH_InitTypeDef
         * to avoid having to duplicate all the members.
         */

        struct Parameters : ETH_InitTypeDef,
                            virtual PhyBase::Parameters,
                            MacBase::Parameters {

          uint8_t mac_irqPriority;          //!< NVIC priority (default 0)
          uint8_t mac_irqSubPriority;       //!< NVIC sub-priority (default 0)


          /**
           * Constructor: initialise the stdperiph struct to default values
           */

          Parameters() {

            // default IRQ priority/subpriority

            mac_irqPriority=0;
            mac_irqSubPriority=0;

            // set defaults for the ST driver

            ETH_StructInit(this);

            // setup as if we're to be used by an IP client with auto-checksum offload

            ETH_AutoNegotiation=ETH_AutoNegotiation_Enable;
            ETH_LoopbackMode=ETH_LoopbackMode_Disable;
            ETH_RetryTransmission=ETH_RetryTransmission_Disable;
            ETH_AutomaticPadCRCStrip=ETH_AutomaticPadCRCStrip_Disable;
            ETH_ReceiveAll=ETH_ReceiveAll_Disable;
            ETH_BroadcastFramesReception=ETH_BroadcastFramesReception_Enable;
            ETH_PromiscuousMode=ETH_PromiscuousMode_Disable;
            ETH_MulticastFramesFilter=ETH_MulticastFramesFilter_Perfect;
            ETH_UnicastFramesFilter=ETH_UnicastFramesFilter_Perfect;
            ETH_ChecksumOffload=ETH_ChecksumOffload_Enable;

            ETH_DropTCPIPChecksumErrorFrame=ETH_DropTCPIPChecksumErrorFrame_Enable;
            ETH_ReceiveStoreForward=ETH_ReceiveStoreForward_Enable;
            ETH_TransmitStoreForward=ETH_TransmitStoreForward_Enable;

            ETH_ForwardErrorFrames=ETH_ForwardErrorFrames_Disable;
            ETH_ForwardUndersizedGoodFrames=ETH_ForwardUndersizedGoodFrames_Disable;
            ETH_SecondFrameOperate=ETH_SecondFrameOperate_Enable;
            ETH_AddressAlignedBeats=ETH_AddressAlignedBeats_Enable;
            ETH_FixedBurst=ETH_FixedBurst_Enable;
            ETH_RxDMABurstLength=ETH_RxDMABurstLength_32Beat;
            ETH_TxDMABurstLength=ETH_TxDMABurstLength_32Beat;

            // enable 1:1 (equal) access to the AHB bus by DMA. We receive one frame
            // completely out of the MAC FIFO and that frame can result in an auto-generated
            // response (e.g. ICMP reply). If access was not even then a high frequency of
            // such incoming frames could cause the TX queue to overflow.

            ETH_DMAArbitration=ETH_DMAArbitration_RoundRobin_RxTx_1_1;

            // don't call ETH_Start here because we still need to initialise the rest
            // of the stack and a receive interrupt may fire while we're doing that
          }
        };

      protected:
        bool initMac(Parameters& params);

        void onNotification(NetEventDescriptor& ned);

      public:
        bool initialise(Parameters& params);
        bool startup();

        bool phyReadRegister(uint16_t phyAddress,uint16_t regNumber,uint16_t& value,uint16_t timeoutMillis);
        bool phyWriteRegister(uint16_t phyAddress,uint16_t regNumber,uint16_t value,uint16_t timeoutMillis);
    };


    /**
     * Initialiser. Set up the MAC and the link
     * @param params The parameters class
     * @return true if all OK
     */

    template<class TPhysicalLayer>
    inline bool Mac<TPhysicalLayer>::initialise(Parameters& params) {

      // subscribe to notification events

      this->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&Mac<TPhysicalLayer>::onNotification));

      // enable the interrupts

      Nvic::configureIrq(ETH_IRQn,ENABLE,params.mac_irqPriority,params.mac_irqSubPriority);

      // de-initialise the peripheral

      ETH_DeInit();

      // software reset and wait until done

      ETH_SoftwareReset();
      while(ETH_GetSoftwareResetStatus()==SET);

      // initialise the MAC. the cable must be connected and the network "live"
      // the PHY feature base class is configured into our hierarchy

      if(!initMac(params))
        return false;

      // enable all interrupts

      ETH_DMAITConfig(ETH_DMA_IT_NIS | ETH_DMA_IT_AIS | ETH_DMA_IT_R | ETH_DMA_IT_T, ENABLE);

      // call upwards

      if(!MacBase::initialise(params))
        return false;

      // finished

      return true;
    }


    /**
     * Start Tx/Rx
     * @return
     */

    template<class TPhysicalLayer>
    inline bool Mac<TPhysicalLayer>::startup() {

      // call the base class

      if(!MacBase::startup())
        return false;

      // startup the MAC

      ETH_Start();
      return true;
    }


    /**
     * Network notification event handler
     * @param ned The event descriptor
     */

    template<class TPhysicalLayer>
    inline void Mac<TPhysicalLayer>::onNotification(NetEventDescriptor& ned) {

      if(ned.eventType==NetEventDescriptor::NetEventType::PHY_READ_REQUEST) {

        PhyReadRequestEvent& revent(static_cast<PhyReadRequestEvent&>(ned));
        revent.succeeded=phyReadRegister(revent.phyAddress,revent.regNumber,revent.result,revent.timeoutMillis);
      }
      else if(ned.eventType==NetEventDescriptor::NetEventType::PHY_WRITE_REQUEST) {

        PhyWriteRequestEvent& wevent(static_cast<PhyWriteRequestEvent&>(ned));
        wevent.succeeded=phyWriteRegister(wevent.phyAddress,wevent.regNumber,wevent.regValue,wevent.timeoutMillis);
      }
    }


    /**
     * Initialise the MAC and the PHY. If this function succeeds then the link
     * has been established. This is largely cribbed from the ST example ETH_Init()
     * call in the sample ethernet driver code.
     * @return true if it works
     */

    template<class TPhysicalLayer>
    inline bool Mac<TPhysicalLayer>::initMac(Parameters& params) {

      uint32_t tmpreg;
      RCC_ClocksTypeDef rcc_clocks;
      uint32_t hclk;

      // Get the ETHERNET MACMIIAR value
      tmpreg=ETH->MACMIIAR;

      // Clear CSR Clock Range CR[2:0] bits
      tmpreg &= MACMIIAR_CR_MASK;

      // Get hclk frequency value
      RCC_GetClocksFreq(&rcc_clocks);
      hclk=rcc_clocks.HCLK_Frequency;

      // Set CR bits depending on hclk value
      if ((hclk >= 20000000) && (hclk < 35000000)) {
        // CSR Clock Range between 20-35 MHz
        tmpreg |= (uint32_t) ETH_MACMIIAR_CR_Div16;
      } else if ((hclk >= 35000000) && (hclk < 60000000)) {
        // CSR Clock Range between 35-60 MHz
        tmpreg |= (uint32_t) ETH_MACMIIAR_CR_Div26;
      } else if ((hclk >= 60000000) && (hclk < 100000000)) {
        // CSR Clock Range between 60-100 MHz
        tmpreg |= (uint32_t) ETH_MACMIIAR_CR_Div42;
      } else if ((hclk >= 100000000) && (hclk < 150000000)) {
        // CSR Clock Range between 100-150 MHz
        tmpreg |= (uint32_t) ETH_MACMIIAR_CR_Div62;         // only on the F4
      } else {
        // ((hclk >= 150000000)&&(hclk <= 168000000))
        // CSR Clock Range between 150-168 MHz
        tmpreg |= (uint32_t) ETH_MACMIIAR_CR_Div102;        // only on the F4
      }

      // Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range
      ETH->MACMIIAR=(uint32_t) tmpreg;

      /*
       * PHY initialization and configuration
       */

      // reset the PHY

      if(!this->phySoftReset())
        return false;

      if(params.ETH_AutoNegotiation!=ETH_AutoNegotiation_Disable) {

        // wait for link

        if(!this->phyWaitForLink())
          return false;

        // enable auto-negotiation

        if(!this->phyEnableAutoNegotiation())
          return false;

        // wait for auto-negotiation to completed

        if(!this->phyWaitForAutoNegotiationComplete())
          return false;

        // set duplex and speed

        bool value;
        if(!this->phyIsFullDuplex(value))
          return false;

        params.ETH_Mode=value ? ETH_Mode_FullDuplex : ETH_Mode_HalfDuplex;

        if(!this->phyIs100M(value))
          return false;

        params.ETH_Speed=value ? ETH_Speed_100M : ETH_Speed_10M;
      }
      else {

        // manual configuration of speed and mode

        if (params.ETH_Mode==ETH_Mode_FullDuplex)
          this->phySetFullDuplex();
        else
          this->phySetHalfDuplex();

        if (params.ETH_Speed==ETH_Speed_100M)
          this->phySet100M();
        else
          this->phySet10M();

        // Delay to assure PHY configuration
        this->phyPostConfigurationDelay();
      }


      /*
       * ETHERNET MACCR Configuration
       * */

      // Get the ETHERNET MACCR value
      tmpreg=ETH->MACCR;

      // Clear WD, PCE, PS, TE and RE bits
      tmpreg &= MACCR_CLEAR_MASK;

      // Set the WD bit according to ETH_Watchdog value
      // Set the JD: bit according to ETH_Jabber value
      // Set the IFG bit according to ETH_InterFrameGap value
      // Set the DCRS bit according to ETH_CarrierSense value
      // Set the FES bit according to ETH_Speed value
      // Set the DO bit according to ETH_ReceiveOwn value
      // Set the LM bit according to ETH_LoopbackMode value
      // Set the DM bit according to ETH_Mode value
      // Set the IPCO bit according to ETH_ChecksumOffload value
      // Set the DR bit according to ETH_RetryTransmission value
      // Set the ACS bit according to ETH_AutomaticPadCRCStrip value
      // Set the BL bit according to ETH_BackOffLimit value
      // Set the DC bit according to ETH_DeferralCheck value

      tmpreg|=(uint32_t) (params.ETH_Watchdog
          | params.ETH_Jabber | params.ETH_InterFrameGap
          | params.ETH_CarrierSense | params.ETH_Speed
          | params.ETH_ReceiveOwn | params.ETH_LoopbackMode
          | params.ETH_Mode | params.ETH_ChecksumOffload
          | params.ETH_RetryTransmission
          | params.ETH_AutomaticPadCRCStrip
          | params.ETH_BackOffLimit | params.ETH_DeferralCheck);
      // Write to ETHERNET MACCR
      ETH->MACCR=(uint32_t) tmpreg;

      /*
       * ETHERNET MACFFR Configuration
       */

      // Set the RA bit according to ETH_ReceiveAll value
      // Set the SAF and SAIF bits according to ETH_SourceAddrFilter value
      // Set the PCF bit according to ETH_PassControlFrames value
      // Set the DBF bit according to ETH_BroadcastFramesReception value
      // Set the DAIF bit according to ETH_DestinationAddrFilter value
      // Set the PR bit according to ETH_PromiscuousMode value
      // Set the PM, HMC and HPF bits according to ETH_MulticastFramesFilter value
      // Set the HUC and HPF bits according to ETH_UnicastFramesFilter value
      // Write to ETHERNET MACFFR
      ETH->MACFFR=(uint32_t) (params.ETH_ReceiveAll
          | params.ETH_SourceAddrFilter
          | params.ETH_PassControlFrames
          | params.ETH_BroadcastFramesReception
          | params.ETH_DestinationAddrFilter
          | params.ETH_PromiscuousMode
          | params.ETH_MulticastFramesFilter
          | params.ETH_UnicastFramesFilter);

      /*
       * ETHERNET MACHTHR and MACHTLR Configuration
       */

      // Write to ETHERNET MACHTHR
      ETH->MACHTHR=(uint32_t) params.ETH_HashTableHigh;
      // Write to ETHERNET MACHTLR
      ETH->MACHTLR=(uint32_t) params.ETH_HashTableLow;
      /*----------------------- ETHERNET MACFCR Configuration --------------------*/
      // Get the ETHERNET MACFCR value
      tmpreg=ETH->MACFCR;
      // Clear xx bits
      tmpreg &= MACFCR_CLEAR_MASK;

      // Set the PT bit according to ETH_PauseTime value
      // Set the DZPQ bit according to ETH_ZeroQuantaPause value
      // Set the PLT bit according to ETH_PauseLowThreshold value
      // Set the UP bit according to ETH_UnicastPauseFrameDetect value
      // Set the RFE bit according to ETH_ReceiveFlowControl value
      // Set the TFE bit according to ETH_TransmitFlowControl value
      tmpreg |= (uint32_t) ((params.ETH_PauseTime << 16)
          | params.ETH_ZeroQuantaPause
          | params.ETH_PauseLowThreshold
          | params.ETH_UnicastPauseFrameDetect
          | params.ETH_ReceiveFlowControl
          | params.ETH_TransmitFlowControl);
      // Write to ETHERNET MACFCR
      ETH->MACFCR=(uint32_t) tmpreg;

      /*
       * ETHERNET MACVLANTR Configuration
       */

      // Set the ETV bit according to ETH_VLANTagComparison value
      // Set the VL bit according to ETH_VLANTagIdentifier value
      ETH->MACVLANTR=(uint32_t) (params.ETH_VLANTagComparison
          | params.ETH_VLANTagIdentifier);

      /*
       * ETHERNET DMAOMR Configuration
       */

      // Get the ETHERNET DMAOMR value
      tmpreg=ETH->DMAOMR;
      // Clear xx bits
      tmpreg &= DMAOMR_CLEAR_MASK;

      // Set the DT bit according to ETH_DropTCPIPChecksumErrorFrame value
      // Set the RSF bit according to ETH_ReceiveStoreForward value
      // Set the DFF bit according to ETH_FlushReceivedFrame value
      // Set the TSF bit according to ETH_TransmitStoreForward value
      // Set the TTC bit according to ETH_TransmitThresholdControl value
      // Set the FEF bit according to ETH_ForwardErrorFrames value
      // Set the FUF bit according to ETH_ForwardUndersizedGoodFrames value
      // Set the RTC bit according to ETH_ReceiveThresholdControl value
      // Set the OSF bit according to ETH_SecondFrameOperate value
      tmpreg |= (uint32_t) (params.ETH_DropTCPIPChecksumErrorFrame
          | params.ETH_ReceiveStoreForward
          | params.ETH_FlushReceivedFrame
          | params.ETH_TransmitStoreForward
          | params.ETH_TransmitThresholdControl
          | params.ETH_ForwardErrorFrames
          | params.ETH_ForwardUndersizedGoodFrames
          | params.ETH_ReceiveThresholdControl
          | params.ETH_SecondFrameOperate);
      // Write to ETHERNET DMAOMR
      ETH->DMAOMR=(uint32_t) tmpreg;

      /*
       * ETHERNET DMABMR Configuration
       */

      // Set the AAL bit according to ETH_AddressAlignedBeats value
      // Set the FB bit according to ETH_FixedBurst value
      // Set the RPBL and 4*PBL bits according to ETH_RxDMABurstLength value
      // Set the PBL and 4*PBL bits according to ETH_TxDMABurstLength value
      // Set the DSL bit according to ETH_DesciptorSkipLength value
      // Set the PR and DA bits according to ETH_DMAArbitration value
      ETH->DMABMR=(uint32_t) (params.ETH_AddressAlignedBeats
          | params.ETH_FixedBurst | params.ETH_RxDMABurstLength
          | // !! if 4xPBL is selected for Tx or Rx it is applied for the other
          params.ETH_TxDMABurstLength
          | (params.ETH_DescriptorSkipLength << 2)
          | params.ETH_DMAArbitration | ETH_DMABMR_USP); // Enable use of separate PBL for Rx and Tx

      // Enable the Enhanced DMA descriptors if we're on the F4

#if defined(STM32PLUS_F4)
      ETH->DMABMR |= ETH_DMABMR_EDE;
#endif
      // Return Ethernet configuration success
      return true;
    }


    /**
     * Read a PHY register. This is derived from the similar function in the ST
     * driver with changes to support accurate timing. Can hang forever if called
     * from an IRQ and there's an error reading from the PHY.
     * @param phyAddress The station number
     * @param regNumber The register number
     * @param value[out] Where to store the read value
     * @param true if it works, false if it fails
     */

    template<class TPhysicalLayer>
    inline bool Mac<TPhysicalLayer>::phyReadRegister(uint16_t phyAddress,
                                                     uint16_t regNumber,
                                                     uint16_t& value,
                                                     uint16_t timeoutMillis) {

      volatile uint32_t tmpreg;
      uint32_t start;

      // get the ETHERNET MACMIIAR value
      tmpreg=ETH->MACMIIAR;

      // keep only the CSR Clock Range CR[2:0] bits value
      tmpreg &= ~MACMIIAR_CR_MASK;

      // prepare the MII address register value

      tmpreg |=(((uint32_t)phyAddress<<11) & ETH_MACMIIAR_PA); // Set the PHY device address
      tmpreg |=(((uint32_t)regNumber<<6) & ETH_MACMIIAR_MR);      // Set the PHY register address
      tmpreg &= ~ETH_MACMIIAR_MW;                              // Set the read mode
      tmpreg |= ETH_MACMIIAR_MB;                               // Set the MII Busy bit

      // write the result value into the MII Address register
      ETH->MACMIIAR=tmpreg;

      // check for the Busy flag

      start=MillisecondTimer::millis();

      do
      {
        if(MillisecondTimer::hasTimedOut(start,timeoutMillis))
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_MAC,E_PHY_READ_TIMEOUT);

        tmpreg=ETH->MACMIIAR;
      } while((tmpreg & ETH_MACMIIAR_MB)!=0);

      // return data register value

      value=ETH->MACMIIDR;
      return true;
    }


    /**
     * Write a PHY register. This is derived from the similar function in the ST
     * driver with changes to support accurate timing. Can hang forever if called
     * from an IRQ and there's an error reading from the PHY.
     * @param phyAddress The station number
     * @param regNumber The register number
     * @param value[out] Where to store the read value
     * @param true if it works, false if it fails
     */

    template<class TPhysicalLayer>
    inline bool Mac<TPhysicalLayer>::phyWriteRegister(uint16_t phyAddress,
                                                      uint16_t regNumber,
                                                      uint16_t value,
                                                      uint16_t timeoutMillis) {
      volatile uint32_t tmpreg;
      uint32_t start;

      // get the ETHERNET MACMIIAR value
      tmpreg=ETH->MACMIIAR;

      // Keep only the CSR Clock Range CR[2:0] bits value
      tmpreg &= ~MACMIIAR_CR_MASK;

      // Prepare the MII register address value
      tmpreg |= (((uint32_t)phyAddress<<11) & ETH_MACMIIAR_PA);   // Set the PHY device address
      tmpreg |= (((uint32_t)regNumber<<6) & ETH_MACMIIAR_MR);     // Set the PHY register address
      tmpreg |= ETH_MACMIIAR_MW;                                  // Set the write mode
      tmpreg |= ETH_MACMIIAR_MB;                                  // Set the MII Busy bit

      // Give the value to the MII data register
      ETH->MACMIIDR=value;

      // Write the result value into the MII Address register
      ETH->MACMIIAR=tmpreg;

      // Check for the Busy flag

      start=MillisecondTimer::millis();

      do
      {
        if(MillisecondTimer::hasTimedOut(start,timeoutMillis))
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_MAC,E_PHY_WRITE_TIMEOUT);

        tmpreg=ETH->MACMIIAR;
      } while((tmpreg & ETH_MACMIIAR_MB)!=0);

      return true;
    }
  }
}
// END FILE: ../lib/include/net/datalink/mac/Mac.h
// START FILE: ../lib/include/net/datalink/mac/MacBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Base class for MAC IO features. Designed to handle the transmit/receive
     * operations without being a template and cannot have dependencies on the PHY
     */

    class MacBase : public virtual NetworkReceiveEvents,
                    public virtual NetworkErrorEvents,
                    public virtual NetworkSendEvents,
                    public virtual NetworkNotificationEvents {

      public:
        static MacBase *_instance;

        /**
         * Error codes generated by this class
         */

        enum {
          E_PHY_WRITE_TIMEOUT=1,                //!< PHY write timeout
          E_PHY_READ_TIMEOUT,                   //!< PHY read timeout
          E_PHY_WAIT_TIMEOUT,                   //!< PHY timed out
          E_CRC,                                //!< E_CRC
          E_TOO_BIG,                            //!< Frame is too big
          E_TRANSMIT_ERROR,                     //!< failed to transmit a frame (see cause for extended error)
          E_RECEIVE,                            //!< E_RECEIVE
          E_WATCHDOG,                           //!< E_WATCHDOG
          E_LATE_COLLISION,                     //!< E_LATE_COLLISION
          E_IP_HEADER_CHECKSUM,                 //!< E_IP_HEADER_CHECKSUM
          E_OVERFLOW,                           //!< E_OVERFLOW
          E_TRUNCATED,                          //!< E_TRUNCATED
          E_PAYLOAD,                            //!< E_PAYLOAD
          E_HEADER,                             //!< E_HEADER
          E_UNSUPPORTED_802_3_FRAME_FORMAT,     //!< The frame format is unsupported (e.g. 802.3 not SNAP)
          E_BUSY,                               //!< A frame is already being sent
          E_TRANSMIT_PROCESS_STOPPED,
          E_TRANSMIT_JABBER_TIMEOUT,
          E_RECEIVE_OVERFLOW,
          E_TRANSMIT_UNDERFLOW,
          E_RECEIVE_BUFFER_UNAVAILABLE,
          E_RECEIVE_PROCESS_STOPPED,
          E_RECEIVE_WATCHDOG_TIMEOUT,
          E_FATAL_BUS_ERROR,
          E_NO_FLASH_DATA,                      ///< cannot transmit data in-place from the flash banks (hardware limitation)
          E_UNSPECIFIED                         //!< E_UNSPECIFIED
        };


        /**
         * Parameters for the MAC base class
         */

        struct Parameters {

          uint16_t mac_mtu;                 //!< default this to 1518 bytes (1500 data plus header (incl vlan option)
          MacAddress mac_address;           //!< address of this device on the LAN
          uint32_t mac_txWaitMillis;        //!< max time to wait for a pending frame to go
          uint8_t mac_receiveBufferCount;   //!< number of receive buffers
          uint8_t mac_transmitBufferCount;  //!< number of transmit buffers

          /**
           * Constructor, set up the defaults
           */

          Parameters() {

            // default MTU

            mac_mtu=1518;

            // generate a default MAC address 02-00-00-00-00-00
            // override this after construction to set your own address

            mac_address.macAddress[0]=2;      // locally-administered bit
            mac_address.macAddress[1]=0;
            mac_address.macAddress[2]=0;
            mac_address.macAddress[3]=0;
            mac_address.macAddress[4]=0;
            mac_address.macAddress[5]=0;

            // time to wait for a pending frame to go = 200ms

            mac_txWaitMillis=200;

            // default number of buffers. higher means better performance and more memory usage but you
            // need to be responsive to the network traffic. lower means less memory usage. The default
            // of 5 is the same as the ST driver default.

            mac_receiveBufferCount=5;
            mac_transmitBufferCount=5;
          }
        };


      protected:

        // receive buffers and descriptors. there's little scope to improve this over ST's
        // implementation as data arrives at the MAC unsolicited

        scoped_array<uint8_t[ETH_MAX_PACKET_SIZE]> _receiveBuffers;
        scoped_array<ETH_DMADESCTypeDef> _receiveDmaDescriptors;

        // the transmit descriptors are created ahead of time but we use no memory for buffers
        // unless we have data to go out and it's free'd once gone

        scoped_array<ETH_DMADESCTypeDef> _transmitDmaDescriptors;
        scoped_array<NetBuffer *> _transmitNetBuffers;
        int _transmitBufferIndex;

        // parameters class

        Parameters _params;

      protected:
        void processReceivedFrame(const FrameTypeDef& frame);
        bool setupEthernetFrame(const FrameTypeDef& fd,EthernetFrame& ef) const;

        bool sendBuffer(NetBuffer *nb);

        bool initialise(const Parameters& params);
        bool startup();

        void onSend(NetEventDescriptor& ned);

      public:
        MacBase();

        void handleReceiveInterrupt();
        void handleTransmitInterrupt();
        void handleErrorInterrupt(uint32_t dmaStatus);

        uint32_t getDatalinkTransmitHeaderSize() const;
        uint32_t getDatalinkMtuSize() const;
    };


    /**
     * Constructor: set up the static instance pointer needed for the
     * interrupt callbacks
     */

    inline MacBase::MacBase() {
      _instance=this;
    }


    /**
     * Get the size of the headers needed to transmit an ethernet frame
     * @return The size of 2 MAC addresses and the EtherType field. A total of 14 bytes.
     */

    inline uint32_t MacBase::getDatalinkTransmitHeaderSize() const {
      return 14;
    }


    /**
     * Get the datalink MTU size. Default is 1500 bytes.
     * @return The MTU size
     */

    inline uint32_t MacBase::getDatalinkMtuSize() const {
      return _params.mac_mtu;
    }
  }
}
// END FILE: ../lib/include/net/datalink/mac/MacBase.h
// START FILE: ../lib/include/net/datalink/mac/MacAddressFilter.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * MAC address filtering option. Provides access to the STM32 built-in filtering
     * capabilities. You can whitelist or blacklist up to 3 MAC addresses as sources
     * or destinations.
     */

    template<class TPhysicalLayer>
    class MacAddressFilter : public virtual TPhysicalLayer {

      public:

        /**
         * Parameters class
         */

        struct Parameters {

          struct Filter {
            MacAddress address;           ///< address for filtering
            bool source;                  ///< true to filter sources (senders), false to filter destinations (default is true)
            uint32_t maskBytes;           ///< combination of ETH_MAC_AddressMask_Byte1..6. When set, the address byte for that bit is NOT used in the comparison. Default is zero.

            Filter() {
              source=true;
              maskBytes=0;
            }
          };

          Filter macfilter_filters[3];    ///< the addresses to filter on, up to 3.
          bool macfilter_whitelist;       ///< true to pass addresses that match, false to fail. default is true


          /**
           * Constructor
           */

          Parameters() {
            macfilter_whitelist=true;
          }
        };

      protected:

        void initialiseFilter(const typename Parameters::Filter& filter,uint32_t macId,uint8_t& sources,uint8_t& dests) const;

        bool initialise(const Parameters& params);
        bool startup();
    };


    /**
     * Initialise the filtering
     */

    template<class TPhysicalLayer>
    inline bool MacAddressFilter<TPhysicalLayer>::initialise(const Parameters& params) {

      uint8_t sources,dests;

      // initialise each filter

      sources=dests=0;

      initialiseFilter(params.macfilter_filters[0],ETH_MAC_Address1,sources,dests);
      initialiseFilter(params.macfilter_filters[1],ETH_MAC_Address2,sources,dests);
      initialiseFilter(params.macfilter_filters[2],ETH_MAC_Address3,sources,dests);

      // clear source/dest filtering options

      ETH->MACFFR&=~(0x300 | 8);

      // source filtering can be disabled, normal, inverse

      ETH->MACFFR|=sources==0 ?
                      ETH_SourceAddrFilter_Disable :
                      (params.macfilter_whitelist ? ETH_SourceAddrFilter_Normal_Enable : ETH_SourceAddrFilter_Inverse_Enable);


      // destination filtering can be normal, inverse

      ETH->MACFFR|=dests==0 || params.macfilter_whitelist ?
                      ETH_DestinationAddrFilter_Normal : ETH_DestinationAddrFilter_Inverse;

      return true;
    }


    /**
     * Startup, nothing to do
     * @return true
     */

    template<class TPhysicalLayer>
    inline bool MacAddressFilter<TPhysicalLayer>::startup() {
      return true;
    }


    /**
     * Initialise filtering for a given address
     * @param filter The filter definition
     * @param macId The mac address identifier (ETH_MAC_Address1..3)
     */

    template<class TPhysicalLayer>
    inline void MacAddressFilter<TPhysicalLayer>::initialiseFilter(const typename Parameters::Filter& filter,uint32_t macId,uint8_t& sources,uint8_t& dests) const {

      if(filter.address.isValid()) {

        // set the source/dest selection, filter mask bytes and enable it

        if(filter.source) {
          sources++;
          ETH_MACAddressFilterConfig(macId,ETH_MAC_AddressFilter_SA);
        }
        else {
          dests++;
          ETH_MACAddressFilterConfig(macId,ETH_MAC_AddressFilter_DA);
        }

        ETH_MACAddressMaskBytesFilterConfig(macId,filter.maskBytes);
        ETH_MACAddressPerfectFilterCmd(macId,ENABLE);
      }
    }
  }
}
// END FILE: ../lib/include/net/datalink/mac/MacAddressFilter.h
// START FILE: ../lib/include/net/datalink/EthernetTaggedSnapFrameData.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Ethernet frame data structure incorporating a QTAG and the 802.3 SNAP header.
     * This can be cast directly on to a frame memory
     * buffer. Note multi-byte members will be in network byte order
     */

    struct EthernetTaggedSnapFrameData {

      MacAddress eth_destinationAddress;        ///< destination MAC
      MacAddress eth_sourceAddress;             ///< source MAC
      uint16_t eth_qtagType;                    ///< qtag type field
      uint16_t eth_qtagControlInfo;             ///< qtag control information
      uint16_t eth_length;                      ///< frame length
      uint8_t eth_dsap;                         ///< destination SAP
      uint8_t eth_ssap;                         ///< source SAP
      uint8_t eth_control;                      ///< control code
      uint16_t eth_etherType;                   ///< ethertype for ethernet v2
      uint8_t eth_data[36];                     ///< at least 36 bytes including 4 for the FCS
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/datalink/EthernetTaggedSnapFrameData.h
// START FILE: ../lib/include/net/datalink/DatalinkLayer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Template feature-holder for features that live in the datalink
     * network layer, e.g. MAC. The layer below this is the physical layer
     * and the layer above is the network layer.
     */

    template<class TPhysicalLayer,template<class> class... Features>
    class DatalinkLayer : public virtual TPhysicalLayer,
                          public Features<TPhysicalLayer>... {

      public:

        /**
         * Base parameters collection-class for datalink features
         */

        struct Parameters : TPhysicalLayer::Parameters,
                            Features<TPhysicalLayer>::Parameters... {
        };

      public:
        bool initialise(Parameters& params);
        bool startup();
    };


    /**
     * Initialise the features
     * @param params The parameters class to initialise the layer features
     * @return true if it worked
     */

    template<class TPhysicalLayer,template<class> class... Features>
    bool DatalinkLayer<TPhysicalLayer,Features...>::initialise(Parameters& params) {
      return TPhysicalLayer::initialise(params) &&
             RecursiveBoolInitWithParams<DatalinkLayer,Features<TPhysicalLayer>...>::tinit(this,params);
    }


    /**
     * Startup the components in this layer
     * @return
     */

    template<class TPhysicalLayer,template<class> class... Features>
    bool DatalinkLayer<TPhysicalLayer,Features...>::startup() {
      return TPhysicalLayer::startup() &&
             RecursiveBoolStartup<DatalinkLayer,Features<TPhysicalLayer>...>::tstartup(this);
    }
  }
}
// END FILE: ../lib/include/net/datalink/DatalinkLayer.h
// START FILE: ../lib/include/net/datalink/MacAddress.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * MAC address structure. This must be packed because it can be cast as a pointer directly
     * on to the data received in an ethernet frame
     */

    struct MacAddress {

      /**
       * the word and half-word structure enable us to do fast copy and comparisons
       */

      union {
        uint8_t macAddress[6];          //!< The MAC address bytes
        struct {
          uint32_t w;
          uint16_t hw;
        } __attribute__((packed)) macAddressWords;
      };

      /**
       * Constructor, ensure mac is zero
       */

      MacAddress() {
        memset(macAddress,0,sizeof(macAddress));
      }


      /**
       * We can beat gcc's trivial-ctor byte-by-byte copy implementation by
       * using a word and a half-word copy
       * @param src The src structure
       */

      MacAddress(const MacAddress& src) {
        macAddressWords.w=src.macAddressWords.w;
        macAddressWords.hw=src.macAddressWords.hw;
      }


      /**
       * Constructor with components
       */

      MacAddress(uint8_t f1,uint8_t f2,uint8_t f3,uint8_t f4,uint8_t f5,uint8_t f6) {
        macAddress[0]=f1;
        macAddress[1]=f2;
        macAddress[2]=f3;
        macAddress[3]=f4;
        macAddress[4]=f5;
        macAddress[5]=f6;
      }


      /**
       * Check if this is a valid (non-zero) mac address
       */

      bool isValid() const {
        return (macAddress[0] | macAddress[1] | macAddress[2] |
                macAddress[3] | macAddress[4] | macAddress[5]) !=0;
      }


      /**
       * Equality operator. Do it with two comparisons, a word and a half-word
       * @param rhs The other mac address
       * @return true if they are equal
       */

      bool operator==(const MacAddress& rhs) const {
        return macAddressWords.w==rhs.macAddressWords.w &&
               macAddressWords.hw==rhs.macAddressWords.hw;
      }
      bool operator!=(const MacAddress& rhs) const {
        return !operator==(rhs);
      }


      /**
       * Assignment.
       * @param src where to copy from
       * @return self reference
       */

      MacAddress& operator=(const MacAddress& src) {
        macAddressWords.w=src.macAddressWords.w;
        macAddressWords.hw=src.macAddressWords.hw;
        return *this;
      }


      /**
       * Create a MacAddress structure for the ethernet broadcast address
       * FF:FF:FF:FF:FF:FF
       * @return the address
       */

      static const MacAddress& createBroadcastAddress() {
        static const MacAddress mc(0xff,0xff,0xff,0xff,0xff,0xff);
        return mc;
      }


      /**
       * Create a multicast address from the IP address according to the
       * compression algorithm in RFC1112
       * @param ipGroupAddress The IP multicast group address
       */

      void createMulticastAddress(const uint8_t *ipAddressBytes) {

        // the IANA OUI plus LSB[0]=1 to indicate mcast

        macAddress[0]=0x01;
        macAddress[1]=0x00;
        macAddress[2]=0x5e;
        macAddress[3]=0x00;
        macAddress[4]=0x00;
        macAddress[5]=0x00;

        // merge in lower 23 bits of host group address into the lower 23 bits of the MAC

        macAddress[3]=ipAddressBytes[1] & 0x7F;
        macAddress[4]=ipAddressBytes[2];
        macAddress[5]=ipAddressBytes[3];
      }

    } __attribute__ ((packed));
  }
}
// END FILE: ../lib/include/net/datalink/MacAddress.h
// START FILE: ../lib/include/net/datalink/MacAddressAnnoucementEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for a client Mac address announcement
     */

    struct MacAddressAnnouncementEvent : NetEventDescriptor {

      /**
       * References to the value
       */

      const MacAddress& macAddress;


      /**
       * Constructor
       */

      MacAddressAnnouncementEvent(const MacAddress& address)
        : NetEventDescriptor(NetEventType::MAC_ADDRESS_ANNOUNCEMENT),
          macAddress(address) {
      }
    };
  }
}
// END FILE: ../lib/include/net/datalink/MacAddressAnnoucementEvent.h
// START FILE: ../lib/include/net/datalink/EthernetFrameData.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Ethernet frame data structure. This can be cast directly on to a frame memory
     * buffer. Note multi-byte members will be in network byte order
     */

    struct EthernetFrameData {

      MacAddress eth_destinationAddress;        ///< destination MAC
      MacAddress eth_sourceAddress;             ///< source MAC
      uint16_t eth_etherType;                   ///< ethertype for ethernet v2
      uint8_t eth_data[46];                     ///< at least 46 bytes, plus 4 for the FCS
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/datalink/EthernetFrameData.h
// START FILE: ../lib/include/net/datalink/EthernetSnapFrameData.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Ethernet frame data structure incorporating the 802.3 SNAP header.
     * This can be cast directly on to a frame memory
     * buffer. Note multi-byte members will be in network byte order
     */

    struct EthernetSnapFrameData {

      MacAddress eth_destinationAddress;        ///< destination MAC
      MacAddress eth_sourceAddress;             ///< source MAC
      uint16_t eth_length;                      ///< frame length
      uint8_t eth_dsap;                         ///< destination SAP
      uint8_t eth_ssap;                         ///< source SAP
      uint8_t eth_control;                      ///< control code
      uint16_t eth_etherType;                   ///< ethertype for ethernet v2
      uint8_t eth_data[41];                     ///< at least 41 bytes including 4 for the FCS
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/datalink/EthernetSnapFrameData.h
// START FILE: ../lib/include/net/datalink/DatalinkChecksum.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * The type of checksum calculation requested
     */

    enum class DatalinkChecksum {
      NONE,                       //!< NONE: Already done
      IP_HEADER,                  //!< IP_HEADER: Just the IP header
      IP_HEADER_AND_PROTOCOL      //!< IP_HEADER_AND_PROTOCOL: IP header and protocol
    };
  }
}
// END FILE: ../lib/include/net/datalink/DatalinkChecksum.h
// START FILE: ../lib/include/net/datalink/DatalinkFrameEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for a datalink frame
     */

    struct DatalinkFrameEvent : NetEventDescriptor {

      /**
       * The frame reference
       */

      DatalinkFrame& datalinkFrame;


      /**
       * Constructor
       * @param frame
       */

      DatalinkFrameEvent(DatalinkFrame& frame)
        : NetEventDescriptor(NetEventType::DATALINK_FRAME),
          datalinkFrame(frame) {
      }
    };
  }
}
// END FILE: ../lib/include/net/datalink/DatalinkFrameEvent.h
// START FILE: ../lib/include/net/datalink/DatalinkFrame.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Datalink layer frame information
     */

    struct DatalinkFrame {

      enum class FrameSource {
        ETHERNET_FRAME
      };

      uint8_t *payload;           //!< frame payload data - do not attempt to free
      uint32_t payloadLength;     //!< length of the frame payload
      uint16_t protocol;          //!< values match EtherType
      FrameSource frameSource;    //!< identify this frame to enable safe casting
    };
  }
}
// END FILE: ../lib/include/net/datalink/DatalinkFrame.h
// START FILE: ../lib/include/net/datalink/DatalinkFrameSentEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for a datalink frame-sent event. This event is
     * sent when a frame has been put on to the wire and the NetBuffer
     * is about to be released.
     */

    struct DatalinkFrameSentEvent : NetEventDescriptor {

      /**
       * The net buffer reference
       */

      NetBuffer& netBuffer;


      /**
       * Constructor
       * @param nb The NetBuffer holding the frame that's just gone
       */

      DatalinkFrameSentEvent(NetBuffer& nb)
        : NetEventDescriptor(NetEventType::DATALINK_FRAME_SENT),
          netBuffer(nb) {
      }
    };
  }
}
// END FILE: ../lib/include/net/datalink/DatalinkFrameSentEvent.h
// START FILE: ../lib/include/net/datalink/EthernetTaggedFrameData.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Ethernet frame data structure with Qtag. This can be cast directly on to a frame memory
     * buffer. Note multi-byte members will be in network byte order
     */

    struct EthernetTaggedFrameData {

      MacAddress eth_destinationAddress;        ///< destination MAC
      MacAddress eth_sourceAddress;             ///< source MAC
      uint16_t eth_qtagType;                    ///< qtag type field
      uint16_t eth_qtagControlInfo;             ///< qtag control information
      uint16_t eth_etherType;                   ///< ethertype for ethernet v2
      uint8_t eth_data[42];                     ///< at least 42 bytes, plus 4 for the FCS
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/datalink/EthernetTaggedFrameData.h
// START FILE: ../lib/include/net/datalink/EthernetTransmitRequestEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for a request to transmit an ethernet frame
     */

    struct EthernetTransmitRequestEvent : NetEventDescriptor {

      NetBuffer *networkBuffer;             ///< buffer to send
      const MacAddress& macAddress;         ///< reference to MAC (will be copied out)
      EtherType etherType;                  ///< ethertype number
      bool succeeded;                       ///< set to true by the link layer if the transmit was accepted

      /**
       * Constructor
       * @param nb The buffer pointer to send (the receive owns it)
       * @param mac The MAC address
       * @param et The event type
       */

      EthernetTransmitRequestEvent(NetBuffer *nb,const MacAddress& mac,EtherType et,DatalinkChecksum ckreq)
        : NetEventDescriptor(NetEventType::ETHERNET_TRANSMIT_REQUEST),
          networkBuffer(nb),
          macAddress(mac),
          etherType(et),
          succeeded(false) {

        // transfer the checksum request into the netbuffer as they are tightly coupled

        nb->setChecksumRequest(ckreq);
      }
    };
  }
}
// END FILE: ../lib/include/net/datalink/EthernetTransmitRequestEvent.h
// START FILE: ../lib/include/net/NetworkUtilityObjects.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Do-nothing container that holds all the base structures that are required by
     * all layers of the network stack. This is convenient for passing as a reference
     * to utility classes that are not directly linked into the stack but do need to
     * make use of its events and clock during their lifetime.
     */

    struct NetworkUtilityObjects : virtual NetworkReceiveEvents,
                                   virtual NetworkSendEvents,
                                   virtual NetworkErrorEvents,
                                   virtual NetworkNotificationEvents,
                                   virtual NetworkIntervalTicker,
                                   virtual DefaultRng {
    };
  }
}
// END FILE: ../lib/include/net/NetworkUtilityObjects.h
// START FILE: ../lib/include/net/NetworkStack.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Convenience template to allow a network stack to be declared with a sensibly named
     * root object (NetworkStack) instead of the top layer (Application)
     */

    template<class TApplicationLayer>
    class NetworkStack : public TApplicationLayer {

      public:

        /*
         * We have no parameters of our own
         */

        typedef typename TApplicationLayer::Parameters Parameters;

      public:
        bool initialise(Parameters& params);
        bool startup();
    };


    /**
     * Initialise. Call upwards.
     * @param params The parameters to be passed upwards
     * @return the result of all the initialisation
     */

    template<class TApplicationLayer>
    bool NetworkStack<TApplicationLayer>::initialise(Parameters& params) {
      return TApplicationLayer::initialise(params);
    }


    /**
     * Start up the stack
     * @return
     */

    template<class TApplicationLayer>
    bool NetworkStack<TApplicationLayer>::startup() {
      return TApplicationLayer::startup();
    }
  }
}
// END FILE: ../lib/include/net/NetworkStack.h
// START FILE: ../lib/include/net/NetEventDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Base class for all network events, contains an identifier that
     * can be used to determine how to downcast this structure
     */

    struct NetEventDescriptor {

        /**
         * Possible event types raised
         */

        enum class NetEventType {
          NETWORK_ERROR,                ///< An error occurred
          PHY_READ_REQUEST,             ///< request to read a PHY register
          PHY_WRITE_REQUEST,            ///< request to write a PHY register
          ETHERNET_TRANSMIT_REQUEST,    ///< request to send an ethernet frame
          DATALINK_FRAME,               ///< Datalink frame arrived
          DATALINK_FRAME_SENT,          ///< Datalink frame sent on to the wire
          IP_PACKET,                    ///< IP packet arrived
          IP_TRANSMIT_REQUEST,          ///< an IP packet needs to be transmitted
          IP_ADDRESS_MAPPING,         ///< an association between a MAC and an IP is being notified
          ICMP_PACKET,                  ///< an ICMP packet has been received
          ICMP_TRANSMIT_REQUEST,        ///< an ICMP packet should be sent
          UDP_DATAGRAM,                 ///< a UDP datagram has been received
          ARP_MAPPING_REQUEST,          ///< a request to get an ARP mapping
          ARP_FRAME,                    ///< an ARP frame has been received
          IP_ADDRESS_ANNOUNCEMENT,      ///< a new ip address has been assigned
          SUBNET_MASK_ANNOUNCEMENT,     ///< a new subnet mask has been assigned
          DOMAIN_NAME_ANNOUNCEMENT,     ///< a new domain name has been assigned
          DNS_SERVERS_ANNOUNCEMENT,     ///< DNS servers have been assigned
          DEFAULT_GATEWAY_ANNOUNCEMENT, ///< A new default gateway has been assigned
          MAC_ADDRESS_ANNOUNCEMENT,     ///< a new mac address has been set
          DHCP_RENEWAL_DUE,           ///< time to renew the DHCP lease
          TCP_ACCEPT,                   ///< TCP connection arrived
          TCP_SERVER_RELEASED,          ///< TCP server is being destroyed and a port can be released
          TCP_CONNECTION_RELEASED,      ///< A TCP connection is released
          TCP_SEGMENT,                  ///< TCP segment arrived
          TCP_FIND_CONNECTION,          ///< TCP connection finder
          TCP_CONNECTION_CLOSED,        ///< TCP remote end has closed
          TCP_CONNECTION_DATA_READY,    ///< we have buffered some data from the remote end
          TCP_CONNECTION_STATE_CHANGED, ///< the state of a TCP connection has changed
          DEBUG_MESSAGE                 ///< message for debugging
        };

        NetEventType eventType;

      public:
        NetEventDescriptor(NetEventType type)
          : eventType(type) {
        }
    };
  }
}
// END FILE: ../lib/include/net/NetEventDescriptor.h
// START FILE: ../lib/include/net/NetBuffer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Network buffer class. This is designed to hold an un-owned pointer to an optional
     * user-supplied data buffer intended for transmission together with an owned buffer
     * large enough to contain data to transmit before the user buffer, i.e. network
     * headers and such like.
     */

    class NetBuffer {

      protected:
        const void *_userBuffer;
        uint32_t _userBufferSize;

        void *_internalBuffer;
        uint32_t _internalBufferSize;

        void *_writePointer;

        // this is normall nullptr except when a fragmented packet is going out. In that case the last
        // in the sequence has the original packet pointer here

        scoped_ptr<NetBuffer> _reference;

        // this is inserted by the network layer so the datalink layer knows whether it has to
        // compute a checksum or not

        DatalinkChecksum _checksumRequest;

      public:
        NetBuffer(uint32_t headerSpace,uint32_t dataSpace,const void *userBuffer=nullptr,uint32_t userBufferSize=0);
        ~NetBuffer();

        const void *getUserBuffer() const;
        void *getInternalBuffer() const;

        uint32_t getUserBufferSize() const;
        uint32_t getInternalBufferSize() const;
        uint32_t getSizeFromWritePointerToEnd() const;

        void *getWritePointer() const;
        void *moveWritePointerBack(uint32_t size);

        NetBuffer *getReference() const;
        void setReference(NetBuffer *reference);

        DatalinkChecksum getChecksumRequest() const;
        void setChecksumRequest(DatalinkChecksum checksumRequest);
    };


    /**
     * Constructor, save variables and allocate internal buffer
     * @param headerSpace
     * @param dataSpace
     * @param userBuffer
     */

    inline NetBuffer::NetBuffer(uint32_t headerSpace,uint32_t dataSpace,const void *userBuffer,uint32_t userBufferSize) {

      _userBufferSize=userBufferSize;
      _userBuffer=userBuffer;

      // allocate space for net buffer and position the write pointer past the end

      _internalBufferSize=headerSpace+dataSpace;
      _internalBuffer=malloc(_internalBufferSize);
      _writePointer=reinterpret_cast<void *>(reinterpret_cast<uint8_t *>(_internalBuffer)+_internalBufferSize);
    }


    /**
     * Destructor, clean up
     */

    inline NetBuffer::~NetBuffer() {
      if(_internalBuffer)
        free(_internalBuffer);
    }


    /**
     * Get the size of the user buffer
     * @return The user buffer size
     */

    inline uint32_t NetBuffer::getUserBufferSize() const {
      return _userBufferSize;
    }


    /**
     * Return the user buffer pointer
     */

    inline const void *NetBuffer::getUserBuffer() const {
      return _userBuffer;
    }


    /**
     * Return the internal buffer pointer
     */

    inline void *NetBuffer::getInternalBuffer() const {
      return _internalBuffer;
    }


    /**
     * Get the internal buffer size
     * @return The internal buffer size
     */

    inline uint32_t NetBuffer::getInternalBufferSize() const {
      return _internalBufferSize;
    }


    /**
     * Get the size of the buffer from the current write pointer
     * to the end of the data. This is effectively a "total packet
     * size" when called for a protocol whose header begins at the
     * current write pointer
     * @return The size requested
     */

    inline uint32_t NetBuffer::getSizeFromWritePointerToEnd() const {
      return (reinterpret_cast<uint32_t>(_internalBuffer)+_internalBufferSize)-
             reinterpret_cast<uint32_t>(_writePointer);
    }


    /**
     * Get the write pointer
     * @return the current write pointer
     */

    inline void *NetBuffer::getWritePointer() const {
      return _writePointer;
    }


    /**
     * Decrement the write pointer by the given size and return its
     * new position
     * @return the new position
     */

    inline void *NetBuffer::moveWritePointerBack(uint32_t size) {
      _writePointer=reinterpret_cast<uint8_t *>(_writePointer)-size;
      return _writePointer;
    }


    /**
     * Get the 'reference' netbuffer. This will be non-null if this netbuffer
     * is the last in a sequence of fragmented packets. Basically the reference pointer
     * serves to keep the original bumper packet in scope while the fragments are transmitted. This
     * means that the fragments can exist as pointers into the original buffer without having to
     * create new memory buffers with all the memory and CPU overhead that would entail.
     * @return The pointer
     */

    inline NetBuffer *NetBuffer::getReference() const {
      return _reference.get();
    }


    /**
     * Set a new reference pointer. Can only be called once.
     * @param reference The new reference pointer
     */

    inline void NetBuffer::setReference(NetBuffer *reference) {
      _reference.reset(reference);
    }


    /**
     * Get the checksum request type
     * @return The checksum request type
     */

    inline DatalinkChecksum NetBuffer::getChecksumRequest() const {
      return _checksumRequest;
    }


    /**
     * Set the checksum request flag
     * @param checksumRequest The flag
     */

    inline void NetBuffer::setChecksumRequest(DatalinkChecksum checksumRequest) {
      _checksumRequest=checksumRequest;
    }
  }
}
// END FILE: ../lib/include/net/NetBuffer.h
// START FILE: ../lib/include/net/NetMeta.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Recursive initialisation of feature classes defined using variadic templates.
     * This initialiser has parameters and NetworkUtilityObjects class and returns bool
     * Here's the forward definition
     */

    template<typename F,typename... T>
    struct RecursiveBoolInitWithParamsAndNetworkUtilityObjects;

    /**
     * Recursion termination condition, always return success
     */

    template<class F>
    struct RecursiveBoolInitWithParamsAndNetworkUtilityObjects<F> {
      static bool tinit(F *,typename F::Parameters&,NetworkUtilityObjects&) {
        return true;
      }
    };


    /**
     * General recursive initialiser
     */

    template<class F,class T,class... G>
    struct RecursiveBoolInitWithParamsAndNetworkUtilityObjects<F,T,G...> {
      static bool tinit(F *ptr,typename F::Parameters& p,NetworkUtilityObjects& netUtils) {

        if(!ptr->T::initialise(p,netUtils))
          return false;

        return RecursiveBoolInitWithParamsAndNetworkUtilityObjects<F,G...>::tinit(ptr,p,netUtils);
      }
    };


    /**
     * Recursive initialisation of physical layer feature classes defined using variadic
     * templates. This initialiser has parameters, NetworkUtilityObjects and a PHY class
     * and returns bool. Here's the forward definition
     */

    template<class F,class TPhy,class... T>
    struct RecursivePhysicalLayerInit;

    /**
     * Recursion termination condition, always return success
     */

    template<class F,class TPhy>
    struct RecursivePhysicalLayerInit<F,TPhy> {
      static bool tinit(F *,typename F::Parameters&,NetworkUtilityObjects&,TPhy&) {
        return true;
      }
    };


    /**
     * General recursive initialiser
     */

    template<class F,class TPhy,class T,class... G>
    struct RecursivePhysicalLayerInit<F,TPhy,T,G...> {
      static bool tinit(F *ptr,typename F::Parameters& p,TPhy& phy,NetworkUtilityObjects& netUtils) {

        if(!ptr->T::initialise(p,netUtils,phy))
          return false;

        return RecursivePhysicalLayerInit<F,TPhy,G...>::tinit(ptr,p,netUtils,phy);
      }
    };
  }
}
// END FILE: ../lib/include/net/NetMeta.h
// START FILE: ../lib/include/net/NetworkErrorEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for a network error. We hold the provider, code and cause
     * variables because early reports using the errorProvider may be overwritten
     * as the error works its way up the stack.
     */

    struct NetworkErrorEvent : NetEventDescriptor {

      int provider;
      uint32_t code;
      uint32_t cause;

      /**
       * Constructor
       * @param provider The error provider code
       * @param code The error code (provider specific)
       * @param cause extended error information, if any
       */

      NetworkErrorEvent(int provider_,uint32_t code_,uint32_t cause_=0)
        : NetEventDescriptor(NetEventType::NETWORK_ERROR),
          provider(provider_),
          code(code_),
          cause(cause_) {
        errorProvider.set(provider,code,cause);
      }
    };
  }
}
// END FILE: ../lib/include/net/NetworkErrorEvent.h
// START FILE: ../lib/include/net/transport/udp/Udp.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    DECLARE_EVENT_SIGNATURE(UdpReceive,void (UdpDatagramEvent&));

    /**
     * Implementation of the UDP protocol over IP. Datagrams are received asynchronously from the IP
     * layer and passed on to the upper layers. Functionality is provided for sending and receiving
     * datagrams synchronously to the caller.
     */

    template<class TNetworkLayer>
    class Udp : public virtual TNetworkLayer {

      public:

        /**
         * Parameters class
         */

        struct Parameters {

          bool udp_sendPortUnreachable;     ///< datagrams sent to ports with no handler will get an ICMP error message (if ICMP is configured in). default is true

          Parameters() {
            udp_sendPortUnreachable=true;
          }
        };


        /**
         * Error codes
         */

        enum {
          E_TIMED_OUT = 1,    ///< timed out while waiting for data
          E_MSG_SIZE,         ///< data was received, but more is available and has been lost
        };

        DECLARE_EVENT_SOURCE(UdpReceive);

      protected:
        Parameters _params;                           ///< protocol parameters
        volatile bool _awaiting;                      ///< true to indicate we're waiting for receive
        volatile uint16_t _awaitingPort;              ///< port we're waiting on
        volatile void *_awaitingBuffer;               ///< buffer to copy incoming data into
        volatile uint16_t *_awaitingBufferSize;       ///< buffer size, updated with actual value
        volatile uint16_t _awaitingDatagramSize;      ///< the actual size received
        volatile IpPacketHeader _ipPacketHeader;      ///< the underlying IP packet header

      protected:
        void onReceive(IpPacketEvent& ned);
        void onNotification(NetEventDescriptor& ned);

        volatile NetBuffer *_waitForThisBuffer;

      public:
        bool initialise(const Parameters& params);
        bool startup();

        bool udpSend(const IpAddress& ipaddress,
                     uint16_t sourcePortNumber,
                     uint16_t destinationPortNumber,
                     const void *data,
                     uint16_t dataSize,
                     bool async,
                     uint32_t transmitTimeout);

        // synchronous receive functions

        bool udpReceive(uint16_t portNumber,void *buffer,uint16_t& size,uint32_t receiveTimeout=0);
        const volatile IpPacketHeader& udpGetIpPacketHeader() const;
        const volatile IpAddress& udpGetRemoteAddress() const;
    };


    /**
     * Initialise the class
     * @param params The parameters class
     * @return true if it worked
     */

    template<class TNetworkLayer>
    inline bool Udp<TNetworkLayer>::initialise(const Parameters& params) {

      // remember parameters

      _params=params;

      // not waiting for anything

      _waitForThisBuffer=nullptr;
      _awaiting=false;

      // subscribe for receive and notification events from the IP implementation

      this->IpReceiveEventSender.insertSubscriber(IpReceiveEventSourceSlot::bind(this,&Udp<TNetworkLayer>::onReceive));
      this->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&Udp<TNetworkLayer>::onNotification));

      return true;
    }


    /**
     * Startup the class
     * @return true if it worked
     */

    template<class TNetworkLayer>
    inline bool Udp<TNetworkLayer>::startup() {
      return true;
    }


    /**
     * Receive event notification from the stack
     * @param ipe The IP packet event
     */

    template<class TNetworkLayer>
    inline void Udp<TNetworkLayer>::onReceive(IpPacketEvent& ipe) {

      bool handled;

      // is this UDP?

      if(ipe.ipPacket.header->ip_hdr_protocol!=IpProtocol::UDP)
        return;

      // notify upwards that a UDP datagram has arrived

      UdpDatagram *datagram=reinterpret_cast<UdpDatagram *>(ipe.ipPacket.payload);

      // are we waiting for a datagram?

      if(_awaiting) {

        // the destination port must match

        if(NetUtil::ntohs(datagram->udp_destinationPort)==_awaitingPort) {

          // copy the incoming data and release the waiting code

          _awaitingDatagramSize=NetUtil::ntohs(datagram->udp_length)-UdpDatagram::getHeaderSize();
          *_awaitingBufferSize=std::min<uint16_t>((uint16_t)_awaitingDatagramSize,(uint16_t)*_awaitingBufferSize);
          memcpy(const_cast<void *>(_awaitingBuffer),datagram->udp_data,*_awaitingBufferSize);
          const_cast<IpPacketHeader&>(_ipPacketHeader)=*(ipe.ipPacket.header);     // struct copy

          _awaiting=false;
          handled=true;
        }
        else
          handled=false;
      }
      else
        handled=false;

      // raise the receive event

      UdpDatagramEvent ude(*datagram,ipe.ipPacket);
      UdpReceiveEventSender.raiseEvent(ude);

      // merge the handled flag

      if(!handled)
        handled=ude.handled;

      // if nobody could handle this packet and we are configured to do so then we will
      // raise an ICMP port unreachable event which, if ICMP is configured into the stack,
      // will get sent back to the remote end

      if(!handled &&
          _params.udp_sendPortUnreachable &&
          !ipe.ipPacket.header->ip_destinationAddress.isBroadcast() &&
          !ipe.ipPacket.header->ip_destinationAddress.isMulticastGroup()) {

        uint16_t errorPacketSize;

        // the incoming IP header is of a variable size so allocate memory for a
        // packet large enough for it and the ICMP structure

        IcmpDestinationUnreachable *errorPacket=createIcmpErrorPacket<IcmpDestinationUnreachable>(
            IcmpCode::DESTINATION_PORT_UNREACHABLE,
            ipe.ipPacket,
            errorPacketSize
          );

        // create the ICMP transmit request event

        IcmpTransmitRequestEvent itre(
            *errorPacket,
            errorPacketSize,
            ipe.ipPacket.header->ip_sourceAddress);

        // send it

        this->NetworkSendEventSender.raiseEvent(itre);

        // free the error packet

        free(errorPacket);
      }
    }


    /**
     * Send a UDP datagram. The data must be a single datagram which implies a maximum
     * dataSize of 65507 bytes though in practice you should avoid exceeding the
     * MAC MTU size unless you know that the network layer driver supports
     * packet fragmentation and reassembly.
     *
     * If you set the async flag then you should be aware that dynamic memory is
     * allocated to hold the datagram until transmission is complete so you must have
     * enough SRAM to hold it and any other datagrams pending transmission. If you
     * do not set the async flag then this method blocks until the datagram has been
     * transmitted or the timeout expires. Datagrams transmitted synchronously only
     * use dynamic memory for the datagram and frame header information because the
     * datagram data is transmitted directly from the memory pointer that you supply.
     * Synchronous mode trades network throughput for reduced CPU load and SRAM usage.
     *
     * @param ipaddress The IP address to send to.
     * @param sourcePortNumber The port number that you are sending from, or zero if you don't care
     * @param destinationPortNumber The destination port to send to.
     * @param data The data buffer to send
     * @param dataSize The size of the data buffer
     * @param async true to transmit asynchronously. false to transmit synchronously.
     * @param transmitTimeout In synchronous mode the number of ms to wait for a datagram to be
     * transmitted. Ignored in asychronous mode.
     * @return async mode always returns true. sync mode will return false if the datagram send operation times out.
     */

    template<class TNetworkLayer>
    bool Udp<TNetworkLayer>::udpSend(const IpAddress& ipaddress,
                                      uint16_t sourcePortNumber,
                                      uint16_t destinationPortNumber,
                                      const void *data,
                                      uint16_t dataSize,
                                      bool async,
                                      uint32_t transmitTimeout) {

      NetBuffer *nb;

      // create a net buffer for the echo reply
      // replies are always coming from an incoming frame IRQ
      // cannot use the incoming request data in-place because it's going
      // to go out of scope before the frame is transmitted

      if(async) {

        nb=new NetBuffer(this->getDatalinkTransmitHeaderSize()+this->getIpTransmitHeaderSize()+UdpDatagram::getHeaderSize(),
                         dataSize,
                         nullptr);

        // copy over the data from the request, if there was any - there doesn't have to be

        if(dataSize) {
          uint8_t *packetData=reinterpret_cast<uint8_t *>(nb->moveWritePointerBack(dataSize));
          memcpy(packetData,data,dataSize);
        }
      }
      else {

        // in this mode the user's data is transmitted in-place after the headers have gone out
        // much larger datagrams are possible in this mode at the expense of throughput

        nb=new NetBuffer(this->getDatalinkTransmitHeaderSize()+this->getIpTransmitHeaderSize()+UdpDatagram::getHeaderSize(),
                         0,
                         data,
                         dataSize);

        // we'll need to wait for this buffer to go out

        _waitForThisBuffer=nb;
      }

      // set up the header

      UdpDatagram *header=reinterpret_cast<UdpDatagram *>(nb->moveWritePointerBack(UdpDatagram::getHeaderSize()));

      header->udp_sourcePort=NetUtil::htons(sourcePortNumber);
      header->udp_destinationPort=NetUtil::htons(destinationPortNumber);
      header->udp_checksum=0;         // will be calculated by the MAC
      header->udp_length=NetUtil::htons(dataSize+UdpDatagram::getHeaderSize());

      // send the datagram

      IpTransmitRequestEvent iptre(
                  nb,
                  ipaddress,
                  IpProtocol::UDP
                );

      this->NetworkSendEventSender.raiseEvent(iptre);

      // check that it was accepted for sending

      if(!iptre.succeeded)
        return false;

      // in sync mode we need to wait for the event raised by the datalink layer that indicates
      // the datagram has gone on to the wire

      if(!async) {

        uint32_t now;

        now=MillisecondTimer::millis();

        while(_waitForThisBuffer) {
          if(MillisecondTimer::hasTimedOut(now,transmitTimeout)) {
            _waitForThisBuffer=nullptr;
            return this->setError(ErrorProvider::ERROR_PROVIDER_NET_UDP,E_TIMED_OUT);
          }
        }
      }

      // succeeded

      return true;
    }


    /**
     * Receive a datagram synchronously. This method blocks until data is available or the
     * timeout is hit. Data from the received datagram is stored in 'buffer' up to a maximum
     * of 'size' bytes. The actual amount received is returned in 'size'. If more data is
     * available in the datagram then the method returns false and the error provider code
     * will be E_MSG_SIZE. true is returned if all the data in the datagram could be copied
     * into your 'buffer'
     * @param portNumber The port to wait for data on
     * @param buffer Where to store the data
     * @param[in,out] size The maximum number of bytes to store in 'buffer'. Modified on return
     *   to indicate the actual number of bytes stored.
     * @param receiveTimeout The number of ms to wait for a response. Specify zero to make this a blocking call.
     * @return true if it worked. false on error and also if the datagram was too big to fit in 'buffer'.
     */

    template<class TNetworkLayer>
    bool Udp<TNetworkLayer>::udpReceive(uint16_t portNumber,void *buffer,uint16_t& size,uint32_t receiveTimeout) {

      uint32_t start;

      // set the wait variables

      _awaitingPort=portNumber;
      _awaitingBuffer=buffer;
      _awaitingBufferSize=&size;
      _awaiting=true;

      // wait for something to happen

      start=MillisecondTimer::millis();

      while(_awaiting)
        if(receiveTimeout>0 && MillisecondTimer::hasTimedOut(start,receiveTimeout))
          return this->setError(ErrorProvider::ERROR_PROVIDER_NET_UDP,E_TIMED_OUT);

      // return the correct value

      return _awaitingDatagramSize>size ? this->setError(ErrorProvider::ERROR_PROVIDER_NET_UDP,E_MSG_SIZE) : true;
    }


    /**
     * Get a reference to the IP packet header belonging to the datagram that was last
     * received with the udpReceive() synchronous method. The reference returned by this method
     * is valid until the next call to udpReceive()
     * @return A reference to the IP packet header
     */

    template<class TNetworkLayer>
    const volatile IpPacketHeader& Udp<TNetworkLayer>::udpGetIpPacketHeader() const {
      return _ipPacketHeader;
    }


    /**
     * Convenience function to get the remote address (sender) of the last datagram to be
     * received by the udpReceive() synchronous method. The reference returned by this method
     * is valid until the next call to udpReceive()
     * @return A reference to the IP address
     */

    template<class TNetworkLayer>
    const volatile IpAddress& Udp<TNetworkLayer>::udpGetRemoteAddress() const {
      return _ipPacketHeader.ip_sourceAddress;
    }


    /**
     * Notification event notification from the stack
     * @param ned The network event descriptor
     */

    template<class TNetworkLayer>
    inline void Udp<TNetworkLayer>::onNotification(NetEventDescriptor& ned) {

      // we're interested in datalink frames going out when we're in a wait state

      if(_waitForThisBuffer==nullptr || ned.eventType!=NetEventDescriptor::NetEventType::DATALINK_FRAME_SENT)
        return;

      // if it's the buffer we're waiting for then clear it out (wakes up the sender)

      DatalinkFrameSentEvent& dfse(static_cast<DatalinkFrameSentEvent&>(ned));
      if(&dfse.netBuffer==_waitForThisBuffer)
        _waitForThisBuffer=nullptr;
    }
  }
}
// END FILE: ../lib/include/net/transport/udp/Udp.h
// START FILE: ../lib/include/net/transport/udp/UdpDatagram.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * UDP datagram structure. This structure may be cast directly on to an incoming
     * packet which of course means that 16 and 32 bit values are in
     * network byte order.
     */

    struct UdpDatagram {

      uint16_t udp_sourcePort;              ///< sender port number or zero if not used
      uint16_t udp_destinationPort;         ///< destination port number
      uint16_t udp_length;                  ///< overall length including this header
      uint16_t udp_checksum;                ///< checksum
      uint8_t udp_data[1];                  ///< user's data (may be zero but zero length arrays are not allowed)

      static uint32_t getHeaderSize() {
        return sizeof(UdpDatagram)-1;
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/transport/udp/UdpDatagram.h
// START FILE: ../lib/include/net/transport/udp/UdpDatagramEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for a UDP datagram arrival
     */

    struct UdpDatagramEvent : NetEventDescriptor {

      UdpDatagram& udpDatagram;             ///< the UDP datagram
      IpPacket& ipPacket;                   ///< the underlying IP packet

      bool handled;                         ///< set to true if this datagram was handled

      /**
       * Constructor
       * @param udp The UDP packet structure
       * @param ip The IP packet structure
       */

      UdpDatagramEvent(UdpDatagram& udp,IpPacket& ipp)
        : NetEventDescriptor(NetEventType::UDP_DATAGRAM),
          udpDatagram(udp),
          ipPacket(ipp),
          handled(false) {
      }
    };
  }
}
// END FILE: ../lib/include/net/transport/udp/UdpDatagramEvent.h
// START FILE: ../lib/include/net/transport/icmp/IcmpCode.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * ICMP code field
     */

    enum class IcmpCode : uint8_t {

      /// type = 0: echo reply

      ECHO_REPLY = 0,

      /// type = 3: destination unreachable

      DESTINATION_NETWORK_UNREACHABLE           = 0,
      DESTINATION_HOST_UNREACHABLE              = 1,
      DESTINATION_PROTOCOL_UNREACHABLE          = 2,
      DESTINATION_PORT_UNREACHABLE              = 3,
      FRAGMENTATION_REQUIRED                    = 4,
      SOURCE_ROUTE_FAILED                       = 5,
      DESTINATION_NETWORK_UNKNOWN               = 6,
      DESTINATION_HOST_UNKNOWN                  = 7,
      SOURCE_HOST_ISOLATED                      = 8,
      NETWORK_ADMINISTRATIVELY_PROHIBITED       = 9,
      HOST_ADMINISTRATIVELY_PROHIBITED          = 10,
      NETWORK_UNREACHABLE_FOR_TOS               = 11,
      HOST_UNREACHABLE_FOR_TOS                  = 12,
      COMMUNICATION_ADMINISTRATIVELY_PROHIBITED = 13,
      HOST_PRECEDENCE_VIOLATION                 = 14,
      PRECEDENCE_CUTOFF_IN_EFFECT               = 15,

      /// type = 4: source quench

      SOURCE_QUENCH = 0,

      /// type = 5: redirect message

      REDIRECT_DATAGRAM_FOR_THE_NETWORK         = 0,
      REDIRECT_DATAGRAM_FOR_THE_HOST            = 1,
      REDIRECT_DATAGRAM_FOR_THE_TOS_AND_NETWORK = 2,
      REDIRECT_DATAGRAM_FOR_THE_TOS_AND_HOST    = 3,

      /// type = 8: echo request

      ECHO_REQUEST = 0,

      /// type = 9: router advertisement

      ROUTER_ADVERTISEMENT = 0,

      /// type = 10: router solicitation

      ROUTER_SOLICITATION = 0,

      /// type = 11: time exceeded

      TTL_EXPIRED_IN_TRANSIT            = 0,
      FRAGMENT_REASSEMBLY_TIME_EXCEEDED = 1,

      /// type = 12: parameter problem (bad ip header)

      POINTER_INDICATES_ERROR = 0,
      MISSING_REQUIRED_OPTION = 1,
      BAD_LENGTH              = 2,

      /// type = 13: timestamp

      TIMESTAMP = 0,

      /// type = 14: timestamp reply

      TIMESTAMP_REPLY = 0,

      /// type = 15: information request

      INFORMATION_REQUEST = 0,

      /// type = 16: information reply

      INFORMATION_REPLY = 0,

      /// type = 17: address mask request

      ADDRESS_MASK_REQUEST = 0,

      /// type = 18: address mask reply

      ADDRESS_MASK_REPLY = 0,

      /// type = 30: traceroute

      TRACEROUTE_INFORMATION_REQUEST = 0
    };
  }
}
// END FILE: ../lib/include/net/transport/icmp/IcmpCode.h
// START FILE: ../lib/include/net/transport/icmp/IcmpErrorPacket.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Utility to create and initialise an ICMP error type
     * @param icmpCode The ICMP code corresponding to the error
     * @param ipPacket The IP packet that caused this error
     * @param[out] The size of the allocated packet
     * @return A pointer to the ICMP packet (free it with free() )
     */

    template<class T>
    T *createIcmpErrorPacket(IcmpCode icmpCode,const IpPacket& ipPacket,uint16_t& packetSize) {

      T *packet;
      uint16_t dataSize;

      // up to 8 bytes of the payload go back in an error packet

      dataSize=std::min(static_cast<uint16_t>(8),ipPacket.payloadLength);

      // allocate space for it

      packetSize=T::getHeaderSize()+ipPacket.headerLength+dataSize;
      packet=reinterpret_cast<T *>(malloc(packetSize));

      // initialise it

      packet->initialise(icmpCode);

      // copy the IP header and data fragment into place

      memcpy(reinterpret_cast<uint8_t *>(packet)+T::getHeaderSize(),
             ipPacket.header,
             ipPacket.headerLength+dataSize);

      // ready

      return packet;
    }
  }
}
// END FILE: ../lib/include/net/transport/icmp/IcmpErrorPacket.h
// START FILE: ../lib/include/net/transport/icmp/IcmpPacketEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for an ICMP packet arrival
     */

    struct IcmpPacketEvent : NetEventDescriptor {

      /**
       * The IP packet reference
       */

      IpPacket& ipPacket;


      /**
       * The ICMP packet data encapsulated in the above packet
       */

      IcmpPacket& icmpPacket;


      /**
       * Constructor
       * @param icmp The ICMP packet
       * @param ip The IP packet holding the ICMP packet
       */

      IcmpPacketEvent(IcmpPacket& icmp,IpPacket& ip)
        : NetEventDescriptor(NetEventType::ICMP_PACKET),
          ipPacket(ip),
          icmpPacket(icmp) {
      }
    };
  }
}
// END FILE: ../lib/include/net/transport/icmp/IcmpPacketEvent.h
// START FILE: ../lib/include/net/transport/icmp/Icmp.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * ICMPv4 protocol implementation. We support automatic response to echo-request
     * packets.
     */

    template<class TNetworkLayer>
    class Icmp : public virtual TNetworkLayer {

      public:

        /**
         * Parameters class
         */

        struct Parameters {
          bool icmp_enableEchoReply;      ///< true to respond to ping requests, default is true

          /**
           * Constructor: create default settings
           */

          Parameters() {
            icmp_enableEchoReply=true;
          }
        };

      protected:
        Parameters _params;

      protected:
        bool handleEchoReply(IcmpEchoRequest *echoRequest,IpPacket& ipPacket);
        void onReceive(IpPacketEvent& ned);
        void onSend(NetEventDescriptor& ned);

      public:
        bool initialise(const Parameters& params);
        bool startup();

        bool icmpSendEchoRequest(const IpAddress& ipaddress,
                                  uint16_t sequenceNumber,
                                  const uint8_t *data,
                                  uint32_t dataSize,
                                  uint8_t ttl=0);
    };


    /**
     * Initialise the class
     * @param params The parameters class
     * @return true if it worked
     */

    template<class TNetworkLayer>
    inline bool Icmp<TNetworkLayer>::initialise(const Parameters& params) {

      _params=params;

      // subscribe for receive events from the IP implementation

      this->IpReceiveEventSender.insertSubscriber(IpReceiveEventSourceSlot::bind(this,&Icmp<TNetworkLayer>::onReceive));

      // subscribe to send events from the stack

      this->NetworkSendEventSender.insertSubscriber(NetworkSendEventSourceSlot::bind(this,&Icmp<TNetworkLayer>::onSend));

      return true;
    }


    /**
     * Startup the class
     * @return true if it worked
     */

    template<class TNetworkLayer>
    inline bool Icmp<TNetworkLayer>::startup() {
      return true;
    }


    /**
     * Notification from our subscription to the network's send event
     * @param ned The event descriptor
     */

    template<class TNetworkLayer>
    inline void Icmp<TNetworkLayer>::onSend(NetEventDescriptor& ned) {

      NetBuffer *nb;

      // check the event type

      if(ned.eventType!=NetEventDescriptor::NetEventType::ICMP_TRANSMIT_REQUEST)
        return;

      IcmpTransmitRequestEvent& icmptre(static_cast<IcmpTransmitRequestEvent&>(ned));

      // create a net buffer for the packet

      nb=new NetBuffer(this->getDatalinkTransmitHeaderSize()+this->getIpTransmitHeaderSize(),
                       0,
                       &icmptre.packet,
                       icmptre.packetSize);

      // raise a transmit event for the IP layer to pick up


      IpTransmitRequestEvent iptre(
          nb,
          icmptre.destinationIpAddress,
          IpProtocol::ICMP);

      this->NetworkSendEventSender.raiseEvent(iptre);
      icmptre.succeeded=iptre.succeeded;
    }


    /**
     * Receive event notification from the stack
     * @param ipe The IP packet event
     */

    template<class TNetworkLayer>
    inline void Icmp<TNetworkLayer>::onReceive(IpPacketEvent& ipe) {

      IpPacket& ipPacket(ipe.ipPacket);

      // protocol/type of service == 1/0

      if(ipPacket.header->ip_hdr_protocol!=IpProtocol::ICMP || ipPacket.header->ip_hdr_typeOfService!=0)
        return;

      IcmpPacket *icmpPacket=reinterpret_cast<IcmpPacket *>(ipPacket.payload);

      // is it an echo request

      if(IcmpEchoRequest::isPacket(*icmpPacket)) {

        // are we supporting replies to echo (ping) requests?

        if(_params.icmp_enableEchoReply)
          handleEchoReply(reinterpret_cast<IcmpEchoRequest *>(icmpPacket),ipPacket);
      }

      // all packets are pushed up the stack in the form of events including the echo
      // request even though it may be in the process of having a reply packet pushed out

      this->NetworkReceiveEventSender.raiseEvent(IcmpPacketEvent(*icmpPacket,ipPacket));
    }


    /**
     * Handle the echo reply.
     * @param echoRequest The echo request coming in.
     */

    template<class TNetworkLayer>
    inline bool Icmp<TNetworkLayer>::handleEchoReply(IcmpEchoRequest *echoRequest,IpPacket& ipPacket) {

      NetBuffer *nb;
      uint32_t requestDataSize;

      // calculate the request data size

      requestDataSize=ipPacket.payloadLength-IcmpEchoRequest::getHeaderSize();

      // create a net buffer for the echo reply
      // replies are always coming from an incoming frame IRQ
      // cannot use the incoming request data in-place because it's going
      // to go out of scope before the frame is transmitted

      nb=new NetBuffer(this->getDatalinkTransmitHeaderSize()+this->getIpTransmitHeaderSize(),
                       IcmpEchoReply::getHeaderSize()+requestDataSize);

      // copy over the data from the request, if there was any - there doesn't have to be

      if(requestDataSize) {
        uint8_t *replyData=reinterpret_cast<uint8_t *>(nb->moveWritePointerBack(requestDataSize));
        memcpy(replyData,echoRequest->icmp_data,requestDataSize);
      }

      // move back to the location of the ICMP header and set it up

      IcmpEchoReply *reply=reinterpret_cast<IcmpEchoReply *>(nb->moveWritePointerBack(IcmpEchoReply::getHeaderSize()));
      reply->initialise();
      reply->icmp_identifier=echoRequest->icmp_identifier;
      reply->icmp_sequenceNumber=echoRequest->icmp_sequenceNumber;

      // raise a transmit event for the IP layer to pick up

      IpTransmitRequestEvent iptre(
          nb,
          ipPacket.header->ip_sourceAddress,
          IpProtocol::ICMP);

      this->NetworkSendEventSender.raiseEvent(iptre);
      return iptre.succeeded;
    }


    /**
     * Create and send an echo request to the given IP address.
     * @param ipaddress Where to send the echo request
     * @param data The data to send in the packet
     * @param dataSize The number of bytes to send
     * @param ttl TTL for the IP packet. Default of zero means use value from initialisation parameters.
     */

    template<class TNetworkLayer>
    inline bool Icmp<TNetworkLayer>::icmpSendEchoRequest(
            const IpAddress& ipaddress,
            uint16_t sequenceNumber,
            const uint8_t *data,
            uint32_t dataSize,
            uint8_t ttl) {

      NetBuffer *nb;
      uint32_t requestDataSize;

      // calculate the request data size

      requestDataSize=IcmpEchoRequest::getHeaderSize()+dataSize;

      // create a net buffer for the echo reply
      // replies are always coming from an incoming frame IRQ
      // cannot use the incoming request data in-place because it's going
      // to go out of scope before the frame is transmitted

      nb=new NetBuffer(this->getDatalinkTransmitHeaderSize()+this->getIpTransmitHeaderSize(),
                       requestDataSize,
                       nullptr);

      // copy over the data for the request

      uint8_t *requestData=reinterpret_cast<uint8_t *>(nb->moveWritePointerBack(dataSize));
      memcpy(requestData,data,dataSize);

      // move back to the location of the ICMP header and set it up

      IcmpEchoRequest *request=reinterpret_cast<IcmpEchoRequest *>(nb->moveWritePointerBack(IcmpEchoRequest::getHeaderSize()));
      request->initialise();
      request->icmp_identifier=0x55;        // constant to indicate we sent it
      request->icmp_sequenceNumber=NetUtil::htons(sequenceNumber);

      // raise a transmit event for the IP layer to pick up

      IpTransmitRequestEvent iptre(
          nb,
          ipaddress,
          IpProtocol::ICMP,
          ttl);

      this->NetworkSendEventSender.raiseEvent(iptre);
      return iptre.succeeded;
    }
  }
}
// END FILE: ../lib/include/net/transport/icmp/Icmp.h
// START FILE: ../lib/include/net/transport/icmp/IcmpType.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * ICMP type field
     */

    enum class IcmpType : uint8_t {

      ECHO_REPLY              = 0,
      DESTINATION_UNREACHABLE = 3,
      SOURCE_QUENCH           = 4,
      REDIRECT_MESSAGE        = 5,
      ECHO_REQUEST            = 8,
      ROUTER_ADVERTISEMENT    = 9,
      ROUTER_SOLICITATION     = 10,
      TIME_EXCEEDED           = 11,
      BAD_IP_HEADER           = 12,
      TIMESTAMP               = 13,
      TIMESTAMP_REPLY         = 14,
      INFORMATION_REQUEST     = 15,
      INFORMATION_REPLY       = 16,
      ADDRESS_MASK_REQUEST    = 17,
      ADDRESS_MASK_REPLY      = 18,
      TRACEROUTE              = 30
    };
  }
}
// END FILE: ../lib/include/net/transport/icmp/IcmpType.h
// START FILE: ../lib/include/net/transport/icmp/IcmpPacket.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Packet definition for ICMP v4. This structure can be cast directly on to the
     * payload of an incoming IpPacket.
     */

    struct IcmpPacket {
      IcmpType icmp_type;             // uint8_t
      IcmpCode icmp_code;             // uint8_t
      uint16_t icmp_checksum;

    } __attribute__((packed));


    /**
     * Echo reply structure (0/0)
     */

    struct IcmpEchoReply : IcmpPacket {

      uint16_t icmp_identifier;
      uint16_t icmp_sequenceNumber;
      uint8_t icmp_data[1];

      void initialise() {
        icmp_type=IcmpType::ECHO_REPLY;
        icmp_code=IcmpCode::ECHO_REPLY;
        icmp_checksum=0;
      }

      static uint32_t getHeaderSize() {
        return sizeof(IcmpEchoReply)-1;
      }
    } __attribute__((packed));


    /**
     * Echo request packet definition (8/0)
     */

    struct IcmpEchoRequest : IcmpPacket {

      uint16_t icmp_identifier;
      uint16_t icmp_sequenceNumber;
      uint8_t icmp_data[1];

      void initialise() {
        icmp_type=IcmpType::ECHO_REQUEST;
        icmp_code=IcmpCode::ECHO_REQUEST;
        icmp_checksum=0;
      }

      static uint32_t getHeaderSize() {
        return sizeof(IcmpEchoRequest)-1;
      }

      static bool isPacket(IcmpPacket& icmpPacket) {
        return icmpPacket.icmp_type==IcmpType::ECHO_REQUEST && icmpPacket.icmp_code==IcmpCode::ECHO_REQUEST;
      }
    } __attribute__((packed));


    /**
     * Destination unreachable (3/X)
     */

    struct IcmpDestinationUnreachable : IcmpPacket {

      uint16_t icmp_unused;
      uint16_t icmp_nextHopMtu;

      void initialise(IcmpCode code) {
        icmp_type=IcmpType::DESTINATION_UNREACHABLE;
        icmp_code=code;
        icmp_checksum=0;
        icmp_unused=icmp_nextHopMtu=0;
      }

      static uint32_t getHeaderSize() {
        return sizeof(IcmpDestinationUnreachable);
      }

      static bool isPacket(IcmpPacket& icmpPacket) {
        return icmpPacket.icmp_type==IcmpType::DESTINATION_UNREACHABLE;
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/transport/icmp/IcmpPacket.h
// START FILE: ../lib/include/net/transport/icmp/IcmpTransmitRequestEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Transmit request event to the ICMP module
     */

    struct IcmpTransmitRequestEvent  : NetEventDescriptor {

      const IcmpPacket& packet;                   ///< the ICMP packet structure (and data following)
      uint16_t packetSize;                        ///< total size of the packet and any following data
      const IpAddress& destinationIpAddress;      ///< destination IP address (will be copied out)
      uint8_t ttl;                                ///< The ttl if to be overriden
      bool succeeded;                             ///< true if the transmit succeeded

      /**
       * Constructor
       * @param pkt The packet to send
       * @param pktSize The total packet size include data
       * @param address The destination address
       * @param overrideTtl The TTL for the packet if it is to be overridden. The default of zero means
       *   use the value configured in the initialisation parameters.
       */

      IcmpTransmitRequestEvent(const IcmpPacket& pkt,
                                uint16_t pktSize,
                                const IpAddress& address,
                                uint8_t overrideTtl=0)
        : NetEventDescriptor(NetEventType::ICMP_TRANSMIT_REQUEST),
          packet(pkt),
          packetSize(pktSize),
          destinationIpAddress(address),
          ttl(overrideTtl),
          succeeded(false) {
      }
    };
  }
}
// END FILE: ../lib/include/net/transport/icmp/IcmpTransmitRequestEvent.h
// START FILE: ../lib/include/net/transport/tcp/TcpOptions.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * All the options we care about
     */

    enum class TcpOptionKind : uint8_t {
      END_OF_OPTIONS       = 0x00,                      ///< no more options in the header
      NOP                  = 0x01,                      ///< padding option
      MAXIMUM_SEGMENT_SIZE = 0x02                       ///< MSS
    };


    /**
     * Global operator == for comparison against uint8_t
     * @param lhs
     * @param rhs
     * @return
     */

    inline bool operator==(uint8_t lhs,TcpOptionKind rhs) {
      return lhs==static_cast<uint8_t>(rhs);
    }


    /**
     * Base structure for the header options
     */

    struct TcpOption {

      TcpOptionKind tcp_optionKind;

      void initialise(TcpOptionKind optionKind) {
        tcp_optionKind=optionKind;
      }
    } __attribute__((packed));


    /**
     * Base structure for a header option with length
     */

    struct TcpVariableLengthOption : TcpOption {

      uint8_t tcp_optionLength;

      void initialise(TcpOptionKind optionKind,uint8_t length) {
        TcpOption::initialise(optionKind);
        tcp_optionLength=length;
      }
    } __attribute__((packed));


    /**
     * End of options
     */

    struct TcpOptionEndOfOptions : TcpOption {
      void initialise() {
        TcpOption::initialise(TcpOptionKind::END_OF_OPTIONS);
      }
    } __attribute__((packed));


    /**
     * no-operation
     */

    struct TcpOptionNop : TcpOption {
      void initialise() {
        TcpOption::initialise(TcpOptionKind::NOP);
      }
    } __attribute__((packed));


    /**
     * MSS
     */

    struct TcpOptionMaximumSegmentSize : TcpVariableLengthOption {

      uint16_t tcp_optionMss;

      void initialise(uint16_t mss) {
        TcpVariableLengthOption::initialise(TcpOptionKind::MAXIMUM_SEGMENT_SIZE,4);
        tcp_optionMss=NetUtil::htons(mss);
      }

      constexpr static uint16_t getSize() {
        return 4;
      }

      constexpr static TcpOptionKind getOptionKind() {
        return TcpOptionKind::MAXIMUM_SEGMENT_SIZE;
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpOptions.h
// START FILE: ../lib/include/net/transport/tcp/TcpReceiveBuffer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Simple wrapper for the circular buffer used for received data that ensures
     * IRQ-safe access to the methods.
     */

    class TcpReceiveBuffer {

      protected:
        volatile circular_buffer<uint8_t> _receiveBuffer;

      public:
        TcpReceiveBuffer(uint32_t size);

        void read(uint8_t *output,uint32_t size) volatile;
        void write(const uint8_t *input,uint32_t size) volatile;

        uint32_t availableToWrite() const volatile;
        uint32_t availableToRead() const volatile;
    };


    /**
     * Constructor
     * @param size the buffer size
     */

    inline TcpReceiveBuffer::TcpReceiveBuffer(uint32_t size)
      : _receiveBuffer(size) {
    }

    inline void TcpReceiveBuffer::read(uint8_t *output,uint32_t size) volatile {
      IrqSuspend suspender;
      _receiveBuffer.read(output,size);
    }


    inline void TcpReceiveBuffer::write(const uint8_t *input,uint32_t size) volatile {
      IrqSuspend suspender;
      _receiveBuffer.write(input,size);
    }

    inline uint32_t TcpReceiveBuffer::availableToWrite() const volatile {
      IrqSuspend suspend;
      return _receiveBuffer.availableToWrite();
    }

    inline uint32_t TcpReceiveBuffer::availableToRead() const volatile {
      IrqSuspend suspend;
      return _receiveBuffer.availableToRead();
    }
  }
}

// END FILE: ../lib/include/net/transport/tcp/TcpReceiveBuffer.h
// START FILE: ../lib/include/net/transport/tcp/TcpServer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Class to manage a listening TCP server. Each TCP server has a port on which
     * it listens for incoming connections. When a remote client attempts a SYN with the
     * server we create a connection object to handle the interaction and leave it to
     * handle the state machine.
     *
     * Unlike the common berkeley sockets implementation there is no concept of a 'listen'
     * backlog because the API is entirely event based. The server is created in an unstarted
     * state. The user should subscribe to accept events and then call start().
     *
     * @tparam TConnection The user's derivation of the library-supplied connection class.
     * @tparam TUser optional type of a pointer that the user would like to be passed to the connection constructor.
     */

    template<class TConnection,class TUser=void>
    class TcpServer : public TcpServerBase {

      protected:
        TUser *_userptr;                                            // connection constructor may take optional typed user parameter
        const typename TConnection::Parameters _connectionParams;   // connection parameters are shared between instances

      protected:
        void onReceive(TcpSegmentEvent&);

      public:
        TcpServer(uint16_t listeningPort,
                  NetworkUtilityObjects& networkUtilityObjects,
                  TcpEvents& tcpEvents,
                  const Parameters& params,
                  uint16_t segmentSizeLimit,
                  uint16_t additionalHeaderSize,
                  TUser *userptr);

        ~TcpServer();
    };


    /**
     * Create a connection type by calling the correct constructor without forcing
     * the user to declare the 'other' constructor
     */

    namespace {

      /**
       * This instance creates a connection class where the user wants to pass in a
       * user-defined parameter
       */

      template<class TConnection,class TUser>
      struct ConnectionCreator {
        static TConnection *createConnection(const typename TConnection::Parameters& params,TUser *userptr) {
          return new TConnection(params,userptr);
        }
      };


      /**
       * This instance is a specialisation that calls the default constructor when the
       * user does not want to pass in a user defined parameter
       */

      template<class TConnection>
      struct ConnectionCreator<TConnection,void> {
        static TConnection *createConnection(const typename TConnection::Parameters& params,void *) {
          return new TConnection(params);
        }
      };
    }

    /**
     * Constructor
     * @param listeningPort the port number to listen on
     */

    template<class TConnection,class TUser>
    inline TcpServer<TConnection,TUser>::TcpServer(uint16_t listeningPort,
                                             NetworkUtilityObjects& networkUtilityObjects,
                                             TcpEvents& tcpEvents,
                                             const Parameters& params,
                                             uint16_t segmentSizeLimit,
                                             uint16_t additionalHeaderSize,
                                             TUser *userptr)
      : TcpServerBase(listeningPort,
                      networkUtilityObjects,
                      tcpEvents,
                      params,
                      segmentSizeLimit,
                      additionalHeaderSize),
        _userptr(userptr) {

      // subscribe to receive events

      _tcpEvents.TcpReceiveEventSender.insertSubscriber(TcpReceiveEventSourceSlot::bind(this,&TcpServer::onReceive));
    }


    /**
     * Send a notification that this server is being released
     */

    template<class TConnection,class TUser>
    inline TcpServer<TConnection,TUser>::~TcpServer() {

      // unsubscribe from receive events

      _tcpEvents.TcpReceiveEventSender.removeSubscriber(TcpReceiveEventSourceSlot::bind(this,&TcpServer::onReceive));

      // raise the event that we're going away

      _networkUtilityObjects.NetworkNotificationEventSender.raiseEvent(TcpServerReleasedEvent(*this));
    }


    /**
     * Network receive event
     * @param ned The event descriptor
     */

    template<class TConnection,class TUser>
    inline void TcpServer<TConnection,TUser>::onReceive(TcpSegmentEvent& event) {

      // we are only interested in segments sent to our port

      if(event.destinationPort!=_listeningPort)
        return;

      // we are only interested in segments that have the SYN flag set (but no ACK)

      if(!(event.tcpHeader.hasSyn() && !event.tcpHeader.hasAck()))
        return;

      // this event is handled here

      event.handled=true;

      // we are doing nothing unless we are started

      if(!_started)
        return;

      // if an existing connection already has this source/dest port combo then this
      // segment is a retransmit and we're going to drop it

      TcpFindConnectionNotificationEvent findconn(event.ipPacket.header->ip_sourceAddress,event.sourcePort,event.destinationPort);
      _networkUtilityObjects.NetworkNotificationEventSender.raiseEvent(findconn);

      // if there's a connection, return now as we have a dupe SYN

      if(findconn.tcpConnection!=nullptr)
        return;

      // if we've hit the maximum number of connections then we have to ignore it

      if(_connectionCount==_params.tcp_maxConnectionsPerServer)
        return;

      // new connection to record

      _connectionCount++;

      // create a new TcpConnection to handle the interaction
      // there is 2 phase construction here so that the user's derivation of TcpConnection does
      // not have to be aware of the objects required by the base class

      TConnection *connection=ConnectionCreator<TConnection,TUser>::createConnection(_connectionParams,_userptr);

      if(!connection->initialise(
            _networkUtilityObjects,
            _tcpEvents,
            event,
            _segmentSizeLimit,
            _additionalHeaderSize)) {

        delete connection;
        return;
      }

      // send a notification event so the caller can claim the connection

      TcpAcceptEvent acceptEvent(*this,connection);
      TcpAcceptEventSender.raiseEvent(acceptEvent);

      // if the caller does not want this connection then we delete it

      if(!acceptEvent.accepted)
        delete connection;
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpServer.h
// START FILE: ../lib/include/net/transport/tcp/TcpSegmentEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event that is sent when a TCP segment is received from the IP module
     */

    struct TcpSegmentEvent : NetEventDescriptor {

      IpPacket& ipPacket;               ///< the original IP packet
      TcpHeader& tcpHeader;             ///< the TCP header structure
      uint8_t *payload;                   ///< pointer to the payload
      uint16_t payloadLength;             ///< the size of the payload
      uint16_t sourcePort;                ///< taken from the header and converted to host order
      uint16_t destinationPort;           ///< taken from the header and converted to host order
      bool handled;                       ///< set if any connection or server recognises this segment

      TcpSegmentEvent(IpPacket& packet,TcpHeader& header,uint8_t *data,uint16_t datalen,uint16_t sPort,uint16_t dPort)
        : NetEventDescriptor(NetEventType::TCP_SEGMENT),
          ipPacket(packet),
          tcpHeader(header),
          payload(data),
          payloadLength(datalen),
          sourcePort(sPort),
          destinationPort(dPort),
          handled(false) {
      }
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpSegmentEvent.h
// START FILE: ../lib/include/net/transport/tcp/TcpInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * @brief An input stream for reading from a TCP connection. The stream is unbuffered.
     */

    class TcpInputStream : public InputStream {

      protected:
        TcpConnection& _conn;

      public:
        TcpInputStream(TcpConnection& conn);

        // overrides from InputStream

        virtual int16_t read() override;
        virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
        virtual bool skip(uint32_t howMuch) override;
        virtual bool available() override;
        virtual bool reset() override;
        virtual bool close() override;
    };


    /**
     * Constructor
     * @param conn The connection to read from
     */

    inline TcpInputStream::TcpInputStream(TcpConnection& conn)
      : _conn(conn) {
    }


    /**
     * Read a single byte
     * @return the byte, E_STREAM_ERROR or E_END_OF_STREAM
     */

    inline int16_t TcpInputStream::read() {

      uint8_t c;
      uint32_t actuallyRead;

      if(!read(&c,1,actuallyRead))
        return E_STREAM_ERROR;

      if(actuallyRead==1)
        return c;

      return E_END_OF_STREAM;
    }


    /**
     * Read a block of bytes. This call will block until some bytes are available.
     * @param buffer Where to read out to
     * @param size The maximum number to read
     * @param actuallyRead How many were read
     * @return true if some bytes were read. Zero bytes are a success condition that indicate the end of the stream
     */

    inline bool TcpInputStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {
      return _conn.receive(buffer,size,actuallyRead);
    }


    /**
     * Cannot skip
     * @return false
     */

    inline bool TcpInputStream::skip(uint32_t /* howMuch */) {
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_TCP_INPUT_STREAM,E_OPERATION_NOT_SUPPORTED);
    }


    /**
     * Check if there are byte(s) available for immediate consumption
     * @return true if bytes are available
     */

    inline bool TcpInputStream::available() {
      return _conn.getDataAvailable()>0;
    }


    /**
     * Cannot reset to start
     * @return false
     */

    inline bool TcpInputStream::reset() {
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_TCP_INPUT_STREAM,E_OPERATION_NOT_SUPPORTED);
    }


    /**
     * Cannot close, but it's not an error either. The underlying connection must be
     * deleted to close the connection
     * @return true
     */

    inline bool TcpInputStream::close() {
      return true;
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpInputStream.h
// START FILE: ../lib/include/net/transport/tcp/TcpAcceptEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * TCP connection accept event
     */

    class TcpServerBase;

    struct TcpAcceptEvent : NetEventDescriptor {

      TcpServerBase& server;              ///< server that raised this event
      TcpConnection *connection;          ///< new connection reference
      bool accepted;


      /**
       * Constructor
       * @param s The server that's accepting this connection
       * @param c The connection to potentially accept
       */

      TcpAcceptEvent(TcpServerBase&s,TcpConnection *c)
        : NetEventDescriptor(NetEventDescriptor::NetEventType::TCP_ACCEPT),
          server(s),
          connection(c),
          accepted(false) {
      }


      /**
       * The client MUST call this to accept the connection. If not then the server
       * will delete the connection.
       * @return the connection
       */

      TcpConnection *acceptConnection() {
        accepted=true;
        return connection;
      }
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpAcceptEvent.h
// START FILE: ../lib/include/net/transport/tcp/TcpReceiveWindow.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * The sliding receive window. This class manages the following variables.
     *
     *          |<      receiveWindow       >   |
     * +---------------------------------------------
     * |        |                               |
     * +---------------------------------------------
     *          ^
     *     receiveNext
     */

    struct TcpReceiveWindow {
      uint32_t receiveNext;           ///< seq num of next byte expected to arrive
      uint16_t receiveWindow;         ///< the number of bytes that we are currently prepared to receive
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpReceiveWindow.h
// START FILE: ../lib/include/net/transport/tcp/TcpConnectionClosedEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * TCP connection closed event. This event signifies that the remote end has closed and will
     * not be sending any more data. It is legal to send data to the remote end in this state but
     * most likely you'll want to delete your TcpConnection object, thereby closing your end and
     * cleaning up.
     */

    class TcpConnection;

    struct TcpConnectionClosedEvent : NetEventDescriptor {

      /**
       * Reference to the TCP connection object.
       */

      TcpConnection& connection;


      /**
       * Constructor
       * @param The connection reference
       */

      TcpConnectionClosedEvent(TcpConnection& c)
        : NetEventDescriptor(NetEventDescriptor::NetEventType::TCP_CONNECTION_CLOSED),
          connection(c) {
      }
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpConnectionClosedEvent.h
// START FILE: ../lib/include/net/transport/tcp/TcpEvents.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Base class for Tcp that declares the events. Lifting this up gets us out of the trap
     * of circular dependencies.
     */

    DECLARE_EVENT_SIGNATURE(TcpReceive,void (TcpSegmentEvent&));

    struct TcpEvents {
      DECLARE_EVENT_SOURCE(TcpReceive);
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpEvents.h
// START FILE: ../lib/include/net/transport/tcp/TcpClosingConnectionState.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Extend the state to include a time field for when we give
     * up and clean up this connection
     */

    struct TcpClosingConnectionState : TcpConnectionState {

      /**
       * The tick time when we will expire this entry due to receiving nothing
       * from the other end (2 * msl)
       */

      uint32_t cleanupTime;


      /**
       * Construct from an existing remote state
       * @param rstate
       */

      TcpClosingConnectionState(const TcpConnectionState& rstate,uint32_t ctime) {
        *static_cast<TcpConnectionState *>(this)=rstate;
        cleanupTime=ctime;
      }


      /**
       * Default constructor
       */

      TcpClosingConnectionState() {
      }


      /**
       * Copy constructor
       * @param src where to copy from
       */

      TcpClosingConnectionState(const TcpClosingConnectionState& src) {
        TcpConnectionState::operator=(src);
        cleanupTime=src.cleanupTime;
      }


      /**
       * Check if this event matches this remote state
       * @param event The event to check
       * @return true if it matches
       */

      bool matches(TcpSegmentEvent& event) const {

        return event.ipPacket.header->ip_sourceAddress==remoteAddress &&
               localPort==event.destinationPort &&
               remotePort==event.sourcePort;
      }
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpClosingConnectionState.h
// START FILE: ../lib/include/net/transport/tcp/TcpHeaderFlags.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Options found in the TCP header. These values are adjusted for network byte order
     * and are designed to be set into and compared against TCP segment header options
     */

    enum class TcpHeaderFlags : uint16_t {
      FIN = 0x0100,               // closing
      SYN = 0x0200,               // syncing
      RST = 0x0400,               // aborting
      PSH = 0x0800,               // push immediate
      ACK = 0x1000,               // acknowledge included
      URG = 0x2000,               // urgent
      ECE = 0x4000,               // ECN echo
      CWR = 0x8000                // congestion window reduced
    };


    /**
     * Global | operator for flag combining
     * @param lhs flag 1
     * @param rhs flag 2
     * @return result
     */

    inline TcpHeaderFlags operator|(TcpHeaderFlags lhs,TcpHeaderFlags rhs) {
      return static_cast<TcpHeaderFlags>(
          static_cast<uint16_t>(lhs) | static_cast<uint16_t>(rhs)
        );
    }


    /**
     * Global & operator for flag selection
     * @param lhs flag 1
     * @param rhs flag 2
     * @return The selection
     */

    inline TcpHeaderFlags operator&(TcpHeaderFlags lhs,TcpHeaderFlags rhs) {
      return static_cast<TcpHeaderFlags>(
          static_cast<uint16_t>(lhs) & static_cast<uint16_t>(rhs)
        );
    }


    /**
     * Global & operator for flag selection
     * @param lhs flag 1
     * @param rhs flag 2
     * @return The selection
     */

    inline uint16_t operator&(uint16_t lhs,TcpHeaderFlags rhs) {
      return lhs & static_cast<uint16_t>(rhs);
    }


    /**
     * Global equality operator
     * @param lhs flag1
     * @param rhs comparison
     * @return true if equal
     */

    inline bool operator==(TcpHeaderFlags lhs,uint16_t rhs) {
      return static_cast<uint16_t>(lhs)==rhs;
    }


    /**
     * Global inequality operator
     * @param lhs flag1
     * @param rhs comparison
     * @return true if not-equal
     */

    inline bool operator!=(TcpHeaderFlags lhs,uint16_t rhs) {
      return static_cast<uint16_t>(lhs)!=rhs;
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpHeaderFlags.h
// START FILE: ../lib/include/net/transport/tcp/TcpWaitState.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

namespace stm32plus {
  namespace net {


    /**
     * Possible connection states that you can ask a connection array
     * to wait for.
     */

    enum class TcpWaitState : uint8_t {
      NONE     = 0,         ///< nothing (used in comparisons)
      READ     = 0x1,       ///< ready to read (rx buffer has data)
      WRITE    = 0x2,       ///< ready to tx (ESTABLISHED and remote window>0)
      CLOSED   = 0x4,       ///< closed or reset (either end)
      CALLBACK = 0x8        ///< implement handleCallback() to get a round-robin callback regardless of connection state
    };


    /**
     * Global & operator
     */

    inline TcpWaitState operator&(TcpWaitState rhs,TcpWaitState lhs) {
      return static_cast<TcpWaitState>(static_cast<uint8_t>(rhs) & static_cast<uint8_t>(lhs));
    }


    /**
     * Global | operator
     */

    inline TcpWaitState operator|(TcpWaitState rhs,TcpWaitState lhs) {
      return static_cast<TcpWaitState>(static_cast<uint8_t>(rhs) | static_cast<uint8_t>(lhs));
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpWaitState.h
// START FILE: ../lib/include/net/transport/tcp/TcpConnection.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Class to represent the lifecycle of a TCP connection. This is a base class and
     * will not be created directly. Users derive from this to implement the I/O functionality
     * they need for their connection.
     */

    DECLARE_EVENT_SIGNATURE(TcpConnectionClosed,void (TcpConnectionClosedEvent&));
    DECLARE_EVENT_SIGNATURE(TcpConnectionDataReady,void (TcpConnectionDataReadyEvent&));

    class TcpConnection {

      public:

      /**
       * Error codes
       */

      enum {
        E_TIMED_OUT = 1,
        E_INVALID_STATE,        ///< you tried to do something when the connection is not in a state that would allow it
        E_CONNECTION_RESET      ///< connection was closed while we were sending data
      };


      /**
       * Parameters class
       */

      struct Parameters {

        uint16_t tcp_receiveBufferSize;     ///< per-connection receive buffer size. Default is 256 bytes.
        uint32_t tcp_initialResendDelay;    ///< first delay to resend an un-acked segment. Default is 4 seconds.
        uint32_t tcp_maxResendDelay;        ///< the resend delay exponential backoff is capped at this value. default is 60 (1 minute)
        bool tcp_push;                      ///< if true, set the PSH flag in sent segments. Default is false.
        bool tcp_nagleAvoidance;            ///< if true, single packet sends are broken into 2 to force the receiver's Nagle algorithm to generate an ACK without delay. Default is true.

        /**
         * Constructor
         */

        Parameters() {
          tcp_receiveBufferSize=256;
          tcp_maxResendDelay=60000;
          tcp_initialResendDelay=4000;
          tcp_nagleAvoidance=true;
          tcp_push=false;
        }
      };

      protected:
        NetworkUtilityObjects *_networkUtilityObjects;
        TcpEvents *_tcpEvents;

        TcpReceiveBuffer *_receiveBuffer;
        uint16_t _remoteMss;
        uint16_t _segmentSizeLimit;
        uint16_t _additionalHeaderSize;
        uint32_t _lastZeroWindowPollTime;
        uint32_t _zeroWindowPollDelay;
        uint32_t _lastActiveTime;                   // from the millisecond timer
        TcpConnectionState _state;
        const Parameters& _params;
        bool _receiveWindowIsClosed;

      protected:
        void onNotification(NetEventDescriptor& ned);
        void onReceive(TcpSegmentEvent& event);

        void handleIncomingSynAck(const TcpHeader& header);
        void handleIncomingAck(const TcpHeader& header,bool hasData);
        void handleIncomingFin(TcpSegmentEvent& event);
        void handleIncomingRst();
        void handleIncomingData(const TcpSegmentEvent& event);

        void initialise(const IpAddress& remoteAddress,uint16_t remotePort,uint16_t localPort);
        void handleFindConnectionEvent(TcpFindConnectionNotificationEvent& tfcne);

        bool sendSynAck();

        uint16_t getReceiveBufferSpaceAvailable() const;
        uint16_t sillyWindowAvoidance();
        bool receiveWindowCanBeOpened() const;

      public:
        TcpConnection(const Parameters& params);
        ~TcpConnection();

        bool sendSyn();

        bool initialise(NetworkUtilityObjects& networkUtilityObjects,
                        TcpEvents& tcpEvents,
                        TcpSegmentEvent& segmentEvent,
                        uint16_t segmentSizeLimit,
                        uint16_t additionalHeaderSize);

        bool initialise(NetworkUtilityObjects& networkUtilityObjects,
                        TcpEvents& tcpEvents,
                        const IpAddress& remoteAddress,
                        uint16_t localPort,
                        uint16_t remotePort,
                        uint16_t segmentSizeLimit,
                        uint16_t additionalHeaderSize);

        uint16_t getLocalPort() const;
        const IpAddress& getRemoteAddress() const;
        const TcpConnectionState& getConnectionState() const;

        bool receive(void *data,uint32_t dataSize,uint32_t& actuallyReceived,uint32_t timeoutMillis=0);
        bool send(const void *data,uint32_t dataSize,uint32_t& actuallySent,uint32_t timeoutMillis=0);
        bool abort();

        bool isRemoteEndClosed() const;
        bool isLocalEndClosed() const;
        bool waitForStateChange(TcpState oldState,uint32_t timeoutMillis) const;

        uint16_t getTransmitWindowSize() const;
        uint16_t getDataAvailable() const;

        uint32_t getLastActiveTime() const;

        DECLARE_EVENT_SOURCE(TcpConnectionClosed);
        DECLARE_EVENT_SOURCE(TcpConnectionDataReady);
    };


    /**
     * Constructor. This actual instance referenced by 'params' lives either in the TcpServer instance
     * for TCP servers or in the TcpClientConnection instance for clients. For servers this saves memory
     * because there will be only ever one parameters instance shared between all the connections created
     * by the server.
     *
     * For servers, in your derivation of TcpConnection you can also derive a Parameters class from
     * TcpConnection::Parameters and the server will automagically use that and it will be passed to your
     * constructor. See the net_web_server example for an example where I use this method to tweak some
     * of the TcpConnection parameters.
     *
     * @param reference to the parameters class that we'll use
     */

    inline TcpConnection::TcpConnection(const Parameters& params)
      : _params(params) {
    }


    /**
     * Handle an event that's searching for a connection
     * @param tfcne The event descriptor
     */

    inline void TcpConnection::handleFindConnectionEvent(TcpFindConnectionNotificationEvent& tfcne) {

      if(tfcne.localPort==_state.localPort &&
         tfcne.remotePort==_state.remotePort &&
         tfcne.remoteAddress==_state.remoteAddress)
        tfcne.tcpConnection=this;
    }


    /**
     * Get the local port
     * @return the local port number
     */

    inline uint16_t TcpConnection::getLocalPort() const {
      return _state.localPort;
    }


    /**
     * Get the connection state object
     * @return A reference to the remote state
     */

    inline const TcpConnectionState& TcpConnection::getConnectionState() const {
      return _state;
    }


    /**
     * Wait for the state to move from the given last-known-state
     * @param oldState the state we think it's currently at
     * @param timeout, in millis, or zero to block
     */

    inline bool TcpConnection::waitForStateChange(TcpState oldState,uint32_t timeoutMillis) const {

      uint32_t now;

      now=MillisecondTimer::millis();

      while(_state.state==oldState)
        if(timeoutMillis && MillisecondTimer::hasTimedOut(now,timeoutMillis))
          return _networkUtilityObjects->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP_CONNECTION,E_TIMED_OUT);

      return true;
    }


    /**
     * Return true if the remote end has closed its port. True here means that
     * the remote end will not send any more data
     * @return true if it has closed
     */

    inline bool TcpConnection::isRemoteEndClosed() const {
      return _state.state==TcpState::CLOSE_WAIT ||
             _state.state==TcpState::LAST_ACK ||
             _state.state==TcpState::CLOSING ||
             _state.state==TcpState::TIME_WAIT;
    }


    /**
     * Return true if the local end has closed its port. Closed here means
     * that no more data can be accepted for sending
     * @return true if it has closed
     */

    inline bool TcpConnection::isLocalEndClosed() const {
      return _state.state==TcpState::FIN_WAIT_1 ||
             _state.state==TcpState::FIN_WAIT_2 ||
             _state.state==TcpState::CLOSING ||
             _state.state==TcpState::TIME_WAIT ||
             _state.state==TcpState::LAST_ACK ||
             _state.state==TcpState::CLOSED;
    }


    /**
     * Get the size of the transmit window. The transmit window is the maximum number of bytes that can
     * be send to the other side without blocking. The caller can poll for this being non-zero as an indicator
     * that the remote end is ready to receive data. The actual non-zero size may not be particularly useful
     * because the remote end can continually change its window size with each segment acknowledgement.
     * @return The transmit window size
     */

    inline uint16_t TcpConnection::getTransmitWindowSize() const {
      return _state.txWindow.sendWindow;
    }


    /**
     * Get the amount of data available for reading without blocking. The maximum
     * amount that can ever be returned by this function is the value that you specified in the
     * tcp_receiveBufferSize configuration parameter.
     */

    inline uint16_t TcpConnection::getDataAvailable() const {
      return _receiveBuffer->availableToRead();
    }


    /**
     * Try to abort this connection by sending an RST to the other end.
     * @return true if it was in an abortable state and an RST has been sent
     */

    inline bool TcpConnection::abort() {

      switch(_state.state) {

        case TcpState::SYN_RCVD:
        case TcpState::SYN_SENT:
        case TcpState::ESTABLISHED:
          _state.sendRstAck(*_networkUtilityObjects,0);
          return true;

        default:
          return _networkUtilityObjects->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP_CONNECTION,E_INVALID_STATE);
      }
    }


    /**
     * Get the amount of write space available in the receive buffer
     * @return The amount of space
     */

    inline uint16_t TcpConnection::getReceiveBufferSpaceAvailable() const {
      return _receiveBuffer->availableToWrite();
    }


    /**
     * Get the remote IP address
     * @return The IP address
     */

    inline const IpAddress& TcpConnection::getRemoteAddress() const {
      return _state.remoteAddress;
    }


    /**
     * Get the last active time in millis for this connection. The 'active time' is the last
     * time that send() was called or the last time that a data-carrying segment arrived.
     * @return The last time in millis.
     */

    inline uint32_t TcpConnection::getLastActiveTime() const {
      return _lastActiveTime;
    }


    /**
     * Return true if the receive window advertised in an ACK can be opened
     * @return true if the current receive window can be advertised
     */

    inline bool TcpConnection::receiveWindowCanBeOpened() const {
      return _state.rxWindow.receiveWindow>=std::min(_params.tcp_receiveBufferSize/2,(int)_segmentSizeLimit);
    }


    /**
     * Handle a RST coming from the other side.
     * Change the state to CLOSED
     */

    inline void TcpConnection::handleIncomingRst() {

      // the connection has gone bad

      _state.changeState(*_networkUtilityObjects,TcpState::CLOSED);

      // notify

      TcpConnectionClosedEventSender.raiseEvent(TcpConnectionClosedEvent(*this));
    }


    /**
     * Return an appropriate window size for an ACK based on Clarke's simple algorithm
     * for avoiding silly window syndrome.
     *
     * If the current real window is less than the lesser of half the buffer size and 1 segment
     * then we close the window, otherwise we advertise a real window size
     *
     * This is IRQ code.
     *
     * @return The window size.
     */

    inline uint16_t TcpConnection::sillyWindowAvoidance() {

      if(receiveWindowCanBeOpened()) {
        _receiveWindowIsClosed=false;
        return _state.rxWindow.receiveWindow;
      }

      _receiveWindowIsClosed=true;
      return 0;
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpConnection.h
// START FILE: ../lib/include/net/transport/tcp/TcpConnectionArray.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Class to manage a statically sized array of connections. Typically a TCP server
     * would use this to keep track of activity from its clients. The connection array
     * would be sized to be equal to the configured maximum number of connections that
     * the server has been configured to simultaneously accept.
     *
     * The memory required for an instance of this class is sizeof(TcpConnectionArray)
     * plus 4*connection-count
     */

    template<class TConnection>
    class TcpConnectionArray {

      public:

        /**
         * Possible error codes
         */

        enum {
          E_FULL = 1,             ///< no more slots available
          E_NOT_FOUND,            ///< connection not found
          E_ALREADY_SUBSCRIBED    ///< cannot subscribed to accept events twice
        };

      protected:
        NetworkUtilityObjects& _networkUtilityObjects;
        TConnection **_connections;
        uint16_t _connectionCount;
        uint16_t _lastFree;
        uint16_t _index;
        TcpServerBase *_subscribedServer;
        uint32_t _idleTimeout;

      protected:
        void initialise();
        bool handleFail(TConnection *conn,TcpWaitState state,TConnection **outputConnection,TcpWaitState *outputState) const;

        void onNotification(NetEventDescriptor& ned);
        void onAccept(TcpAcceptEvent& event);
        void unsubscribeServer();

      public:
        TcpConnectionArray(TcpServerBase& server);
        TcpConnectionArray(NetworkUtilityObjects& netUtils,uint16_t count);
        ~TcpConnectionArray();

        bool autoAdd(TcpServerBase& server);
        bool add(TConnection& conn);
        bool remove(const TcpConnection& conn);

        bool wait(TcpWaitState states,uint32_t timeout,TConnection** outputConnection=nullptr,TcpWaitState *outputState=nullptr);
    };


    /**
     * Construct against an existing TCP server. This constructor will automatically subscribe to
     * connections created by this server and will size the internal connections array to match
     * the max connection count of the server
     */

    template<class TConnection>
    inline TcpConnectionArray<TConnection>::TcpConnectionArray(TcpServerBase& server)
      : _networkUtilityObjects(server.getNetworkUtilityObjects()) {

      _connectionCount=server.getParameters().tcp_maxConnectionsPerServer;
      initialise();

      autoAdd(server);
    }


    /**
     * Constructor
     * @param count The maximum number of connections to manage
     */

    template<class TConnection>
    inline TcpConnectionArray<TConnection>::TcpConnectionArray(NetworkUtilityObjects& netUtils,uint16_t count)
      : _networkUtilityObjects(netUtils) {

      // set up the connection array

      _connectionCount=count;
      initialise();
    }


    /**
     * Initialise the array
     */

    template<class TConnection>
    inline void TcpConnectionArray<TConnection>::initialise() {

      _connections=reinterpret_cast<TConnection **>(malloc(sizeof(TConnection *)*_connectionCount));

      memset(_connections,0,sizeof(TConnection *)*_connectionCount);
      _lastFree=0;
      _index=0;
      _idleTimeout=0;

      // we're not subscribed to a server yet

      _subscribedServer=nullptr;

      // subscribe to network notification events so we know when a TCP server or connection is released

      _networkUtilityObjects.NetworkNotificationEventSender.insertSubscriber(
          NetworkNotificationEventSourceSlot::bind(this,&TcpConnectionArray<TConnection>::onNotification));
    }


    /**
     * Destructor, release array memory. We don't own the connection pointers
     * so leave those alone
     */

    template<class TConnection>
    inline TcpConnectionArray<TConnection>::~TcpConnectionArray() {

      // if we are subscribed to a server then unsubscribe

      unsubscribeServer();

      // unsubscribe from notification events

      _networkUtilityObjects.NetworkNotificationEventSender.removeSubscriber(
          NetworkNotificationEventSourceSlot::bind(this,&TcpConnectionArray<TConnection>::onNotification));

      // release the connections

      free(_connections);
    }


    /**
     * Unsubscribe from a server's accept events
     */

    template<class TConnection>
    inline void TcpConnectionArray<TConnection>::unsubscribeServer() {

      if(_subscribedServer)
        _subscribedServer->TcpAcceptEventSender.removeSubscriber(
            TcpAcceptEventSourceSlot::bind(this,&TcpConnectionArray<TConnection>::onAccept));

      _subscribedServer=nullptr;
      _idleTimeout=0;
    }


    /**
     * Auto-add all connections created by a given TCP server. This subscribes this
     * class to accept events from the TCP server. Only one TCP server can be auto-added.
     *
     * We subscribe to TCP server released events and will automatically remove our
     * subscription if the TCP server goes away
     * @param server The server to subscribe to
     * @return true if successfully subscribed
     */

    template<class TConnection>
    inline bool TcpConnectionArray<TConnection>::autoAdd(TcpServerBase& server) {

      // cannot be already subscribed

      if(_subscribedServer!=nullptr)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_TCP_CONNECTION_ARRAY,E_ALREADY_SUBSCRIBED);

      _subscribedServer=&server;
      _idleTimeout=server.getParameters().tcp_idleConnectionTimeout;

      // subscribe to accept events from the server

      server.TcpAcceptEventSender.insertSubscriber(
          TcpAcceptEventSourceSlot::bind(this,&TcpConnectionArray<TConnection>::onAccept));

      return true;
    }


    /**
     * A network notification arrived. We listen for 'release' notifications from connections and servers
     * so we can automatically clean up.
     * @param ned The notification descriptor
     */

    template<class TConnection>
    inline void TcpConnectionArray<TConnection>::onNotification(NetEventDescriptor& ned) {

      // only interested in server released events when we are subscribed

      if(ned.eventType==NetEventDescriptor::NetEventType::TCP_SERVER_RELEASED) {

        if(_subscribedServer!=nullptr) {

          // unsubscribe from events raised by this server

          TcpServerReleasedEvent& tsre(static_cast<TcpServerReleasedEvent&>(ned));

          if(&tsre.server==_subscribedServer)
            unsubscribeServer();
        }
      }
      else if(ned.eventType==NetEventDescriptor::NetEventType::TCP_CONNECTION_RELEASED) {

        // remove this connection from the array

        TcpConnectionReleasedEvent& tcre(static_cast<TcpConnectionReleasedEvent&>(ned));
        remove(tcre.connection);
      }
    }


    /**
     * A connection-accept event has been received, auto-add it to the array
     * @param event The accept event
     */

    template<class TConnection>
    inline void TcpConnectionArray<TConnection>::onAccept(TcpAcceptEvent& event) {

      // the accept must be from the server that we are subscribed to

      if(&event.server==_subscribedServer) {

        // auto-add the connection and mark it as being accepted

        if(add(static_cast<TConnection&>(*event.connection)))
          event.accepted=true;
      }
    }


    /**
     * Add a connection to the array
     */

    template<class TConnection>
    inline bool TcpConnectionArray<TConnection>::add(TConnection& conn) {

      uint16_t i,start;

      // need to rely on the internal state being immutable

      IrqSuspend suspender;

      i=start=_lastFree;

      for(;;) {

        if(_connections[i]) {

          // the connection slot is in use, try the next one or fail if we've done a complete wrap

          if(++i==_connectionCount)
            i=0;

          if(i==start)
            return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_TCP_CONNECTION_ARRAY,E_FULL);
        }
        else {

          // the connection is free, use it and update the next search start

          _connections[i]=&conn;

          if(++_lastFree==_connectionCount)
            _lastFree=0;

          return true;
        }
      }
    }


    /**
     * Remove a connection from the array. Often not needed because connections are automatically
     * removed when they are closed.
     * @param conn The connection to remove
     * @return true if it was found and removed
     */

    template<class TConnection>
    inline bool TcpConnectionArray<TConnection>::remove(const TcpConnection& conn) {

      uint16_t i;

      // need to rely on the internal state being immutable

      IrqSuspend suspender;

      for(i=0;i<_connectionCount;i++) {

        if(_connections[i]==&conn) {

          // found it. remove it and make a note of a guaranteed empty slot

          _connections[i]=nullptr;
          _lastFree=i;

          return true;
        }
      }

      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_TCP_CONNECTION_ARRAY,E_NOT_FOUND);
    }


    /**
     * wait() will go around the connections in round-robin fashion looking for connections
     * that are ready for (read/write) or closed, the desired states are passed in via the states parameter.
     * If a connection matches the required state then its handleRead() handleWrite() or handleClosed() method
     * is called and we move around the rest of the connections in the array in round-robin fashion until
     * the timeout expires. A zero value for the timeout means that it never expires.
     *
     * If a handleXXXX method returns false then this function returns false immediately and the connection
     * in question is returned in the outputConnection parameter and the state that returned false is returned
     * in the outputState parameter.
     *
     * @param states The states to test for
     * @param timeout Maximum time to go on testing states
     * @param[out] outputConnection the connection that returned false. You can pass nullptr if you don't care for this
     * @paran[out] outputState the connection state when it returned false. You can pass nullptr if you don't care for this
     */

    template<class TConnection>
    inline bool TcpConnectionArray<TConnection>::wait(TcpWaitState states,
                                                      uint32_t timeout,
                                                      TConnection** outputConnection,
                                                      TcpWaitState *outputState) {


      uint32_t now;
      TConnection *conn;

      // get the current time

      if(timeout)
        now=MillisecondTimer::millis();
      else
        now=0;

      // loop while something happens

      for(;;) {

        // have we timed out?

        if(timeout && MillisecondTimer::hasTimedOut(now,timeout))
          return true;

        // increment the search pointer

        if(_index==_connectionCount-1)
          _index=0;
        else
          _index++;

        // read is possible when there is some data in the buffer

        if((conn=_connections[_index])!=nullptr && (states & TcpWaitState::READ)!=TcpWaitState::NONE && conn->getDataAvailable()>0) {
          if(!conn->handleRead())
            return handleFail(conn,TcpWaitState::READ,outputConnection,outputState);
        }

        // write is possible when the connection is ESTABLISHED (zero bytes may be written in a zero-window state)

        if((conn=_connections[_index])!=nullptr && (states & TcpWaitState::WRITE)!=TcpWaitState::NONE && conn->getConnectionState().state==TcpState::ESTABLISHED) {
          if(!conn->handleWrite())
            return handleFail(conn,TcpWaitState::WRITE,outputConnection,outputState);
        }

        // callback is possible at any time

        if((conn=_connections[_index])!=nullptr && (states & TcpWaitState::CALLBACK)!=TcpWaitState::NONE) {
          if(!conn->handleCallback())
            return handleFail(conn,TcpWaitState::CALLBACK,outputConnection,outputState);
        }

        // closed is called when local or remote end is closed

        if((conn=_connections[_index])!=nullptr && (states & TcpWaitState::CLOSED)!=TcpWaitState::NONE && (conn->isRemoteEndClosed() || conn->isLocalEndClosed())) {
          if(!conn->handleClosed())
            return handleFail(conn,TcpWaitState::WRITE,outputConnection,outputState);
        }

        // has the connection timed out?

        if(_idleTimeout && (conn=_connections[_index])!=nullptr && MillisecondTimer::hasTimedOut(conn->getLastActiveTime(),_idleTimeout)) {

          // we'll get a callback via our connection-released notification subscription
          // and we'll remove it from the array automatically

          delete conn;
        }
      }
    }


    /**
     * Set parameters for a fail return
     * @param conn The connection that was called
     * @param state The state that it was in
     * @param outputConnection Where to store conn
     * @param outputState Where to store state
     * @return Always false
     */

    template<class TConnection>
    inline bool TcpConnectionArray<TConnection>::handleFail(TConnection *conn,
                                                            TcpWaitState state,
                                                            TConnection **outputConnection,
                                                            TcpWaitState *outputState) const {
      if(outputConnection)
        *outputConnection=conn;

      if(outputState)
        *outputState=state;

      return false;
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpConnectionArray.h
// START FILE: ../lib/include/net/transport/tcp/TcpConnectionStateChangedEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event that is sent when a TCP connection state has changed. For example when a client
     * asynchronous connection attempt moves away from SYN_SENT to ESTABLISHED or CLOSED.
     */

    struct TcpConnectionStateChangedEvent : NetEventDescriptor {

      IpAddress destAddress;
      uint16_t destPort;
      TcpState oldState;
      TcpState newState;

      TcpConnectionStateChangedEvent(const IpAddress& address,uint16_t port,TcpState old_state,TcpState new_state)
        : NetEventDescriptor(NetEventType::TCP_CONNECTION_STATE_CHANGED),
          destAddress(address),
          destPort(port),
          oldState(old_state),
          newState(new_state) {
      }
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpConnectionStateChangedEvent.h
// START FILE: ../lib/include/net/transport/tcp/TcpOutputStreamOfStreams.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * TcpOutputStreamOfStreams manages a list of streams that should be sequentially
     * pushed out over a TCP connection. Each input stream can be optionally deleted
     * when it's empty, or when this class is destroyed. The write methods are non-blocking.
     * If a call would block then an error code is returned.
     *
     * Because streams cannot be rewound and the TCP connection can write less than you
     * ask for, a local buffer is maintained that holds data read from the stream but not
     * yet sent to the TCP connection. The default size of this buffer is 256 bytes but
     * that can be configured in the constructor. This buffer size has an important impact
     * on performance because it will correspond to the largest TCP data segment that this
     * class will send over the connection.
     */

    class TcpOutputStreamOfStreams {

      protected:
        typedef std::pair<InputStream *,bool> StreamEntry;
        std::list<StreamEntry> _streamList;
        TcpConnection& _conn;
        scoped_array<uint8_t> _localBuffer;
        uint16_t _localBufferPos;
        uint16_t _localBufferMaxSize;
        uint16_t _localBufferSize;

      protected:
        bool fillLocalBuffer();

      public:
        TcpOutputStreamOfStreams(TcpConnection& conn,uint16_t localBufferMaxSize=256);
        ~TcpOutputStreamOfStreams();

        bool completed() const;
        void addStream(InputStream *stream,bool takeOwnership);
        bool canWriteToConnection() const;
        bool writeDataToConnection(uint32_t& actuallySent);
    };


    /**
     * Constructor
     * @param The TCP connection to write to.
     */

    inline TcpOutputStreamOfStreams::TcpOutputStreamOfStreams(TcpConnection& conn,uint16_t localBufferMaxSize)
      : _conn(conn),
        _localBuffer(new uint8_t[localBufferMaxSize]),
        _localBufferPos(0),
        _localBufferMaxSize(localBufferMaxSize),
        _localBufferSize(0) {
    }


    /**
     * Destructor. Delete any streams that we have taken ownership of
     */

    inline TcpOutputStreamOfStreams::~TcpOutputStreamOfStreams() {

      // delete all entries in the list that we own

      for(auto it=_streamList.begin();it!=_streamList.end();it++)
        if(it->second)
          delete it->first;
    }


    /**
     * Add a stream to the list, optionally owning it
     * @param stream The stream pointer
     * @param takeOwnership true if we own the pointer and will delete it when finished
     * @return
     */

    inline void TcpOutputStreamOfStreams::addStream(InputStream *stream,bool takeOwnership) {
      _streamList.push_back(StreamEntry(stream,takeOwnership));
    }


    /**
     * Return true if we can write to this connection without blocking
     * @return true if we can do the write
     */

    inline bool TcpOutputStreamOfStreams::canWriteToConnection() const {
      return _conn.getTransmitWindowSize()>0;
    }


    /**
     * Write out some data to the connection. Will never block. Will return false
     * if the underlying connection write attempt or a stream read attempt returned
     * false. If this method returns true then zero or more bytes have been transmitted.
     * @param actuallySent The number of bytes sent.
     * @return true if it worked.
     */

    inline bool TcpOutputStreamOfStreams::writeDataToConnection(uint32_t& actuallySent) {

      // reset this

      actuallySent=0;

      // if the local buffer is empty, get some data

      if(_localBufferPos==_localBufferSize)
        if(!fillLocalBuffer())
          return false;

      // if the local buffer is still empty then there is no data to write

      if(_localBufferPos==_localBufferSize)
        return true;

      // write out the data from the buffer with no blocking

      if(!_conn.send(&_localBuffer[_localBufferPos],_localBufferSize-_localBufferPos,actuallySent,0))
        return false;

      // update position and return

      _localBufferPos+=actuallySent;
      return true;
    }


    /**
     * Fill the local buffer with data to send
     * @return false if a stream failed
     */

    inline bool TcpOutputStreamOfStreams::fillLocalBuffer() {

      uint16_t pos,toread;
      uint32_t actuallyRead;

      // it's empty now

      _localBufferSize=0;
      _localBufferPos=0;
      pos=0;

      // if there are no streams then then we cannot read any data - not an error

      if(_streamList.size()==0)
        return true;

      StreamEntry se(*_streamList.begin());

      while(_localBufferSize!=_localBufferMaxSize) {

        // try to read to the end

        toread=_localBufferMaxSize-_localBufferSize;

        // read the data and return false if the stream fails

        if(!se.first->read(&_localBuffer[pos],toread,actuallyRead))
          return false;

        if(actuallyRead==0) {

          // no data was read, need to move to the next stream

          if(se.second)
            delete se.first;        // we own the stream, delete it

          // remove it from the list

          _streamList.erase(_streamList.begin());

          // get out if the list is empty

          if(_streamList.size()==0)
            return true;

          // move to the next stream

          se=*_streamList.begin();
        }
        else {
          _localBufferSize+=actuallyRead;
          pos+=actuallyRead;
        }
      }

      return true;
    }

    /**
     * Return true if all data has gone
     * @return true if all data has gone
     */

    inline bool TcpOutputStreamOfStreams::completed() const {
      return _streamList.size()==0 && _localBufferPos==_localBufferSize;
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpOutputStreamOfStreams.h
// START FILE: ../lib/include/net/transport/tcp/TcpState.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * State of a TCP connection as illustrated in the state diagram from
     * TCP/IP Illustrated by W. Richard Stevens
     */

    enum class TcpState : uint8_t {
      NONE,
      CLOSED,
      SYN_RCVD,
      SYN_SENT,
      ESTABLISHED,
      CLOSE_WAIT,
      CLOSING,
      FIN_WAIT_1,
      FIN_WAIT_2,
      TIME_WAIT,
      LAST_ACK
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpState.h
// START FILE: ../lib/include/net/transport/tcp/TcpClientConnection.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Simple intermediate class to manage holding the TcpConnection parameters
     * instance. Client connections are unlikely to need their own subclass of the
     * parameters and can customise the members of the default instance declared here.
     */

    class TcpClientConnection : public TcpConnection {

      protected:
        TcpConnection::Parameters _params;

      public:
        TcpClientConnection();
    };


    /**
     * Constructor
     */

    inline TcpClientConnection::TcpClientConnection()
      : TcpConnection(_params) {
    }
  }
}

// END FILE: ../lib/include/net/transport/tcp/TcpClientConnection.h
// START FILE: ../lib/include/net/transport/tcp/TcpServerBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

namespace stm32plus {
  namespace net {

    DECLARE_EVENT_SIGNATURE(TcpAccept,void (TcpAcceptEvent&));


    /**
     * Non-template base class for the TCP server class. Most of the implementation is here. The template
     * is really only needed to manage the creation of correctly typed connections
     */

    class TcpServerBase {

      public:

        /**
         * Server parameters
         */

        struct Parameters {

          uint16_t tcp_maxConnectionsPerServer;       ///< maximum number of connections to accept per server. Default is 5
          uint32_t tcp_idleConnectionTimeout;         ///< the time in millis after which an idle connection will be auto-closed. Zero never times out. The default is zero.

          /**
           * Constructor
           */

          Parameters() {
            tcp_maxConnectionsPerServer=5;      // 5 simultaneous connections per server
            tcp_idleConnectionTimeout=0;        // never time out
          }
        };

      protected:
        uint16_t _listeningPort;                              // listener port for this server
        NetworkUtilityObjects& _networkUtilityObjects;        // various utils
        TcpEvents& _tcpEvents;                                // event source for TCP receive events
        const Parameters& _params;                            // reference to the parameters instance
        uint16_t _segmentSizeLimit;                           // maximum segment size (MSS)
        uint16_t _additionalHeaderSize;                       // additional bytes required for lower layer headers

        volatile bool _started;                               // true if the server has been started
        uint16_t _connectionCount;                            // total number of connections for this server

      public:
        TcpServerBase(uint16_t listeningPort,
                      NetworkUtilityObjects& networkUtilityObjects,
                      TcpEvents& tcpEvents,
                      const Parameters& params,
                      uint16_t segmentSizeLimit,
                      uint16_t additionalHeaderSize);
        ~TcpServerBase();

        DECLARE_EVENT_SOURCE(TcpAccept);

        void start();
        uint16_t getListeningPort() const;
        const Parameters& getParameters() const;
        NetworkUtilityObjects& getNetworkUtilityObjects() const;

      protected:
        void onNotification(NetEventDescriptor& ned);
        void handleConnectionReleased(const TcpConnectionReleasedEvent& tcre);
    };


    /**
     * Constructor
     * @param listeningPort the port number to listen on
     */

    inline TcpServerBase::TcpServerBase(uint16_t listeningPort,
                                        NetworkUtilityObjects& networkUtilityObjects,
                                        TcpEvents& tcpEvents,
                                        const Parameters& params,
                                        uint16_t segmentSizeLimit,
                                        uint16_t additionalHeaderSize)
      : _listeningPort(listeningPort),
        _networkUtilityObjects(networkUtilityObjects),
        _tcpEvents(tcpEvents),
        _params(params),
        _segmentSizeLimit(segmentSizeLimit),
        _additionalHeaderSize(additionalHeaderSize) {

      _started=false;
      _connectionCount=0;

      // subscribe to network notifications

      _networkUtilityObjects.NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&TcpServerBase::onNotification));
    }


    /**
     * Send a notification that this server is being released
     */

    inline TcpServerBase::~TcpServerBase() {

      // unsubscribe from notify events

      _networkUtilityObjects.NetworkNotificationEventSender.removeSubscriber(NetworkNotificationEventSourceSlot::bind(this,&TcpServerBase::onNotification));
    }


    /**
     * Start the server. After this method has completed the server is ready to accept connections
     */

    inline void TcpServerBase::start() {
      _started=true;
    }


    /**
     * Get the listening port
     * @return the port number
     */

    inline uint16_t TcpServerBase::getListeningPort() const {
      return _listeningPort;
    }


    /**
     * Get the net utils
     * @return The network utilities
     */

    inline NetworkUtilityObjects& TcpServerBase::getNetworkUtilityObjects() const {
      return _networkUtilityObjects;
    }


    /**
     * Network notification event
     * @param ned The event descriptor
     */

    inline void TcpServerBase::onNotification(NetEventDescriptor& ned) {

      if(ned.eventType==NetEventDescriptor::NetEventType::TCP_CONNECTION_RELEASED)
        handleConnectionReleased(static_cast<TcpConnectionReleasedEvent&>(ned));
    }


    /**
     * A connection is released
     * @param tcre The connection released event
     */

    inline void TcpServerBase::handleConnectionReleased(const TcpConnectionReleasedEvent& tcre) {

      // if it was a connection to our server then release it

      if(tcre.connection.getLocalPort()==_listeningPort)
        _connectionCount--;
    }


    /**
     * Get a reference to the parameters class
     * @return A parameters reference
     */

    inline const TcpServerBase::Parameters& TcpServerBase::getParameters() const {
      return _params;
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpServerBase.h
// START FILE: ../lib/include/net/transport/tcp/TcpTextLineReceiver.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Many application layer IETF protocols are text based and rely on
     * being able to process data a line at a time. This class simplifies receiving
     * data from a TcpConnection a line at a time.
     *
     * Data is read into a pre-sized std::string class a character at a time until
     * an LF is hit. Any CR characters are discarded. The trailing LF is not included
     * in the string.
     */

    class TcpTextLineReceiver {

      public:

        /**
         * Error codes
         */

        enum {
          E_RESET_REQUIRED = 1      ///< you called add() but you haven't reset() since the last line was ready()
        };

      protected:
        std::string _line;
        uint16_t _maxLength;
        bool _ready;

      public:
        TcpTextLineReceiver(uint16_t maxLength);

        bool add(TcpConnection& conn);
        bool ready() const;
        void reset();
        uint16_t length() const;

        operator const std::string&() const;
        const std::string& str() const;
    };


    /**
     * Constructor
     * @param maxLength The longest line that we can receive. Longer lines are truncated.
     */

    inline TcpTextLineReceiver::TcpTextLineReceiver(uint16_t maxLength)
      : _maxLength(maxLength) {
      reset();
    }


    /**
     * Add some more data from this TCP connection. Only data up to and including the
     * first LF will be consumed. This call will not block. It will check for data available
     * in the TCP receive buffer before calling receive(). If data is not available then it
     * will return 'true' and expect to be called back later when you have been signalled
     * that data is available.
     * @param conn The TCP connection to read from
     * @return false if the underlying call to the connection read() fails.
     */

    inline bool TcpTextLineReceiver::add(TcpConnection& conn) {

      char c;
      uint32_t actuallyRead;

      // cannot procede if you haven't called reset on the previous line

      if(_ready)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_TCP_TEXT_LINE_RECEIVER,E_RESET_REQUIRED);

      // loop while data is ready to read

      while(conn.getDataAvailable()) {

        // try to read a character

        if(!conn.receive(&c,1,actuallyRead,1) || actuallyRead!=1)
          return false;

        // if LF then done, otherwise store non-CR char

        if(c=='\n') {
          _ready=true;
          break;
        }
        else if(c!='\r' && _line.length()<_maxLength)
          _line+=c;
      }

      return true;
    }


    /**
     * Check if the line is ready
     * @return true if a line is ready to be consumed
     */

    inline bool TcpTextLineReceiver::ready() const {
      return _ready;
    }


    /**
     * Reset the class. After calling this you may call add() again to start receiving
     * a new line
     */

    inline void TcpTextLineReceiver::reset() {

      // clear the line, cancel the ready flag

      _line.clear();
      _ready=false;
    }


    /**
     * Cast to a std::string const reference
     */

    inline TcpTextLineReceiver::operator const std::string&() const {
      return _line;
    }


    /**
     * Method to return as a string reference
     * @return The string
     */

    inline const std::string& TcpTextLineReceiver::str() const {
      return _line;
    }


    /**
     * Get the string length
     * @return The length of the string
     */

    inline uint16_t TcpTextLineReceiver::length() const {
      return _line.length();
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpTextLineReceiver.h
// START FILE: ../lib/include/net/transport/tcp/TcpConnectionState.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Simple structure to hold the remote state of a connection: this allows it to be
     * easily transferred between a connection and the closing handler when the connection
     * goes away
     */

    struct TcpConnectionState {

      uint16_t additionalHeaderSize;              ///< how much extra space needed for IP and link layer headers
      IpAddress remoteAddress;                    ///< our peer's address
      uint16_t localPort;                         ///< our local port
      uint16_t remotePort;                        ///< peer remote port
      bool localPortIsEphemeral;                  ///< true if this is a client (local ports are ephemeral)
      volatile TcpState state;                    ///< the state of the connection
      volatile TcpTransmitWindow txWindow;        ///< the transmit window state
      volatile TcpReceiveWindow rxWindow;         ///< the receive window state
      volatile bool pendingDataAck;               ///< true if there's a pending data ACK

      /*
       * Constructor
       */

      TcpConnectionState()
        : state(TcpState::NONE) {
      }

      /**
       * = operator. need this because of the volatile members. used when move the state to the closed
       * manager
       * @param src to copy from
       * @return self-reference
       */

      TcpConnectionState& operator=(const TcpConnectionState& src) {

        additionalHeaderSize=src.additionalHeaderSize;
        remoteAddress=src.remoteAddress;
        localPort=src.localPort;
        localPortIsEphemeral=src.localPortIsEphemeral;
        remotePort=src.remotePort;
        state=src.state;
        pendingDataAck=src.pendingDataAck;

        // OK to cast off the volatile qualifier because by the time this operator is used
        // these variables are no longer volatile

        const_cast<TcpTransmitWindow&>(txWindow)=const_cast<TcpTransmitWindow&>(src.txWindow);
        const_cast<TcpReceiveWindow&>(rxWindow)=const_cast<TcpReceiveWindow&>(src.rxWindow);

        return *this;
      }


      /**
       * (re)send the current ACK
       * @param netutils The network utils
       * @param windowSize the current receive window size
       * @return true if it was sent
       */

      bool sendAck(NetworkUtilityObjects& netutils,uint16_t windowSize) {
        return sendHeaderOnly(netutils,TcpHeaderFlags::ACK,windowSize);
      }


      /**
       * Send a FIN and ACK
       * @param netutils The network utils
       * @param windowSize the current receive window size
       * @return true if it was sent
       */

      bool sendFinAck(NetworkUtilityObjects& netutils,uint16_t windowSize) {
        return sendHeaderOnly(netutils,TcpHeaderFlags::FIN | TcpHeaderFlags::ACK,windowSize);
      }


      /**
       * Send a reset (RST) segment to the other end. After a connection has been reset it is considered
       * aborted and closed. No further operations are possible.
       * @param netutils The network utils
       * @param windowSize the current receive window size
       * @return true if it was sent
       */

      bool sendRstAck(NetworkUtilityObjects& netutils,uint16_t windowSize) {
        changeState(netutils,TcpState::CLOSED);
        return sendHeaderOnly(netutils,TcpHeaderFlags::RST | TcpHeaderFlags::ACK,windowSize);
      }


      /**
       * Send header-with-flags
       * @param netutils The network utils
       * @param windowSize the current receive window size
       * @param flags The flags to set in the header
       * @return true if it was sent
       */

      bool sendHeaderOnly(NetworkUtilityObjects& netutils,
                          TcpHeaderFlags flags,
                          uint16_t windowSize) {

        // create a NetBuffer to hold the RST segment

        NetBuffer *nb=new NetBuffer(additionalHeaderSize+TcpHeader::getNoOptionsHeaderSize(),0);

        // construct the header

        TcpHeader *header=reinterpret_cast<TcpHeader *>(nb->moveWritePointerBack(TcpHeader::getNoOptionsHeaderSize()));

        header->initialise(localPort,
                           remotePort,
                           txWindow.sendNext,           // where we are sending from
                           (flags & TcpHeaderFlags::ACK)==0 ? 0 : rxWindow.receiveNext, //  ack up to receiveNext
                           windowSize,                  // data space available
                           flags);

        // ask the IP layer to send the packet

        IpTransmitRequestEvent iptre(
            nb,
            remoteAddress,
            IpProtocol::TCP);

        netutils.NetworkSendEventSender.raiseEvent(iptre);
        return iptre.succeeded;
      }


      /**
       * Change the state of this connection and notify subscribers
       * @param netutils The network utility objects
       * @param newState The new state
       */

      void changeState(NetworkUtilityObjects& netutils,TcpState newState) {

        TcpState oldState;

        oldState=state;
        state=newState;

        netutils.NetworkNotificationEventSender.raiseEvent(
            TcpConnectionStateChangedEvent(remoteAddress,remotePort,oldState,newState)
          );
      }
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpConnectionState.h
// START FILE: ../lib/include/net/transport/tcp/TcpHeader.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Definition of a TCP version 4 header. This is designed to be cast directly
     * to a memory buffer which of course means that 16 and 32 bit values are in
     * network byte order.
     */

    struct TcpHeader {

      uint16_t tcp_sourcePort;              ///< sender port number or zero if not used
      uint16_t tcp_destinationPort;         ///< destination port number
      uint32_t tcp_sequenceNumber;          ///< sequence number of the incoming data
      uint32_t tcp_ackNumber;               ///< acknowledgement number of data received
      uint16_t tcp_headerLengthAndFlags;    ///< 4-bit header length and various flags
      uint16_t tcp_windowSize;              ///< number of bytes willing to receive
      uint16_t tcp_checksum;                ///< checksum
      uint16_t tcp_urgentPointer;           ///< offset from sequence number of last urgent byte


      /**
       * Initialise the header with some values
       * @param localPort,
       * @param remotePort,
       * @param localSequenceNumber
       * @param remoteAckNumber
       * @param localReceiveWindowSize
       * @param options
       */

      void initialise(uint16_t localPort,
                      uint16_t remotePort,
                      uint32_t localSequenceNumber,
                      uint32_t remoteAckNumber,
                      uint16_t localReceiveWindowSize,
                      TcpHeaderFlags options) {

        // set up default options in the header

        tcp_sourcePort=NetUtil::htons(localPort);
        tcp_destinationPort=NetUtil::htons(remotePort);
        tcp_sequenceNumber=NetUtil::htonl(localSequenceNumber);
        tcp_ackNumber=NetUtil::htonl(remoteAckNumber);
        tcp_windowSize=NetUtil::htons(localReceiveWindowSize);
        tcp_headerLengthAndFlags=static_cast<uint16_t>(options) | 0x50;     // 5 words default header size
        tcp_checksum=0;
        tcp_urgentPointer=0;
      }


      /**
       * Set the total size of the header including options
       * @param size The header size in bytes
       */

      void setSize(uint16_t size) {

        // we're manipulating this field in network byte order

        tcp_headerLengthAndFlags=(tcp_headerLengthAndFlags & 0xff0f) | ((size/4) << 4);
      }


      /**
       * Get the total header size
       * @return the total size
       */

      uint16_t getHeaderSize() const {
        return getDataOffset();
      }


      /**
       * Get the offset of the data in bytes
       * @return data offset (20 is minimum)
       */

      uint16_t getDataOffset() const {
        return (NetUtil::ntohs(tcp_headerLengthAndFlags) & 0xf000) >> 10;
      }


      /**
       * Return true if this segment has the SYN flag
       * @return true if it has
       */

      bool hasSyn() const {
        return (tcp_headerLengthAndFlags & TcpHeaderFlags::SYN)!=0;   // takes into account net byte order
      }


      /**
       * Return true if this segment has the ACK flag
       * @return true if it has
       */

      bool hasAck() const {
        return (tcp_headerLengthAndFlags & TcpHeaderFlags::ACK)!=0;   // takes into account net byte order
      }


      /**
       * Return true if this segment has the RST flag
       * @return true if it has
       */

      bool hasRst() const {
        return (tcp_headerLengthAndFlags & TcpHeaderFlags::RST)!=0;   // takes into account net byte order
      }


      /**
       * Return true if this segment has the FIN flag
       * @return true if it has
       */

      bool hasFin() const {
        return (tcp_headerLengthAndFlags & TcpHeaderFlags::FIN)!=0;   // takes into account net byte order
      }


      /**
       * Get the size of a header with no options
       */

      constexpr static uint16_t getNoOptionsHeaderSize() {
        return 20;
      }


      /**
       * Search for an option in the header
       * @param optionKind The option id to search for
       * @return a pointer to the option or nullptr if it's not there
       */

      template<class TOption>
      const TOption *findOption() const {
        return reinterpret_cast<const TOption *>(findOption(TOption::getOptionKind()));
      }


      /**
       * Search for a pointer to an option in the header
       * @param optionKind The option id to search for
       * @return a pointer to the option or nullptr if it's not there
       */

      const void *findOption(TcpOptionKind optionKind) const {

        const uint8_t *ptr,*endptr;

        ptr=reinterpret_cast<const uint8_t *>(this)+getNoOptionsHeaderSize();
        endptr=ptr+getHeaderSize()-getNoOptionsHeaderSize();

        while(ptr!=endptr) {

          if(*ptr==0)       // end of options
            break;
          else if(*ptr==1)  // padding
            ptr++;
          else {

            if(*ptr==optionKind)
              return ptr;
            else
              ptr+=ptr[1];      // step past length
          }
        }

        // not found

        return nullptr;
      }

    } __attribute__((packed));

    // options follow...
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpHeader.h
// START FILE: ../lib/include/net/transport/tcp/TcpResendDelayCalculator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * State management for the resend algorithm. This implements the algorithm in RFC2988 as
     * best we can here. Round-trip times are used to calculate an adaptive value that defines
     * how long to wait before a packet is considered lost and should be retransmitted for the
     * first time.
     */

    class TcpResendDelayCalculator {

      protected:
        uint16_t _initialDelay;
        uint16_t _maxDelay;

        uint32_t _srtt;
        uint32_t _rttvar;
        uint32_t _timerStart;
        bool _first;

      public:
        bool initialise(uint16_t initialDelay,uint16_t maxDelay);

        void startTimer();
        void stopTimer();

        uint16_t getResendDelay() const;
    };


    /**
     * Initialise the class
     * @param initialDelay The first delay seconds
     * @param maxDelay The maximum delay seconds
     * @return true
     */

    inline bool TcpResendDelayCalculator::initialise(uint16_t initialDelay,uint16_t maxDelay) {
      _initialDelay=initialDelay;
      _maxDelay=maxDelay;
      return true;
    }


    /**
     * Start the RTT timer
     */

    inline void TcpResendDelayCalculator::startTimer() {
      _timerStart=MillisecondTimer::millis();
    }


    /**
     * Stop the RTT timer and calculate the state variables
     */

    inline void TcpResendDelayCalculator::stopTimer() {

      uint32_t r;

      r=MillisecondTimer::difference(_timerStart);

      if(_first) {
        _srtt=r;
        _rttvar=r/2;
        _first=false;
      }
      else {
        _rttvar=((3*_rttvar)+std::abs((int32_t)_srtt-(int32_t)r))/4;
        _srtt=((7*_srtt)+r)/8;
      }
    }


    /**
     * Get the current resend delay, calculated from the state variables
     * @return the current resend delay
     */

    inline uint16_t TcpResendDelayCalculator::getResendDelay() const {

      if(_first)
        return _initialDelay;

      return std::min((uint32_t)_maxDelay,(_srtt+std::max(1ul,4*_rttvar))/1000);
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpResendDelayCalculator.h
// START FILE: ../lib/include/net/transport/tcp/Tcp.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Implementation of the UDP protocol over IP. Datagrams are received asynchronously from the IP
     * layer and passed on to the upper layers. Functionality is provided for sending and receiving
     * datagrams synchronously to the caller.
     */

    template<class TNetworkLayer>
    class Tcp : public virtual TNetworkLayer,
                public TcpEvents {

      public:
        /**
         * Error codes
         */

        enum {
          E_TOO_MANY_SERVERS = 1,       ///< tcp_maxServers limit hit
          E_PORT_IN_USE,                ///< trying to bind to a port that's already claimed
          E_TIMEOUT,                    ///< timed out while waiting to connect
          E_CONNECT_FAILED              ///< connection failed
        };


        /**
         * Parameters class
         */

        struct Parameters : TcpServerBase::Parameters {

          uint16_t tcp_maxServers;                ///< maximum number of servers at any one time. default is 5
          uint16_t tcp_msl;                       ///< maximum segment lifetime, in seconds. default is 30
          uint16_t tcp_connectRetryInterval;      ///< the time, in millis to wait for a SYN-ACK before sending another. Default is 4000.
          uint16_t tcp_connectMaxRetries;         ///< number of times to retry a connect if SYN-ACK not received. Default is 5.

          /**
           * Constructor
           */

          Parameters() {
            tcp_maxServers=5;
            tcp_msl=30;
            tcp_connectRetryInterval=4000;
            tcp_connectMaxRetries=5;
          }
        };

      protected:
        Parameters _params;
        uint16_t _serverCount;
        std::slist<TcpClosingConnectionState> _closingConnections;

      protected:
        void onNotification(NetEventDescriptor& ned);
        void onReceive(IpPacketEvent& event);
        void onTick(NetworkIntervalTickData& nitd);
        void handleConnectionReleased(const TcpConnectionReleasedEvent& tcre);
        bool rejectWithRst(const TcpSegmentEvent& event);
        void handleFinWait1(const TcpHeader& header,TcpConnectionState& rstate);
        void handleFinWait2(const TcpHeader& header,TcpConnectionState& rstate);
        bool handleLastAck(const TcpHeader& header,TcpConnectionState& rstate);

      public:
        template<class TConnection,class TUser=void>
        bool tcpCreateServer(uint16_t port,TcpServer<TConnection,TUser> *&server,TUser *userptr=nullptr);

        template<class TConnection>
        bool tcpConnect(const IpAddress& remoteAddress,
                        uint16_t remotePort,
                        TConnection *& connection);

        template<class TConnection>
        bool tcpConnect(const IpAddress& remoteAddress,
                        uint16_t localPort,
                        uint16_t remotePort,
                        TConnection *& connection);

        template<class TConnection>
        bool tcpConnectAsync(const IpAddress& remoteAddress,
                        uint16_t remotePort,
                        TConnection *& connection);

        template<class TConnection>
        bool tcpConnectAsync(const IpAddress& remoteAddress,
                        uint16_t localPort,
                        uint16_t remotePort,
                        TConnection *& connection);

        bool initialise(const Parameters& params);
        bool startup();

        Parameters& tcpGetParameters();
    };


    /**
     * Initialise the class
     * @param params The parameters class
     * @return true if it worked
     */

    template<class TNetworkLayer>
    inline bool Tcp<TNetworkLayer>::initialise(const Parameters& params) {

      uint16_t tickSeconds;

      // save parameters

      _params=params;
      _serverCount=0;

      // subscribe to notify events from the network

      this->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&Tcp<TNetworkLayer>::onNotification));

      // subscribe to packet events from the IP module

      this->IpReceiveEventSender.insertSubscriber(IpReceiveEventSourceSlot::bind(this,&Tcp<TNetworkLayer>::onReceive));

      // subscribe to the second ticker so we can clean up closed connections. the ticker has a granularity of
      // 10 seconds or msl/4, whichever is the greater. the lower limit prevents us taking up too much CPU checking
      // whether closed connections should be cleaned up.

      tickSeconds=std::max(10,params.tcp_msl/4);
      this->subscribeIntervalTicks(tickSeconds,NetworkIntervalTicker::TickIntervalSlotType::bind(this,&Tcp<TNetworkLayer>::onTick));

      return true;
    }


    /**
     * Startup the class
     * @return true if it worked
     */

    template<class TNetworkLayer>
    inline bool Tcp<TNetworkLayer>::startup() {
      return true;
    }


    /**
     * Network receive event
     * @param ned The event descriptor
     */

    template<class TNetworkLayer>
    inline void Tcp<TNetworkLayer>::onReceive(IpPacketEvent& ipe) {

      // must be a TCP packet

      if(ipe.ipPacket.header->ip_hdr_protocol!=IpProtocol::TCP)
        return;

      // sending an event of our own saves each interested recipient from having
      // to decode the ip structure and reduces the number of events sent to something
      // that only cares for TCP receive events

      TcpHeader *header=reinterpret_cast<TcpHeader *>(ipe.ipPacket.payload);
      uint8_t *data=ipe.ipPacket.payload+header->getDataOffset();
      uint16_t datalen=ipe.ipPacket.payloadLength-header->getHeaderSize();

      // send the event

      TcpSegmentEvent event(ipe.ipPacket,
                             *header,
                             data,
                             datalen,
                             NetUtil::ntohs(header->tcp_sourcePort),
                             NetUtil::ntohs(header->tcp_destinationPort));

      TcpReceiveEventSender.raiseEvent(event);

      // if a connection or server handled it then we don't need to go further

      if(event.handled)
        return;

      // check if this segment is for one of the closing connections

      std::slist<TcpClosingConnectionState>::iterator it,previt;
      bool notfound;

      {
        IrqSuspend suspender;

        // find the connection, under pre-emption prevention

        for(it=previt=_closingConnections.begin();it!=_closingConnections.end();it++) {

          if(it->matches(event))
            break;

          previt=it;
        }

        notfound=it==_closingConnections.end();
      }


      // if not one of ours then a segment has arrived for an unknown connection
      // we reply with RST

      if(notfound)
        rejectWithRst(event);
      else {
        // do something with it

        switch(it->state) {

          case TcpState::FIN_WAIT_1:
            handleFinWait1(*header,*it);
            break;

          case TcpState::FIN_WAIT_2:
            handleFinWait2(*header,*it);
            break;

          case TcpState::LAST_ACK:

            if(handleLastAck(*header,*it)) {

              IrqSuspend suspender;

              if(it==_closingConnections.begin())
                _closingConnections.erase(_closingConnections.begin());
              else
                _closingConnections.erase_after(previt);
            }
            break;

          default:
            break;
        }
      }
    }


    /**
     * Reject this segment with an RST. This is IRQ code
     * @param event The segment event
     * @return true if it was sent
     */

    template<class TNetworkLayer>
    inline bool Tcp<TNetworkLayer>::rejectWithRst(const TcpSegmentEvent& event) {

      uint32_t sequence,ack;

      // don't RST a segment that was itself a RST

      if(event.tcpHeader.hasRst())
        return false;

      // calculate sequence and ack for this RST (see RFC793 for reasoning)

      if(event.tcpHeader.hasAck())
        sequence=NetUtil::ntohl(event.tcpHeader.tcp_ackNumber);
      else
        sequence=0;

      ack=NetUtil::ntohl(event.tcpHeader.tcp_sequenceNumber)+event.payloadLength;

      // create a NetBuffer to hold the RST segment

      NetBuffer *nb=new NetBuffer(
          this->getDatalinkTransmitHeaderSize()+this->getIpTransmitHeaderSize()+TcpHeader::getNoOptionsHeaderSize(),
          0);

      // construct the header

      TcpHeader *header=reinterpret_cast<TcpHeader *>(nb->moveWritePointerBack(TcpHeader::getNoOptionsHeaderSize()));

      header->initialise(event.destinationPort,         // was sent to this local port
                         event.sourcePort,              // came from this remote port
                         sequence,
                         ack,
                         0,                             // zero window
                         TcpHeaderFlags::RST);

      // ask the IP layer to send the packet

      IpTransmitRequestEvent iptre(
            nb,
            event.ipPacket.header->ip_sourceAddress,
            IpProtocol::TCP);

      this->NetworkSendEventSender.raiseEvent(iptre);
      return iptre.succeeded;
    }


    /**
     * Notification from our subscription to notification events
     * @param ned The event descriptor
     */

    template<class TNetworkLayer>
    inline void Tcp<TNetworkLayer>::onNotification(NetEventDescriptor& ned) {

      // handle a TCP server being released by releasing its listening port

      if(ned.eventType==NetEventDescriptor::NetEventType::TCP_SERVER_RELEASED) {

        uint16_t port;

        // get the port from the message

        port=static_cast<TcpServerReleasedEvent&>(ned).server.getListeningPort();

        // most likely it's on a defined port but could be on an ephemeral (e.g. FTP data connection)

        if(this->ip_releaseDefinedPort(port) || this->ip_releaseEphemeralPort(port))
          _serverCount--;
      }
      else if(ned.eventType==NetEventDescriptor::NetEventType::TCP_CONNECTION_RELEASED)
        handleConnectionReleased(static_cast<TcpConnectionReleasedEvent&>(ned));
    }


    /**
     * Network interval ticker callback. This is IRQ code.
     * @param nitd The tick data
     */

    template<class TNetworkLayer>
    inline void Tcp<TNetworkLayer>::onTick(NetworkIntervalTickData& nitd) {

      std::slist<TcpClosingConnectionState>::iterator previt,it;

      // iterate the closing connections

      for(it=previt=_closingConnections.begin();it!=_closingConnections.end();) {

        // check if it's expired

        if(nitd.timeNow>it->cleanupTime) {

          // if the state is not CLOSED or TIME_WAIT then the close sequence has not
          // completed as it should. we send a RST to the other end to tell it to shutdown.

          if(it->state!=TcpState::TIME_WAIT && it->state!=TcpState::CLOSED)
            it->sendRstAck(*this,0);

          // if the local port is ephemeral then release it

          if(it->localPortIsEphemeral)
            this->ip_releaseEphemeralPort(it->localPort);

          // if this is the head of the list, remove it and continue again from the start

          if(it==_closingConnections.begin()) {
            _closingConnections.erase(_closingConnections.begin());
            it=previt=_closingConnections.begin();
          }
          else {

            // erase the current one efficiently. erase_after returns iterator AFTER the one removed
            // previt does not change

            it=_closingConnections.erase_after(previt);
          }
        }
        else {

          // update both iterators

          previt=it;
          it++;
        }
      }
    }


    /**
     * A connection is released. The destructor for the connection is underway and we must now
     * decide if we need to go into the closing sequence based on the state of this connection.
     * @param tcre The connection released event
     */

    template<class TNetworkLayer>
    inline void Tcp<TNetworkLayer>::handleConnectionReleased(const TcpConnectionReleasedEvent& tcre) {

      switch(tcre.connection.getConnectionState().state) {

        case TcpState::SYN_RCVD:
        case TcpState::ESTABLISHED:
        case TcpState::CLOSE_WAIT:
          break;

        default:

          // if the local port is ephemeral then release it

          if(tcre.connection.getConnectionState().localPortIsEphemeral)
            this->ip_releaseEphemeralPort(tcre.connection.getConnectionState().localPort);

          return;
      }

      // add to the list (struct copy)

      std::slist<TcpClosingConnectionState>::iterator it;

      {
        IrqSuspend suspender;

        _closingConnections.push_front(
          TcpClosingConnectionState(tcre.connection.getConnectionState(),
                                     this->getRtc().getTick()+(_params.tcp_msl*2)));

        it=_closingConnections.begin();
      }

      // if we are the active closer or we've received a FIN from the other end
      // then we need to send a FIN

      switch(it->state) {

        case TcpState::SYN_RCVD:          // we are the active closer in these cases
        case TcpState::ESTABLISHED:
          it->changeState(*this,TcpState::FIN_WAIT_1);
          it->sendFinAck(*this,0);
          it->txWindow.sendNext++;
          break;

        case TcpState::CLOSE_WAIT:        // we are the passive closer in these cases
          it->changeState(*this,TcpState::LAST_ACK);
          it->sendFinAck(*this,0);
          it->txWindow.sendNext++;
          break;

        default:
          return;
      }
    }


    /**
     * Handle the segment received while in FIN_WAIT_1. This is IRQ code.
     * We are expecting to receive an ACK for our FIN
     * @param header the TCP header
     * @param rstate the state variables
     */

    template<class TNetworkLayer>
    inline void Tcp<TNetworkLayer>::handleFinWait1(const TcpHeader& header,TcpConnectionState& rstate) {

      // must be an ACK and the sequence number must match

      if(!header.hasAck() || NetUtil::ntohl(header.tcp_ackNumber)!=rstate.txWindow.sendNext)
        return;

      rstate.txWindow.sendUnacknowledged=rstate.txWindow.sendNext;

      // new state is FIN_WAIT_2

      rstate.changeState(*this,TcpState::FIN_WAIT_2);
    }


    /**
     * Handle the segment received while in FIN_WAIT_2. This is IRQ code.
     * We are expecting to receive a FIN from the other side.
     * @param header the TCP header
     * @param rstate the remote state variables
     */

    template<class TNetworkLayer>
    inline void Tcp<TNetworkLayer>::handleFinWait2(const TcpHeader& header,TcpConnectionState& rstate) {

      // must be an ACK and the sequence number must match

      if(!header.hasFin())
        return;

      // update the remote sequence number and send the ACK for that

      rstate.rxWindow.receiveNext=NetUtil::ntohl(header.tcp_sequenceNumber)+1;
      rstate.sendAck(*this,0);

      // new state is TIME_WAIT

      rstate.changeState(*this,TcpState::TIME_WAIT);
    }


    /**
     * Handle the segment received while in LAST_ACK. This is IRQ code.
     * We are expecting to receive an ACK from the other side.
     * @param header the TCP header
     * @param rstate the remote state variables
     * @return true if the connection is closed and can be removed
     */

    template<class TNetworkLayer>
    inline bool Tcp<TNetworkLayer>::handleLastAck(const TcpHeader& header,TcpConnectionState& rstate) {

      // must be an ACK and the sequence number must match

      if(!header.hasAck() || NetUtil::ntohl(header.tcp_ackNumber)!=rstate.txWindow.sendNext)
        return false;

      // we're done

      rstate.changeState(*this,TcpState::CLOSED);
      return true;
    }


    /**
     * Create a new TCP server that will listen on the specified port. The port number must not be in
     * the ephemeral range (default 49152 to 65535). The ephemeral range is customisable through the
     * module parameters.
     * @param port The port number to listen on
     * @param[out] server The server pointer
     * @param userptr Optional pointer that you would like to be passed to your TConnection's constructor. This allows you to pass state around.
     * @tparam TConnection Your most-derived subclass of TcpConnection. The server will create instances of this.
     * @tparam TUser optional type of the parameter to your TConnection's constructor, if your TConnection takes a constructor.
     * @return true if it worked, and is now listening.
     */

    template<class TNetworkLayer>
    template<class TConnection,class TUser>
    inline bool Tcp<TNetworkLayer>::tcpCreateServer(uint16_t port,
                                                    TcpServer<TConnection,TUser> *&server,
                                                    TUser *userptr) {

      // check that the server limit has not been hit

      if(_serverCount==_params.tcp_maxServers)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_TCP,E_TOO_MANY_SERVERS);

      // try to claim the port

      if(!this->ip_acquireDefinedPort(port))
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP,E_PORT_IN_USE);

      // create the server

      server=new TcpServer<TConnection,TUser>(
          port,
          *this,
          *this,
          _params,
          this->getDatalinkMtuSize()-IpPacketHeader::getNoOptionsHeaderSize()-TcpHeader::getNoOptionsHeaderSize(),
          this->getDatalinkTransmitHeaderSize()+this->getIpTransmitHeaderSize(),
          userptr);

      _serverCount++;
      return true;
    }


    /**
     * Connect to a remote endpoint and port. The interval between retries and the number of retries that are
     * attempted can be configured in the Parameters class. A random local port from the ephemeral range will
     * be selected.
     * This is not IRQ safe.
     * @param remoteAddress The remote IP address to connect to
     * @param remotePort The remote server port to connect to
     * @param connection The new connection object. Delete when you're done.
     * @tparam TConnection Your most-derived subclass of TcpConnection that you're using to handle the connection.
     * @return true if it works, false if not
     */

    template<class TNetworkLayer>
    template<class TConnection>
    bool Tcp<TNetworkLayer>::tcpConnect(const IpAddress& remoteAddress,
                                        uint16_t remotePort,
                                        TConnection *&connection) {

      uint16_t localPort;

      // get a port from the ephemeral range

      if(!this->ip_acquireEphemeralPort(localPort))
        return false;

      // connect with all parameters

      if(!tcpConnect(remoteAddress,localPort,remotePort,connection)) {

        // didn't work, release the local port

        this->ip_releaseEphemeralPort(localPort);
        return false;
      }

      // worked

      return true;
    }


    /**
     * Connect to a remote endpoint and port. The interval between retries and the number of retries that are
     * attempted can be configured in the Parameters class. You specify the local port number, which must be from
     * the ephemeral range. This is not IRQ safe.
     * @param remoteAddress The remote IP address to connect to
     * @param remotePort The remote server port to connect to
     * @param connection The new connection object. Delete when you're done.
     * @tparam TConnection Your most-derived subclass of TcpConnection that you're using to handle the connection.
     * @return true if it works, false if not
     */

    template<class TNetworkLayer>
    template<class TConnection>
    bool Tcp<TNetworkLayer>::tcpConnect(const IpAddress& remoteAddress,
                                        uint16_t localPort,
                                        uint16_t remotePort,
                                        TConnection *&connection) {
      uint16_t retry;

      // create and initialise the new connection. this will send the first SYN

      connection=nullptr;
      scoped_ptr<TConnection> conn(new TConnection);

      if(!conn->initialise(
                        *this,
                        *this,
                        remoteAddress,
                        localPort,
                        remotePort,
                        this->getDatalinkMtuSize()-IpPacketHeader::getNoOptionsHeaderSize()-TcpHeader::getNoOptionsHeaderSize(),
                        this->getDatalinkTransmitHeaderSize()+this->getIpTransmitHeaderSize()))
        return false;

      // _params.tcp_connectMaxRetries really does mean retries. That is, there will be the initial
      // attempt followed by that many retries.

      retry=0;

      do {

        // now wait for the state to move away from SYN_SENT

        if(conn->waitForStateChange(TcpState::SYN_SENT,_params.tcp_connectRetryInterval)) {

          // anything but ESTABLISHED means failure. most likely the remote end RST'd our SYN

          if(conn->getConnectionState().state==TcpState::ESTABLISHED) {
            connection=conn.release();
            return true;
          }

          // failed

          return this->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP,E_CONNECT_FAILED);
        }

        // send the next SYN

        if(retry!=_params.tcp_connectMaxRetries)
          conn->sendSyn();

      } while(retry++<_params.tcp_connectMaxRetries);

      // retries exhausted

      return this->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP,E_TIMEOUT);
    }


    /**
     * Connect to a remote endpoint and port. The interval between retries and the number of retries that are
     * attempted can be configured in the Parameters class. A random local port from the ephemeral range will
     * be selected. This asynchronous method requires you to subscribe to the TcpConnectionStateChangedEvent
     * This is not IRQ safe.
     * @param remoteAddress The remote IP address to connect to
     * @param remotePort The remote server port to connect to
     * @param connection The new connection object. Delete when you're done.
     * @tparam TConnection Your most-derived subclass of TcpConnection that you're using to handle the connection.
     * @return true if it works, false if not
     */

    template<class TNetworkLayer>
    template<class TConnection>
    bool Tcp<TNetworkLayer>::tcpConnectAsync(const IpAddress& remoteAddress,
                                        uint16_t remotePort,
                                        TConnection *&connection) {

      uint16_t localPort;

      // get a port from the ephemeral range

      if(!this->ip_acquireEphemeralPort(localPort))
        return false;

      // connect with all parameters

      if(!tcpConnectAsync(remoteAddress,localPort,remotePort,connection)) {

        // didn't work, release the local port

        this->ip_releaseEphemeralPort(localPort);
        return false;
      }

      // worked

      return true;
    }


    /**
     * Connect to a remote endpoint and port. The interval between retries and the number of retries that are
     * attempted can be configured in the Parameters class. You specify the local port number, which must be from
     * the ephemeral range. This asynchronous method requires you to subscribe to the TcpConnectionStateChangedEvent
     * and look out for a move away from SYN_SENT to ESTABLISHED in the successful case or anything else in
     * the case of an error. You must handle timeout and retry logic yourself by calling sendSyn() when you want
     * to retry.
     * This is not IRQ safe.
     * @param remoteAddress The remote IP address to connect to
     * @param remotePort The remote server port to connect to
     * @param connection The new connection object. Delete when you're done.
     * @tparam TConnection Your most-derived subclass of TcpConnection that you're using to handle the connection.
     * @return true if it works, false if not
     */

    template<class TNetworkLayer>
    template<class TConnection>
    bool Tcp<TNetworkLayer>::tcpConnectAsync(const IpAddress& remoteAddress,
                                        uint16_t localPort,
                                        uint16_t remotePort,
                                        TConnection *&connection) {

      // create and initialise the new connection. this will send the first SYN

      connection=nullptr;
      connection=new TConnection;

      if(!connection->initialise(
                        *this,
                        *this,
                        remoteAddress,
                        localPort,
                        remotePort,
                        this->getDatalinkMtuSize()-IpPacketHeader::getNoOptionsHeaderSize()-TcpHeader::getNoOptionsHeaderSize(),
                        this->getDatalinkTransmitHeaderSize()+this->getIpTransmitHeaderSize())) {

        // failed, clean up

        delete connection;
        connection=nullptr;
        return false;
      }

      return true;
    }


    /**
     * Get a reference to the TCP parameters object
     * @return A reference to the parameters
     */

    template<class TNetworkLayer>
    typename Tcp<TNetworkLayer>::Parameters& Tcp<TNetworkLayer>::tcpGetParameters() {
      return _params;
    }
  }
}

// END FILE: ../lib/include/net/transport/tcp/Tcp.h
// START FILE: ../lib/include/net/transport/tcp/TcpFindConnectionNotificationEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event used to find an existing TCP connection that matches
     * the given source and destination ports
     */

    class TcpConnection;

    struct TcpFindConnectionNotificationEvent : NetEventDescriptor {

      const IpAddress& remoteAddress;       ///< the remote address
      uint16_t localPort;                     ///< local port
      uint16_t remotePort;                    ///< remote port

      TcpConnection *tcpConnection;           ///< the connection if found, nullptr if not


      /**
       * Constructor
       * @param raddr The remote address
       * @param sPort The source port (remote end)
       * @param dPort The destination port (local end)
       */

      TcpFindConnectionNotificationEvent(const IpAddress& raddr,uint16_t sPort,uint16_t dPort)
        : NetEventDescriptor(NetEventType::TCP_FIND_CONNECTION),
          remoteAddress(raddr),
          localPort(dPort),
          remotePort(sPort),
          tcpConnection(nullptr) {
      }
    };
  }
}

// END FILE: ../lib/include/net/transport/tcp/TcpFindConnectionNotificationEvent.h
// START FILE: ../lib/include/net/transport/tcp/TcpServerReleasedEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for a TCP server being released
     */

    class TcpServerBase;

    struct TcpServerReleasedEvent : NetEventDescriptor {

      const TcpServerBase& server;

      /**
       * Constructor
       * @param s The server being released
       */

      TcpServerReleasedEvent(const TcpServerBase& s)
        : NetEventDescriptor(NetEventDescriptor::NetEventType::TCP_SERVER_RELEASED),
          server(s) {
      }
    };
  }
}

// END FILE: ../lib/include/net/transport/tcp/TcpServerReleasedEvent.h
// START FILE: ../lib/include/net/transport/tcp/TcpConnectionDataReadyEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * TCP connection data ready event. This event signifies that we have buffered
     * some data from the remote end that the application should consume.
     */

    class TcpConnection;

    struct TcpConnectionDataReadyEvent : NetEventDescriptor {

      /**
       * Reference to the TCP connection object.
       */

      TcpConnection& connection;

      /**
       * Constructor
       * @param The connection reference
       */

      TcpConnectionDataReadyEvent(TcpConnection& c)
        : NetEventDescriptor(NetEventDescriptor::NetEventType::TCP_CONNECTION_DATA_READY),
          connection(c) {
      }
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpConnectionDataReadyEvent.h
// START FILE: ../lib/include/net/transport/tcp/TcpTransmitWindow.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * The sliding transmit window. This class manages the following variables.
     *
     *          |<       sendWindow        >|
     * +-----------------------------------------
     * |        |                 |         |
     * +-----------------------------------------
     *          ^                 ^
     *     sendUnacknowleged     sendNext
     */

    struct TcpTransmitWindow {
      uint32_t sendUnacknowledged;      ///< seq num of first byte of data sent but not acked
      uint32_t sendNext;                ///< seq num of next byte of data to be sent
      uint16_t sendWindow;              ///< send window (starts at _sendUnacknowledged)
    };
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpTransmitWindow.h
// START FILE: ../lib/include/net/transport/tcp/TcpOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * An input stream for writing to a TCP connection. The stream is unbuffered which makes
     * it quite inefficient for the network if small data items are repeatedly pushed to it.
     */

    class TcpOutputStream : public OutputStream {

      public:
        enum {
          E_CONNECTION_CLOSED = 1      ///< The connection was closed while we were writing to it
        };

      protected:
        TcpConnection& _conn;

      public:
        TcpOutputStream(TcpConnection& conn);

        // overrides from OutputStream

        virtual bool write(uint8_t c) override;
        virtual bool write(const void *buffer,uint32_t size) override;
        virtual bool flush() override;
        virtual bool close() override;
    };


    /**
     * Constructor
     */

    inline TcpOutputStream::TcpOutputStream(TcpConnection& conn)
      : _conn(conn) {
    }


    /**
     * Write a single byte. Not efficient!
     * @param c The byte to write
     * @return true if it worked
     */

    inline bool TcpOutputStream::write(uint8_t c) {
      return write(&c,1);
    }


    /**
     * Write a stream of bytes
     * @param buffer The buffer address
     * @param size The number of bytes to write
     */

    inline bool TcpOutputStream::write(const void *buffer,uint32_t size) {

      const uint8_t *ptr;
      uint32_t actuallySent;

      ptr=reinterpret_cast<const uint8_t *>(buffer);
      while(size) {

        // try to send everything

        if(!_conn.send(ptr,size,actuallySent))
          return false;

        // check for connection closed

        if(actuallySent==0)
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_TCP_OUTPUT_STREAM,E_CONNECTION_CLOSED);

        // something went out, decrement and loop if all did not go

        size-=actuallySent;
        ptr+=actuallySent;
      }

      return true;
    }


    /**
     * Cannot flush, not an error either
     * @return true
     */

    inline bool TcpOutputStream::flush() {
      return true;
    }


    /**
     * Cannot close, not an error either. The underlying connection must be deleted to close it
     * @return true
     */

    inline bool TcpOutputStream::close() {
      return true;
    }
  }
}
// END FILE: ../lib/include/net/transport/tcp/TcpOutputStream.h
// START FILE: ../lib/include/net/transport/tcp/TcpConnectionReleasedEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor for a TCP connection being released
     */

    class TcpConnection;

    struct TcpConnectionReleasedEvent : NetEventDescriptor {

      const TcpConnection& connection;

      /**
       * Constructor
       * @param c The connection being released
       */

      TcpConnectionReleasedEvent(const TcpConnection& c)
        : NetEventDescriptor(NetEventDescriptor::NetEventType::TCP_CONNECTION_RELEASED),
          connection(c) {
      }
    };
  }
}

// END FILE: ../lib/include/net/transport/tcp/TcpConnectionReleasedEvent.h
// START FILE: ../lib/include/net/transport/TransportLayer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Template feature-holder for features that live in the transport
     * layer of the stack, e.g. the TCP and UDP protocols. The next level
     * down is the network layer and the next level up is the application
     * layer (we omit session and presentation layers). The features
     * must themselves be templated on, and virtually inherit from TNetworkLayer
     * so that the stack is correctly formed.
     */

    template<class TNetworkLayer,template<class> class... Features>
    class TransportLayer : public virtual TNetworkLayer,
                           public Features<TNetworkLayer>... {

      public:

        /**
         * Base parameters collection-class for transport features
         */

        struct Parameters : TNetworkLayer::Parameters,
                            Features<TNetworkLayer>::Parameters... {
        };

      public:
        bool initialise(Parameters& params);
        bool startup();
    };


    /**
     * Initialise the features after initialising upwards first
     * @param params The parameters class to initialise the layer features
     * @return true if it worked
     */

    template<class TNetworkLayer,template<class> class... Features>
    bool TransportLayer<TNetworkLayer,Features...>::initialise(Parameters& params) {
      return TNetworkLayer::initialise(params) &&
             RecursiveBoolInitWithParams<TransportLayer,Features<TNetworkLayer>...>::tinit(this,params);
    }


    /**
     * Startup the components in this layer
     * @return
     */

    template<class TNetworkLayer,template<class> class... Features>
    bool TransportLayer<TNetworkLayer,Features...>::startup() {
      return TNetworkLayer::startup() &&
             RecursiveBoolStartup<TransportLayer,Features<TNetworkLayer>...>::tstartup(this);
    }
  }
}
// END FILE: ../lib/include/net/transport/TransportLayer.h
// START FILE: ../lib/include/net/NetworkIntervalTicker.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event signature for the interval callback
     */

    DECLARE_EVENT_SIGNATURE(NetworkIntervalTick,void (uint32_t& interval));


    /**
     * Tick data passed to the callback
     */

    struct NetworkIntervalTickData {

      uint32_t& interval;                 ///< tick interval - can be modified by the caller
      uint32_t timeNow;                   ///< the current time

      NetworkIntervalTickData(uint32_t& i,uint32_t now)
        : interval(i),
          timeNow(now) {
      }
    };


    /**
     * Many of the caches and algorithms within the stack have timeouts or other
     * course-grained thresholds. This class provides the ability to subscribe to an
     * event that will call you after N seconds. The finest granularity is 1 second.
     */

    class NetworkIntervalTicker {

      public:
        typedef wink::slot<void (NetworkIntervalTickData&)> TickIntervalSlotType;

        /**
         * Parameters class
         */

        struct Parameters {
          RtcSecondInterruptFeature *base_rtc;            ///< Cannot be nullptr, an RTC is required
        };

      protected:


        /**
         * Subscriber information structure.
         */

        struct SubscriberInfo {
          uint32_t nextCall;
          uint32_t interval;
          TickIntervalSlotType delegate;
        };

        RtcBase *_rtc;
        RtcSecondInterruptFeature *_rtcInterruptFeature;
        std::slist<SubscriberInfo> _subscribers;
        bool _ready;

      protected:
        void onTickF4(uint8_t extiNumber);      ///< The raw per-second ticker
        void onTick();

      public:
        bool initialise(Parameters& params);
        bool startup();

        void subscribeIntervalTicks(uint32_t interval,const TickIntervalSlotType& delegate);
        void updateIntervalTickSubscription(uint32_t interval,const TickIntervalSlotType& delegate);

        const RtcBase& getRtc() const;
        RtcSecondInterruptFeature& getRtcSecondInterruptFeature() const;
    };


    /**
     * Initialise the class
     * @param rtcInterruptFeature The RTC's interrupt feature
     * @return true if it worked
     */

    inline bool NetworkIntervalTicker::initialise(Parameters& params) {

      // not started up

      _ready=false;

      // remember parameters

      _rtcInterruptFeature=params.base_rtc;
      _rtc=&static_cast<RtcBase&>(*_rtcInterruptFeature);

      // subscribe to the interrupts. this is a bit different between the F1 and F4 because
      // the RTC on those devices is so different.

#if defined(STM32PLUS_F4)
      _rtcInterruptFeature->ExtiInterruptEventSender.insertSubscriber(ExtiInterruptEventSourceSlot::bind(this,&NetworkIntervalTicker::onTickF4));
#elif defined(STM32PLUS_F1_CL_E)
      _rtcInterruptFeature->RtcSecondInterruptEventSender.insertSubscriber(RtcSecondInterruptEventSourceSlot::bind(this,&NetworkIntervalTicker::onTick));
#else
      #error Unsupported MCU
#endif

      return true;
    }


    /**
     * Startup the class
     * @return true if it worked
     */

    inline bool NetworkIntervalTicker::startup() {

      // start the second interrupt

      _ready=true;
      _rtcInterruptFeature->enableSecondInterrupt();

      return true;
    }


    /**
     * Get the RTC base class
     * @return The RTC base
     */

    inline const RtcBase& NetworkIntervalTicker::getRtc() const {
      return *_rtc;
    }


    /**
     * Get the RTC second interrupt feature class
     * @return The feature class
     */

    inline RtcSecondInterruptFeature& NetworkIntervalTicker::getRtcSecondInterruptFeature() const {
      return *_rtcInterruptFeature;
    }


    /**
     * Subscribe to ticks by interval. The first callback will be after the first interval period and then at
     * subsequent interval periods ad-infinitum unless modified by the caller. Must not be called from IRQ code
     * because the list structure is modified here. Should only be called during module initialise() so that the
     * list remains stable during operation.
     * @param interval The interval in seconds. An interval of zero creates this callback initially disabled.
     * @param delegate The delegate to call back on
     */

    inline void NetworkIntervalTicker::subscribeIntervalTicks(uint32_t interval,const TickIntervalSlotType& delegate) {

      SubscriberInfo si;

      // set up the subscriber info and add to the list

      si.delegate=delegate;
      si.interval=interval;

      if(interval)
        si.nextCall=interval+_rtc->getTick();
      else
        si.nextCall=0;

      _subscribers.push_front(si);
    }


    /**
     * Update an existing subscription with a new next-tick interval.
     * @param interval The new interval, which may be zero to disable ticking.
     * @param delegate The delegate to call back (this is used as the comparator when searching for the existing subscription)
     */

    inline void NetworkIntervalTicker::updateIntervalTickSubscription(uint32_t interval,const TickIntervalSlotType& delegate) {

      for(auto it=_subscribers.begin();it!=_subscribers.end();it++) {

        if(it->delegate==delegate) {

          // found it, update values

          it->interval=interval;

          if(interval)
            it->nextCall=interval+_rtc->getTick();

          return;
        }
      }
    }


    /**
     * The raw per-second ticker from the RTC. This is IRQ code.
     */

    inline void NetworkIntervalTicker::onTickF4(uint8_t /* extiNumber */) {
      onTick();
    }

    inline void NetworkIntervalTicker::onTick() {

      uint32_t now;

      // return immediately if startup() has not yet happened

      if(!_ready)
        return;

      // get the current time

      now=_rtc->getTick();

      for(auto it=_subscribers.begin();it!=_subscribers.end();it++) {

        // need to call?

        if(it->interval && now>=it->nextCall) {

          // call it

          NetworkIntervalTickData nitd(it->interval,now);

          it->delegate(nitd);

          // this is when it'll tick next

          if(it->interval)
            it->nextCall=now+it->interval;
        }
      }
    }
  }
}
// END FILE: ../lib/include/net/NetworkIntervalTicker.h
// START FILE: ../lib/include/net/NetworkEvents.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Declare the signatures for the transmit, receive, error and notification events. Splitting the
     * events out into separate slots makes it more efficient at dispatch time as there will be fewer
     * false calls.
     */

    DECLARE_EVENT_SIGNATURE(NetworkReceive,void (NetEventDescriptor&));
    DECLARE_EVENT_SIGNATURE(NetworkSend,void (NetEventDescriptor&));
    DECLARE_EVENT_SIGNATURE(NetworkError,void (NetEventDescriptor&));
    DECLARE_EVENT_SIGNATURE(NetworkNotification,void (NetEventDescriptor&));

    /**
     * Network events base classes. Just declares the event slot that
     * users can subscribe to and raise events from. The PhysicalLayer gets to inherit
     * from these because it's at the top of stack.
     */

    struct NetworkReceiveEvents {
      DECLARE_EVENT_SOURCE(NetworkReceive);
    };

    struct NetworkSendEvents {
      DECLARE_EVENT_SOURCE(NetworkSend);
    };

    struct NetworkNotificationEvents {
      DECLARE_EVENT_SOURCE(NetworkNotification);
    };

    struct NetworkErrorEvents {

      DECLARE_EVENT_SOURCE(NetworkError);

      /**
       * Set an error in the error provider and raise an event
       */

      bool setError(int provider,uint32_t code,uint32_t cause=0) const {
        NetworkErrorEventSender.raiseEvent(NetworkErrorEvent(provider,code,cause));
        return false;
      }
    };
  }
}
// END FILE: ../lib/include/net/NetworkEvents.h
// START FILE: ../lib/include/net/application/IpDnsServersAnnouncementEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor that announces a new set of DNS servers (up to 3)
     */

    struct IpDnsServersAnnouncementEvent : NetEventDescriptor {

      /**
       * Up to 3 DNS servers, call isValid() to find the end of the set if less than 3
       */

      const IpAddress *ipDnsServers;


      /**
       * Constructor
       */

      IpDnsServersAnnouncementEvent(const IpAddress *dnsServers)
        : NetEventDescriptor(NetEventType::DNS_SERVERS_ANNOUNCEMENT),
          ipDnsServers(dnsServers) {
      }
    };
  }
}
// END FILE: ../lib/include/net/application/IpDnsServersAnnouncementEvent.h
// START FILE: ../lib/include/net/application/ping/Ping.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Application layer feature to provide the functionality of the "Ping" application
     * that sends and receives ICMP packets
     */

    template<class TTransportLayer>
    class Ping : public virtual TTransportLayer {

      public:
        struct Parameters {
          uint32_t ping_timeout;          ///< 1000ms is the default
          const uint8_t *ping_data;       ///< the alphabet is the default if this is null
          uint32_t ping_dataLength;       ///< only matters if ping_data is not null
          uint8_t ping_ttl;               ///< default (0) lets the IP layer use its configured value

          Parameters() {
            ping_timeout=1000;
            ping_data=nullptr;
            ping_ttl=0;
          }
        };

        /**
         * error codes
         */

        enum {
          E_TIMEOUT = 1,                  ///< timed out waiting for a response
          E_ERROR_REPLY                   ///< got a reply, but it was an error
        };

      protected:
        Parameters _params;               ///< stored parameters
        uint16_t _nextId;                 ///< the next identifier to put into a ping packet

        volatile bool _waiting;           ///< reset by the onReceive IRQ when we get a reply or error
        IcmpType _icmpType;             ///< taken from the ICMP reply/error packet header
        IcmpCode _icmpCode;             ///< taken from the ICMP reply/error packet header

        /**
         * struct that we can cast directly on to the ping payload
         */

        struct PingData {
          uint32_t millis;          ///< timestamp
          uint8_t data[1];          ///< variable length data
        } __attribute__((packed));

      protected:
        void onReceive(NetEventDescriptor& ned);

      public:
        bool initialise(const Parameters& params);
        bool startup();

        bool ping(const IpAddress& host,uint32_t& elapsed);

        uint32_t pingGetElapsed() const;
        IcmpType pingGetIcmpType() const;
    };


    /**
     * Initialise the class
     * @param params The parameters
     * @return true if it worked
     */

    template<class TTransportLayer>
    inline bool Ping<TTransportLayer>::initialise(const Parameters& params) {

      static const char *_defaultData="abcdefghijklmnopqrstuvwxyz";

      // remember params

      _params=params;

      if(_params.ping_data==nullptr) {
        _params.ping_data=reinterpret_cast<const uint8_t *>(_defaultData);
        _params.ping_dataLength=26;
      }

      // next id is zero

      _nextId=0;
      _waiting=false;

      // subscribe to receive events from the network

      this->NetworkReceiveEventSender.insertSubscriber(NetworkReceiveEventSourceSlot::bind(this,&Ping<TTransportLayer>::onReceive));
      return true;
    }


    /**
     * Startup the feature
     * @return true
     */

    template<class TTransportLayer>
    inline bool Ping<TTransportLayer>::startup() {
      return true;
    }


    /**
     * Ping the host and wait for a reply - once only
     * @param host The IP address of the host to ping.
     * @param elapsed The elapsed time in ms. for a successful ping.
     * @return true if a reply was received, false otherwise.
     */

    template<class TTransportLayer>
    inline bool Ping<TTransportLayer>::ping(const IpAddress& host,uint32_t& elapsed) {

      uint32_t sent;

      // send the echo request

      _waiting=true;
      elapsed=0;

      sent=MillisecondTimer::millis();
      this->icmpSendEchoRequest(host,_nextId,_params.ping_data,_params.ping_dataLength,_params.ping_ttl);

      // wait for a response or timeout

      while(_waiting) {

        elapsed=MillisecondTimer::millis()-sent;

        if(elapsed>_params.ping_timeout) {

          // timed out, don't reuse this id so soon

          _nextId++;
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_PING,E_TIMEOUT);
        }
      }

      // got a response

      _nextId++;

      // echo reply is a good response

      if(_icmpType==IcmpType::ECHO_REPLY)
        return true;

      // anything else is an error

      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_PING,E_ERROR_REPLY);
    }


    /**
     * Receive notification callback. We're interested in ICMP receive events
     * that we can use to correlate against the messages we send.
     * @param ned The network event descriptor base classes
     */

    template<class TTransportLayer>
    inline void Ping<TTransportLayer>::onReceive(NetEventDescriptor& ned) {

      // only interested in ICMP packets

      if(ned.eventType!=NetEventDescriptor::NetEventType::ICMP_PACKET)
        return;

      // not interested unless we solicited this packet

      if(!_waiting)
        return;

      // get the ICMP event

      IcmpPacketEvent& rxevent(static_cast<IcmpPacketEvent&>(ned));

      // not interested if it's not a possible response to a ping

      IcmpType type=rxevent.icmpPacket.icmp_type;

      if(type!=IcmpType::ECHO_REPLY && type!=IcmpType::DESTINATION_UNREACHABLE)
        return;

      // not interested if the id doesn't match the one we're waiting for
      // reply and error messages have the id in the same header position

      if(static_cast<IcmpEchoReply&>(rxevent.icmpPacket).icmp_sequenceNumber!=NetUtil::htons(_nextId))
        return;

      // extract the type/code and set the found flag to release the caller

      _icmpType=rxevent.icmpPacket.icmp_type;
      _icmpCode=rxevent.icmpPacket.icmp_code;

      _waiting=false;
    }


    /**
     * Get the ICMP type code
     * @return The type code
     */

    template<class TTransportLayer>
    inline IcmpType Ping<TTransportLayer>::pingGetIcmpType() const {
      return _icmpType;
    }
  }
}
// END FILE: ../lib/include/net/application/ping/Ping.h
// START FILE: ../lib/include/net/application/http/HttpVersion.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

namespace stm32plus {
  namespace net {


    /**
     * HTTP version enumeration
     */

    enum class HttpVersion : uint8_t {
      HTTP_1_0,         // version 1.0 (1 request per connection)
      HTTP_1_1          // version 1.1 (connection keep alive)
    };
  }
}
// END FILE: ../lib/include/net/application/http/HttpVersion.h
// START FILE: ../lib/include/net/application/http/HttpClient.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    class HttpClient {

      public:

        /**
         * Error codes
         */

        enum {
          E_INVALID_METHOD,     ///< only GET and POST are supported
          E_INVALID_RESPONSE,   ///< could not parse the first line of the response
          E_TIMED_OUT           ///< timed out while sending/receiving
        };

      protected:
        TcpConnection& _conn;                       ///< reference to the TCP connection

        std::slist<std::string> _requestHeaders;    ///< headers to set on the request
        HttpVersion _httpVersion;                   ///< protocol version, default is 1.1
        HttpMethod _httpMethod;                     ///< method, default is GET
        std::string _uri;                           ///< URI for the request (no host and no protocol)
        std::string _host;                          ///< the Host: header value (mandatory for HTTP/1.1)

        uint16_t _maxResponseHeaderLineLength;      ///< maximum length of a response header line before we truncate it. default is 100.
        std::slist<std::string> _responseHeaders;   ///< response header list
        uint16_t _responseCode;                     ///< HTTP response code number
        int32_t _responseContentLength;             ///< content length of response, or -1 if server not sent
        std::string _responseContentType;           ///< response content type, or empty if server not sent

      public:
        HttpClient(TcpConnection& conn);

        bool sendRequest(uint32_t timeoutMillis=0);
        bool readResponse(uint32_t timeoutMillis=0);

        void setVersion(HttpVersion version);
        void setMethod(HttpMethod method);
        void setUri(const std::string& uri);
        void setHost(const std::string& host);
        void setRequestContentType(const std::string& contentType);
        void setRequestContentLength(uint32_t contentLength);

        uint16_t getResponseCode() const;
        int32_t getResponseContentLength() const;
        const std::string& getResponseContentType() const;
        const std::slist<std::string>& getResponseHeaders() const;
    };


    /**
     * Constructor, initialise the stream constructors and some defaults
     * @param The TCP connection to use
     */

    inline HttpClient::HttpClient(TcpConnection& conn)
      : _conn(conn) {

      _httpVersion=HttpVersion::HTTP_1_1;
      _httpMethod=HttpMethod::GET;
      _maxResponseHeaderLineLength=100;
    }


    /**
     * Convenience method to set the Content-Type header for POST-type requests
     * @param contentType The content type string
     */

    inline void HttpClient::setRequestContentType(const std::string& contentType) {
      _requestHeaders.push_front("Content-Type: "+contentType);
    }


    /**
     * Set the Content-Length header for POST-type requests
     * @param contentLength The content length, in bytes.
     */

    inline void HttpClient::setRequestContentLength(uint32_t contentLength) {

      char buffer[30];

      strcpy(buffer,"Content-Length: ");
      StringUtil::modp_uitoa10(contentLength,buffer+16);

      _requestHeaders.push_front(buffer);
    }


    /**
     * Set the http version
     * @param version The http version
     */

    inline void HttpClient::setVersion(HttpVersion version) {
      _httpVersion=version;
    }


    /**
     * Set the HTTP method
     * @param method The HTTP method
     */

    inline void HttpClient::setMethod(HttpMethod method) {
      _httpMethod=method;
    }


    /**
     * Set the HTTP URI
     * @param uri The URI
     */

    inline void HttpClient::setUri(const std::string& uri) {
      _uri=uri;
    }


    /**
     * Set the HTTP host (mandatory for HTTP/1.1)
     * @param host The host
     */

    inline void HttpClient::setHost(const std::string& host) {
      _host=host;
    }


    /**
     * Connect to the remote server, send the request line and headers.
     *
     * If this is a GET request then the response code and response content length will be
     * available to read and then the methods of the TcpConnection and TcpInputStream parents
     * are available to read the response body.
     *
     * If this is a request that requires a body (e.g. POST) then the methods of TcpConnection
     * and TcpOutputStream can be used to send the post content. When the content has been sent
     * you must manually call readResponse().
     * You can then use the methods of TcpConnection and TcpInputStream to read the response body.
     *
     * @param timeoutMillis how long to wait for a send or receive to complete (0=blocking), default is zero.
     * @return true if it worked, false if there was a network error
     */

    inline bool HttpClient::sendRequest(uint32_t timeoutMillis) {

      // embed this in a subcontext so the request string is destructed before
      // the automatic call to readResponse

      {
        std::string request;
        uint32_t actuallySent;

        // all the methods are supported

        if(_httpMethod==HttpMethod::POST)
          request="POST ";
        else if(_httpMethod==HttpMethod::GET)
          request="GET ";
        else if(_httpMethod==HttpMethod::HEAD)
          request="HEAD ";
        else if(_httpMethod==HttpMethod::PUT)
          request="PUT ";
        else if(_httpMethod==HttpMethod::DELETE)
          request="DELETE ";
        else if(_httpMethod==HttpMethod::TRACE)
          request="TRACE ";
        else if(_httpMethod==HttpMethod::CONNECT)
          request="CONNECT ";
        else
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_HTTP_CLIENT,E_INVALID_METHOD);

        // add the URI

        request+=_uri;

        // add the version

        if(_httpVersion==HttpVersion::HTTP_1_0)
          request+=" HTTP/1.0\r\n";
        else
          request+=" HTTP/1.1\r\n";

        // add the Host header

        request+="Host: "+_host+"\r\n";

        // add user headers

        for(auto it=_requestHeaders.begin();it!=_requestHeaders.end();it++)
          request+=*it+"\r\n";

        // add the termination blank line

        request+="\r\n";

        // send it to the server

        if(!_conn.send(request.c_str(),request.length(),actuallySent,timeoutMillis) || actuallySent!=request.length())
          return false;
      }

      // if this was a GET then automatically read the response

      if(_httpMethod==HttpMethod::GET)
        return readResponse(timeoutMillis);

      return true;
    }


    /**
     * Read the response from the server up to and including the headers. The response code is made available
     * by calling getResponseCode() and the headers by calling getResponseHeaders(). You only call this method
     * if you are using a POST request. sendRequest() calls it automatically for GET requests.
     *
     * @param timeoutMillis how long to wait for a send or receive to complete (0=blocking), default is zero.
     * @return true if it worked, false if there was a network error
     */

    inline bool HttpClient::readResponse(uint32_t timeoutMillis) {

      TcpTextLineReceiver lineReceiver(_maxResponseHeaderLineLength);
      std::string::size_type pos1,pos2;
      uint32_t now;

      if(timeoutMillis)
        now=MillisecondTimer::millis();
      else
        now=0;

      // read the response line

      while(!lineReceiver.ready()) {

        if(!lineReceiver.add(_conn))
          return false;

        if(timeoutMillis && MillisecondTimer::hasTimedOut(now,timeoutMillis))
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_HTTP_CLIENT,E_TIMED_OUT);
      }

      // get the status code from the response line

      const std::string& statusLine(lineReceiver.str());

      if((pos1=statusLine.find(' '))==std::string::npos || (pos2=statusLine.find(' ',pos1+1))==std::string::npos)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_HTTP_CLIENT,E_INVALID_RESPONSE);

      _responseCode=atoi(statusLine.substr(pos1+1,pos2-pos1+1).c_str());

      // read the headers

      _responseHeaders.clear();
      _responseContentType.clear();
      _responseContentLength=-1;

      for(;;) {

        // reset the line

        lineReceiver.reset();

        // read the next line

        while(!lineReceiver.ready()) {

          if(!lineReceiver.add(_conn))
            return false;

          if(timeoutMillis && MillisecondTimer::hasTimedOut(now,timeoutMillis))
            return errorProvider.set(ErrorProvider::ERROR_PROVIDER_NET_HTTP_CLIENT,E_TIMED_OUT);
        }

        // finished?

        const std::string& headerLine(lineReceiver.str());
        if(headerLine.length()==0)
          break;

        if((pos1=headerLine.find(':'))!=std::string::npos) {

          // advance past white space

          for(pos1++;pos1!=headerLine.length() && isspace(headerLine[pos1]);pos1++);

          if(pos1!=headerLine.length()) {

            // check for content-type and content-length

            if(!strncasecmp(headerLine.c_str(),"Content-Type",12))
              _responseContentType=headerLine.substr(pos1);
            else if(!strncasecmp(headerLine.c_str(),"Content-Length",14))
              _responseContentLength=atol(headerLine.substr(pos1).c_str());
          }

          // add the header line

          _responseHeaders.push_front(lineReceiver.str());
        }
      }

      // we've read the headers

      return true;
    }


    /**
     * Return the last response code
     * @return The response code
     */

    inline uint16_t HttpClient::getResponseCode() const {
      return _responseCode;
    }


    /**
     * Return the last response headers
     * @return The last response headers
     */

    inline const std::slist<std::string>& HttpClient::getResponseHeaders() const {
      return _responseHeaders;
    }


    /**
     * Return the response content length. The value is -1 if the content length was
     * not provided.
     * @return The content length, or -1 if the server did not set it
     */

    inline int32_t HttpClient::getResponseContentLength() const {
      return _responseContentLength;
    }


    /**
     * Get the response content type, or empty string if not set by the server
     * @return The content type
     */

    inline const std::string& HttpClient::getResponseContentType() const {
      return _responseContentType;
    }
  }
}
// END FILE: ../lib/include/net/application/http/HttpClient.h
// START FILE: ../lib/include/net/application/http/HttpServerConnection.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {

    /**
     * HttpServerConnection provides a derivation of TcpConnection that understands how
     * to receive an HTTP request and transmit the response. The actual work of processing
     * the request is delegated to your subclass once the request has been received and
     * parsed. This template follows the CRTP pattern of you parameterising it with your
     * implementation.
     *
     * We support HTTP/1.1 and HTTP/1.0 connections. In HTTP/1.1 mode
     */

    template<class TImpl>
    class HttpServerConnection : public TcpConnection {

      public:

        /**
         * Parameters for this class
         */

        struct Parameters : TcpConnection::Parameters {

          bool http_version11;                      ///< are we operating in HTTP/1.1 mode? default is true.
          uint16_t http_maxRequestLineLength;       ///< size includes the verb, URL and HTTP version. Default is 200
          uint16_t http_outputStreamBufferMaxSize;  ///< buffer size of the stream-of-streams class. Default is 256
          uint16_t http_maxRequestsPerConnection;   ///< in http1.1, close connection after this many requests. 0 = never, default is 5.

          Parameters() {
            http_version11=false;
            http_maxRequestLineLength=200;
            http_outputStreamBufferMaxSize=256;
            http_maxRequestsPerConnection=5;
          }
        };

      protected:
        const Parameters& _params;          ///< reference to the parameters class
        uint32_t _contentLength;            ///< value of the Content-Length header
        OutputStream *_requestBody;         ///< derivation sets this non-null when it wants the request body
        uint32_t _responseSize;             ///< derivation sets this non-zero along with response body so Content-Length header can be sent back to client
        TcpTextLineReceiver _currentLine;   ///< current line that we're processing
        TcpOutputStreamOfStreams _output;   ///< the output streams that form the response
        uint16_t _requestsServed;           ///< count of requests served so far
        std::string _version;
        std::string _action;
        std::string _uri;

        /**
         * States that we transition through while processing a request
         */

        enum class State : uint8_t {

          READING_REQUEST_LINE,         ///< Reading the first line, e.g. GET /index.html HTTP/1.1
          READING_REQUEST_HEADERS,      ///< Reading the request headers
          READING_REQUEST_BODY,         ///< Reading the request body
          WRITING_BEGIN,                ///< Writing is ready to start
          WRITING_RESPONSE,             ///< Writing back the response from the stream of streams
        } _state;

      protected:
        HttpServerConnection(const Parameters& params);

        void changeState(State newState);
        void processRequestHeader(const std::string& header);

        void addConnectionHeader(std::string& response);
        void addContentTypeHeader(std::string& response);
        void addContentTypeHeader(std::string& response,const char *contentType);
        void addContentLengthHeader(std::string& response,uint32_t contentLength);

        void readRequestLine();
        void readRequestHeaders();
        void readRequestBody();
        void parseRequestLine();
        std::string decodeUri(const std::string& uri);

      public:
        bool handleRead();              ///< implementation requirement from the TcpConnectionArray
        bool handleWrite();             ///< implementation requirement from the TcpConnectionArray
    };


    /**
     * Constructor
     */

    template<class TImpl>
    inline HttpServerConnection<TImpl>::HttpServerConnection(const Parameters& params)
      : TcpConnection(params),
        _params(params),
        _contentLength(0),
        _requestBody(nullptr),
        _responseSize(0),
        _currentLine(params.http_maxRequestLineLength),
        _output(*this,params.http_outputStreamBufferMaxSize),
        _requestsServed(0),
        _state(State::READING_REQUEST_LINE) {
    }


    /**
     * Some data is ready for reading
     * @return true always: we don't want to ever abandon the client's wait() call
     */

    template<class TImpl>
    inline bool HttpServerConnection<TImpl>::handleRead() {

      while(getDataAvailable()) {

        switch(_state) {

          case State::READING_REQUEST_LINE:       // first line of a request. contains the verb, URL, http version
            readRequestLine();
            break;

          case State::READING_REQUEST_HEADERS:
            readRequestHeaders();
            break;

          case State::READING_REQUEST_BODY:
            readRequestBody();
            break;

          default:                // not a read state
            return true;
        }
      }

      return true;
    }


    /**
     * Read the request line
     */

    template<class TImpl>
    inline void HttpServerConnection<TImpl>::readRequestLine() {

      _currentLine.add(*this);

      if(_currentLine.ready()) {
        parseRequestLine();
        changeState(State::READING_REQUEST_HEADERS);
        _currentLine.reset();
      }
    }


    /**
     * Parse the request line: ACTION SP URI SP PROTOCOL
     * e.g. GET http://www.foo.com/this/file.html HTTP/1.1
     * e.g. GET /this/file.html HTTP/1.1
     */

    template<class TImpl>
    inline void HttpServerConnection<TImpl>::parseRequestLine() {

      std::string::size_type pos,pos2;
      const std::string& request(_currentLine.str());

      if((pos=request.find(' '))!=std::string::npos) {

        // first the action

        _action=request.substr(0,pos);

        if((pos2=request.find(' ',pos+1))!=std::string::npos) {

          // now URI and protocol

          _uri=decodeUri(request.substr(pos+1,pos2-pos-1));
          _version=request.substr(pos2+1);

          // URI may be absolute. deal with that.

          if((pos=_uri.find("://"))!=std::string::npos) {

            // found the abs prefix, find the URI at the end

            if((pos=_uri.find('/',pos+3))!=std::string::npos)
              _uri=_uri.substr(pos);      // URI found, keep it
            else
              _uri="/index.html";         // only host and protocol found, default to /index.html
          }
        }
      }
    }


    /**
     * Read the request headers
     */

    template<class TImpl>
    inline void HttpServerConnection<TImpl>::readRequestHeaders() {

      _currentLine.add(*this);

      if(_currentLine.ready()) {

        if(_currentLine.length()==0) {
          if(_contentLength>0)
            changeState(State::READING_REQUEST_BODY);                       // there's a body to read
          else
            changeState(State::WRITING_BEGIN);                              // zero length = request complete
        }
        else {
          processRequestHeader(_currentLine);                               // got a header, see if we care about it
          static_cast<TImpl *>(this)->handleRequestHeader(_currentLine);    // notify the subclass
        }

        _currentLine.reset();                                               // ready for reading next header
      }
    }


    /**
     * Read the request body
     */

    template<class TImpl>
    inline void HttpServerConnection<TImpl>::readRequestBody() {

      uint8_t buf[100];
      uint32_t size,actuallyReceived;

      // loop until we've read all

      while(_contentLength && getDataAvailable()) {

        // read a chunk

        size=std::min((uint32_t)sizeof(buf),_contentLength);

        if(!receive(buf,size,actuallyReceived,0))
          return;

        // write or discard

        if(_requestBody)
          _requestBody->write(buf,actuallyReceived);

        // reduce data to read

        _contentLength-=size;
      }
    }


    /**
     * Some data is ready for writing
     * @return true always: we don't want to ever abandon the client's wait() call
     */

    template<class TImpl>
    inline bool HttpServerConnection<TImpl>::handleWrite() {

      if(_state==State::WRITING_BEGIN) {

        // WRITING_BEGIN exists so that a subclass can detect a state change from WRITING_BEGIN
        // to WRITING_RESPONSE and use it to open the resource demanded by the request. The subclass
        // should not use the state change *to* WRITING_BEGIN because that may happen in IRQ code
        // if fast reading is enabled.

        changeState(State::WRITING_RESPONSE);
      }
      else if(_state==State::WRITING_RESPONSE) {

        uint32_t actuallySent;

        if(!_output.writeDataToConnection(actuallySent)) {        // try to write data and kill the connection if it fails

          delete this;
          return true;
        }

        // any more data to write?

        if(_output.completed()) {

          _requestsServed++;

          // if this is not HTTP/1.1 or we have served the max number of connections then close the connection

          if(strcasecmp(_version.c_str(),"HTTP/1.1")!=0 ||
             !_params.http_version11 ||
             (_params.http_maxRequestsPerConnection && _requestsServed>=_params.http_maxRequestsPerConnection)) {

            delete this;
            return true;
          }

          // reset and move on to next request from client

          _contentLength=0;

          _action.clear();
          _uri.clear();
          _version.clear();

          changeState(State::READING_REQUEST_LINE);
        }
      }

      return true;
    }


    /**
     * Notify the subclass of a state change. The subclass can opt to change the next state.
     * @param newState the new state. The subclass can read _state to determine the old (current) state
     */

    template<class TImpl>
    inline void HttpServerConnection<TImpl>::changeState(State newState) {
      _state=static_cast<TImpl *>(this)->handleStateChange(newState);
    }


    /**
     * Process an incoming request header
     * @param header The header, as supplied by the client
     */

    template<class TImpl>
    inline void HttpServerConnection<TImpl>::processRequestHeader(const std::string& header) {

      std::string::size_type pos;

      // we only care about Content-Length since the client may be doing a POST

      if(!strcasecmp(header.c_str(),"Content-Length:")) {
        for(pos=15;pos!=header.length() && isspace(header[pos]);pos++);
        if(pos!=header.length())
          _contentLength=atoi(header.c_str()+pos);
      }
    }


    /**
     * Add the Connection: close/keep-alive header
     * @param response The response string
     */

    template<class TImpl>
    inline void HttpServerConnection<TImpl>::addConnectionHeader(std::string& response) {

      if(!strcasecmp(_version.c_str(),"HTTP/1.1") &&
          _params.http_version11 &&
          (_params.http_maxRequestsPerConnection==0 || _requestsServed!=_params.http_maxRequestsPerConnection-1))
        response+="Connection: keep-alive\r\n";
      else
        response+="Connection: close\r\n";
    }


    /**
     * Try to add a content-type header from a limited set of known types
     * @param response The response string
     */

    template<class TImpl>
    inline void HttpServerConnection<TImpl>::addContentTypeHeader(std::string& response) {

      std::string::size_type pos;
      const char *ext;

      if((pos=_uri.find_last_of('.'))==std::string::npos)
        return;       // not found

      ext=&_uri.c_str()[pos+1];

      if(!strcasecmp(ext,"htm") || !strcasecmp(ext,"html"))
        addContentTypeHeader(response,"text/html");
      else if(!strcasecmp(ext,"js"))
        addContentTypeHeader(response,"application/javascript");
      else if(!strcasecmp(ext,"jpg"))
        addContentTypeHeader(response,"image/jpeg");
      else if(!strcasecmp(ext,"gif"))
        addContentTypeHeader(response,"image/gif");
      else if(!strcasecmp(ext,"png"))
        addContentTypeHeader(response,"image/png");
      else if(!strcasecmp(ext,"pdf"))
        addContentTypeHeader(response,"application/pdf");
      else if(!strcasecmp(ext,"txt"))
        addContentTypeHeader(response,"text/plain");
      else if(!strcasecmp(ext,"css"))
        addContentTypeHeader(response,"text/css");
    }


    /**
     * Add the given content type
     * @param response The response string
     * @param contentType The content type
     */

    template<class TImpl>
    inline void HttpServerConnection<TImpl>::addContentTypeHeader(std::string& response,const char *contentType) {
      response+="Content-Type: ";
      response+=contentType;
      response+="\r\n";
    }


    /**
     * Add the given content length
     * @param response The response string
     * @param contentLength The content length
     */

    template<class TImpl>
    inline void HttpServerConnection<TImpl>::addContentLengthHeader(std::string& response,uint32_t contentLength) {

      char buffer[20];

      StringUtil::modp_uitoa10(contentLength,buffer);
      response+="Content-Length: ";
      response+=buffer;
      response+="\r\n";
    }


    /**
     * Decode the URI by replacing %xx chars
     * @param uri
     * @return
     */

    template<class TImpl>
    inline std::string HttpServerConnection<TImpl>::decodeUri(const std::string& uri) {

      std::string ret;
      std::string::size_type i;
      uint8_t ch;

      ret.reserve(uri.length());

      for(i=0;i<uri.length();i++) {

        if(uri[i]=='%' && i<=uri.length()-3) {

          ch=((uri[i+1]-'0')*16)+(uri[i+2]-'0');
          ret+=static_cast<char>(ch);
          i+=2;
        }
        else
          ret+=uri[i];
      }
      return ret;
    }
  }
}
// END FILE: ../lib/include/net/application/http/HttpServerConnection.h
// START FILE: ../lib/include/net/application/http/HttpMethod.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

namespace stm32plus {
  namespace net {


    /**
     * HTTP method constants
     */

    enum class HttpMethod : uint8_t {
      OPTIONS,    //!< OPTIONS
      GET,        //!< GET
      HEAD,       //!< HEAD
      POST,       //!< POST
      PUT,        //!< PUT
      DELETE,     //!< DELETE
      TRACE,      //!< TRACE
      CONNECT     //!< CONNECT
    };
  }
}
// END FILE: ../lib/include/net/application/http/HttpMethod.h
// START FILE: ../lib/include/net/application/IpSubnetMaskAnnouncementEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor that announces a new subnet mask
     */

    struct IpSubnetMaskAnnouncementEvent : NetEventDescriptor {

      /**
       *  Your subnet mask
       */

      const IpSubnetMask& subnetMask;


      /**
       * Constructor
       */

      IpSubnetMaskAnnouncementEvent(const IpSubnetMask& subnetMask)
        : NetEventDescriptor(NetEventType::SUBNET_MASK_ANNOUNCEMENT),
          subnetMask(subnetMask) {
      }
    };
  }
}
// END FILE: ../lib/include/net/application/IpSubnetMaskAnnouncementEvent.h
// START FILE: ../lib/include/net/application/IpDefaultGatewayAnnouncementEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Your default gateway (router)
     */

    struct IpDefaultGatewayAnnouncementEvent : NetEventDescriptor {

      /**
       * References to the values
       */

      const IpAddress& defaultGateway;


      /**
       * Constructor
       */

      IpDefaultGatewayAnnouncementEvent(const IpAddress& gateway)
        : NetEventDescriptor(NetEventType::DEFAULT_GATEWAY_ANNOUNCEMENT),
          defaultGateway(gateway) {
      }
    };
  }
}
// END FILE: ../lib/include/net/application/IpDefaultGatewayAnnouncementEvent.h
// START FILE: ../lib/include/net/application/staticIpClient/StaticIpClient.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Application layer feature to provide a static IP address and subnet mask.
     * This is an alternative to using a DHCP server
     */

    template<class TTransportLayer>
    class StaticIpClient : public virtual TTransportLayer {

      public:

        struct Parameters {
          IpAddress staticip_address;
          IpSubnetMask staticip_subnetMask;
          IpAddress staticip_defaultGateway;
          IpAddress staticip_dnsServers[3];
          const char *staticip_domainName;

          Parameters()
            : staticip_domainName(nullptr) {
          }
        };

      protected:
        Parameters _params;

      public:
        bool initialise(const Parameters& params);
        bool startup();
    };


    /**
     * Initialise the class
     * @param params The parameters class containing the IP address and subnet mask
     * @return true always
     */

    template<class TTransportLayer>
    inline bool StaticIpClient<TTransportLayer>::initialise(const Parameters& params) {
      _params=params;
      return true;
    }


    /**
     * Startup the class. Broadcast the IP address and subnet mask as an event
     * @return true
     */

    template<class TTransportLayer>
    inline bool StaticIpClient<TTransportLayer>::startup() {

      // send the events for anything that we've been configured with

      if(_params.staticip_address.isValid())
        this->NetworkNotificationEventSender.raiseEvent(IpAddressAnnouncementEvent(_params.staticip_address));

      if(_params.staticip_subnetMask.isValid())
        this->NetworkNotificationEventSender.raiseEvent(IpSubnetMaskAnnouncementEvent(_params.staticip_subnetMask));

      if(_params.staticip_defaultGateway.isValid())
        this->NetworkNotificationEventSender.raiseEvent(IpDefaultGatewayAnnouncementEvent(_params.staticip_defaultGateway));

      if(_params.staticip_dnsServers[0].isValid())
        this->NetworkNotificationEventSender.raiseEvent(IpDnsServersAnnouncementEvent(_params.staticip_dnsServers));

      if(_params.staticip_domainName)
        this->NetworkNotificationEventSender.raiseEvent(DomainNameAnnouncementEvent(_params.staticip_domainName));

      // done

      return true;
    }
  }
}
// END FILE: ../lib/include/net/application/staticIpClient/StaticIpClient.h
// START FILE: ../lib/include/net/application/llip/LinkLocalIp.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * This link-local IP client provides the means to obtain an address from the 169.254/16
     * range that does not conflict with any other stations on this ARP domain. ARP must also
     * be configured into your network stack. The ability to start the search from a random
     * address or from a pre-defined address is provided. Starting from a pre-defined address
     * gives some level of predictability to the address that you will be assigned.
     *
     * This client implements RFC3927 within the constraints of this environment. There are
     * some differences, particularly in the selection and duration of time intervals, however
     * the general procedure is complete.
     */

    template<class TTransportLayer>
    class LinkLocalIp : public virtual TTransportLayer {

      public:

        /**
         * Error codes
         */

        enum {
          E_UNCONFIGURED = 1,         ///< The MAC address has not been notified to us by the link layer
          E_NO_ADDRESSES_FOUND,       ///< could not find an address within the retry parameters
          E_ADDRESS_CLASH             ///< there was an address clash during operation
        };

      public:

        /**
         * Parameters class
         */

        struct Parameters {

          bool llip_randomStart;            ///< true to start search from random address, false to use the fixed address as a start. default is true.
          IpAddress llip_fixedStart;      ///< if llip_randomStart is false then this is where the search starts
          uint16_t llip_tries;              ///< total number of tries for different addresses. Default is 30 (about 180 seconds)

          /**
           * Constructor
           */

          Parameters() {
            llip_randomStart=true;
            llip_tries=30;
          }
        };

      protected:

        /**
         * Possible states
         */

        enum class State : uint8_t {
          NONE,                       ///< just initialised
          ERROR,                      ///< unable to get an address
          PROBING,                    ///< we are probing, _probeNumber is the number of this probe
          ANNOUNCING,                 ///< we're sending 2 ARP announcements
          DEFENDING                   ///< we are idling, waiting for trouble.
        };

        volatile State _state;
        volatile IpAddress _currentProbe;
        volatile uint8_t _probeNumber;
        volatile uint8_t _announceNumber;
        volatile bool _addressInUse;

        Parameters _params;
        MacAddress _myMacAddress;
        uint16_t _tryNumber;

      protected:
        bool startProbing();

        void getRandomAddress();
        void onTick(NetworkIntervalTickData& nitd);
        void onNotification(NetEventDescriptor& ned);
        void onReceive(ArpReceiveEvent& are);

      public:
        bool initialise(const Parameters& params);
        bool startup();
    };


    /**
     * Initialise the class
     * @param params The parameters
     * @return true always
     */

    template<class TTransportLayer>
    inline bool LinkLocalIp<TTransportLayer>::initialise(const Parameters& params) {

      // remember params

      _params=params;

      // idle for now

      _state=State::NONE;

      // subscribe to ARP messages

      this->ArpReceiveEventSender.insertSubscriber(ArpReceiveEventSourceSlot::bind(this,&LinkLocalIp<TTransportLayer>::onReceive));

      // subscribe to notifications (to get the stack's MAC)

      this->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&LinkLocalIp<TTransportLayer>::onNotification));

      // set up our RTC ticker, initially disabled

      this->subscribeIntervalTicks(0,NetworkIntervalTicker::TickIntervalSlotType::bind(this,&LinkLocalIp<TTransportLayer>::onTick));
      return true;
    }


    /**
     * Startup the class: start the sequence
     */

    template<class TTransportLayer>
    inline bool LinkLocalIp<TTransportLayer>::startup() {

      State s;

      // start probing

      if(!startProbing())
        return false;

      // wait for error or DEFENDING state

      while((s=_state)!=State::ERROR && s!=State::DEFENDING);
      return s==State::DEFENDING;
    }


    /**
     * Start probing
     */

    template<class TTransportLayer>
    inline bool LinkLocalIp<TTransportLayer>::startProbing() {

      // set the current state

      _probeNumber=0;
      _tryNumber=0;
      _state=State::PROBING;

      // must have a MAC address

      if(!_myMacAddress.isValid())
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_LINK_LOCAL_IP,E_UNCONFIGURED);

      // set the current probe address

      if(_params.llip_randomStart)
        getRandomAddress();
      else
        const_cast<IpAddress&>(_currentProbe)=_params.llip_fixedStart;

      // send the ARP probe request (source ip = 0, source mac = mymac)

      _addressInUse=false;
      this->arpSendProbe(const_cast<IpAddress&>(_currentProbe));

      // subscribe to a 2 second tick from the RTC

      this->updateIntervalTickSubscription(2,NetworkIntervalTicker::TickIntervalSlotType::bind(this,&LinkLocalIp<TTransportLayer>::onTick));
      return true;
    }


    /**
     * Tick callback from the RTC
     * @param nitd The interval ticker, which we may modify
     */

    template<class TTransportLayer>
    inline void LinkLocalIp<TTransportLayer>::onTick(NetworkIntervalTickData& nitd) {

      if(_state==State::PROBING) {

        if(!_addressInUse) {

          if(_probeNumber==2) {

            // announce the address and mask internally to the stack

            this->NetworkNotificationEventSender.raiseEvent(IpAddressAnnouncementEvent(const_cast<IpAddress&>(_currentProbe)));
            this->NetworkNotificationEventSender.raiseEvent(IpSubnetMaskAnnouncementEvent(IpSubnetMask("255.255.0.0")));

            // we're now announcing our address externally using ARP broadcast

            _announceNumber=0;
            _state=State::ANNOUNCING;

            return;
          }

          // probe again

          _probeNumber++;
          this->arpSendProbe(const_cast<IpAddress&>(_currentProbe));

          return;
        }

        // the address is in use
        // have we run out of tries

        if(++_tryNumber==_params.llip_tries) {

          // unsubscribe from the ticker

          nitd.interval=0;

          // set the error and return;

          _state=State::ERROR;
          this->setError(ErrorProvider::ERROR_PROVIDER_NET_LINK_LOCAL_IP,E_NO_ADDRESSES_FOUND);

          return;
        }

        // we have not run out of tries, get a new address and start again

        getRandomAddress();
        _probeNumber=0;
        _addressInUse=false;

        // send the probe

        this->arpSendProbe(const_cast<IpAddress&>(_currentProbe));
      }
      else if(_state==State::ANNOUNCING) {

        // broadcast the announcement after a delay
        // there are 2 announcements

        if(_announceNumber>0)
          this->arpBroadcastMyAddress();

        if(_announceNumber==2) {

          // cancel the timer and move to defending state

          nitd.interval=0;
          _state=State::DEFENDING;
        }
        else
          _announceNumber++;
      }
    }


    /**
     * Subscription to the ARP events
     * @param are The ARP receive event
     */

    template<class TTransportLayer>
    inline void LinkLocalIp<TTransportLayer>::onReceive(ArpReceiveEvent& are) {

      if(_state==State::PROBING) {

        // any ARP reply that has the address we're looking for indicates fail

        if(are.arpFrameData.arp_senderProtocolAddress==const_cast<IpAddress&>(_currentProbe))
          _addressInUse=true;
      }
      else if(_state==State::DEFENDING) {

        // if any ARP frame arrives with our IP address in the sender address and it's not
        // our MAC in the sender mac then we have to get a new address. any open TCP connections
        // will detect the new address assignment and fail.

        if(are.arpFrameData.arp_senderProtocolAddress==const_cast<IpAddress&>(_currentProbe) &&
           are.arpFrameData.arp_senderHardwareAddress!=_myMacAddress) {

          this->setError(ErrorProvider::ERROR_PROVIDER_NET_LINK_LOCAL_IP,E_ADDRESS_CLASH);
          startProbing();
        }
      }
    }


    /**
     * Subscription to the network notification events
     * @param ned The network event descriptor
     */

    template<class TTransportLayer>
    inline void LinkLocalIp<TTransportLayer>::onNotification(NetEventDescriptor& ned) {

      // remember our MAC address when it's notified to us by the link layer

      if(ned.eventType==NetEventDescriptor::NetEventType::MAC_ADDRESS_ANNOUNCEMENT)
        _myMacAddress=static_cast<MacAddressAnnouncementEvent&>(ned).macAddress;
    }


    /**
     * Get a random address for the search. The address space is 169.254.x.y excluding the
     * first and last 256 addresses.
     */

    template<class TTransportLayer>
    inline void LinkLocalIp<TTransportLayer>::getRandomAddress() {

      uint16_t xy;
      uint32_t randomNumber;

      // get a random number from the RNG

      this->nextRandom(randomNumber);
      xy=256+(randomNumber % (65536-512));

      // create the address

      _currentProbe.ipAddressBytes[0]=169;
      _currentProbe.ipAddressBytes[1]=254;
      _currentProbe.ipAddressBytes[2]=xy;
      _currentProbe.ipAddressBytes[3]=xy >> 8;
    }
  }
}
// END FILE: ../lib/include/net/application/llip/LinkLocalIp.h
// START FILE: ../lib/include/net/application/dns/Dns.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

#include "strings.h"


namespace stm32plus {
  namespace net {


    /**
     * Application layer feature to provide DNS client functionality
     * for IP name resolution
     */

    template<class TTransportLayer>
    class Dns : public virtual TTransportLayer {

      public:
        struct Parameters {

          uint32_t dns_timeout;               ///< 10000ms is the default. don't go less than 5000 according to RFC 1123
          uint32_t dns_cacheSize;             ///< DNS cache size (default is 20)
          uint8_t dns_retries;                ///< number of times to retry all servers (default is 5)

          Parameters() {
            dns_timeout=10000;
            dns_cacheSize=20;
            dns_retries=5;
          }
        };


        /**
         * error codes
         */

        enum {
          E_TIMEOUT = 1,                      ///< timed out waiting for a response
          E_UNCONFIGURED,                     ///< we haven't been given a DNS server
          E_TIMED_OUT,                        ///< timed out waiting for a response
          E_TRUNCATED_REPLY,                  ///< reply was truncated, which it should not be
          E_SERVER_RECURSION_NOT_SUPPORTED,   ///< the server could not recursively resolve the query
          E_SERVER_ERROR,                     ///< the server returned an error (cause is set)
          E_NO_ANSWERS,                       ///< the server did not return an answer
          E_NO_A_RECORD_IN_ANSWERS,           ///< server did not return an A record in the answers
          E_OUT_OF_MEMORY                     ///< memory allocation failure
        };

      protected:
        Parameters _params;
        uint16_t _queryId;
        uint16_t _replyPort;
        IpAddress _dnsServers[3];
        DnsCache _cache;

        volatile bool _awaitingReply;
        DnsReplyPacket volatile *_replyPacket;

      protected:
        void onNotification(NetEventDescriptor& ned);
        void onReceive(UdpDatagramEvent& ned);
        bool queryServer(const IpAddress& dnsServer,const DnsQueryPacket& packet,uint16_t querySize,IpAddress& ipAddress,uint32_t& ttl);
        bool processQueryResponse(IpAddress& ipAddress,uint32_t& ttl);
        void freeReplyPacket();

      public:
        Dns();
        ~Dns();

        bool initialise(const Parameters& params);
        bool startup();

        bool dnsHostnameQuery(const char *hostname,IpAddress& ipAddress);
    };


    /**
     * Constructor
     */

    template<class TTransportLayer>
    inline Dns<TTransportLayer>::Dns() {

      uint32_t randomNumber;

      _dnsServers[0]=nullptr;
      _replyPacket=nullptr;
      _awaitingReply=false;

      this->nextRandom(randomNumber);
      _queryId=randomNumber;
    }


    /**
     * Destructor
     */

    template<class TTransportLayer>
    inline Dns<TTransportLayer>::~Dns() {
      freeReplyPacket();
    }


    /**
     * Initialise the class
     * @param params The parameters
     * @return true if it worked
     */

    template<class TTransportLayer>
    inline bool Dns<TTransportLayer>::initialise(const Parameters& params) {

      // remember params

      _params=params;

      // create the cache

      if(!_cache.initialise(_params.dns_cacheSize,this->_rtc))
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DNS,E_OUT_OF_MEMORY);

      // subscribe to notifications and receive events

      this->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&Dns<TTransportLayer>::onNotification));
      this->UdpReceiveEventSender.insertSubscriber(UdpReceiveEventSourceSlot::bind(this,&Dns<TTransportLayer>::onReceive));
      return true;
    }


    /**
     * Startup the feature
     * @return true
     */

    template<class TTransportLayer>
    inline bool Dns<TTransportLayer>::startup() {
      return true;
    }


    /**
     * Notification event notification from the stack
     * @param ned The network event descriptor
     */

    template<class TTransportLayer>
    inline void Dns<TTransportLayer>::onNotification(NetEventDescriptor& ned) {

      uint8_t i;

      // only concerned with DNS servers

      if(ned.eventType!=NetEventDescriptor::NetEventType::DNS_SERVERS_ANNOUNCEMENT)
        return;

      IpDnsServersAnnouncementEvent& dnsevent(static_cast<IpDnsServersAnnouncementEvent&>(ned));

      // copy out the valid servers from the event

      for(i=0;i<3;i++)
        if(dnsevent.ipDnsServers[i]!=nullptr && dnsevent.ipDnsServers[i].isValid())
          _dnsServers[i]=*dnsevent.ipDnsServers;

      // invalidate the others

      while(i!=3)
        _dnsServers[i++].invalidate();
    }


    /**
     * This is the basic host namet to IP address lookup functionality
     * @param hostname The host to lookup
     * @param[out] ipAddress The IP address of the host
     * @return true if it worked
     */

    template<class TTransportLayer>
    inline bool Dns<TTransportLayer>::dnsHostnameQuery(const char *hostname,IpAddress& ipAddress) {

      uint16_t querySize;
      uint32_t ttl;
      uint8_t i,retry;

      // special case for localhost

      if(!strcasecmp(hostname,"localhost")) {
        ipAddress.setLocalhost();
        return true;
      }

      // is the association cached?

      if(_cache.lookup(hostname,ipAddress))
        return true;

      // must have at least one server

      if(_dnsServers[0]==nullptr)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DNS,E_UNCONFIGURED);

      // the size of the query is the hostname+2+header+4

      querySize=DnsPacketHeader::getPacketHeaderSize()+
                strlen(hostname)+2+
                4;

      // allocate the query

      scoped_array<uint8_t> packetData(new uint8_t[querySize]);
      if(packetData.get()==nullptr)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DNS,E_OUT_OF_MEMORY);

      // create the header and data

      DnsQueryPacket& packet=reinterpret_cast<DnsQueryPacket&>(*(packetData.get()));

      freeReplyPacket();
      _queryId++;
      packet.createQuery(hostname,_queryId);

      // retry for the configured number of times

      for(retry=0;retry<_params.dns_retries;retry++) {

        // run through the list of servers

        for(i=0;i<3 && _dnsServers[i].isValid();i++) {
          if(queryServer(_dnsServers[i],packet,querySize,ipAddress,ttl)) {
            _cache.add(hostname,ipAddress,ttl);
            return true;
          }
        }
      }

      // they all failed, preserve error returned by the last one

      return false;
    }


    /**
     * Query the server and wait for a response
     * @param packet The packet to send
     * @param querySize The size of the packet
     * @param[out] ipAddress The returned IP address mapping
     * @param[out] ttl The time-to-live of the entry in seconds
     * @return true if it worked
     */

    template<class TTransportLayer>
    inline bool Dns<TTransportLayer>::queryServer(const IpAddress& dnsServer,
                                                   const DnsQueryPacket& packet,
                                                   uint16_t querySize,
                                                   IpAddress& ipAddress,
                                                   uint32_t& ttl) {

      uint32_t now;
      bool retval;

      // claim an ephemeral port for the reply

      if(!this->ip_acquireEphemeralPort(_replyPort))
        return false;

      // send the packet asynchronously over UDP to the DHCP server

      _awaitingReply=true;

      if(!this->udpSend(dnsServer,                                  // server to send to
                        _replyPort,                                 // source port
                        IpPorts::PORT_DNS_REQUEST,                  // destination port,
                        reinterpret_cast<const uint8_t *>(&packet), // data
                        querySize,                                  // data size
                        true,                                       // asynchronous flag
                        0)) {                                       // n/a for async
        this->ip_releaseEphemeralPort(_replyPort);
        return false;         // should not happen, async always returns true
      }

      // await a response

      now=MillisecondTimer::millis();
      while(_awaitingReply) {
        if(MillisecondTimer::hasTimedOut(now,_params.dns_timeout)) {
          this->ip_releaseEphemeralPort(_replyPort);
          return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DNS,E_TIMED_OUT);
        }
      }

      retval=processQueryResponse(ipAddress,ttl);

      freeReplyPacket();
      this->ip_releaseEphemeralPort(_replyPort);
      return retval;
    }


    /**
     * Process the response from the server
     * @param[out] ipAddress The response IP address
     * @param[out] ttl The time-to-live of the entry in seconds
     * @return true if it worked
     */

    template<class TTransportLayer>
    inline bool Dns<TTransportLayer>::processQueryResponse(IpAddress& ipAddress,uint32_t& ttl) {

      uint16_t flags=NetUtil::ntohs(_replyPacket->dns_flags);
      uint8_t *answers,*record;

      // the flags must not have an error (unknown host is picked up here as cause=3)

      if((flags & 0xf)!=0)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DNS,E_SERVER_ERROR,flags & 0xf);

      // the flags must not indicate truncation

      if((flags & DnsPacketHeader::TRUNCATED)!=0)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DNS,E_TRUNCATED_REPLY);

      // there must be at least one answer

      if(NetUtil::ntohs(_replyPacket->dns_numberOfAnswerRrs)==0)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DNS,E_NO_ANSWERS);

      // find the answers

      DnsReplyPacket *packet(const_cast<DnsReplyPacket *>(_replyPacket));
      answers=packet->findAnswers();

      // find the first A record

      if((record=packet->findRecord(answers,DnsPacketHeader::RecordType::A))==nullptr)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DNS,E_NO_A_RECORD_IN_ANSWERS);

      // step over the name (should possibly verify that it's the answer to our question here)

      record=packet->stepOverName(record);

      // pull out the IP address and ttl from the record

      ipAddress.ipAddress=*reinterpret_cast<uint32_t *>(record+10);
      ttl=NetUtil::ntohl(*reinterpret_cast<uint32_t *>(record+4));

      return true;
    }


    /**
     * Receive event notification from the stack
     * @param upe The UDP packet event descriptor
     */

    template<class TTransportLayer>
    inline void Dns<TTransportLayer>::onReceive(UdpDatagramEvent& upe) {

      // must be for our reply port

      if(NetUtil::ntohs(upe.udpDatagram.udp_destinationPort)!=_replyPort)
        return;

      // it's considered handled now

      upe.handled=true;

      // handle UDP packets when we're waiting

      if(!_awaitingReply || _replyPacket!=nullptr)
        return;

      // must be a valid packet on the DNS port

      if(NetUtil::ntohs(upe.udpDatagram.udp_sourcePort)!=IpPorts::PORT_DNS_REQUEST ||
         NetUtil::ntohs(upe.udpDatagram.udp_length)<DnsPacketHeader::getPacketHeaderSize())
        return;

      DnsQueryPacket *reply(reinterpret_cast<DnsQueryPacket *>(upe.udpDatagram.udp_data));

      // must be our DNS packet. there is no fixed magic number to indicate that this packet is
      // a DNS response. we only have our ID to go on

      if(NetUtil::ntohs(reply->dns_identification)!=_queryId)
        return;

      // it's for us

      _replyPacket=(DnsReplyPacket *)malloc(upe.udpDatagram.udp_length);
      memcpy(const_cast<DnsReplyPacket *>(_replyPacket),upe.udpDatagram.udp_data,upe.udpDatagram.udp_length);

      // wake up the caller

      _awaitingReply=false;
    }


    /**
     * Free the reply packet
     */

    template<class TTransportLayer>
    inline void Dns<TTransportLayer>::freeReplyPacket() {

      if(_replyPacket) {
        free((void *)_replyPacket);
        _replyPacket=nullptr;
        _awaitingReply=false;
      }
    }
  }
}
// END FILE: ../lib/include/net/application/dns/Dns.h
// START FILE: ../lib/include/net/application/dns/DnsCache.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Simple DNS cache of hostname to IP address with TTL. A full pass through the cache is
     * required for add and lookup so this is not intended for high volumes, not that you'd
     * have the SRAM for that anyway. A pessimistic average domain name length of 25 characters
     * with 20 entries would use around (26*20)+(12*20) = 760 bytes of SRAM in the cache.
     * Whatever, parsing 20 entries per lookup is massively cheaper than a network DNS lookup.
     */

    class DnsCache {

      protected:

        /**
         * Constant to indicate the cache entry is free
         */

        enum {
          NO_ENTRY = 0xffffffff       //!< The cache entry is free
        };

        struct Entry {
          scoped_array<char> _hostname;
          uint32_t expiryTicks;
          IpAddress address;
        };

        scoped_array<Entry> _entries;
        uint32_t _maxEntries;
        RtcBase *_rtc;

      public:
        bool initialise(uint32_t cacheSize,RtcBase *rtc);

        void add(const char *hostname,const IpAddress& address,uint32_t expiry);
        bool lookup(const char *hostname,IpAddress& address);
    };
  }
}

// END FILE: ../lib/include/net/application/dns/DnsCache.h
// START FILE: ../lib/include/net/application/dns/DnsReplyPacket.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * DNS reply packet
     */

    struct DnsReplyPacket : DnsPacketHeader {

      /**
       * Find the start of the answers in this packet. Assumes a well-formed response.
       * @return the answers pointer
       */

      uint8_t *findAnswers() {

        uint16_t i;
        uint8_t *ptr;

        // get a pointer to the questions

        ptr=reinterpret_cast<uint8_t *>(this)+DnsPacketHeader::getPacketHeaderSize();

        // step over each question

        for(i=NetUtil::ntohs(dns_numberOfQuestions);i!=0;i--)
          ptr=stepOverName(ptr)+4;          // step over the name + (type, class)

        return ptr;
      }


      /**
       * Step over the labels that make up the name pointed at by ptr. The labels that make up a
       * name may optionally end in a pointer, or just be a pointer. In any case the occurence of
       * a pointer is the end of the name.
       * @param ptr The start of a name
       * @return The start of the next name
       */

      uint8_t *stepOverName(uint8_t *ptr) {

        while(*ptr) {

          // check for a pointer

          if((*ptr & 0xc0)==0xc0)
            return ptr+2;           // don't care what the pointer is, just that this is the end of the name

          ptr+=(*ptr)+1;            // normal label with length prefix
        }

        // and over the \0 terminator

        return ptr+1;
      }


      /**
       * Find the first occurrence of a record with the given type
       * @param answers The start of the answers records
       * @param requestedType The type to search for
       * @return A pointer to the record, or null
       */

      uint8_t *findRecord(uint8_t *answers,RecordType requestedType) {

        uint8_t *dataptr,*ptr;
        RecordType thisType;
        uint16_t i;

        ptr=answers;

        for(i=NetUtil::ntohs(dns_numberOfAnswerRrs);i!=0;i--) {

          // get past the encoded name

          dataptr=stepOverName(ptr);

          // is it a record of the correct type?

          thisType=static_cast<RecordType>(NetUtil::ntohs(*reinterpret_cast<uint16_t *>(dataptr)));
          if(thisType==requestedType)
            return ptr;

          // next one

          ptr=dataptr+8;                                                // to the resource data length
          ptr+=2+NetUtil::ntohs(*reinterpret_cast<uint16_t *>(ptr));    // over the length and data
        }

        // not found

        return nullptr;
      }

    } __attribute__((packed));
  }
}

// END FILE: ../lib/include/net/application/dns/DnsReplyPacket.h
// START FILE: ../lib/include/net/application/dns/DnsPacketHeader.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {

    /**
     * Generic 12-byte DNS header. This is designed to be cast directly
     * to a memory buffer which of course means that 16 and 32 bit values are in
     * network byte order.
     */

    struct DnsPacketHeader {

      /**
       * Flags
       */

      enum Flags {
        RESPONSE              = 0x8000,
        AUTHORITATIVE_ANSWER  = 0x400,
        TRUNCATED             = 0x200,
        RECURSION_DESIRED     = 0x100,
        RECURSION_AVAILABLE   = 0x80
      };


      /**
       * Common types
       */

      enum class RecordType : uint16_t {
        A     = 1,          //!< IP address
        NS    = 2,          //!< name server
        CNAME = 5,          //!< canonical name
        PTR   = 12,         //!< pointer record
        HINFO = 13,         //!< host info
        MX    = 15          //!< mail exchange record
      };



      uint16_t dns_identification;
      uint16_t dns_flags;
      uint16_t dns_numberOfQuestions;
      uint16_t dns_numberOfAnswerRrs;
      uint16_t dns_numberOfAuthorityRrs;
      uint16_t dns_numberOfAdditionalRrs;


      /**
        * Get the total packet size, including options
        * @return
        */

      static uint16_t getPacketHeaderSize() {
        return sizeof(DnsPacketHeader);
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/application/dns/DnsPacketHeader.h
// START FILE: ../lib/include/net/application/dns/DnsQueryPacket.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * DNS query packet
     */

    struct DnsQueryPacket : DnsPacketHeader {

      /**
       * Create the query
       * @param hostname The host name
       * @param id The query identifier
       */

      uint16_t createQuery(const char *hostname,uint16_t id) {

        // we'd like the server to do the legwork

        dns_identification=NetUtil::htons(id);
        dns_flags=NetUtil::htons(RECURSION_DESIRED);
        dns_numberOfQuestions=NetUtil::htons(1);
        dns_numberOfAnswerRrs=
          dns_numberOfAuthorityRrs=
          dns_numberOfAdditionalRrs=0;

        // write out the question

        uint8_t *question=reinterpret_cast<uint8_t *>(this)+DnsPacketHeader::getPacketHeaderSize();
        uint8_t *lenptr;
        const char *srcptr;

        lenptr=question++;
        srcptr=hostname;

        while(*srcptr) {
          if(*srcptr=='.') {
            *lenptr=question-lenptr-1;
            lenptr=question++;
            srcptr++;
          }
          else
            *question++=*srcptr++;
        }

        // terminate the question label

        *lenptr=question-lenptr-1;
        *question++=0;

        // add in the type and class(1)

        *reinterpret_cast<uint16_t *>(question)=NetUtil::htons(static_cast<uint16_t>(RecordType::A));
        *reinterpret_cast<uint16_t *>(question+2)=NetUtil::htons(1);

        // return the complete query size

        return question-reinterpret_cast<uint8_t *>(this)+4;
      }

    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/application/dns/DnsQueryPacket.h
// START FILE: ../lib/include/net/application/ApplicationLayer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Template feature-holder for features that live in the application
     * layer of the stack, e.g. DNS, HTTP, FTP, DHCP protocols. The next level
     * down is the transport layer and there is no layer above this. The features
     * must themselves be templated on, and virtually inherit from TTransportLayer
     * so that the stack is correctly formed.
     */

    template<class TTransportLayer,template<class> class... Features>
    class ApplicationLayer : public virtual TTransportLayer,
                             public Features<TTransportLayer>... {

      public:

        /**
         * Base parameters collection-class for application features
         */

        struct Parameters : TTransportLayer::Parameters,
                            Features<TTransportLayer>::Parameters... {
        };


      public:
        bool initialise(Parameters& params);
        bool startup();
    };


    /**
     * Initialise the features after initialising upwards first
     * @param params The parameters class to initialise the layer features
     * @return true if it worked
     */

    template<class TTransportLayer,template<class> class... Features>
    bool ApplicationLayer<TTransportLayer,Features...>::initialise(Parameters& params) {
      return TTransportLayer::initialise(params) &&
             RecursiveBoolInitWithParams<ApplicationLayer,Features<TTransportLayer>...>::tinit(this,params);
    }


    /**
     * Startup the components in this layer
     * @return
     */

    template<class TTransportLayer,template<class> class... Features>
    bool ApplicationLayer<TTransportLayer,Features...>::startup() {
      return TTransportLayer::startup() &&
             RecursiveBoolStartup<ApplicationLayer,Features<TTransportLayer>...>::tstartup(this);
    }
  }
}
// END FILE: ../lib/include/net/application/ApplicationLayer.h
// START FILE: ../lib/include/net/application/IpAddressAnnouncementEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor that announces a new client IP address
     */

    struct IpAddressAnnouncementEvent : NetEventDescriptor {

      /**
       * References to the value
       */

      const IpAddress& ipAddress;           ///< Your IP address


      /**
       * Constructor
       */

      IpAddressAnnouncementEvent(const IpAddress& address)
        : NetEventDescriptor(NetEventType::IP_ADDRESS_ANNOUNCEMENT),
          ipAddress(address) {
      }
    };
  }
}
// END FILE: ../lib/include/net/application/IpAddressAnnouncementEvent.h
// START FILE: ../lib/include/net/application/DomainNameAnnouncementEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor that announces a new domain suffix
     */

    struct DomainNameAnnouncementEvent : NetEventDescriptor {

      /**
       * Your local domain suffix (\0 terminated string)
       */

      const char *domainName;


      /**
       * Constructor
       */

      DomainNameAnnouncementEvent(const char *domain)
        : NetEventDescriptor(NetEventType::DOMAIN_NAME_ANNOUNCEMENT),
          domainName(domain) {
      }
    };
  }
}
// END FILE: ../lib/include/net/application/DomainNameAnnouncementEvent.h
// START FILE: ../lib/include/net/application/dhcp/DhcpPacket.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Structure of a DHCP packet. This can be cast directly on to memory.
     */

    struct DhcpPacket {

      /**
       * DHCP operations
       */

      enum class Operation : uint8_t {
        REQUEST = 1,      //!< REQUEST
        REPLY = 2         //!< REPLY
      };


      /**
       * Hardware address types from the ARP section of RFC1700. We only use one
       * so that's all I'm including
       */

      enum class HardwareAddressType : uint8_t {
        ETHERNET_10Mb = 1               //!< ETHERNET_10Mb
      };


      /**
       * MessageType option values
       */

      enum class MessageType : uint8_t {
        NONE      = 0,    //!< not a real code
        DISCOVER  = 1,    //!< DISCOVER
        OFFER     = 2,    //!< OFFER
        REQUEST   = 3,    //!< REQUEST
        DECLINE   = 4,    //!< DECLINE
        ACK       = 5,    //!< ACK
        NAK       = 6,    //!< NAK
        RELEASE   = 7,    //!< RELEASE
        INFORM    = 8     //!< INFORM
      };

      /**
       * Flags
       */

      enum class Flags : uint16_t {
        BROADCAST_RESPONSE = 0x8000           ///< server must respond via a broadcast
      };


      /**
       * Structure members
       */

      Operation dhcp_op;                      ///< operation
      HardwareAddressType dhcp_htype;         ///< hardware address type
      uint8_t dhcp_hlen;                      ///< hardware address length (6 for a MAC)
      uint8_t dhcp_hops;
      uint32_t dhcp_xid;
      uint16_t dhcp_secs;
      uint16_t dhcp_flags;
      IpAddress dhcp_ciaddr;
      IpAddress dhcp_yiaddr;
      IpAddress dhcp_siaddr;
      IpAddress dhcp_giaddr;
      MacAddress dhcp_chaddr;               ///< 6 bytes of MAC address
      uint8_t dhcp_chaddr_[10];             ///< padding to make up the 16-byte field
      uint8_t dhcp_sname[64];
      uint8_t dhcp_file[128];
      uint32_t dhcp_magic;


      /**
       * Get the total packet size, including options
       * @return
       */

      static uint16_t getPacketSize() {
        return sizeof(DhcpPacket);
      }


      /**
       * Create options common to all packets
       * @param myMacAddress Local client MAC
       * @param transactionId 32-bit ID that will be carried through this transaction
       */

      void createCommonRequestOptions(const MacAddress& myMacAddress,uint32_t transactionId) {

        // the packet is mostly zeros

        memset(this,0,sizeof(DhcpPacket));

        // set up the non-zero common values

        dhcp_op=Operation::REQUEST;                       // uint8_t
        dhcp_htype=HardwareAddressType::ETHERNET_10Mb;      // uint8_t
        dhcp_hlen=6;                                        // uint8_t
        dhcp_chaddr=myMacAddress;                         // 6 bytes
        dhcp_xid=transactionId;                           // uint32_t
        dhcp_magic=NetUtil::htonl(0x63825363);            // uint32_t
      }


      /**
       * Create a DISCOVERY packet. This is the first one in the DHCP transaction
       * that is used to solicit offers from DHCP servers on the network
       * @param myMacAddress Our local MAC address
       * @param transactionId 32-bit ID that will be carried through this transaction
       * @param expectUnicastResponse true if the client wants a unicast response from the server
       * @param requestDefaultGateway true if we want to know the default gateway
       * @param requestSubnetMask true if we want to know the subnet mask
       * @param requestDnsServer true if we want to know the DNS servers
       * @param requestDomainName true if we want to know the domain suffix
       * @return The packet size with the options
       */

      uint16_t createDiscovery(const MacAddress& myMacAddress,
                               uint32_t transactionId,
                               bool expectUnicastResponse,
                               bool requestDefaultGateway,
                               bool requestSubnetMask,
                               bool requestDnsServer,
                               bool requestDomainName) {

        createCommonRequestOptions(myMacAddress,transactionId);

        if(!expectUnicastResponse)
          dhcp_flags=NetUtil::htons(static_cast<uint16_t>(Flags::BROADCAST_RESPONSE));

        uint8_t *options=reinterpret_cast<uint8_t *>(this)+getPacketSize();

        options=createMessageTypeOption(options,MessageType::DISCOVER);
        options=createParameterRequestListOption(options,requestDefaultGateway,requestSubnetMask,requestDnsServer,requestDomainName);
        options=createEndOption(options);

        return options-reinterpret_cast<uint8_t *>(this);
      }


      /**
       * Create MessageType option
       * @param options Start of options data
       * @param type MessageType
       * @return The next option start location
       */

      uint8_t *createMessageTypeOption(uint8_t *options,MessageType type) {

        *options++=53;
        *options++=1;
        *options++=static_cast<uint8_t>(type);

        return options;
      }


      /**
       * Create a REQUEST packet.
       * @param myMacAddress Our local mac adress
       * @param transactionId 32-bit ID that will be carried through this transaction
       * @param dhcpServerAddress Address of the DHCP server
       * @param offeredIpAddress Address offered to us in the OFFER response
       * @param hostname Our hostname that we report to the server
       * @param expectUnicastResponse true if the client wants a unicast response from the server
       * @param requestDefaultGateway true if we want to know the default gateway
       * @param requestSubnetMask true if we want to know the subnet mask
       * @param requestDnsServer true if we want to know the DNS servers
       * @param requestDomainName true if we want to know the domain suffix
       * @return The packet size with the options
       */

      uint16_t createRequest(const MacAddress& myMacAddress,
                             uint32_t transactionId,
                             const IpAddress& dhcpServerAddress,
                             const IpAddress& offeredIpAddress,
                             const char *hostname,
                             bool expectUnicastResponse,
                             bool requestDefaultGateway,
                             bool requestSubnetMask,
                             bool requestDnsServer,
                             bool requestDomainName) {

        createCommonRequestOptions(myMacAddress,transactionId);

        if(!expectUnicastResponse)
          dhcp_flags=NetUtil::htons(static_cast<uint16_t>(Flags::BROADCAST_RESPONSE));

        dhcp_siaddr=dhcpServerAddress;

        uint8_t *options=reinterpret_cast<uint8_t *>(this)+getPacketSize();

        options=createMessageTypeOption(options,MessageType::REQUEST);

        if(hostname)
          options=createHostNameOption(options,hostname);

        options=createRequestIpAddressOption(options,offeredIpAddress);
        options=createParameterRequestListOption(options,requestDefaultGateway,requestSubnetMask,requestDnsServer,requestDomainName);
        options=createDhcpServerOption(options,dhcpServerAddress);
        options=createEndOption(options);

        return options-reinterpret_cast<uint8_t *>(this);
      }


      /**
       * Create the hostname option (12)
       * @param options Start of options data
       * @param hostname My host name
       * @return The next option start location
       */

      uint8_t *createHostNameOption(uint8_t *options,const char *hostname) {

        uint8_t hostnamelen(strlen(hostname));

        *options++=12;
        *options++=hostnamelen;
        memcpy(options,hostname,hostnamelen);
        options+=hostnamelen;

        return options;
      }


      /**
       * Create the requested IP address option (50)
       * @param options Start of options data
       * @param ipAddress The requested IP address
       * @return The next option start location
       */

      uint8_t *createRequestIpAddressOption(uint8_t *options,const IpAddress& address) {

        *options++=50;
        *options++=4;
        *reinterpret_cast<uint32_t *>(options)=address.ipAddress;
        options+=4;

        return options;
      }


      /**
       * Create DHCP server option
       * @param options Start of options data
       * @param type MessageType
       * @return The next option start location
       */

      uint8_t *createDhcpServerOption(uint8_t *options,const IpAddress& dhcpServerAddress) {

        *options++=54;
        *options++=4;
        *reinterpret_cast<uint32_t *>(options)=dhcpServerAddress.ipAddress;

        return options+4;
      }


      /**
       * Create the additional request items option
       * @param options Start of options data
       * @param requestDefaultGateway
       * @param requestSubnetMask
       * @param requestDnsServer
       * @param requestDomainName
       * @return The next option start location
       */

      uint8_t *createParameterRequestListOption(uint8_t *options,
                                                bool requestDefaultGateway,
                                                bool requestSubnetMask,
                                                bool requestDnsServer,
                                                bool requestDomainName) {

        if(requestDefaultGateway || requestSubnetMask || requestDnsServer) {

          uint8_t *len;

          *options++=55;
          len=options++;
          *len=0;

          if(requestDefaultGateway) {
            (*len)++;
            *options++=3;
          }

          if(requestSubnetMask) {
            (*len)++;
            *options++=1;
          }

          if(requestDnsServer) {
            (*len)++;
            *options++=6;
          }

          if(requestDomainName) {
            (*len)++;
            *options++=15;
          }
        }

        return options;
      }


      /**
       * Create the end-of-options option
       * @param options Start of options data
       * @return The next option start location
       */

      uint8_t *createEndOption(uint8_t *options) {
        *options++=0xff;
        return options;
      }


      /**
       * Get the message type option
       * @return The message type
       */

      MessageType getMessageType() {

        uint8_t *option;

        if((option=getOption(53))==nullptr)
          return MessageType::NONE;

        return static_cast<MessageType>(option[2]);
      }


      /**
       * Get the address of a specific option
       * @return The address or nullptr if not found
       */

      uint8_t *getOption(uint8_t code) {

        uint8_t *options;
        options=reinterpret_cast<uint8_t *>(this)+getPacketSize();

        while(*options!=255 && *options!=code) {
          if(*options==0)             // code 0 is just a null byte
            options++;
          else
            options+=options[1]+2;    // length is in *(code+1)
        }

        return *options==255 ? nullptr : options;
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/net/application/dhcp/DhcpPacket.h
// START FILE: ../lib/include/net/application/dhcp/DhcpClient.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Application layer feature to provide IP configuration information from
     * a DHCP server. The DHCP protocol is entirely IRQ driven and is automatically
     * initiated by the stack's startup() call. You need do nothing except configure
     * this class into your stack.
     */

    template<class TTransportLayer>
    class DhcpClient : public virtual TTransportLayer {

      public:

        /**
         * The parameters class
         */

        struct Parameters {

          uint32_t dhcp_responseTimeout;            ///< number of seconds to wait for the UDP packets to get a response (default is 6)
          uint8_t dhcp_retries;                     ///< number of times to retry on failure (default is 5)
          bool dhcp_expectUnicastResponse;          ///< true if the DHCP server should call back via unicast (default is false)
          bool dhcp_requestSubnetMask;              ///< ask for the subnet mask (default is true)
          bool dhcp_requestDefaultGateway;          ///< ask for the default gateway (default is true)
          bool dhcp_requestDnsServer;               ///< ask for the DNS server (default is true)
          bool dhcp_requestDomainName;              ///< ask for the domain name (default is true)
          const char *dhcp_hostname;                ///< we'll tell the DHCP server that this is your name

          /**
           * Constructor, set defaults
           */

          Parameters() {
            dhcp_responseTimeout=6;                 // max of 6 secs to wait for a UDP response
            dhcp_requestSubnetMask=true;            // ask for the subnet mask
            dhcp_requestDefaultGateway=true;        // ask for the default gateway
            dhcp_requestDnsServer=true;             // ask for the DNS server
            dhcp_requestDomainName=true;            // ask for our domain name
            dhcp_expectUnicastResponse=false;       // we want a broadcast response
            dhcp_retries=5;                         // default times to retry
            dhcp_hostname=nullptr;
          }
        };


        /**
         * Error codes
         */

        enum {
          E_UNCONFIGURED,           ///< we don't have a client mac address
          E_UNEXPECTED_STATE,       ///< an internal error: the state machine is bad
          E_NO_DHCP_SERVER_OPTION,  ///< OFFER message does not contain DHCP server
          E_UDP_SEND_FAILED,        ///< failed to send a UDP message
          E_FAILED                  ///< could not complete the process
        };

      protected:

        /**
         * Possible DHCP states
         */

        enum class State {
          DISCOVERY,            ///< ready to discover DHCP servers
          OFFER,                ///< ready to receive an offer
          REQUEST,              ///< ready to send the request
          ACK,                  ///< ready to receive the ACK
          COMPLETED,            ///< completed OK
          FAILED                ///< process failed
        };

        volatile State _state;                          ///< the current state
        Parameters _params;                             ///< The initialisation parameters
        MacAddress _myMacAddress;                       ///< Received via a notification event
        uint32_t _transactionId;                        ///< Current transaction id
        uint32_t _stateBeginTime;                       ///< last start time of an async operation
        uint8_t _retryIndex;                            ///< current retry index
        IpAddress _ipAddress;                           ///< IP address from ACK packet
        IpAddress _dhcpServerAddress;                   ///< DHCP server address from OFFER packet
        IpSubnetMask _subnetMask;                       ///< requested subnet mask
        IpAddress _defaultGateway;                      ///< default gateway address
        IpAddress _dnsServers[3];                       ///< DNS server addresses
        uint32_t _expiryTime;                           ///< when this lease expires
        scoped_array<char> _domainName;                 ///< our domain name

        volatile DhcpPacket::MessageType _expectedResponseMessage;  ///< which message type is expected next
        DhcpPacket volatile *_responsePacket;           ///< the received packet

      protected:
        bool stateIdle();
        bool stateDiscovery();
        bool stateOffer();
        bool stateRequest();
        bool stateAck();
        void freeResponsePacket();
        bool internalDhcpClientAcquire();

        void retryRestart(NetworkIntervalTickData& nitd);
        void handleOfferTick(NetworkIntervalTickData& nitd);
        void handleAckTick(NetworkIntervalTickData& nitd);
        void handleCompleteTick(NetworkIntervalTickData& nitd);

        void onNotification(NetEventDescriptor& ned);
        void onReceive(UdpDatagramEvent& ned);
        void onTick(NetworkIntervalTickData& nitd);

      public:
        DhcpClient();
        ~DhcpClient();

        bool initialise(const Parameters& params);
        bool startup();

        bool dhcpClientAcquire();
    };


    /**
     * Constructor
     */

    template<class TTransportLayer>
    inline DhcpClient<TTransportLayer>::DhcpClient() {
      _responsePacket=nullptr;
    }


    /**
     * Destructor
     */

    template<class TTransportLayer>
    inline DhcpClient<TTransportLayer>::~DhcpClient() {
      freeResponsePacket();
    }


    /**
     * Initialise the class
     * @param params The parameters class
     * @return true always
     */

    template<class TTransportLayer>
    inline bool DhcpClient<TTransportLayer>::initialise(const Parameters& params) {

      // remember parameters

      _params=params;

      // initialise members

      _transactionId=0;
      _expectedResponseMessage=DhcpPacket::MessageType::NONE;

      // subscribe to notifications and receive events

      this->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&DhcpClient<TTransportLayer>::onNotification));
      this->UdpReceiveEventSender.insertSubscriber(UdpReceiveEventSourceSlot::bind(this,&DhcpClient<TTransportLayer>::onReceive));

      // start the ticker off as disabled

      this->subscribeIntervalTicks(0,NetworkIntervalTicker::TickIntervalSlotType::bind(this,&DhcpClient<TTransportLayer>::onTick));
      return true;
    }


    /**
     * Startup the class. Broadcast the IP address and subnet mask as an event
     * @return true
     */

    template<class TTransportLayer>
    inline bool DhcpClient<TTransportLayer>::startup() {

      if(!dhcpClientAcquire())
        return false;

      // adjust our subscription to the RTC ticker to 1 second intervals

      this->updateIntervalTickSubscription(1,NetworkIntervalTicker::TickIntervalSlotType::bind(this,&DhcpClient<TTransportLayer>::onTick));

      // wait for the process to complete or fail

      while(_state!=State::COMPLETED && _state!=State::FAILED);
      return _state==State::COMPLETED;
    }


    /**
     * Go through the process of acquiring what we need
     * @return true if succeeded
     */

    template<class TTransportLayer>
    inline bool DhcpClient<TTransportLayer>::dhcpClientAcquire() {

      _retryIndex=0;
      return internalDhcpClientAcquire();
    }

    template<class TTransportLayer>
    inline bool DhcpClient<TTransportLayer>::internalDhcpClientAcquire() {

      // we must have received a mac address announcement from the lower layers

      if(!_myMacAddress.isValid())
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DHCP,E_UNCONFIGURED);

      _state=State::DISCOVERY;
      _transactionId++;
      _ipAddress.invalidate();
      _subnetMask.invalidate();
      _defaultGateway.invalidate();
      _dnsServers[0].invalidate();
      _dnsServers[1].invalidate();
      _dnsServers[2].invalidate();
      _dhcpServerAddress.invalidate();
      _expiryTime=UINT32_MAX;
      _domainName.reset();

      freeResponsePacket();

      // start if off. the remainder of the process happens via IRQ

      return stateDiscovery();
    }


    /**
     * DISCOVERY state handler
     * @return true if successfully advanced to next state
     */

    template<class TTransportLayer>
    inline bool DhcpClient<TTransportLayer>::stateDiscovery() {

      DhcpPacket *dp;
      char buffer[314];

      // create a DISCOVERY packet on the stack

      memset(buffer,0,sizeof(buffer));
      dp=reinterpret_cast<DhcpPacket *>(&buffer);
      dp->createDiscovery(_myMacAddress,
                           _transactionId,
                           _params.dhcp_expectUnicastResponse,
                           _params.dhcp_requestDefaultGateway,
                           _params.dhcp_requestSubnetMask,
                           _params.dhcp_requestDnsServer,
                           _params.dhcp_requestDomainName);

      // Send the packet asynchronously over UDP. At this point we don't know
      // our subnet mask so the broadcast address is all 1's.

      _expectedResponseMessage=DhcpPacket::MessageType::OFFER;

      if(!this->udpSend("255.255.255.255",                      // broadcast address
                        IpPorts::PORT_DHCP_RESPONSE,            // source port
                        IpPorts::PORT_DHCP_REQUEST,             // destination port,
                        reinterpret_cast<uint8_t *>(dp),        // data
                        sizeof(buffer),                         // data size
                        true,                                   // asynchronous
                        0)) {                                   // time to wait (ignored)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DHCP,E_UDP_SEND_FAILED);
      }

      // advance to the next state

      _stateBeginTime=this->getRtc().getTick();
      _state=State::OFFER;
      return true;
    }


    /**
     * OFFER state handler
     * @return true if successfully advanced to next state
     */

    template<class TTransportLayer>
    inline bool DhcpClient<TTransportLayer>::stateOffer() {

      // get the server address from the response - it's not volatile now

      uint8_t *options;
      if((options=const_cast<DhcpPacket *>(_responsePacket)->getOption(54))==nullptr)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DHCP,E_NO_DHCP_SERVER_OPTION);

      // get the DHCP server address from the response

      _dhcpServerAddress.ipAddress=*reinterpret_cast<uint32_t *>(options+2);

      // get our offered address

      _ipAddress=const_cast<IpAddress&>(_responsePacket->dhcp_yiaddr);

      // free the response packet

      freeResponsePacket();
      _state=State::REQUEST;

      return true;
    }


    /**
     * REQUEST state handler
     * @return true if successfully advanced to next state
     */

    template<class TTransportLayer>
    inline bool DhcpClient<TTransportLayer>::stateRequest() {

      DhcpPacket *dp;
      char buffer[314];

      // create a DISCOVERY packet on the stack

      memset(buffer,0,sizeof(buffer));
      dp=reinterpret_cast<DhcpPacket *>(&buffer);
      dp->createRequest(_myMacAddress,
                        _transactionId,
                        _dhcpServerAddress,
                        _ipAddress,
                        _params.dhcp_hostname,
                        _params.dhcp_expectUnicastResponse,
                        _params.dhcp_requestDefaultGateway,
                        _params.dhcp_requestSubnetMask,
                        _params.dhcp_requestDnsServer,
                        _params.dhcp_requestDomainName);

      // Send the packet asynchronously over UDP to the DHCP server

      _expectedResponseMessage=DhcpPacket::MessageType::ACK;

      if(!this->udpSend("255.255.255.255",                      // broadcast address
                        IpPorts::PORT_DHCP_RESPONSE,            // source port
                        IpPorts::PORT_DHCP_REQUEST,             // destination port,
                        reinterpret_cast<uint8_t *>(dp),        // data
                        sizeof(buffer),                         // data size
                        true,                                   // asynchronous
                        0)) {                                   // time to wait (ignored)
        return this->setError(ErrorProvider::ERROR_PROVIDER_NET_DHCP,E_UDP_SEND_FAILED);
      }

      // advance to the next state

      _state=State::ACK;
      _stateBeginTime=this->getRtc().getTick();
      return true;
    }


    /**
     * ACK state handler
     * @return true if successfully advanced to next state
     */

    template<class TTransportLayer>
    inline bool DhcpClient<TTransportLayer>::stateAck() {

      uint32_t lease;

      // get the information from the response - it's no longer volatile

      _ipAddress=const_cast<IpAddress&>(_responsePacket->dhcp_yiaddr);

      uint8_t *options;
      options=reinterpret_cast<uint8_t *>(const_cast<DhcpPacket *>(_responsePacket))+DhcpPacket::getPacketSize();

      while(*options!=255) {

        if(*options==0)             // code 0 is just a null byte
          options++;
        else {
          switch(*options) {

            case 1:                 // subnet mask
              _subnetMask.ipAddress=*reinterpret_cast<uint32_t *>(options+2);
              break;

            case 3:                 // router (default gateway)
              _defaultGateway.ipAddress=*reinterpret_cast<uint32_t *>(options+2);
              break;

            case 6:                 // DNS servers (up to 3)
              if(options[1]>=4)
                _dnsServers[0].ipAddress=*reinterpret_cast<uint32_t *>(options+2);
              if(options[1]>=8)
                _dnsServers[1].ipAddress=*reinterpret_cast<uint32_t *>(options+6);
              if(options[1]>=12)
                _dnsServers[2].ipAddress=*reinterpret_cast<uint32_t *>(options+10);
              break;

            case 15:
              _domainName.reset(new char[options[1]+1]);
              memcpy(_domainName.get(),options+2,options[1]);
              _domainName[options[1]]='\0';
              break;

            case 51:                // lease time in seconds (renew 50% of time through)
              lease=NetUtil::ntohl(*reinterpret_cast<uint32_t *>(options+2));
              _expiryTime=this->_rtc->getTick()+lease;
              break;
          }

          // move to next option

          options+=2+options[1];
        }
      }

      // free the response packet

      freeResponsePacket();

      // announce our information

      if(_ipAddress.isValid())
        this->NetworkNotificationEventSender.raiseEvent(IpAddressAnnouncementEvent(_ipAddress));

      if(_subnetMask.isValid())
        this->NetworkNotificationEventSender.raiseEvent(IpSubnetMaskAnnouncementEvent(_subnetMask));

      if(_defaultGateway.isValid())
        this->NetworkNotificationEventSender.raiseEvent(IpDefaultGatewayAnnouncementEvent(_defaultGateway));

      if(_dnsServers[0].isValid())
        this->NetworkNotificationEventSender.raiseEvent(IpDnsServersAnnouncementEvent(_dnsServers));

      // we are completed

      _state=State::COMPLETED;
      return true;
    }


    /**
     * Free the response packet
     */

    template<class TTransportLayer>
    inline void DhcpClient<TTransportLayer>::freeResponsePacket() {

      if(_responsePacket) {
        free((void *)_responsePacket);
        _responsePacket=nullptr;
        _expectedResponseMessage=DhcpPacket::MessageType::NONE;
      }
    }


    /**
     * Notification event notification from the stack
     * @param ned The network event descriptor
     */

    template<class TTransportLayer>
    inline void DhcpClient<TTransportLayer>::onNotification(NetEventDescriptor& ned) {

      // we're interested in mac address announcements

      if(ned.eventType!=NetEventDescriptor::NetEventType::MAC_ADDRESS_ANNOUNCEMENT)
        return;

      _myMacAddress=static_cast<MacAddressAnnouncementEvent&>(ned).macAddress;
    }


    /**
     * Receive event notification from the stack
     * @param upe The UDP packet event
     */

    template<class TTransportLayer>
    inline void DhcpClient<TTransportLayer>::onReceive(UdpDatagramEvent& upe) {

      // handle UDP packets when we're waiting

      if(_expectedResponseMessage==DhcpPacket::MessageType::NONE || _responsePacket!=nullptr)
        return;

      // must be a DHCP packet on the response port

      if(NetUtil::ntohs(upe.udpDatagram.udp_destinationPort)!=IpPorts::PORT_DHCP_RESPONSE ||
         NetUtil::ntohs(upe.udpDatagram.udp_length)<UdpDatagram::getHeaderSize())
        return;

      // it's valid for our port

      upe.handled=true;

      // check the packet content magic number

      DhcpPacket *packet=reinterpret_cast<DhcpPacket *>(upe.udpDatagram.udp_data);
      if(packet->dhcp_magic!=NetUtil::htonl(0x63825363))
        return;

      // must be for the current session and our mac address and be a reply

      if(packet->dhcp_xid!=_transactionId || packet->dhcp_chaddr!=_myMacAddress || packet->dhcp_op!=DhcpPacket::Operation::REPLY)
        return;

      // must be the message type we expect

      if(_expectedResponseMessage!=packet->getMessageType())
        return;

      // store the packet and release the waiting code. not too concerned about the performance
      // overhead of copying packets around here because DHCP only runs when the system is
      // starting up or renewing.

      uint16_t packetLength=NetUtil::ntohs(upe.udpDatagram.udp_length);

      DhcpPacket *rp=reinterpret_cast<DhcpPacket *>(malloc(packetLength));
      memcpy(reinterpret_cast<void *>(rp),packet,packetLength);

      _responsePacket=rp;
    }


    /**
     * This IRQ code is a callback from our subscription to the NetworkIntervalTicker
     * class. We use ticks of the RTC to manage state transitions, timeout detection
     * and automatic lease renewal.
     * @param nitd The tick data
     */

    template<class TTransportLayer>
    inline void DhcpClient<TTransportLayer>::onTick(NetworkIntervalTickData& nitd) {

      if(_state==State::OFFER)
        handleOfferTick(nitd);
      else if(_state==State::ACK)
        handleAckTick(nitd);
      else if(_state==State::COMPLETED)
        handleCompleteTick(nitd);
    }


    /**
     * The RTC clock ticked while we were in the OFFER state
     */

    template<class TTransportLayer>
    inline void DhcpClient<TTransportLayer>::handleOfferTick(NetworkIntervalTickData& nitd) {

      if(_responsePacket==nullptr) {

        // check for timeout

        if(nitd.timeNow-_stateBeginTime>_params.dhcp_responseTimeout)
          retryRestart(nitd);         // timed out, retry the process
      }
      else {
        if(!stateOffer() || !stateRequest())        // invalid data in the response, retry restart
          retryRestart(nitd);
      }
    }


    /**
     * The RTC clock ticked while we were in the ACK state
     */

    template<class TTransportLayer>
    inline void DhcpClient<TTransportLayer>::handleAckTick(NetworkIntervalTickData& nitd) {

      if(_responsePacket==nullptr) {

        // check for timeout

        if(nitd.timeNow-_stateBeginTime>_params.dhcp_responseTimeout)
          retryRestart(nitd);         // timed out, retry the process
      }
      else {

        // process the ACK

        if(!stateAck())
          retryRestart(nitd);

        // the interval ticker is now updated to come back when we're
        // half way through the lease so we can renew it automatically

        nitd.interval=_expiryTime/2;
      }
    }


    /**
     * Something went wrong during the process. start it off again
     */

    template<class TTransportLayer>
    inline void DhcpClient<TTransportLayer>::retryRestart(NetworkIntervalTickData& nitd) {

      if(++_retryIndex==_params.dhcp_retries) {

        // run out of retries, cancel the timer

        _state=State::FAILED;
        this->setError(ErrorProvider::ERROR_PROVIDER_NET_DHCP,E_FAILED);
        nitd.interval=0;
      }
      else {

        if(internalDhcpClientAcquire())
          nitd.interval=1;                  // we're off again
        else {

          // cannot even restart the process, cancel the timer

          _state=State::FAILED;
          this->setError(ErrorProvider::ERROR_PROVIDER_NET_DHCP,E_FAILED);
          nitd.interval=0;
        }
      }
    }


    /**
     * RTC clock ticked while we were in the COMPLETED state. This can only mean that
     * the lease is to be renewed
     */

    template<class TTransportLayer>
    inline void DhcpClient<TTransportLayer>::handleCompleteTick(NetworkIntervalTickData& nitd) {

      // use the notification event to tell clients

      this->NetworkNotificationEventSender.raiseEvent(DhcpRenewalDueEvent(_expiryTime));

      // start the process again

      dhcpClientAcquire();

      // ticks are now at 1 second intervals

      nitd.interval=1;
    }
  }
}
// END FILE: ../lib/include/net/application/dhcp/DhcpClient.h
// START FILE: ../lib/include/net/application/dhcp/DhcpRenewalDueEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Event descriptor that announces that the DHCP release
     * is due for renewal
     */

    struct DhcpRenewalDueEvent : NetEventDescriptor {

      /**
       * The expiry time expressed as an RTC time in ticks. This is a time, not an offset.
       */

      uint32_t renewalTime;

      DhcpRenewalDueEvent(uint32_t rt)
        : NetEventDescriptor(NetEventType::DHCP_RENEWAL_DUE),
          renewalTime(rt) {
      }
    };
  }
}
// END FILE: ../lib/include/net/application/dhcp/DhcpRenewalDueEvent.h
// START FILE: ../lib/include/net/application/ftp/FtpServerConnection.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * FTP server connection class. Template parameters are used to access the actual implementation
     * for serving files and the TCP implementation for maintaining data connections
     */

    template<class TImpl,class TTcp>
    class FtpServerConnection : public FtpServerConnectionBase {

      protected:
        TTcp *_tcpImpl;                   ///< TCP implementation - need this to get client data server

      protected:
        void onAccept(TcpAcceptEvent& event);
        void onTick(NetworkIntervalTickData& nitd);

        bool flushCommandStreams();
        bool executeCommand();
        void invalidSyntax();
        void addResponseString(const char *str);
        bool assertParameter(const char *str);
        bool assertLoggedIn();
        void directoryListing(bool (TImpl::*listingFunction)());
        void saveCommand(const char *param,bool append);

        void userCommand(const char *param);
        void passCommand(const char *param);
        void systCommand();
        void cwdCommand(const char *param);
        void pwdCommand();
        void mkdCommand(const char *param);
        void rmdCommand(const char *param);
        void pasvCommand();
        void nlstCommand();
        void helpCommand();
        void noopCommand();
        void listCommand();
        void aborCommand();
        void retrCommand(const char *param);
        void restCommand(const char *param);
        void typeCommand(const char *param);
        void appeCommand(const char *param);
        void storCommand(const char *param);
        void deleCommand(const char *param);
        void sizeCommand(const char *param);

      public:
        FtpServerConnection(const Parameters& params,TTcp* tcpImpl);

        bool handleRead();              ///< implementation requirement from the TcpConnectionArray
        bool handleWrite();             ///< implementation requirement from the TcpConnectionArray
        bool handleCallback();          ///< implementation requirement from the TcpConnectionArray
    };


    /**
     * Constructor
     * @param params reference to the parameters class
     * tcpImpl pointer to the network stack's TCP implementation
     */

    template<class TImpl,class TTcp>
    inline FtpServerConnection<TImpl,TTcp>::FtpServerConnection(const Parameters& params,TTcp *tcpImpl)
      : FtpServerConnectionBase(params),
        _tcpImpl(tcpImpl) {

      // start the last active timer

      updateLastActiveTime();
    }


    /**
     * Some data is ready for reading
     * @return true always: we don't want to ever abandon the client's wait() call
     */

    template<class TImpl,class TTcp>
    inline bool FtpServerConnection<TImpl,TTcp>::handleRead() {

      if(!_commandReceiver.add(*this)) {

        // error reading data from the client. don't return false as that would stop the whole server.
        // abort the connection

        delete this;
        return true;
      }

      // are we ready to run ?

      if(!_commandReceiver.ready())
        return true;

      // update the last active time

      updateLastActiveTime();

      // run the command and disconnect if it fails badly

      if(!executeCommand()) {

        flushCommandStreams();

        // close the connection

        delete this;
        return true;
      }

      // reset the command reader for the next one

      _commandReceiver.reset();
      return true;
    }


    /**
     * Write is possible, handle it
     * @return true always: we don't want to ever abandon the client's wait() call
     */

    template<class TImpl,class TTcp>
    inline bool FtpServerConnection<TImpl,TTcp>::handleWrite() {

      uint32_t actuallySent;

      // if we've just started, write the greeting

      if(_authenticationState==FtpServerAuthenticationState::STARTING) {

        if(!static_cast<TImpl *>(this)->writeGreeting()) {
          delete this;
          return true;
        }

        // advance to unauthenticated

        _authenticationState=FtpServerAuthenticationState::UNAUTHENTICATED;
        return true;
      }

      // write pending data to this connection

      if(!_outputStreams.writeDataToConnection(actuallySent))
        delete this;

      if(actuallySent)
        updateLastActiveTime();

      return true;
    }


    /**
     * We'll use the callback feature of the TCP connection array to service the data connection
     * @return true (no close)
     */

    template<class TImpl,class TTcp>
    inline bool FtpServerConnection<TImpl,TTcp>::handleCallback() {

      // check the pointer

      if(_dataConnection) {

        if(_dataConnection->getDirection()==FtpServerDataConnection::Direction::DOWNLOAD) {

          // writing data to the data connection

          if(_dataConnection->getConnectionState().state==TcpState::ESTABLISHED) {

            if(_dataConnection->handleWrite()) {

              // has it finished?

              if(_dataConnection->finished()) {

                // it has finished, close the port, reset the send counter and send a message

                freeDataConnection();
                _sendStartPosition=0;
                addResponseString("226 Closing data connection.");
              }
            }
          }
          else {

            // write failed, send a message and close the data connection

            addResponseString("426 Connection closed; transfer aborted.");
            freeDataConnection();
          }
        }
        else if(_dataConnection->getDirection()==FtpServerDataConnection::Direction::UPLOAD) {

          // reading data from the data connection

          if(_dataConnection->handleRead()) {

            // has it finished?

            if(_dataConnection->finished()) {

              // it has finished, close the port, reset the send counter and send a message

              freeDataConnection();
              addResponseString("226 Closing data connection.");
            }
          }
          else {

            // read failed, send a message and close the data connection

            addResponseString("426 Connection closed; transfer aborted.");
            freeDataConnection();
          }
        }
      }

      // finally check for an idle timeout

      if(static_cast<TImpl *>(this)->hasTimedOut(MillisecondTimer::millis()-_lastActiveTime))
        delete this;

      return true;
    }


    /**
     * Flush the command streams
     * @return false if there was a fail
     */

    template<class TImpl,class TTcp>
    inline bool FtpServerConnection<TImpl,TTcp>::flushCommandStreams() {

      uint32_t actuallySent;

      // flush the streams

      while(!_outputStreams.completed()) {
        if(_outputStreams.canWriteToConnection() && !_outputStreams.writeDataToConnection(actuallySent))
          return false;
      }

      return true;
    }


    /**
     * Execute the command
     */

    template<class TImpl,class TTcp>
    inline bool FtpServerConnection<TImpl,TTcp>::executeCommand() {

      const char *cmd,*param;
      int size;
      std::string str;

      // the client can embed telnet control characters anywhere in the command. Maybe 40 years ago
      // that seemed like a good idea. Today it's just data corruption. Get rid of them.

      const std::string& rawCommand(_commandReceiver.str());
      str.reserve(rawCommand.length());

      for(auto it=rawCommand.begin();it!=rawCommand.end();it++)
        if((*it & 0x80)==0)
          str+=*it;

      // the spec says ONE space is allowed between the cmd and
      // the optional parameter

      cmd=str.c_str();

      if((param=strchr(cmd,' '))!=nullptr) {
        param++;
        size=param-cmd-1;
      }
      else
        size=_commandReceiver.str().length();

      // sometimes we get telnet

      if(!strncasecmp(cmd,"USER",size))
        userCommand(param);
      else if(!strncasecmp(cmd,"PASS",size))
        passCommand(param);
      else if(!strncasecmp(cmd,"SYST",size))
        systCommand();
      else if(!strncasecmp(cmd,"TYPE",size))
        typeCommand(param);
      else if(!strncasecmp(cmd,"CWD",size) || !strncasecmp(cmd,"XCWD",size))
        cwdCommand(param);
      else if(!strncasecmp(cmd,"PWD",size))
        pwdCommand();
      else if(!strncasecmp(cmd,"PASV",size))
        pasvCommand();
      else if(!strncasecmp(cmd,"NLST",size))
        nlstCommand();
      else if(!strncasecmp(cmd,"LIST",size))
        listCommand();
      else if(!strncasecmp(cmd,"REST",size))
        restCommand(param);
      else if(!strncasecmp(cmd,"RETR",size))
        retrCommand(param);
      else if(!strncasecmp(cmd,"ABOR",size))
        aborCommand();
      else if(!strncasecmp(cmd,"HELP",size))
        helpCommand();
      else if(!strncasecmp(cmd,"NOOP",size))
        noopCommand();
      else if(!strncasecmp(cmd,"MKD",size) || !strncasecmp(cmd,"XMKD",size))
        mkdCommand(param);
      else if(!strncasecmp(cmd,"RMD",size) || !strncasecmp(cmd,"XRMD",size))
        rmdCommand(param);
      else if(!strncasecmp(cmd,"STOR",size))
        storCommand(param);
      else if(!strncasecmp(cmd,"APPE",size))
        appeCommand(param);
      else if(!strncasecmp(cmd,"DELE",size))
        deleCommand(param);
      else if(!strncasecmp(cmd,"SIZE",size))
        sizeCommand(param);
      else if(!strncasecmp(cmd,"QUIT",size)) {

        // ask the subclass tow write its goodbye message

        static_cast<TImpl *>(this)->writeGoodbye();

        // return false to close the connection

        return false;
      }
      else
        addResponseString("500 Invalid command.");

      return true;
    }


    /**
     * Invalid syntax: return error message
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::invalidSyntax() {
      addResponseString("501 Invalid syntax.");
    }


    /**
     * Add a new constant string to the output
     * @param str constant string to add excluding "\r\n"
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::addResponseString(const char *str) {

      std::string *newstr;

      newstr=new std::string(str);
      (*newstr)+="\r\n";

      _outputStreams.addStream(
        new StlStringInputStream(
            newstr,true),
            true
          );
    }


    /**
     * Validate that the parameter is not null
     */

    template<class TImpl,class TTcp>
    inline bool FtpServerConnection<TImpl,TTcp>::assertParameter(const char *str) {

      if(str==nullptr || *str=='\0') {
        addResponseString("501 Parameter missing.");
        return false;
      }
      return true;
    }


    /**
     * Validate that the user is logged in
     */

    template<class TImpl,class TTcp>
    inline bool FtpServerConnection<TImpl,TTcp>::assertLoggedIn() {

      if(_authenticationState==FtpServerAuthenticationState::AUTHENTICATED)
        return true;

      addResponseString("530 Not logged in.");
      return false;
    }


    /**
     * Handle the USER command
     * @return true if it worked
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::userCommand(const char *param) {

      if(!assertParameter(param))
        return;

      // attempt to switch user clears auth state

      _authenticationState=FtpServerAuthenticationState::UNAUTHENTICATED;

      if(!strcasecmp(param,"anonymous")) {

        // if anonymous access is not permitted, reject

        if(!static_cast<TImpl *>(this)->isAnonymousPermitted()) {
          addResponseString("530 Anonymous access forbidden");
          _user.clear();
        }
        else {
          addResponseString("331 Anonymous access granted, enter email address as password");
          _user=param;
        }
      }
      else {
        _user=param;
        addResponseString("331 Enter your password");
      }
    }


    /**
     * Handle the PASS command
     * @return true if it worked
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::passCommand(const char *param) {

      if(!assertParameter(param))
        return;

      if(_user.empty())
        addResponseString("503 The USER command is required before PASS");
      else {

        if(_user=="anonymous" && static_cast<TImpl *>(this)->isAnonymousPermitted()) {

          addResponseString("230 Anonymous access granted");
          _authenticationState=FtpServerAuthenticationState::AUTHENTICATED;
        }
        else {

          // validate the user

          if(static_cast<TImpl *>(this)->loginUser(_user.c_str(),param)) {
            _authenticationState=FtpServerAuthenticationState::AUTHENTICATED;
            addResponseString("230 Access granted");
          }
          else {
            MillisecondTimer::delay(3000);
            addResponseString("530 Access denied");
            _user.clear();
          }
        }
      }
    }


    /**
     * SYST command. Due to abuse of this command over the years we return
     * a meaningless string
     * @return true
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::systCommand() {
      addResponseString("215 UNIX Type: L8");
    }


    /**
     * TYPE command. Set the transfer type. We only support binary.
     * @return true
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::typeCommand(const char *param) {

      if(!assertParameter(param) || !assertLoggedIn())
        return;

      if((param[0] | 32)=='i')
        addResponseString("200 Type set to binary");
      else if((param[0] | 32)=='a')
        addResponseString("200 Type set to ascii");
      else
        addResponseString("500 Invalid type - this server only supports binary");
    }


    /**
     * CWD command. Set the working directory
     * @return true
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::cwdCommand(const char *param) {

      // the pathname is the parameter

      if(!assertParameter(param) || !assertLoggedIn())
        return;

      // call the subclass to store the pathname

      if(!static_cast<TImpl *>(this)->setCwd(param)) {
        addResponseString("550 Failed to change directory.");
        return;
      }

      addResponseString("250 OK");
    }


    /**
     * PWD command. Show the working directory
     * @return true if logged in
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::pwdCommand() {

      if(!assertLoggedIn())
        return;

      // send the response

      std::string cwd(static_cast<TImpl *>(this)->getCwd());

      addResponseString(("257 \""+cwd+"\"").c_str());
    }


    /**
     * PASV command. Respond with an IP address and port number
     * @return true if logged in
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::pasvCommand() {

      char buffer[20],*ptr;

      if(!assertLoggedIn())
        return;

      // if a data connection server is already active then close it. don't do this elsewhere
      // as the TCP server class contains the TCP connection parameters that all connections
      // reference.

      freeDataConnectionServer();
      freeDataConnection();

      // get an ephemeral port

      if(!_tcpImpl->ip_acquireEphemeralPort(_dataConnectionPortNumber)) {
        addResponseString("500 No more ephemeral ports are available");
        return;
      }

      // create the data connection server

      if(!_tcpImpl->template tcpCreateServer<FtpServerDataConnection,FtpServerConnectionBase>(
              _dataConnectionPortNumber,
              _dataConnectionServer,
              this)) {

        // didn't work, free the ephemeral port

        _tcpImpl->ip_releaseEphemeralPort(_dataConnectionPortNumber);
        addResponseString("500 No more data connection servers are available");
        return;
      }

      // subscribe to accept events from the data connection server

      _dataConnectionServer->TcpAcceptEventSender.insertSubscriber(
          TcpAcceptEventSourceSlot::bind(this,&FtpServerConnection<TImpl,TTcp>::onAccept));

      // start the server

      _dataConnectionServer->start();

      // get the IP address separated by commas

      _tcpImpl->getIpAddress().toString(buffer);
      for(ptr=buffer;*ptr;ptr++)
        if(*ptr=='.')
          *ptr=',';

      std::string response("227 Entering Passive Mode (");
      response+=buffer;

      // add the port number

      response+=',';
      StringUtil::modp_uitoa10(_dataConnectionPortNumber >> 8,buffer);
      response+=buffer;

      response+=',';
      StringUtil::modp_uitoa10(_dataConnectionPortNumber & 0xff,buffer);
      response+=buffer;

      response+=").";

      // send the response

      addResponseString(response.c_str());
    }


    /**
     * A connection-accept event has been received, auto-add it to the array
     * @param event The accept event
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::onAccept(TcpAcceptEvent& event) {

      // the accept must be from the server that we are subscribed to

      if(&event.server==_dataConnectionServer) {

        // ensure there's only one

        freeDataConnection();

        // store the connection and mark it as being accepted

        _dataConnection=static_cast<FtpServerDataConnection *>(event.connection);
        event.accepted=true;
      }
    }


    /**
     * STOR: write a file to the server
     * @param param The user parameter to the command
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::storCommand(const char *param) {
      saveCommand(param,false);
    }


    /**
     * APPE: append a file to one on the server
     * @param param The user parameter to the command
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::appeCommand(const char *param) {
      saveCommand(param,true);
    }


    /**
     * Save a file to the server, with append option
     * @param param The parameter to save
     * @param append true to append, false to create/replace as needed
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::saveCommand(const char *param,bool append) {

      // must be logged in

      if(!assertParameter(param) || !assertLoggedIn())
        return;

      // must have a data connection

      if(_dataConnection==nullptr)
        addResponseString("425 Can't open data connection.");
      else {

        OutputStream *uploadStream;

        // this is an upload

        _dataConnection->setDirection(FtpServerDataConnection::Direction::UPLOAD);

        // send the marker

        if(!static_cast<TImpl *>(this)->upload(param,append,uploadStream)) {
          addResponseString("550 Unable to upload the file, sorry");
          freeDataConnection();
        }
        else {

          _dataConnection->setUploadStream(uploadStream);

          // ensure that the 150 mark gets out before the data connection finishes
          // which could happen in a small upload

          addResponseString("150 Upload command accepted");
          flushCommandStreams();
        }
      }
    }


    /**
     * NLST: simple directory listing
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::nlstCommand() {
      directoryListing(&TImpl::simpleListing);
    }


    /**
     * LIST: complex directory listing
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::listCommand() {
      directoryListing(&TImpl::complexListing);
    }


    /**
     * Generic directory lister (calls the fn ptr supplied by caller)
     * @param listingFunction The function to call that will complete the listing
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::directoryListing(bool (TImpl::*listingFunction)()) {

      // must be logged in

      if(!assertLoggedIn())
        return;

      // must have a data connection

      if(_dataConnection==nullptr)
        addResponseString("425 Can't open data connection.");
      else {

        // this is a download

        _dataConnection->setDirection(FtpServerDataConnection::Direction::DOWNLOAD);

        // do the listing

        if(!(static_cast<TImpl *>(this)->*listingFunction)())
          addResponseString("550 Unable to read directory (does it exist?)");
        else {

          // flush the data connection and close it

          addResponseString("150 File status okay; about to open data connection.");

          flushCommandStreams();

          if(_dataConnection->flush())
            addResponseString("226 Directory listing completed");
          else
            addResponseString("426 Directory listing failed");
        }

        freeDataConnection();
      }
    }


    /**
     * REST: reset the start position
     * @param param The user parameter to the command
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::restCommand(const char *param) {

      if(assertParameter(param) && assertLoggedIn()) {

        _sendStartPosition=atoi(param);
        addResponseString("350 Requested file action pending further information.");
      }
    }


    /**
     * RETR: download a file
     * @param param The user parameter to the command
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::retrCommand(const char *param) {

      if(!assertParameter(param) || !assertLoggedIn())
        return;

      // must have a data connection

      if(_dataConnection==nullptr) {
        addResponseString("425 Can't open data connection.");
        freeDataConnection();
      }
      else {

        // this is a download

        _dataConnection->setDirection(FtpServerDataConnection::Direction::DOWNLOAD);

        if(!static_cast<TImpl *>(this)->download(param))
          addResponseString("550 Unable to download the file (does it exist?)");
        else {

          addResponseString("150 Download command accepted");

          // ensure that the 150 mark gets out before the data connection finishes
          // which could happen in a small download

          flushCommandStreams();
        }
      }
    }


    /**
     * NOOP: simple response
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::noopCommand() {
      addResponseString("200 OK");
    }


    /**
     * MKD: create a directory
     * @param param The user parameter to the command
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::mkdCommand(const char *param) {

      std::string newdir;

      if(assertParameter(param) && assertLoggedIn()) {

        if(static_cast<TImpl *>(this)->createDirectory(param,newdir)) {
          newdir="257 \""+newdir+"\" directory created";
          addResponseString(newdir.c_str());
        }
        else
          addResponseString("550 Failed to create directory");
      }
    }


    /**
     * RMD: remove a directory
     * @param param The user parameter to the command
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::rmdCommand(const char *param) {

      if(assertParameter(param) && assertLoggedIn()) {

        if(static_cast<TImpl *>(this)->removeDirectory(param)) {
          addResponseString("250 Directory removed");
        }
        else
          addResponseString("550 Failed to remove directory");
      }
    }


    /**
     * DELE: remove a file
     * @param param The user parameter to the command
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::deleCommand(const char *param) {

      if(assertParameter(param) && assertLoggedIn()) {

        if(static_cast<TImpl *>(this)->removeFile(param)) {
          addResponseString("250 File removed");
        }
        else
          addResponseString("550 Failed to remove file");
      }
    }


    /**
     * SIZE: return the transfer size of a file
     * @param param The user parameter to the command
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::sizeCommand(const char *param) {

      uint32_t fileSize;
      char buffer[20];

      if(assertParameter(param) && assertLoggedIn()) {

        if(static_cast<TImpl *>(this)->fileSize(param,fileSize)) {
          strcpy(buffer,"213 ");
          StringUtil::modp_uitoa10(fileSize,buffer+4);
          addResponseString(buffer);
        }
        else
          addResponseString("550 Size not available");
      }
    }


    /**
     * HELP: show a one liner
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::helpCommand() {

      char buffer[6];
      std::string str;

      // show the build number

      buffer[0]='0'+((STM32PLUS_BUILD >> 16) & 0xff);
      buffer[1]='.';
      buffer[2]='0'+((STM32PLUS_BUILD >> 8) & 0xff);
      buffer[3]='.';
      buffer[4]='0'+(STM32PLUS_BUILD & 0xff);
      buffer[5]='\0';

      str="214 stm32plus ";
      str+=buffer;
      str+=" ftp server ready and waiting";

      addResponseString(str.c_str());
    }


    /**
     * ABOR: abort the data transfer
     */

    template<class TImpl,class TTcp>
    inline void FtpServerConnection<TImpl,TTcp>::aborCommand() {

      // must be logged in

      if(assertLoggedIn()) {

        // abort if in progress

        if(_dataConnection!=nullptr) {
          freeDataConnection();
          addResponseString("426 Download aborted");
        }

        addResponseString("226 Abort successfully processed");
      }
    }
  }
}
// END FILE: ../lib/include/net/application/ftp/FtpServerConnection.h
// START FILE: ../lib/include/net/application/ftp/FtpServerAuthenticationState.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * The client's authentication state
     */

    enum class FtpServerAuthenticationState : uint8_t {
      STARTING,           ///< The server is starting up
      UNAUTHENTICATED,    ///< The server is ready to get credentials
      AUTHENTICATED       ///< The user has authenticated
    };
  }
}
// END FILE: ../lib/include/net/application/ftp/FtpServerAuthenticationState.h
// START FILE: ../lib/include/net/application/ftp/FtpServerDataConnection.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    class FtpServerConnectionBase;

    /**
     * Data connection for the FTP server. There can be only one data connection at any one time
     */

    class FtpServerDataConnection : public TcpConnection {

      public:

        /**
         * Possible data transfer directions
         */

        enum class Direction : uint8_t {
          NOT_STARTED,
          UPLOAD,
          DOWNLOAD
        };


        /**
         * General constants
         */

        enum {
          UPLOAD_TRANSFER_BUFFER_SIZE = 512   // amount read from receive buffer and written to output stream (512b matches SD Card sector size)
        };


        /**
         * Data connection parameters
         */

        struct Parameters : TcpConnection::Parameters {

          /**
           * Constructor
           */

          Parameters() {
            tcp_receiveBufferSize=1024;       // for uploads, increase the receive buffer to 1Kb
          }
        };

      protected:
        FtpServerConnectionBase *_commandConnection;
        TcpOutputStreamOfStreams _outputStreams;
        Direction _direction;
        scoped_ptr<OutputStream> _uploadStream;

        enum class State : uint8_t {
          NOT_STARTED,
          RUNNING
        } _state;

      public:
        FtpServerDataConnection(const Parameters& params,FtpServerConnectionBase *serverbase);
        ~FtpServerDataConnection();

        bool handleWrite();
        bool handleRead();

        bool flush();
        bool finished() const;

        void addString(const char *str);
        void addStream(InputStream *stream,bool owned);
        void setUploadStream(OutputStream *stream);
        void setDirection(Direction dir);
        Direction getDirection() const;
    };


    /**
     * Set the direction
     * @param dir
     */

    inline void FtpServerDataConnection::setDirection(Direction dir) {
      _direction=dir;
    }


    /**
     * Get the direction
     * @return
     */

    inline FtpServerDataConnection::Direction FtpServerDataConnection::getDirection() const {
      return _direction;
    }


    /**
     * Set a new upload stream
     * @param stream The upload stream
     */

    inline void FtpServerDataConnection::setUploadStream(OutputStream *stream) {
      _uploadStream.reset(stream);
    }
  }
}
// END FILE: ../lib/include/net/application/ftp/FtpServerDataConnection.h
// START FILE: ../lib/include/net/application/ftp/FtpServerConnectionBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * Non-template base class for the FTP server connection class
     */

    class FtpServerConnectionBase : public TcpConnection {

      public:

        /**
         * Parameters for this class
         */

        struct Parameters : TcpConnection::Parameters {

          uint16_t ftp_maxRequestLineLength;            ///< size includes the verb, and all parameters. Default is 200
          uint16_t ftp_outputStreamBufferMaxSize;       ///< buffer size of the stream-of-streams class. Default is 256
          uint16_t ftp_dataConnectionSendBufferSize;    ///< data connection send buffer size. Default is 2920 (2*MTU for ethernet)

          /**
           * Constructor
           */

          Parameters() {
            ftp_maxRequestLineLength=200;
            ftp_outputStreamBufferMaxSize=256;
            ftp_dataConnectionSendBufferSize=2918;
          }
        };

      protected:
        void freeDataConnectionServer();
        void freeDataConnection();

      protected:
        const Parameters& _params;        ///< reference to the parameters class

        TcpServer<FtpServerDataConnection,FtpServerConnectionBase> *_dataConnectionServer;
        FtpServerDataConnection *_dataConnection;

        uint16_t _dataConnectionPortNumber;
        TcpTextLineReceiver _commandReceiver;
        TcpOutputStreamOfStreams _outputStreams;
        FtpServerAuthenticationState _authenticationState;
        std::string _user;
        uint32_t _sendStartPosition;
        uint32_t _lastActiveTime;

      public:
        FtpServerConnectionBase(const Parameters& params);
        ~FtpServerConnectionBase();

        void clearDataConnection();       ///< this is a callback for the data connection server to clear itself
        uint16_t getDataConnectionSendBufferSize() const;
        void updateLastActiveTime();
    };


    /**
     * Constructor
     * @param params The parameters class
     */

    inline FtpServerConnectionBase::FtpServerConnectionBase(const Parameters& params)
      : TcpConnection(params),
        _params(params),
        _dataConnectionServer(nullptr),
        _dataConnection(nullptr),
        _commandReceiver(params.ftp_maxRequestLineLength),
        _outputStreams(*this,params.ftp_outputStreamBufferMaxSize),
        _authenticationState(FtpServerAuthenticationState::STARTING),
        _sendStartPosition(0) {
    }


    /**
     * Destructor, clean up data connection pointer
     */

    inline FtpServerConnectionBase::~FtpServerConnectionBase() {

      // this must be done first

      freeDataConnectionServer();

      // then the connection

      freeDataConnection();
    }


    /**
     * Free the data connection server
     */

    inline void FtpServerConnectionBase::freeDataConnectionServer() {

      if(_dataConnectionServer) {
        delete _dataConnectionServer;
        _dataConnectionServer=nullptr;
      }
    }


    /**
     * Free the data connection
     */

    inline void FtpServerConnectionBase::freeDataConnection() {

      if(_dataConnection)
        delete _dataConnection;   // this will cause a callback to clear the pointer
    }


    /**
     * Clear our reference to the data connection that has now been deleted
     */

    inline void FtpServerConnectionBase::clearDataConnection() {
      _dataConnection=nullptr;
    }


    /**
     * Get the data connection send buffer size
     */

    inline uint16_t FtpServerConnectionBase::getDataConnectionSendBufferSize() const {
      return _params.ftp_dataConnectionSendBufferSize;
    }


    /**
     * Update the last active time
     */

    inline void FtpServerConnectionBase::updateLastActiveTime() {
      _lastActiveTime=MillisecondTimer::millis();
    }
  }
}
// END FILE: ../lib/include/net/application/ftp/FtpServerConnectionBase.h
// START FILE: ../lib/include/event/fd/FastDelegateBind.h
//            FastDelegateBind.h 
//  Helper file for FastDelegates. Provides bind() function, enabling
//  FastDelegates to be rapidly compared to programs using boost::function and boost::bind.
//
//  Documentation is found at http://www.codeproject.com/cpp/FastDelegate.asp
//
//    Original author: Jody Hagins.
//     Minor changes by Don Clugston.
//
// Warning: The arguments to 'bind' are ignored! No actual binding is performed.
// The behaviour is equivalent to boost::bind only when the basic placeholder 
// arguments _1, _2, _3, etc are used in order.
//
// HISTORY:
//  1.4 Dec 2004. Initial release as part of FastDelegate 1.4.


#ifndef FASTDELEGATEBIND_H
#define FASTDELEGATEBIND_H
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

////////////////////////////////////////////////////////////////////////////////
//            FastDelegate bind()
//
//        bind() helper function for boost compatibility.
//        (Original author: Jody Hagins).
//
// Add another helper, so FastDelegate can be a dropin replacement
// for boost::bind (in a fair number of cases).
// Note the elipses, because boost::bind() takes place holders
// but FastDelegate does not care about them.  Getting the place holder
// mechanism to work, and play well with boost is a bit tricky, so
// we do the "easy" thing...
// Assume we have the following code...
//      using boost::bind;
//      bind(&Foo:func, &foo, _1, _2);
// we should be able to replace the "using" with...
//      using fastdelegate::bind;
// and everything should work fine...
////////////////////////////////////////////////////////////////////////////////

#ifdef FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX

namespace fastdelegate {

//N=0
template <class X, class Y, class RetType>
FastDelegate< RetType (  ) >
bind(
    RetType (X::*func)(  ),
    Y * y,
    ...)
{ 
  return FastDelegate< RetType (  ) >(y, func);
}

template <class X, class Y, class RetType>
FastDelegate< RetType (  ) >
bind(
    RetType (X::*func)(  ) const,
    Y * y,
    ...)
{ 
  return FastDelegate< RetType (  ) >(y, func);
}

//N=1
template <class X, class Y, class RetType, class Param1>
FastDelegate< RetType ( Param1 p1 ) >
bind(
    RetType (X::*func)( Param1 p1 ),
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1 ) >(y, func);
}

template <class X, class Y, class RetType, class Param1>
FastDelegate< RetType ( Param1 p1 ) >
bind(
    RetType (X::*func)( Param1 p1 ) const,
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1 ) >(y, func);
}

//N=2
template <class X, class Y, class RetType, class Param1, class Param2>
FastDelegate< RetType ( Param1 p1, Param2 p2 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2 ),
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2 ) >(y, func);
}

template <class X, class Y, class RetType, class Param1, class Param2>
FastDelegate< RetType ( Param1 p1, Param2 p2 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2 ) const,
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2 ) >(y, func);
}

//N=3
template <class X, class Y, class RetType, class Param1, class Param2, class Param3>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3 ),
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3 ) >(y, func);
}

template <class X, class Y, class RetType, class Param1, class Param2, class Param3>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3 ) const,
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3 ) >(y, func);
}

//N=4
template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ),
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) >(y, func);
}

template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const,
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) >(y, func);
}

//N=5
template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ),
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) >(y, func);
}

template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const,
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) >(y, func);
}

//N=6
template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ),
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) >(y, func);
}

template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const,
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) >(y, func);
}

//N=7
template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ),
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) >(y, func);
}

template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const,
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) >(y, func);
}

//N=8
template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ),
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) >(y, func);
}

template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) >
bind(
    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const,
    Y * y,
    ...)
{ 
  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) >(y, func);
}


#endif //FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX

} // namespace fastdelegate

#endif // !defined(FASTDELEGATEBIND_H)

// END FILE: ../lib/include/event/fd/FastDelegateBind.h
// START FILE: ../lib/include/event/signal.h
///
/// Wink Signals
/// Copyright (C) 2012 Anax Creations. All rights reserved.
///
///
/// This software is provided 'as-is', without any express or implied warranty.
/// In no event will the authors be held liable for any damages arising from the
/// use of this software.
///
/// Permission is hereby granted, free of charge, to any person
/// obtaining a copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation the rights
/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
/// copies of the Software, and to permit persons to whom the Software is
/// furnished to do so, subject to the following conditions:
///
/// 1. The origin of this software must not be misrepresented;
///    you must not claim that you wrote the original software.
///    If you use this software in a product, an acknowledgment
///    in the product documentation would be appreciated but is not required.
///
/// 2. Altered source versions must be plainly marked as such,
///    and must not be misrepresented as being the original software.
///
/// 3. The above copyright notice and this permission notice shall be included in
///    all copies or substantial portions of the Software.
///

/**
 * In accordance with the above license I need to point out that this file is heavily modified
 * to not require the STL. We use a simple linked list instead.
 */

#pragma once


namespace wink {
  template<class Slot>
  struct signal {

    protected:

      typedef Slot slot_type;

      slot_type _firstSlot;
#ifdef EXT_SLIST     
      __gnu_cxx::slist<slot_type> _slots;
#else
      std::slist<slot_type> _slots;
#endif
    public:

      /// Connects a slot to the signal
      /// \param slot The slot you wish to connect
      /// \see bind To bind a slot to a function

      void insertSubscriber(const slot_type& slot) {

        if(_slots.size()==0)
          _firstSlot=slot;

        _slots.push_front(slot);
      }

      /// Disconnects a slot from the signal
      /// \param slot The slot you wish to disconnect
      /// \see bind To bind a slot to a function

      bool removeSubscriber(const slot_type& slot) {

        for(auto it=_slots.begin();it!=_slots.end();it++) {
          if(*it==slot) {
            _slots.erase(it);
            return true;
          }
        }
        return false;
      }

      /// Emits the events you wish to send to the call-backs
      /// \param args The arguments to emit to the slots connected to the signal
      template <class ...Args>
      void raiseEvent(Args&&... args) const {

        if(_slots.size()==1)
          _firstSlot(args...);
        else {
          for(auto it=_slots.begin();it!=_slots.end();it++)
            (*it)(args...);
        }
      }
  };
}
// END FILE: ../lib/include/event/signal.h
// START FILE: ../lib/include/event/slot.h
///
/// Wink Signals
/// Copyright (C) 2012 Anax Creations. All rights reserved.
///
///
/// This software is provided 'as-is', without any express or implied warranty.
/// In no event will the authors be held liable for any damages arising from the
/// use of this software.
///
/// Permission is hereby granted, free of charge, to any person
/// obtaining a copy of this software and associated documentation files (the "Software"),
/// to deal in the Software without restriction, including without limitation the rights
/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
/// copies of the Software, and to permit persons to whom the Software is
/// furnished to do so, subject to the following conditions:
///
/// 1. The origin of this software must not be misrepresented;
///    you must not claim that you wrote the original software.
///    If you use this software in a product, an acknowledgment
///    in the product documentation would be appreciated but is not required.
///
/// 2. Altered source versions must be plainly marked as such,
///    and must not be misrepresented as being the original software.
///
/// 3. The above copyright notice and this permission notice shall be included in
///    all copies or substantial portions of the Software.
///

#ifndef __WINK_SLOT_H__
#define __WINK_SLOT_H__

#include "fd/FastDelegate.h"

namespace wink
{
  /// \brief Describes a slot that may be added to a signal, or used stand-alone for a call-back
  ///
  /// This can be used as an alternative to std::function, as it is much faster.
  ///
  /// \author Miguel Martin
  template <typename Signature>
  struct slot
  {
  private:
    
    typedef slot<Signature> __this_type;
    
  public:
    
    /// A static function pointer with the correct signature
    typedef Signature FnPtr;
    
    /// Binds a function
    /// \param fn The function you wish to bind
    /// \note This function must be either marked as static, or not inside a class/struct (i.e. in global scope)
    static slot<Signature> bind(Signature fn)
    {
      return __this_type(fn);
    }
    
    /// Binds a member function
    /// \param obj The object you wish
    template <typename T, typename MemFnPtr>
    static slot<Signature> bind(T* obj, MemFnPtr fn)
    {
      return __this_type(obj, fn);
    }
    
    /// Construct a slot with no call-back
    slot()
    {}
    
    /// Construct a slot with a static/global function call-back
    /// \param fn The static/global function
    slot(FnPtr fn)
    : _delegate(fn)
    {}
    
    /// Construct a slot with a member-function
    /// \param obj The object that the member-function belongs to
    /// \param fn The member function of the object
    template <typename T, typename MemFnPtr>
    slot(T* obj, MemFnPtr fn)
    : _delegate(obj, fn)
    {}
    
    /// Copy constructor
    slot(const __this_type& slot)
    : _delegate(slot._delegate)
    {}
    
    /// Destructor
    ~slot() {}
    
    /// Assignment operator
    /// \param slot The slot you wish to assign to
    /// \return *this
    __this_type& operator=(const __this_type& slot)
    {
      _delegate = slot._delegate;
      return *this;
    }
    
    /// Calls the slot
    /// \param args Any arguments you want to pass to the slot
    template <class ...Args>
    void operator()(Args&&... args) const
    {
      _delegate(args...);
    }
    
    
    // comparision operators for sorting and comparing
    
    bool operator==(const __this_type& slot) const
    { return _delegate == slot._delegate; }
    
    bool operator!=(const __this_type& slot) const
    { return !operator==(slot); }
    
    bool operator<(const __this_type& slot) const
    { return _delegate < slot._delegate; }
    
    bool operator>(const __this_type& slot) const
    { return slot._delegate < _delegate; }
    
    bool operator<=(const __this_type& slot) const
    { return operator>(slot); }
    
    bool operator>=(const __this_type& slot) const
    { return operator<(slot); }
    
  private:
    
    /// The implementation of the slot, as a delegate.
    typedef fastdelegate::FastDelegate<Signature> __impl_delegate;
    
    
    __impl_delegate _delegate;
  };
}


#endif // __WINK_SLOT_H__
// END FILE: ../lib/include/event/slot.h
// START FILE: ../lib/include/pwr/f1,f4/LowPowerModes.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#if !defined(STM32PLUS_F1) && !defined(STM32PLUS_F4)
#error This class can only be used with the STM32F0 series
#endif


extern "C" void SystemInit();


namespace stm32plus {

  /**
   * @brief Allow the STM32 to be put into one of the low power modes.
   *
   * Convenience class to wrap the functions in the std peripheral library.
   */

  class LowPowerModes {

    protected:
      void doStop(uint32_t regulatorMode,uint8_t entry);

    public:
      LowPowerModes();

      void standby();

      void stopInterruptWakeup(uint32_t regulatorMode=PWR_Regulator_LowPower);
      void stopEventWakeup(uint32_t regulatorMode=PWR_Regulator_LowPower);

      void enableWakeup() const;
      void disableWakeup() const;

      void disable() const;

      static bool wasWokenUp();
      static bool wasInStandby();
  };


  /**
   * Constructor. Enable access to the backup domain and enable the wakeup pin
   */

  inline LowPowerModes::LowPowerModes() {

    // power and backup domain clocks on

    ClockControl<PERIPHERAL_POWER>::On();

    // wakeup pin enable, backup access enable

    PWR_BackupAccessCmd( ENABLE);
    PWR_WakeUpPinCmd(ENABLE);
  }


  /**
   * disable pins and stop clocks
   */

  inline void LowPowerModes::disable() const {

    // clean up

    PWR_WakeUpPinCmd(DISABLE);
    PWR_BackupAccessCmd( DISABLE);

    ClockControl<PERIPHERAL_POWER>::Off();
  }


  /*
   * Set the processor to STOP mode
   */

  inline void LowPowerModes::doStop(uint32_t regulatorMode,uint8_t entry) {

    bool systickInterruptEnabled;

    // Systick interrupt cannot be enabled during stop mode
    // See: STM32F103xC/D/E errata: "Debugging Stop mode and system tick timer"

    systickInterruptEnabled=(SysTick->CTRL & SysTick_CTRL_TICKINT_Msk) != 0;
    if(systickInterruptEnabled)
      SysTick->CTRL&=~SysTick_CTRL_TICKINT_Msk;

    // enter stop mode

    PWR_EnterSTOPMode(regulatorMode,entry);

    // re-enable clocks - you must supply this function in your app, and you must have done in order
    // to run anything at all though you may have called it something different.

    ::SystemInit();

    // re-enable Systick if it was previously on. If a Systick would have fired during the stop mode
    // then that tick is lost, i.e. the interrupt pending bit is not set on wakeup.

    if(systickInterruptEnabled)
      SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;
  }


  /**
   * Enter standby mode
   */

  inline void LowPowerModes::standby() {
    PWR_EnterSTANDBYMode();
  }


  /**
   * Enter stop mode, waking on EXTI interrupt.
   * @param[in] regulatorMode PWR_Regulator_ON or PWR_Regulator_LowPower determines if the voltage regulator
   *  goes into low power or not
   */

  inline void LowPowerModes::stopInterruptWakeup(uint32_t regulatorMode) {
    doStop(regulatorMode,PWR_STOPEntry_WFI);
  }


  /**
   * Enter stop mode, waking on EXTI event.
   * @param[in] regulatorMode PWR_Regulator_ON or PWR_Regulator_LowPower determines if the voltage regulator
   *  goes into low power or not
   */

  inline void LowPowerModes::stopEventWakeup(uint32_t regulatorMode) {
    doStop(regulatorMode,PWR_STOPEntry_WFE);
  }


  /**
   * Return true if we're running after a wakeup event
   * @return true if wakeup has happened
   */

  inline bool LowPowerModes::wasWokenUp() {
    return PWR_GetFlagStatus(PWR_FLAG_WU)!=RESET;
  }


  /**
   * Return true if we were in standby mode before this run
   * @return true if we were previously in standby
   */

  inline bool LowPowerModes::wasInStandby() {
    return PWR_GetFlagStatus(PWR_FLAG_SB)!=RESET;
  }


  /**
   * Enable the WAKEUP pin
   */

  inline void LowPowerModes::enableWakeup() const {
    PWR_WakeUpPinCmd(ENABLE);
  }


  /**
   * Disable the WAKEUP pin
   */

  inline void LowPowerModes::disableWakeup() const {
    PWR_WakeUpPinCmd(DISABLE);
  }
}
// END FILE: ../lib/include/pwr/f1,f4/LowPowerModes.h
// START FILE: ../lib/include/dma/DmaEventSource.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * DMA event types
   */

  enum class DmaEventType : uint8_t {
    EVENT_COMPLETE,
    EVENT_HALF_COMPLETE,
    EVENT_TRANSFER_ERROR,
  };


  /**
   * The signature for DMA events: void myHandler(DmaEventType det);
   */

  DECLARE_EVENT_SIGNATURE(DmaInterrupt,void(DmaEventType));


  /**
   * Base structure that holds just the event subscriber/publisher for DMA
   */

  struct DmaEventSource {
    DECLARE_EVENT_SOURCE(DmaInterrupt);
  };
}
// END FILE: ../lib/include/dma/DmaEventSource.h
// START FILE: ../lib/include/dma/features/f4/Dma2Stream7InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 2, stream 7 interrupt feature
   */

  typedef DmaInterruptFeature<2,7> Dma2Stream7InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma2Stream7InterruptFeature Timer8Channel4DmaChannelInterruptFeature;
  typedef Dma2Stream7InterruptFeature Timer8TriggerDmaChannelInterruptFeature;
  typedef Dma2Stream7InterruptFeature Timer8ComDmaChannelInterruptFeature;
  typedef Dma2Stream7InterruptFeature Usart6TxStream7DmaChannelInterruptFeature;
  typedef Dma2Stream7InterruptFeature Usart1TxDmaChannelInterruptFeature;
  typedef Dma2Stream7InterruptFeature HashInDmaChannelInterruptFeature;
  typedef Dma2Stream7InterruptFeature DcmiStream7DmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma2Stream7InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma1Stream1InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 1, stream 1 interrupt feature
   */

  typedef DmaInterruptFeature<1,1> Dma1Stream1InterruptFeature;

  /**
   * Typedefs for the peripherals that use this interrupt
   */

  typedef Dma1Stream1InterruptFeature Timer6UpdateDmaChannelInterruptFeature;
  typedef Dma1Stream1InterruptFeature Timer5Channel4DmaChannelInterruptFeature;
  typedef Dma1Stream1InterruptFeature Timer5TriggerDmaChannelInterruptFeature;
  typedef Dma1Stream1InterruptFeature Usart3RxDmaChannelInterruptFeature;
  typedef Dma1Stream1InterruptFeature Timer2UpdateDmaChannelInterruptFeature;
  typedef Dma1Stream1InterruptFeature Timer2Channel3DmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma1Stream1InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma2Stream4InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 2, stream 4 interrupt feature
   */

  typedef DmaInterruptFeature<2,4> Dma2Stream4InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma2Stream4InterruptFeature Timer8Channel3Stream4DmaChannelInterruptFeature;
  typedef Dma2Stream4InterruptFeature Timer1Channel4DmaChannelInterruptFeature;
  typedef Dma2Stream4InterruptFeature Timer1TriggerStream4DmaChannelInterruptFeature;
  typedef Dma2Stream4InterruptFeature Timer1ComDmaChannelInterruptFeature;
  typedef Dma2Stream4InterruptFeature Adc1Stream4DmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma2Stream4InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma2Stream0InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 2, stream 0 interrupt feature
   */

  typedef DmaInterruptFeature<2,0> Dma2Stream0InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma2Stream0InterruptFeature Timer1TriggerDmaChannelInterruptFeature;
  typedef Dma2Stream0InterruptFeature Spi1RxDmaChannelInterruptFeature;
  typedef Dma2Stream0InterruptFeature Adc3DmaChannelInterruptFeature;
  typedef Dma2Stream0InterruptFeature Adc1DmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma2Stream0InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma2Stream5InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 2, stream 5 interrupt feature
   */

  typedef DmaInterruptFeature<2,5> Dma2Stream5InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma2Stream5InterruptFeature Timer1UpdateDmaChannelInterruptFeature;
  typedef Dma2Stream5InterruptFeature Usart1RxStream5DmaChannelInterruptFeature;
  typedef Dma2Stream5InterruptFeature Spi1TxStream5DmaChannelInterruptFeature;
  typedef Dma2Stream5InterruptFeature CrypOutDmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma2Stream5InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma2Stream3InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 2, stream 3 interrupt feature
   */

  typedef DmaInterruptFeature<2,3> Dma2Stream3InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma2Stream3InterruptFeature Timer8Channel2Stream3DmaChannelInterruptFeature;
  typedef Dma2Stream3InterruptFeature Timer1Channel1Stream3DmaChannelInterruptFeature;
  typedef Dma2Stream3InterruptFeature SdioDmaChannelInterruptFeature;
  typedef Dma2Stream3InterruptFeature Spi1TxDmaChannelInterruptFeature;
  typedef Dma2Stream3InterruptFeature Adc2Stream3DmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma2Stream3InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma1Stream6InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 1, stream 6 interrupt feature
   */

  typedef DmaInterruptFeature<1,6> Dma1Stream6InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma1Stream6InterruptFeature Dac2DmaChannelInterruptFeature;
  typedef Dma1Stream6InterruptFeature Timer5UpdateStream6DmaChannelInterruptFeature;
  typedef Dma1Stream6InterruptFeature Usart2TxDmaChannelInterruptFeature;
  typedef Dma1Stream6InterruptFeature Timer2Channel2DmaChannelInterruptFeature;
  typedef Dma1Stream6InterruptFeature Timer2Channel4DmaChannelInterruptFeature;
  typedef Dma1Stream6InterruptFeature Timer4UpdateDmaChannelInterruptFeature;
  typedef Dma1Stream6InterruptFeature I2C1TxDmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma1Stream6InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/DmaPeripheralInfo.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA peripheral info types serve to hold basic information about a peripheral that could be used
   * as a source or target for DMA operations. e.g. the register address and memory transfer size
   */

  struct TimerDmaPeripheralInfo {
      enum {
        MEMORY_WORD_SIZE = DMA_MemoryDataSize_HalfWord,
        PERIPHERAL_WORD_SIZE = DMA_PeripheralDataSize_HalfWord
    };
  };

  struct Timer1CntDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM1_BASE + __builtin_offsetof(TIM_TypeDef,CNT) }; };
  struct Timer1ArrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM1_BASE + __builtin_offsetof(TIM_TypeDef,ARR) }; };
  struct Timer1RcrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM1_BASE + __builtin_offsetof(TIM_TypeDef,RCR) }; };
  struct Timer1Ccr1DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM1_BASE + __builtin_offsetof(TIM_TypeDef,CCR1) }; };
  struct Timer1Ccr2DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM1_BASE + __builtin_offsetof(TIM_TypeDef,CCR2) }; };
  struct Timer1Ccr3DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM1_BASE + __builtin_offsetof(TIM_TypeDef,CCR3) }; };
  struct Timer1Ccr4DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM1_BASE + __builtin_offsetof(TIM_TypeDef,CCR4) }; };

  struct Timer2CntDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM2_BASE + __builtin_offsetof(TIM_TypeDef,CNT) }; };
  struct Timer2ArrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM2_BASE + __builtin_offsetof(TIM_TypeDef,ARR) }; };
  struct Timer2RcrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM2_BASE + __builtin_offsetof(TIM_TypeDef,RCR) }; };
  struct Timer2Ccr1DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM2_BASE + __builtin_offsetof(TIM_TypeDef,CCR1) }; };
  struct Timer2Ccr2DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM2_BASE + __builtin_offsetof(TIM_TypeDef,CCR2) }; };
  struct Timer2Ccr3DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM2_BASE + __builtin_offsetof(TIM_TypeDef,CCR3) }; };
  struct Timer2Ccr4DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM2_BASE + __builtin_offsetof(TIM_TypeDef,CCR4) }; };

  struct Timer3CntDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM3_BASE + __builtin_offsetof(TIM_TypeDef,CNT) }; };
  struct Timer3ArrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM3_BASE + __builtin_offsetof(TIM_TypeDef,ARR) }; };
  struct Timer3RcrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM3_BASE + __builtin_offsetof(TIM_TypeDef,RCR) }; };
  struct Timer3Ccr1DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM3_BASE + __builtin_offsetof(TIM_TypeDef,CCR1) }; };
  struct Timer3Ccr2DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM3_BASE + __builtin_offsetof(TIM_TypeDef,CCR2) }; };
  struct Timer3Ccr3DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM3_BASE + __builtin_offsetof(TIM_TypeDef,CCR3) }; };
  struct Timer3Ccr4DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM3_BASE + __builtin_offsetof(TIM_TypeDef,CCR4) }; };

  struct Timer4CntDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM4_BASE + __builtin_offsetof(TIM_TypeDef,CNT) }; };
  struct Timer4ArrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM4_BASE + __builtin_offsetof(TIM_TypeDef,ARR) }; };
  struct Timer4RcrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM4_BASE + __builtin_offsetof(TIM_TypeDef,RCR) }; };
  struct Timer4Ccr1DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM4_BASE + __builtin_offsetof(TIM_TypeDef,CCR1) }; };
  struct Timer4Ccr2DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM4_BASE + __builtin_offsetof(TIM_TypeDef,CCR2) }; };
  struct Timer4Ccr3DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM4_BASE + __builtin_offsetof(TIM_TypeDef,CCR3) }; };
  struct Timer4Ccr4DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM4_BASE + __builtin_offsetof(TIM_TypeDef,CCR4) }; };

  struct Timer5CntDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM5_BASE + __builtin_offsetof(TIM_TypeDef,CNT) }; };
  struct Timer5ArrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM5_BASE + __builtin_offsetof(TIM_TypeDef,ARR) }; };
  struct Timer5RcrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM5_BASE + __builtin_offsetof(TIM_TypeDef,RCR) }; };
  struct Timer5Ccr1DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM5_BASE + __builtin_offsetof(TIM_TypeDef,CCR1) }; };
  struct Timer5Ccr2DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM5_BASE + __builtin_offsetof(TIM_TypeDef,CCR2) }; };
  struct Timer5Ccr3DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM5_BASE + __builtin_offsetof(TIM_TypeDef,CCR3) }; };
  struct Timer5Ccr4DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM5_BASE + __builtin_offsetof(TIM_TypeDef,CCR4) }; };

#if defined(STM32PLUS_F4_HAS_TIM6_7_8_12_13_14)

  struct Timer6CntDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM6_BASE + __builtin_offsetof(TIM_TypeDef,CNT) }; };
  struct Timer6ArrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM6_BASE + __builtin_offsetof(TIM_TypeDef,ARR) }; };
  struct Timer6RcrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM6_BASE + __builtin_offsetof(TIM_TypeDef,RCR) }; };
  struct Timer6Ccr1DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM6_BASE + __builtin_offsetof(TIM_TypeDef,CCR1) }; };
  struct Timer6Ccr2DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM6_BASE + __builtin_offsetof(TIM_TypeDef,CCR2) }; };
  struct Timer6Ccr3DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM6_BASE + __builtin_offsetof(TIM_TypeDef,CCR3) }; };
  struct Timer6Ccr4DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM6_BASE + __builtin_offsetof(TIM_TypeDef,CCR4) }; };

  struct Timer7CntDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM7_BASE + __builtin_offsetof(TIM_TypeDef,CNT) }; };
  struct Timer7ArrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM7_BASE + __builtin_offsetof(TIM_TypeDef,ARR) }; };
  struct Timer7RcrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM7_BASE + __builtin_offsetof(TIM_TypeDef,RCR) }; };
  struct Timer7Ccr1DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM7_BASE + __builtin_offsetof(TIM_TypeDef,CCR1) }; };
  struct Timer7Ccr2DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM7_BASE + __builtin_offsetof(TIM_TypeDef,CCR2) }; };
  struct Timer7Ccr3DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM7_BASE + __builtin_offsetof(TIM_TypeDef,CCR3) }; };
  struct Timer7Ccr4DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM7_BASE + __builtin_offsetof(TIM_TypeDef,CCR4) }; };

  struct Timer8CntDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM8_BASE + __builtin_offsetof(TIM_TypeDef,CNT) }; };
  struct Timer8ArrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM8_BASE + __builtin_offsetof(TIM_TypeDef,ARR) }; };
  struct Timer8RcrDmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM8_BASE + __builtin_offsetof(TIM_TypeDef,RCR) }; };
  struct Timer8Ccr1DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM8_BASE + __builtin_offsetof(TIM_TypeDef,CCR1) }; };
  struct Timer8Ccr2DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM8_BASE + __builtin_offsetof(TIM_TypeDef,CCR2) }; };
  struct Timer8Ccr3DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM8_BASE + __builtin_offsetof(TIM_TypeDef,CCR3) }; };
  struct Timer8Ccr4DmaPeripheralInfo : TimerDmaPeripheralInfo { enum { REGISTER_ADDRESS = TIM8_BASE + __builtin_offsetof(TIM_TypeDef,CCR4) }; };

#endif

  struct UsartDmaPeripheralInfo {
      enum {
        MEMORY_WORD_SIZE = DMA_MemoryDataSize_Byte,
        PERIPHERAL_WORD_SIZE = DMA_PeripheralDataSize_Byte
    };
  };

  struct Usart1TxDmaPeripheralInfo : UsartDmaPeripheralInfo { enum { REGISTER_ADDRESS = USART1_BASE + __builtin_offsetof(USART_TypeDef,DR) }; };
  struct Usart2TxDmaPeripheralInfo : UsartDmaPeripheralInfo { enum { REGISTER_ADDRESS = USART2_BASE + __builtin_offsetof(USART_TypeDef,DR) }; };
  struct Usart3TxDmaPeripheralInfo : UsartDmaPeripheralInfo { enum { REGISTER_ADDRESS = USART3_BASE + __builtin_offsetof(USART_TypeDef,DR) }; };
  struct Uart4TxDmaPeripheralInfo : UsartDmaPeripheralInfo { enum { REGISTER_ADDRESS = UART4_BASE + __builtin_offsetof(USART_TypeDef,DR) }; };
  struct Uart5TxDmaPeripheralInfo : UsartDmaPeripheralInfo { enum { REGISTER_ADDRESS = UART5_BASE + __builtin_offsetof(USART_TypeDef,DR) }; };

#if defined(STM32PLUS_F4)
  struct Usart6TxDmaPeripheralInfo : UsartDmaPeripheralInfo { enum { REGISTER_ADDRESS = USART6_BASE + __builtin_offsetof(USART_TypeDef,DR) }; };
#endif

  struct SpiDmaPeripheralInfo {
      enum {
        MEMORY_WORD_SIZE = DMA_MemoryDataSize_Byte,
        PERIPHERAL_WORD_SIZE = DMA_PeripheralDataSize_Byte
    };
  };

  struct Spi1TxDmaPeripheralInfo : SpiDmaPeripheralInfo { enum { REGISTER_ADDRESS = SPI1_BASE + __builtin_offsetof(SPI_TypeDef,DR) }; };
  struct Spi2TxDmaPeripheralInfo : SpiDmaPeripheralInfo { enum { REGISTER_ADDRESS = SPI2_BASE + __builtin_offsetof(SPI_TypeDef,DR) }; };
  struct Spi3TxDmaPeripheralInfo : SpiDmaPeripheralInfo { enum { REGISTER_ADDRESS = SPI3_BASE + __builtin_offsetof(SPI_TypeDef,DR) }; };
}
// END FILE: ../lib/include/dma/features/f4/DmaPeripheralInfo.h
// START FILE: ../lib/include/dma/features/f4/Dma1Stream0InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 1, stream 0 interrupt feature
   */

  typedef DmaInterruptFeature<1,0> Dma1Stream0InterruptFeature;

  /**
   * Typedefs for the peripherals that use this interrupt
   */

  typedef Dma1Stream0InterruptFeature Spi3RxDmaChannelInterruptFeature;
  typedef Dma1Stream0InterruptFeature Timer5Channel3DmaChannelInterruptFeature;
  typedef Dma1Stream0InterruptFeature Timer5UpdateDmaChannelInterruptFeature;
  typedef Dma1Stream0InterruptFeature Uart5RxDmaChannelInterruptFeature;
  typedef Dma1Stream0InterruptFeature I2S3ExtRxDmaChannelInterruptFeature;
  typedef Dma1Stream0InterruptFeature Timer4Channel1DmaChannelInterruptFeature;
  typedef Dma1Stream0InterruptFeature I2C1RxDmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma1Stream0InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/SpiDmaWriterFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable writing via DMA
   * @tparam TSpi The type of the Spi peripheral (Spi1<...>, Spi2<...> ... )
   * @tparam TPriority The DMA relative priority level
   * @tparam TFifoMode Whether or not to use the FIFO
   * @tparam TByteSize true if the SPI is running in byte mode, false for half-word mode
   */

  template<class TSpi,uint32_t TPriority=DMA_Priority_High,bool TByteSize=true,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  class SpiDmaWriterFeature : public DmaFeatureBase {

    public:
      SpiDmaWriterFeature(Dma& dma);
      void beginWrite(const void *source,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TSpi,uint32_t TPriority,bool TByteSize,uint32_t TFifoMode>
  inline SpiDmaWriterFeature<TSpi,TPriority,TByteSize,TFifoMode>::SpiDmaWriterFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    SPI_TypeDef *spi;

    spi=(SPI_TypeDef *)TSpi::PERIPHERAL_BASE;

    if(TByteSize) {
      _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte; // transferring bytes
      _init.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;         // transferring bytes
    }
    else {
      _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord; // transferring half words
      _init.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;         // transferring half words
    }

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(spi->DR));
    _init.DMA_DIR=DMA_DIR_MemoryToPeripheral;                 // 'peripheral' is destination
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;        // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                 // memory is incremented
    _init.DMA_Mode=DMA_Mode_Normal;                           // not a circular buffer
    _init.DMA_Priority=TPriority;                             // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;             // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;     // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;       // flush on half-full

    SPI_I2S_DMACmd(spi,SPI_I2S_DMAReq_Tx,ENABLE);
  }


  /**
   * Start a transfer of data to the Spi
   *
   * @param[in] source memory address of the source data bytes.
   * @param[in] count The number of bytes to transfer.
   */

  template<class TSpi,uint32_t TPriority,bool TByteSize,uint32_t TFifoMode>
  inline void SpiDmaWriterFeature<TSpi,TPriority,TByteSize,TFifoMode>::beginWrite(const void *source,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(source);
    _init.DMA_BufferSize=count;

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

    // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/SpiDmaWriterFeature.h
// START FILE: ../lib/include/dma/features/f4/AdcDmaFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable ADC data to be written to memory
   * @tparam TAdc The type of the ADC peripheral (Adc1<...>, Adc2<...> ... )
   *
   * The default configuration is to run in circular buffer mode with half-word
   * transfers. These values can be customised by accessing the DMA_InitTypeDef structure
   * after the constructor has completed.
   */

  template<class TAdc,bool TRequestAfterLastTransfer=true,uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Disable>
  class AdcDmaFeature : public DmaFeatureBase {

    public:
      AdcDmaFeature(Dma& dma);
      void beginRead(volatile void *dest,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TAdc,bool TRequestAfterLastTransfer,uint32_t TPriority,uint32_t TFifoMode>
  inline AdcDmaFeature<TAdc,TRequestAfterLastTransfer,TPriority,TFifoMode>::AdcDmaFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    ADC_TypeDef *adc;

    adc=(ADC_TypeDef *)TAdc::PERIPHERAL_BASE;

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(adc->DR));
    _init.DMA_DIR=DMA_DIR_PeripheralToMemory;                 // 'peripheral' is source
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;        // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                 // memory is incremented
    _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord; // transferring 16-bits
    _init.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;         // transferring 16-bits
    _init.DMA_Mode=DMA_Mode_Circular;                         // is a circular buffer
    _init.DMA_Priority=TPriority;                             // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;             // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;     // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;     // flush on half-full
  }


  /**
   * Start a transfer of data to the destination.
   *
   * @param[in] dest The destination of the transfer.
   * @param[in] count The number of bytes to transfer.
   */

  template<class TAdc,bool TRequestAfterLastTransfer,uint32_t TPriority,uint32_t TFifoMode>
  inline void AdcDmaFeature<TAdc,TRequestAfterLastTransfer,TPriority,TFifoMode>::beginRead(volatile void *dest,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(dest);
    _init.DMA_BufferSize=count;

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

    // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);

    ADC_DMARequestAfterLastTransferCmd((ADC_TypeDef *)TAdc::PERIPHERAL_BASE,TRequestAfterLastTransfer ? ENABLE : DISABLE);
    ADC_MultiModeDMARequestAfterLastTransferCmd(TRequestAfterLastTransfer ? ENABLE : DISABLE);

    ADC_DMACmd((ADC_TypeDef *)TAdc::PERIPHERAL_BASE,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/AdcDmaFeature.h
// START FILE: ../lib/include/dma/features/f4/I2CDmaWriterFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable writing via DMA
   * @tparam The I2C peripheral traits class
   */

  template<class TI2C,uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  class I2CDmaWriterFeature : public DmaFeatureBase {

    public:
      I2CDmaWriterFeature(Dma& dma);
      void beginWrite(const void *source,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TI2C,uint32_t TPriority,uint32_t TFifoMode>
  inline I2CDmaWriterFeature<TI2C,TPriority,TFifoMode>::I2CDmaWriterFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    I2C_TypeDef *i2c;

    i2c=(I2C_TypeDef *)TI2C::PERIPHERAL_BASE;

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(i2c->DR));
    _init.DMA_DIR=DMA_DIR_MemoryToPeripheral;                 // 'peripheral' is destination
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;        // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                 // memory is incremented
    _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte; // transferring bytes
    _init.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;         // user defined word size
    _init.DMA_Mode=DMA_Mode_Normal;                           // not a circular buffer
    _init.DMA_Priority=TPriority;                             // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;             // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;     // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;       // flush on half-full

    I2C_DMACmd(i2c,ENABLE);
  }


  /**
   * Start a transfer of data to the I2C
   *
   * @param[in] source memory address of the source data bytes.
   * @param[in] count The number of bytes to transfer.
   */

  template<class TI2C,uint32_t TPriority,uint32_t TFifoMode>
  inline void I2CDmaWriterFeature<TI2C,TPriority,TFifoMode>::beginWrite(const void *source,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(source);
    _init.DMA_BufferSize=count;

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

      // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/I2CDmaWriterFeature.h
// START FILE: ../lib/include/dma/features/f4/SdioDmaReaderFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F1 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable reading via DMA
   */

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  class SdioDmaReaderFeature : public DmaFeatureBase {

    public:
      SdioDmaReaderFeature(Dma& dma);
      void beginRead(void *dest,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<uint32_t TPriority,uint32_t TFifoMode>
  inline SdioDmaReaderFeature<TPriority,TFifoMode>::SdioDmaReaderFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    // enable what we can

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&SDIO->FIFO);
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;
    _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Word;
    _init.DMA_MemoryDataSize=DMA_MemoryDataSize_Word;
    _init.DMA_Mode=DMA_Mode_Normal;
    _init.DMA_Priority=TPriority;
    _init.DMA_MemoryBurst=DMA_MemoryBurst_INC4;               // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_INC4;       // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_Full;         // flush on half-full
  }


  /**
   * Start a transfer of data to the destination
   *
   * @param[in] dest The destination of the transfer.
   * @param[in] count The number of bytes to transfer. Must be a block multiple
   */

  template<uint32_t TPriority,uint32_t TFifoMode>
  inline void SdioDmaReaderFeature<TPriority,TFifoMode>::beginRead(void *dest,uint32_t) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(dest);
    _init.DMA_BufferSize=0;                                 // hardware flow control instead
    _init.DMA_DIR=DMA_DIR_PeripheralToMemory;               // 'peripheral' is source

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

    // disable and then re-enable

    SDIO_DMACmd(ENABLE);

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_FlowControllerConfig(peripheralAddress,DMA_FlowCtrl_Peripheral);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/SdioDmaReaderFeature.h
// START FILE: ../lib/include/dma/features/f4/SdioDmaWriterFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F1 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable reading via DMA
   */

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  class SdioDmaWriterFeature : public DmaFeatureBase {

    public:
      SdioDmaWriterFeature(Dma& dma);
      void beginWrite(const void *src,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<uint32_t TPriority,uint32_t TFifoMode>
  inline SdioDmaWriterFeature<TPriority,TFifoMode>::SdioDmaWriterFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    // enable what we can

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&SDIO->FIFO);
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;
    _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Word;
    _init.DMA_MemoryDataSize=DMA_MemoryDataSize_Word;
    _init.DMA_Mode=DMA_Mode_Normal;
    _init.DMA_Priority=TPriority;
    _init.DMA_MemoryBurst=DMA_MemoryBurst_INC4;               // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_INC4;       // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_Full;         // flush on full
  }


  /**
   * Start a transfer of data to the peripheral
   *
   * @param[in] src The source of the transfer.
   * @param[in] count The number of bytes to transfer. Must be a block multiple
   */

  template<uint32_t TPriority,uint32_t TFifoMode>
  inline void SdioDmaWriterFeature<TPriority,TFifoMode>::beginWrite(const void *src,uint32_t) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(src);
    _init.DMA_BufferSize=0;                           // hardware flow control instead
    _init.DMA_DIR=DMA_DIR_MemoryToPeripheral;         // 'peripheral' is destination

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

    // disable and then re-enable

    SDIO_DMACmd(ENABLE);

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_FlowControllerConfig(peripheralAddress,DMA_FlowCtrl_Peripheral);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/SdioDmaWriterFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma2Stream6InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 2, stream 6 interrupt feature
   */

  typedef DmaInterruptFeature<2,6> Dma2Stream6InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma2Stream6InterruptFeature Timer1Channel3Stream6DmaChannelInterruptFeature;
  typedef Dma2Stream6InterruptFeature Usart6TxDmaChannelInterruptFeature;
  typedef Dma2Stream6InterruptFeature SdioStream6DmaChannelInterruptFeature;
  typedef Dma2Stream6InterruptFeature CrypInDmaChannelInterruptFeature;
  typedef Dma2Stream6InterruptFeature Timer1Channel1Stream6DmaChannelInterruptFeature;
  typedef Dma2Stream6InterruptFeature Timer1Channel2Stream6DmaChannelInterruptFeature;
  typedef Dma2Stream6InterruptFeature Timer1Channel3DmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma2Stream6InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/DacDmaWriterFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable writing via to the DAC using a DMA channel.
   *
   * If the setup of the initialisation structure is not to your needs then it can be customised before the
   * transfers are started by casting this class to |DMA_InitTypeDef|
   *
   * @tparam TDacAlignmentFeature. This is the feature type that you parameterised your Dac type with. It can
   * be either of the 1/2 channels or the special DacDualChannel*Feature. Note that using the dual channel
   * modes implies that you have packed your data accordingly for transfer. See comments below regarding the
   * packed data format or the register description in RM0008 / RM0090.
   * @tparam TPriority One of the DMA priority constants. The default is |DMA_Priority_High|
   * @tparam TFifoMode Whether the DMA FIFO is enabled. The default is disabled for this peripheral
   * @tparam TMode One of the DMA mode constants (|DMA_Mode_Normal| or |DMA_Mode_Circular|)
   */

  template<class TDacAlignmentFeature,uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Disable,uint32_t TMode=DMA_Mode_Normal>
  class DacDmaWriterFeature  : public DmaFeatureBase {

    public:
      DacDmaWriterFeature(Dma& dma);
      void beginWrite(const void *source,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TDacAlignmentFeature,uint32_t TPriority,uint32_t TFifoMode,uint32_t TMode>
  inline DacDmaWriterFeature<TDacAlignmentFeature,TPriority,TFifoMode,TMode>::DacDmaWriterFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    /*
     * The target for the DMA transfer depends on the alignment, channel (or dual channel).
     * All of these are available as compile-time constants in the alignment feature therefore
     * the optimiser will eliminate all the conditional tests below, remove the dead code and emit
     * only the resulting single storage instructions.
     */

    if(TDacAlignmentFeature::DUAL_CHANNEL_FEATURE) {

      // both channels

      if(TDacAlignmentFeature::getAlignment()==DAC_Align_12b_R)
        _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(DAC->DHR12RD));
      else if(TDacAlignmentFeature::getAlignment()==DAC_Align_12b_L)
        _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(DAC->DHR12LD));
      else if(TDacAlignmentFeature::getAlignment()==DAC_Align_8b_R)
        _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(DAC->DHR8RD));
    }
    else {

      if(TDacAlignmentFeature::getChannel()==DAC_Channel_1) {

        // channel 1

        if(TDacAlignmentFeature::getAlignment()==DAC_Align_12b_R)
          _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(DAC->DHR12R1));
        else if(TDacAlignmentFeature::getAlignment()==DAC_Align_12b_L)
          _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(DAC->DHR12L1));
        else if(TDacAlignmentFeature::getAlignment()==DAC_Align_8b_R)
          _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(DAC->DHR8R1));
      }
      else {

        // channel 2

        if(TDacAlignmentFeature::getAlignment()==DAC_Align_12b_R)
          _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(DAC->DHR12R2));
        else if(TDacAlignmentFeature::getAlignment()==DAC_Align_12b_L)
          _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(DAC->DHR12L2));
        else if(TDacAlignmentFeature::getAlignment()==DAC_Align_8b_R)
          _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(DAC->DHR8R2));
      }
    }

    if(TDacAlignmentFeature::DUAL_CHANNEL_FEATURE) {

      // 8 bit = half-word (packed channels: 22222221111111) transfers

      if(TDacAlignmentFeature::getAlignment()==DAC_Align_8b_R) {
        _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord;
        _init.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;
      }
      else {

        // 12 bit = word (packed channels: xxxx222222222222xxxx111111111111) transfers

        _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Word;
        _init.DMA_MemoryDataSize=DMA_MemoryDataSize_Word;
      }

    }
    else {

      // 8 bit = byte transfers

      if(TDacAlignmentFeature::getAlignment()==DAC_Align_8b_R) {
        _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte;     // transferring bytes
        _init.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;             // transferring bytes
      }
      else {

        // 12 bit = half-word transfers

        _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord; // transferring half-words
        _init.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;         // transferring half-words
      }
    }

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_DIR=DMA_DIR_MemoryToPeripheral;                 // 'peripheral' is destination
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;        // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                 // memory is incremented
    _init.DMA_Mode=TMode;                                     // circular or normal buffer
    _init.DMA_Priority=TPriority;                             // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;             // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;     // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // fifo mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;     // flush on half-full
  }


  /**
   * Start a transfer of data to the DAC
   *
   * @param[in] source memory address of the source data bytes.
   * @param[in] count The number of bytes to transfer.
   */

  template<class TDacAlignmentFeature,uint32_t TPriority,uint32_t TFifoMode,uint32_t TMode>
  inline void DacDmaWriterFeature<TDacAlignmentFeature,TPriority,TFifoMode,TMode>::beginWrite(const void *source,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(source);
    _init.DMA_BufferSize=count;

    // set the peripheral address from the overloaded operator

    peripheralAddress=_dma;

    // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);

    DAC_DMACmd(TDacAlignmentFeature::getChannel(),ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/DacDmaWriterFeature.h
// START FILE: ../lib/include/dma/features/f4/AdcMultiDmaFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable ADC data to be written to memory when the ADC is operating
   * in multi-mode. In multi-mode the ADC data is sourced from the ADC_CDR register
   * and the peripheral data size will be half-words in modes 1 and 3 and words in mode 2.
   *
   * @tparam TAdc The type of the ADC peripheral (Adc1<...>, Adc2<...> ... )
   *
   * The default configuration is to run in circular buffer mode with half-word
   * transfers. These values can be customised by accessing the DMA_InitTypeDef structure
   * after the constructor has completed.
   */

  template<class TAdc,
           uint32_t TPeripheralDataSize,
           uint32_t TMemoryDataSize,
           bool TRequestAfterLastTransfer=true,
           uint32_t TPriority=DMA_Priority_High,
           uint32_t TFifoMode=DMA_FIFOMode_Disable>
  class AdcMultiDmaFeature : public DmaFeatureBase {

    public:
      AdcMultiDmaFeature(Dma& dma);
      void beginRead(volatile void *dest,uint32_t count);
  };

  /*
   * Template typedefs for the different DMA modes
   */

  template<class TAdc,bool TRequestAfterLastTransfer=true,uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Disable>
  using AdcMultiDmaMode1Feature=AdcMultiDmaFeature<TAdc,DMA_PeripheralDataSize_HalfWord,DMA_MemoryDataSize_HalfWord,TRequestAfterLastTransfer,TPriority,TFifoMode>;

  template<class TAdc,bool TRequestAfterLastTransfer=true,uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Disable>
  using AdcMultiDmaMode2Feature=AdcMultiDmaFeature<TAdc,DMA_PeripheralDataSize_Word,DMA_MemoryDataSize_Word,TRequestAfterLastTransfer,TPriority,TFifoMode>;

  template<class TAdc,bool TRequestAfterLastTransfer=true,uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Disable>
  using AdcMultiDmaMode3Feature=AdcMultiDmaFeature<TAdc,DMA_PeripheralDataSize_HalfWord,DMA_MemoryDataSize_HalfWord,TRequestAfterLastTransfer,TPriority,TFifoMode>;


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TAdc,uint32_t TPeripheralDataSize,uint32_t TMemoryDataSize,bool TRequestAfterLastTransfer,uint32_t TPriority,uint32_t TFifoMode>
  inline AdcMultiDmaFeature<TAdc,TPeripheralDataSize,TMemoryDataSize,TRequestAfterLastTransfer,TPriority,TFifoMode>::AdcMultiDmaFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(ADC->CDR));
    _init.DMA_DIR=DMA_DIR_PeripheralToMemory;                 // 'peripheral' is source
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;        // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                 // memory is incremented
    _init.DMA_PeripheralDataSize=TPeripheralDataSize;         // transferring 16 or 32-bits depending on the mode
    _init.DMA_MemoryDataSize=TMemoryDataSize;                 // transferring 16 or 32-bits depending on the mode
    _init.DMA_Mode=DMA_Mode_Circular;                         // is a circular buffer
    _init.DMA_Priority=TPriority;                             // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;             // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;     // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;     // flush on half-full
  }


  /**
   * Start a transfer of data to the destination.
   *
   * @param[in] dest The destination of the transfer.
   * @param[in] count The number of bytes to transfer.
   */

  template<class TAdc,uint32_t TPeripheralDataSize,uint32_t TMemoryDataSize,bool TRequestAfterLastTransfer,uint32_t TPriority,uint32_t TFifoMode>
  inline void AdcMultiDmaFeature<TAdc,TPeripheralDataSize,TMemoryDataSize,TRequestAfterLastTransfer,TPriority,TFifoMode>::beginRead(volatile void *dest,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(dest);
    _init.DMA_BufferSize=count;

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

    // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);

    ADC_DMARequestAfterLastTransferCmd((ADC_TypeDef *)TAdc::PERIPHERAL_BASE,TRequestAfterLastTransfer ? ENABLE : DISABLE);
    ADC_MultiModeDMARequestAfterLastTransferCmd(TRequestAfterLastTransfer ? ENABLE : DISABLE);

    ADC_DMACmd((ADC_TypeDef *)TAdc::PERIPHERAL_BASE,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/AdcMultiDmaFeature.h
// START FILE: ../lib/include/dma/features/f4/DmaInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


/*
 * Forward declare the IRQ handler names
 */

extern "C" void DMA1_Stream0_IRQHandler();
extern "C" void DMA1_Stream1_IRQHandler();
extern "C" void DMA1_Stream2_IRQHandler();
extern "C" void DMA1_Stream3_IRQHandler();
extern "C" void DMA1_Stream4_IRQHandler();
extern "C" void DMA1_Stream5_IRQHandler();
extern "C" void DMA1_Stream6_IRQHandler();
extern "C" void DMA1_Stream7_IRQHandler();

extern "C" void DMA2_Stream0_IRQHandler();
extern "C" void DMA2_Stream1_IRQHandler();
extern "C" void DMA2_Stream2_IRQHandler();
extern "C" void DMA2_Stream3_IRQHandler();
extern "C" void DMA2_Stream4_IRQHandler();
extern "C" void DMA2_Stream5_IRQHandler();
extern "C" void DMA2_Stream6_IRQHandler();
extern "C" void DMA2_Stream7_IRQHandler();


namespace stm32plus {

  /**
   * Helper class to enable only the desired interrupts in the NVIC. This will
   * be fully specialised for each DMA peripheral and channel
   * @tparam TDmaNumber The number of the DMA peripheral (1..2)
   * @tparam TStreamNumber The number of the DMA channel (0..7)
   */

  template<uint8_t TDmaNumber,uint8_t TStreamNumber>
  class DmaInterruptFeatureEnabler {

    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

    public:
      static void enable(uint8_t priority,uint8_t subPriority);
  };


  /**
   * Base class for the DMA feature to handle interrupts
   * @tparam TDmaNumber The number of the DMA peripheral (1..2)
   * @tparam TStreamNumber The number of the DMA stream (0..7)
   */

  template<uint8_t TDmaNumber,uint8_t TStreamNumber>
  class DmaInterruptFeature : public DmaEventSource,
                              public DmaFeatureBase {

    protected:
      uint16_t _interruptMask;
      uint8_t _nvicPriority;
      uint8_t _nvicSubPriority;

    public:
      static DmaEventSource *_dmaInstance;

      enum {
        COMPLETE = DMA_IT_TC,
        HALF_COMPLETE = DMA_IT_HT,
        TRANSFER_ERROR = DMA_IT_TE
      };

    protected:
      DmaInterruptFeature(Dma& dma);

    public:
      ~DmaInterruptFeature();

      void setNvicPriorities(uint8_t priority,uint8_t subPriority=0);

      void enableInterrupts(uint16_t interruptMask);
      void disableInterrupts(uint16_t interruptMask);
  };


  /**
   * Template static data member initialisation
   */

  template<uint8_t TDmaNumber,uint8_t TStreamNumber>
  DmaEventSource *DmaInterruptFeature<TDmaNumber,TStreamNumber>::_dmaInstance;


  /**
   * Constructor, initialises the interrupt mask for this class to zero.
   */

  template<uint8_t TDmaNumber,uint8_t TStreamNumber>
  inline DmaInterruptFeature<TDmaNumber,TStreamNumber>::DmaInterruptFeature(Dma& dma)
    : DmaFeatureBase(dma) {
    _interruptMask=0;
    _nvicPriority=0;
    _nvicSubPriority=0;
    _dmaInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  template<uint8_t TDmaNumber,uint8_t TStreamNumber>
  inline DmaInterruptFeature<TDmaNumber,TStreamNumber>::~DmaInterruptFeature() {
    if(_interruptMask!=0)
      disableInterrupts(_interruptMask);
  }


  /**
   * Set the NVIC priority and subpriority numbers.  This function just remembers your
   * numbers. The actual setting of the priority happens in enableInterrupts()
   * @param priority
   * @param subPriority
   */

  template<uint8_t TDmaNumber,uint8_t TStreamNumber>
  inline void DmaInterruptFeature<TDmaNumber,TStreamNumber>::setNvicPriorities(uint8_t priority,uint8_t subPriority) {
    _nvicPriority=priority;
    _nvicSubPriority=subPriority;
  }


  /**
   * Enable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. DMA_IT_TC/HT/TE
   */

  template<uint8_t TDmaNumber,uint8_t TStreamNumber>
  inline void DmaInterruptFeature<TDmaNumber,TStreamNumber>::enableInterrupts(uint16_t interruptMask) {

    _interruptMask|=interruptMask;
    DmaInterruptFeatureEnabler<TDmaNumber,TStreamNumber>::enable(_nvicPriority,_nvicSubPriority);
    DMA_ITConfig(_dma,interruptMask,ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. DMA_IT_TC/HT/TE
   */

  template<uint8_t TDmaNumber,uint8_t TStreamNumber>
  inline void DmaInterruptFeature<TDmaNumber,TStreamNumber>::disableInterrupts(uint16_t interruptMask) {
    _interruptMask&=~interruptMask;
    DMA_ITConfig(_dma,interruptMask,DISABLE);
  }


  /**
   * Enabler specialisations, DMA1
   */

  template<>
  inline void DmaInterruptFeatureEnabler<1,0>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA1_Stream0_IRQHandler;
    Nvic::configureIrq(DMA1_Stream0_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<1,1>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA1_Stream1_IRQHandler;
    Nvic::configureIrq(DMA1_Stream1_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<1,2>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA1_Stream2_IRQHandler;
    Nvic::configureIrq(DMA1_Stream2_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<1,3>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA1_Stream3_IRQHandler;
    Nvic::configureIrq(DMA1_Stream3_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<1,4>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA1_Stream4_IRQHandler;
    Nvic::configureIrq(DMA1_Stream4_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<1,5>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA1_Stream5_IRQHandler;
    Nvic::configureIrq(DMA1_Stream5_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<1,6>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA1_Stream6_IRQHandler;
    Nvic::configureIrq(DMA1_Stream6_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<1,7>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA1_Stream7_IRQHandler;
    Nvic::configureIrq(DMA1_Stream7_IRQn,ENABLE,priority,subPriority);
  }

  /**
   * Enabler specialisations, DMA2
   */

  template<>
  inline void DmaInterruptFeatureEnabler<2,0>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA2_Stream0_IRQHandler;
    Nvic::configureIrq(DMA2_Stream0_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<2,1>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA2_Stream1_IRQHandler;
    Nvic::configureIrq(DMA2_Stream1_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<2,2>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA2_Stream2_IRQHandler;
    Nvic::configureIrq(DMA2_Stream2_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<2,3>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA2_Stream3_IRQHandler;
    Nvic::configureIrq(DMA2_Stream3_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<2,4>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA2_Stream4_IRQHandler;
    Nvic::configureIrq(DMA2_Stream4_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<2,5>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA2_Stream5_IRQHandler;
    Nvic::configureIrq(DMA2_Stream5_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<2,6>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA2_Stream6_IRQHandler;
    Nvic::configureIrq(DMA2_Stream6_IRQn,ENABLE,priority,subPriority);
  }

  template<>
  inline void DmaInterruptFeatureEnabler<2,7>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&DMA2_Stream7_IRQHandler;
    Nvic::configureIrq(DMA2_Stream7_IRQn,ENABLE,priority,subPriority);
  }
}
// END FILE: ../lib/include/dma/features/f4/DmaInterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/SpiDmaReaderFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable reading via DMA
   * @tparam TSpi The type of the Spi peripheral (Spi1<...>, Spi2<...>, Spi3<...>)
   * @tparam TPriority The DMA relative priority level
   * @tparam TFifoMode Whether or not to use the FIFO
   * @tparam TByteSize true if the SPI is running in byte mode, false for half-word mode
   */

  template<class TSpi,uint32_t TPriority=DMA_Priority_High,bool TByteSize=true,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  class SpiDmaReaderFeature : public DmaFeatureBase {

    public:
      SpiDmaReaderFeature(Dma& dma);
      void beginRead(void *dest,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TSpi,uint32_t TPriority,bool TByteSize,uint32_t TFifoMode>
  inline SpiDmaReaderFeature<TSpi,TPriority,TByteSize,TFifoMode>::SpiDmaReaderFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    SPI_TypeDef *spi;

    spi=(SPI_TypeDef *)TSpi::PERIPHERAL_BASE;

    if(TByteSize) {
      _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte; // transferring bytes
      _init.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;         // transferring bytes
    }
    else {
      _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord; // transferring half words
      _init.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;         // transferring half words
    }

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(spi->DR));
    _init.DMA_DIR=DMA_DIR_PeripheralToMemory;                 // 'peripheral' is source
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;        // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                 // memory is incremented
    _init.DMA_Mode=DMA_Mode_Normal;                           // not a circular buffer
    _init.DMA_Priority=TPriority;                             // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;             // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;     // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;       // flush on half-full

    SPI_I2S_DMACmd(spi,SPI_I2S_DMAReq_Rx,ENABLE);
  }


  /**
   * Start a transfer of data to the destination
   *
   * @param[in] dest The destination of the transfer.
   * @param[in] count The number of bytes to transfer.
   */

  template<class TSpi,uint32_t TPriority,bool TByteSize,uint32_t TFifoMode>
  inline void SpiDmaReaderFeature<TSpi,TPriority,TByteSize,TFifoMode>::beginRead(void *dest,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(dest);
    _init.DMA_BufferSize=count;

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

      // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/SpiDmaReaderFeature.h
// START FILE: ../lib/include/dma/features/f4/I2SDmaWriterFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable writing via DMA
   * @tparam TI2S The type of the I2S peripheral (I2S1<...>, I2S2<...> ... )
   */

  template<class TI2SPeripheralTraits,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal,uint32_t TFifoMode=DMA_FIFOMode_Disable>
  class I2SDmaWriterFeature : public DmaFeatureBase {

    public:
      I2SDmaWriterFeature(Dma& dma);
      void beginWrite(const void *source,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TI2SPeripheralTraits,uint32_t TPriority,uint32_t TDmaMode,uint32_t TFifoMode>
  inline I2SDmaWriterFeature<TI2SPeripheralTraits,TPriority,TDmaMode,TFifoMode>::I2SDmaWriterFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    SPI_TypeDef *i2s;

    i2s=(SPI_TypeDef *)TI2SPeripheralTraits::PERIPHERAL_BASE;

    _init.DMA_Channel=dma.getChannelNumber();                     // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(i2s->DR));
    _init.DMA_DIR=DMA_DIR_MemoryToPeripheral;                     // 'peripheral' is destination
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;            // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                     // memory is incremented
    _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord; // 16-bits
    _init.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;         // 16-bits
    _init.DMA_Mode=TDmaMode;                                      // not a circular buffer by default
    _init.DMA_Priority=TPriority;                                 // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;                 // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;         // burst size
    _init.DMA_FIFOMode=TFifoMode;

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_Full;             // flush on full

    SPI_I2S_DMACmd(i2s,SPI_I2S_DMAReq_Tx,ENABLE);
  }


  /**
   * Start a transfer of data to the I2S
   *
   * @param[in] source memory address of the source data bytes.
   * @param[in] count The number of half-words to transfer.
   */

  template<class TI2SPeripheralTraits,uint32_t TPriority,uint32_t TDmaMode,uint32_t TFifoMode>
  inline void I2SDmaWriterFeature<TI2SPeripheralTraits,TPriority,TDmaMode,TFifoMode>::beginWrite(const void *source,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(source);
    _init.DMA_BufferSize=count;

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

      // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/I2SDmaWriterFeature.h
// START FILE: ../lib/include/dma/features/f4/DmaFsmcLcdMemoryCopyFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * @brief Copy data to an LCD display connected via an 8080 interface.
   *
   * Custom DMA configuration to bulk copy data into the lcd data register through the FSMC.
   * This can free the CPU to do other things while data is transferred to the display. Access
   * to this class from the graphics library is done via the DmaLcdWriter template base class
   * because the graphics library cannot assume that the FSMC is the peripheral being used to
   * access the LCD behind the scenes.
   *
   * @tparam TFsmcAccessMode The access mode class (Fsmc8BitAccessMode/Fsmc16BitAccessMode)
   */

  template<class TFsmcAccessMode>
  class DmaFsmcLcdMemoryCopyFeature : public DmaFeatureBase,
                                      public DmaLcdWriter<DmaFsmcLcdMemoryCopyFeature<TFsmcAccessMode>> {

    private:
      uint32_t _byteSize;

    public:
      DmaFsmcLcdMemoryCopyFeature(Dma& dma);
      void beginCopyToLcd(void *dest,void *source,uint32_t byteCount,uint32_t priority);
  };


  /**
   * Constructor
   */

  template<class TFsmcAccessMode>
  inline DmaFsmcLcdMemoryCopyFeature<TFsmcAccessMode>::DmaFsmcLcdMemoryCopyFeature(Dma& dma)
    : DmaFeatureBase(dma),
      DmaLcdWriter<DmaFsmcLcdMemoryCopyFeature<TFsmcAccessMode>>(*this) {

    DMA_StructInit(&_init);

    _init.DMA_Channel=dma.getChannelNumber();               // channel id
    _init.DMA_DIR=DMA_DIR_MemoryToMemory;                   // memory to memory mode
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Enable;       // 'peripheral' gets incremented
    _init.DMA_MemoryInc=DMA_MemoryInc_Disable;              // LCD register is not incremented
    _init.DMA_Mode=DMA_Mode_Normal;                         // not a circular buffer
    _init.DMA_FIFOMode=DMA_FIFOMode_Enable;                 // FIFO required for memory-to-memory
    _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;     // flush on half-full
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;           // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;   // burst size

    TFsmcAccessMode::getDmaTransferSizes(_init.DMA_PeripheralDataSize,_init.DMA_MemoryDataSize);

    // get the width in bytes

    _byteSize=_init.DMA_PeripheralDataSize==DMA_PeripheralDataSize_Byte ? 1 : 2;
  }


  /**
   * Start a transfer of data from source to the dest. The count is in units
   * of the word size.
   *
   * @param[in] dest The destination of the transfer.
   * @param[in] source The source of the transfer.
   * @param[in] byteCount The number of bytes to transfer.
   * @param[in] priority The DMA priority level
   */

  template<class TFsmcAccessMode>
  inline void DmaFsmcLcdMemoryCopyFeature<TFsmcAccessMode>::beginCopyToLcd(void *dest,void *source,uint32_t byteCount,uint32_t priority) {

    DMA_Stream_TypeDef *peripheralAddress;

    _init.DMA_Priority=priority;
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(source);
    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(dest);
    _init.DMA_BufferSize=byteCount/_byteSize;

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_DeInit(peripheralAddress);

    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/DmaFsmcLcdMemoryCopyFeature.h
// START FILE: ../lib/include/dma/features/f4/UsartDmaWriterFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable writing via DMA
   * @tparam TUsart The type of the usart peripheral (Usart1<...>, Usart2<...> ... )
   */

  template<class TUsart,uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Enable,uint32_t TMode=DMA_Mode_Normal>
  class UsartDmaWriterFeature  : public DmaFeatureBase {

    public:
      UsartDmaWriterFeature(Dma& dma);
      void beginWrite(const void *source,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TUsart,uint32_t TPriority,uint32_t TFifoMode,uint32_t TMode>
  inline UsartDmaWriterFeature<TUsart,TPriority,TFifoMode,TMode>::UsartDmaWriterFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    USART_TypeDef *usart;

    usart=(USART_TypeDef *)TUsart::PERIPHERAL_BASE;

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(usart->DR));
    _init.DMA_DIR=DMA_DIR_MemoryToPeripheral;                 // 'peripheral' is destination
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;        // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                 // memory is incremented
    _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte; // transferring bytes
    _init.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;         // transferring bytes
    _init.DMA_Mode=TMode;                                     // DMA_Mode_Normal/DMA_Mode_Circular
    _init.DMA_Priority=TPriority;                             // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;             // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;     // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;     // flush on half-full

    USART_DMACmd(usart,USART_DMAReq_Tx,ENABLE);
  }


  /**
   * Start a transfer of data to the USART
   *
   * @param[in] source memory address of the source data bytes.
   * @param[in] count The number of bytes to transfer.
   */

  template<class TUsart,uint32_t TPriority,uint32_t TFifoMode,uint32_t TMode>
  inline void UsartDmaWriterFeature<TUsart,TPriority,TFifoMode,TMode>::beginWrite(const void *source,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(source);
    _init.DMA_BufferSize=count;

    // set the peripheral address from the overloaded operator

    peripheralAddress=_dma;

    // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/UsartDmaWriterFeature.h
// START FILE: ../lib/include/dma/features/f4/I2CDmaReaderFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable reading via DMA
   * @tparam TI2C The type of the I2C peripheral (I2C1<...>, I2C2<...>, I2C3<...>)
   */

  template<class TI2C,uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  class I2CDmaReaderFeature : public DmaFeatureBase {

    public:
      I2CDmaReaderFeature(Dma& dma);
      void beginRead(void *dest,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TI2C,uint32_t TPriority,uint32_t TFifoMode>
  inline I2CDmaReaderFeature<TI2C,TPriority,TFifoMode>::I2CDmaReaderFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    I2C_TypeDef *i2c;

    i2c=(I2C_TypeDef *)TI2C::PERIPHERAL_BASE;

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(i2c->DR));
    _init.DMA_DIR=DMA_DIR_PeripheralToMemory;                 // 'peripheral' is source
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;        // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                 // memory is incremented
    _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte; // transferring bytes
    _init.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;         // user defined word size
    _init.DMA_Mode=DMA_Mode_Normal;                           // not a circular buffer
    _init.DMA_Priority=TPriority;                             // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;             // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;     // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;       // flush on half-full

    I2C_DMACmd(i2c,ENABLE);
  }


  /**
   * Start a transfer of data to the destination
   *
   * @param[in] dest The destination of the transfer.
   * @param[in] count The number of bytes to transfer.
   */

  template<class TI2C,uint32_t TPriority,uint32_t TFifoMode>
  inline void I2CDmaReaderFeature<TI2C,TPriority,TFifoMode>::beginRead(void *dest,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(dest);
    _init.DMA_BufferSize=count;

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

      // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/I2CDmaReaderFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma1Stream7InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 1, stream 7 interrupt feature
   */

  typedef DmaInterruptFeature<1,7> Dma1Stream7InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma1Stream7InterruptFeature I2C2TxDmaChannelInterruptFeature;
  typedef Dma1Stream7InterruptFeature Timer3Channel3DmaChannelInterruptFeature;
  typedef Dma1Stream7InterruptFeature Uart5TxDmaChannelInterruptFeature;
  typedef Dma1Stream7InterruptFeature Timer2UpdateStream7DmaChannelInterruptFeature;
  typedef Dma1Stream7InterruptFeature Timer2Channel4Stream7DmaChannelInterruptFeature;
  typedef Dma1Stream7InterruptFeature Timer4Channel3DmaChannelInterruptFeature;
  typedef Dma1Stream7InterruptFeature I2C1TxStream7DmaChannelInterruptFeature;
  typedef Dma1Stream7InterruptFeature Spi3TxStream7DmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma1Stream7InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma1Stream4InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 1, stream 4 interrupt feature
   */

  typedef DmaInterruptFeature<1,4> Dma1Stream4InterruptFeature;

  /**
   * Typedefs for the peripherals that use this interrupt
   */

  typedef Dma1Stream4InterruptFeature Usart3TxStream4DmaChannelInterruptFeature;
  typedef Dma1Stream4InterruptFeature Timer5Channel2DmaChannelInterruptFeature;
  typedef Dma1Stream4InterruptFeature Timer3Channel1DmaChannelInterruptFeature;
  typedef Dma1Stream4InterruptFeature Timer3TriggerDmaChannelInterruptFeature;
  typedef Dma1Stream4InterruptFeature Uart4TxDmaChannelInterruptFeature;
  typedef Dma1Stream4InterruptFeature I2C3TxDmaChannelInterruptFeature;
  typedef Dma1Stream4InterruptFeature I2S2ExtTxDmaChannelInterruptFeature;
  typedef Dma1Stream4InterruptFeature Timer7UpdateStream4DmaChannelInterruptFeature;
  typedef Dma1Stream4InterruptFeature Spi2TxDmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma1Stream4InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/UsartDmaReaderFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable reading via DMA
   * @tparam TUsart The type of the usart peripheral (Usart1<...>, Usart2<...> ... )
   */

  template<class TUsart,uint32_t TPriority=DMA_Priority_High,uint32_t TFifoMode=DMA_FIFOMode_Enable,uint32_t TMode=DMA_Mode_Normal>
  class UsartDmaReaderFeature : public DmaFeatureBase {

    public:
      UsartDmaReaderFeature(Dma& dma);
      void beginRead(void *dest,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TUsart,uint32_t TPriority,uint32_t TFifoMode,uint32_t TMode>
  inline UsartDmaReaderFeature<TUsart,TPriority,TFifoMode,TMode>::UsartDmaReaderFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    USART_TypeDef *usart;

    usart=(USART_TypeDef *)TUsart::PERIPHERAL_BASE;

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(usart->DR));
    _init.DMA_DIR=DMA_DIR_PeripheralToMemory;                 // 'peripheral' is source
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;        // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                 // memory is incremented
    _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_Byte; // transferring bytes
    _init.DMA_MemoryDataSize=DMA_MemoryDataSize_Byte;         // transferring bytes
    _init.DMA_Mode=TMode;                                     // DMA_Mode_Normal/DMA_Mode_Circular
    _init.DMA_Priority=TPriority;                             // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;             // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;     // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;     // flush on half-full

    USART_DMACmd(usart,USART_DMAReq_Rx,ENABLE);
  }


  /**
   * Start a transfer of data to the destination
   *
   * @param[in] dest The destination of the transfer.
   * @param[in] count The number of bytes to transfer.
   */

  template<class TUsart,uint32_t TPriority,uint32_t TFifoMode,uint32_t TMode>
  inline void UsartDmaReaderFeature<TUsart,TPriority,TFifoMode,TMode>::beginRead(void *dest,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(dest);
    _init.DMA_BufferSize=count;

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

      // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/UsartDmaReaderFeature.h
// START FILE: ../lib/include/dma/features/f4/DmaMemoryCopyBaseFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma feature to enable copying from memory to memory. Example declaration:
   *
   * @tparam TSourceInc DMA_PeripheralInc_Enable/DMA_PeripheralInc_Disable
   *
   * Dma1Channel1<DmaMemoryCopyBaseFeature<> > dmaMemoryCopier;
   */

  template<uint32_t TSourceInc,uint32_t TDataSize>
  class DmaMemoryCopyBaseFeature : public DmaFeatureBase {

    public:
      DmaMemoryCopyBaseFeature(Dma& dma);
      void beginCopyMemory(void *dest,void *source,uint32_t count,uint32_t priority);
  };


  /**
   * Constructor
   */

  template<uint32_t TSourceInc,uint32_t TDataSize>
  inline DmaMemoryCopyBaseFeature<TSourceInc,TDataSize>::DmaMemoryCopyBaseFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    uint32_t periphDataSize;

    DMA_StructInit(&_init);

    if(TDataSize==DMA_MemoryDataSize_Byte)
      periphDataSize=DMA_PeripheralDataSize_Byte;
    else if(TDataSize==DMA_MemoryDataSize_HalfWord)
      periphDataSize=DMA_PeripheralDataSize_HalfWord;
    else
      periphDataSize=DMA_PeripheralDataSize_Word;

    _init.DMA_Channel=dma.getChannelNumber();             // channel id
    _init.DMA_DIR=DMA_DIR_MemoryToMemory;                 // memory to memory copy
    _init.DMA_PeripheralInc=TSourceInc;                   // 'peripheral' gets incremented for copy, not for fill.
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;             // memory is incremented
    _init.DMA_PeripheralDataSize=periphDataSize;          // user defined word size
    _init.DMA_MemoryDataSize=TDataSize;                   // user defined word size
    _init.DMA_Mode=DMA_Mode_Normal;                       // not a circular buffer
    _init.DMA_FIFOMode=DMA_FIFOMode_Enable;               // FIFO required for memory-to-memory
    _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;   // flush on half-full
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;         // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single; // burst size
  }

  /**
   * Start a transfer of data from source to the dest. The count is in units
   * of the word size.
   *
   * @param[in] dest The destination of the transfer.
   * @param[in] source The source of the transfer.
   * @param[in] count The number of words to transfer.
   */

  template<uint32_t TSourceInc,uint32_t TDataSize>
  inline void DmaMemoryCopyBaseFeature<TSourceInc,TDataSize>::beginCopyMemory(void *dest,void *source,uint32_t count,uint32_t priority) {

    DMA_Stream_TypeDef *peripheralAddress;

    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(source);
    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(dest);
    _init.DMA_BufferSize=count;
    _init.DMA_Priority=priority;                              // user-configurable priority

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/DmaMemoryCopyBaseFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma1Stream3InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 1, stream 2 interrupt feature
   */

  typedef DmaInterruptFeature<1,3> Dma1Stream3InterruptFeature;

  /**
   * Typedefs for the peripherals that use this interrupt
   */

  typedef Dma1Stream3InterruptFeature I2C2RxStream3DmaChannelInterruptFeature;
  typedef Dma1Stream3InterruptFeature Timer5Channel4Stream3DmaChannelInterruptFeature;
  typedef Dma1Stream3InterruptFeature Timer5TriggerStream3DmaChannelInterruptFeature;
  typedef Dma1Stream3InterruptFeature Usart3TxDmaChannelInterruptFeature;
  typedef Dma1Stream3InterruptFeature I2S2ExtRxStream3DmaChannelInterruptFeature;
  typedef Dma1Stream3InterruptFeature Timer4Channel2DmaChannelInterruptFeature;
  typedef Dma1Stream3InterruptFeature Spi2RxDmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma1Stream3InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/I2SDmaReaderFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * DMA feature to enable reading via DMA
   * @tparam TI2S The type of the I2S peripheral (I2S1<...>, I2S2<...>, I2S3<...>)
   */

  template<class TI2SPeripheralTraits,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  class I2SDmaReaderFeature : public DmaFeatureBase {

    public:
      I2SDmaReaderFeature(Dma& dma);
      void beginRead(void *dest,uint32_t count);
  };


  /**
   * Constructor, store the reference to the DMA base class
   * @param dma the base class reference
   */

  template<class TI2SPeripheralTraits,uint32_t TPriority,uint32_t TDmaMode,uint32_t TFifoMode>
  inline I2SDmaReaderFeature<TI2SPeripheralTraits,TPriority,TDmaMode,TFifoMode>::I2SDmaReaderFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    SPI_TypeDef *i2s;

    i2s=(SPI_TypeDef *)TI2SPeripheralTraits::PERIPHERAL_BASE;

    _init.DMA_Channel=dma.getChannelNumber();                     // channel id
    _init.DMA_PeripheralBaseAddr=reinterpret_cast<uint32_t>(&(i2s->DR));
    _init.DMA_DIR=DMA_DIR_PeripheralToMemory;                     // 'peripheral' is source
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;            // 'peripheral' does not increment
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;                     // memory is incremented
    _init.DMA_PeripheralDataSize=DMA_PeripheralDataSize_HalfWord; // 16-bits
    _init.DMA_MemoryDataSize=DMA_MemoryDataSize_HalfWord;         // 16-bits
    _init.DMA_Mode=TDmaMode;                                      // not a circular buffer by default
    _init.DMA_Priority=TPriority;                                 // user-configurable priority
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;                 // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;         // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;       // flush on half-full

    SPI_I2S_DMACmd(i2s,SPI_I2S_DMAReq_Rx,ENABLE);
  }


  /**
   * Start a transfer of data to the destination
   *
   * @param[in] dest The destination of the transfer.
   * @param[in] count The number of half-words to transfer.
   */

  template<class TI2SPeripheralTraits,uint32_t TPriority,uint32_t TDmaMode,uint32_t TFifoMode>
  inline void I2SDmaReaderFeature<TI2SPeripheralTraits,TPriority,TDmaMode,TFifoMode>::beginRead(void *dest,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(dest);
    _init.DMA_BufferSize=count;

    // this class is always in a hierarchy with DmaPeripheral

    peripheralAddress=_dma;

      // disable and then re-enable

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }
}
// END FILE: ../lib/include/dma/features/f4/I2SDmaReaderFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma2Stream1InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 2, stream 1 interrupt feature
   */

  typedef DmaInterruptFeature<2,1> Dma2Stream1InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma2Stream1InterruptFeature Timer8UpdateDmaChannelInterruptFeature;
  typedef Dma2Stream1InterruptFeature Timer1Channel1DmaChannelInterruptFeature;
  typedef Dma2Stream1InterruptFeature Usart6RxDmaChannelInterruptFeature;
  typedef Dma2Stream1InterruptFeature Adc3Stream1DmaChannelInterruptFeature;
  typedef Dma2Stream1InterruptFeature DcmiDmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma2Stream1InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma2Stream2InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 2, stream 2 interrupt feature
   */

  typedef DmaInterruptFeature<2,2> Dma2Stream2InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma2Stream2InterruptFeature Timer8Channel1Stream2DmaChannelInterruptFeature;
  typedef Dma2Stream2InterruptFeature Timer1Channel2DmaChannelInterruptFeature;
  typedef Dma2Stream2InterruptFeature Usart6RxStream2DmaChannelInterruptFeature;
  typedef Dma2Stream2InterruptFeature Usart1RxDmaChannelInterruptFeature;
  typedef Dma2Stream2InterruptFeature Spi1RxStream2DmaChannelInterruptFeature;
  typedef Dma2Stream2InterruptFeature Adc2DmaChannelInterruptFeature;
  typedef Dma2Stream2InterruptFeature Timer8Channel3DmaChannelInterruptFeature;
  typedef Dma2Stream2InterruptFeature Timer8Channel2DmaChannelInterruptFeature;
  typedef Dma2Stream2InterruptFeature Timer8Channel1DmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma2Stream2InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/TimerDmaFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Template definition of a DMA feature used for transferring data to a peripheral
   * where that transfer is regulated by events from a timer.
   *
   * @tparam TPeripheralInfo a helper class used to describe key data about the target peripheral
   * @tparam TTimerEvent The timer event that triggers a transfer, e.g. TIM_DMA_Update
   * @tparam TPriority The DMA priority, default is high
   * @tparam TDmaMode circular or normal mode (DMA_Mode_Normal is the default),
   * @tparam TFifoMode whether or not the FIFO is enabled (DMA_FIFOMode_Enable/DMA_FIFOMode_Disable). The default is enabled.
   */

  template<class TPeripheralInfo,uint16_t TTimerEvent,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  class TimerDmaFeature : public DmaFeatureBase {

    public:
      TimerDmaFeature(Dma& dma);

      void beginWriteByTimer(Timer& timer,const void *source,uint32_t count);
  };

  /**
   * Constructor. Set up as much of the DMA initialisation structure as can be
   * reused between calls.
   */

  template<class TPeripheralInfo,uint16_t TTimerEvent,uint32_t TPriority,uint32_t TDmaMode,uint32_t TFifoMode>
  inline TimerDmaFeature<TPeripheralInfo,TTimerEvent,TPriority,TDmaMode,TFifoMode>::TimerDmaFeature(Dma& dma)
    : DmaFeatureBase(dma) {

    // set up the DMA peripheral to transfer to a peripheral register
    // the memory source is not set here

    _init.DMA_Channel=dma.getChannelNumber();                 // channel id
    _init.DMA_PeripheralBaseAddr=TPeripheralInfo::REGISTER_ADDRESS;
    _init.DMA_DIR=DMA_DIR_MemoryToPeripheral;
    _init.DMA_PeripheralInc=DMA_PeripheralInc_Disable;
    _init.DMA_MemoryInc=DMA_MemoryInc_Enable;
    _init.DMA_PeripheralDataSize=TPeripheralInfo::PERIPHERAL_WORD_SIZE;
    _init.DMA_MemoryDataSize=TPeripheralInfo::MEMORY_WORD_SIZE;
    _init.DMA_Priority=TPriority;
    _init.DMA_Mode=TDmaMode;
    _init.DMA_MemoryBurst=DMA_MemoryBurst_Single;             // burst size
    _init.DMA_PeripheralBurst=DMA_PeripheralBurst_Single;     // burst size
    _init.DMA_FIFOMode=TFifoMode;                             // FIFO mode

    if(TFifoMode==DMA_FIFOMode_Enable)
      _init.DMA_FIFOThreshold=DMA_FIFOThreshold_HalfFull;       // flush on half-full
  }


  /**
   * Start a transfer of data to the peripheral controlled by timer
   *
   * @param[in] source memory address of the source data bytes.
   * @param[in] count The number of words/half-words/bytes to transfer.
   */

  template<class TPeripheralInfo,uint16_t TTimerEvent,uint32_t TPriority,uint32_t TDmaMode,uint32_t TFifoMode>
  inline void TimerDmaFeature<TPeripheralInfo,TTimerEvent,TPriority,TDmaMode,TFifoMode>::beginWriteByTimer(Timer& timer,const void *source,uint32_t count) {

    DMA_Stream_TypeDef *peripheralAddress;

    // set up the parameters for this transfer

    _init.DMA_Memory0BaseAddr=reinterpret_cast<uint32_t>(source);
    _init.DMA_BufferSize=count;

    // set the peripheral address from the overloaded operator

    peripheralAddress=_dma;

    // connect the timer to its associated DMA channel

    TIM_DMACmd(timer,TTimerEvent,ENABLE);

    // disable and then re-enable DMA

    DMA_Cmd(peripheralAddress,DISABLE);
    DMA_Init(peripheralAddress,&_init);
    DMA_Cmd(peripheralAddress,ENABLE);
  }



  /**
   * Partially specialised types for each timer event type
   */

  template<class TPeripheralInfo,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  struct TimerUpdateDmaFeature : public TimerDmaFeature<TPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode,TFifoMode> {
    TimerUpdateDmaFeature(Dma& dma) : TimerDmaFeature<TPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode,TFifoMode>(dma) {}
  };

  template<class TPeripheralInfo,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  struct TimerCc1DmaFeature : public TimerDmaFeature<TPeripheralInfo,TIM_DMA_CC1,TPriority,TDmaMode,TFifoMode> {
    TimerCc1DmaFeature(Dma& dma) : TimerDmaFeature<TPeripheralInfo,TIM_DMA_CC1,TPriority,TDmaMode,TFifoMode>(dma) {}
  };

  template<class TPeripheralInfo,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  struct TimerCc2DmaFeature : public TimerDmaFeature<TPeripheralInfo,TIM_DMA_CC2,TPriority,TDmaMode,TFifoMode> {
    TimerCc2DmaFeature(Dma& dma) : TimerDmaFeature<TPeripheralInfo,TIM_DMA_CC2,TPriority,TDmaMode,TFifoMode>(dma) {}
  };

  template<class TPeripheralInfo,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  struct TimerCc3DmaFeature : public TimerDmaFeature<TPeripheralInfo,TIM_DMA_CC3,TPriority,TDmaMode,TFifoMode> {
    TimerCc3DmaFeature(Dma& dma) : TimerDmaFeature<TPeripheralInfo,TIM_DMA_CC3,TPriority,TDmaMode,TFifoMode>(dma) {}
  };

  template<class TPeripheralInfo,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  struct TimerCc4DmaFeature : public TimerDmaFeature<TPeripheralInfo,TIM_DMA_CC4,TPriority,TDmaMode,TFifoMode> {
    TimerCc4DmaFeature(Dma& dma) : TimerDmaFeature<TPeripheralInfo,TIM_DMA_CC4,TPriority,TDmaMode,TFifoMode>(dma) {}
  };

  template<class TPeripheralInfo,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  struct TimerComDmaFeature : public TimerDmaFeature<TPeripheralInfo,TIM_DMA_COM,TPriority,TDmaMode,TFifoMode> {
    TimerComDmaFeature(Dma& dma) : TimerDmaFeature<TPeripheralInfo,TIM_DMA_COM,TPriority,TDmaMode,TFifoMode>(dma) {}
  };

  template<class TPeripheralInfo,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal,uint32_t TFifoMode=DMA_FIFOMode_Enable>
  struct TimerTriggerDmaFeature : public TimerDmaFeature<TPeripheralInfo,TIM_DMA_Trigger,TPriority,TDmaMode,TFifoMode> {
    TimerTriggerDmaFeature(Dma& dma) : TimerDmaFeature<TPeripheralInfo,TIM_DMA_Trigger,TPriority,TDmaMode,TFifoMode>(dma) {}
  };
}
// END FILE: ../lib/include/dma/features/f4/TimerDmaFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma1Stream2InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 1, stream 2 interrupt feature
   */

  typedef DmaInterruptFeature<1,2> Dma1Stream2InterruptFeature;

  /**
   * Typedefs for the peripherals that use this interrupt
   */

  typedef Dma1Stream2InterruptFeature I2C2RxDmaChannelInterruptFeature;
  typedef Dma1Stream2InterruptFeature Timer5Channel1DmaChannelInterruptFeature;
  typedef Dma1Stream2InterruptFeature Timer3Channel4DmaChannelInterruptFeature;
  typedef Dma1Stream2InterruptFeature Timer3UpdateDmaChannelInterruptFeature;
  typedef Dma1Stream2InterruptFeature Uart4RxDmaChannelInterruptFeature;
  typedef Dma1Stream2InterruptFeature I2C3RxDmaChannelInterruptFeature;
  typedef Dma1Stream2InterruptFeature I2S2ExtRxDmaChannelInterruptFeature;
  typedef Dma1Stream2InterruptFeature Timer7UpdateDmaChannelInterruptFeature;
  typedef Dma1Stream2InterruptFeature Spi3RxStream2DmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma1Stream2InterruptFeature.h
// START FILE: ../lib/include/dma/features/f4/Dma1Stream5InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Dma 1, stream 5 interrupt feature
   */

  typedef DmaInterruptFeature<1,5> Dma1Stream5InterruptFeature;

  /**
   * Types for the peripherals mapped to this channel
   */

  typedef Dma1Stream5InterruptFeature Dac1DmaChannelInterruptFeature;
  typedef Dma1Stream5InterruptFeature Timer3Channel2DmaChannelInterruptFeature;
  typedef Dma1Stream5InterruptFeature Usart2RxDmaChannelInterruptFeature;
  typedef Dma1Stream5InterruptFeature Timer2Channel1DmaChannelInterruptFeature;
  typedef Dma1Stream5InterruptFeature I2S3ExtTxDmaChannelInterruptFeature;
  typedef Dma1Stream5InterruptFeature I2C1RxStream5DmaChannelInterruptFeature;
  typedef Dma1Stream5InterruptFeature Spi3TxDmaChannelInterruptFeature;
}
// END FILE: ../lib/include/dma/features/f4/Dma1Stream5InterruptFeature.h
// START FILE: ../lib/include/dma/features/DmaMemoryCopyFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Do-nothing type to supply the correct template parameters to the base memory copy class
   * for copying a memory block from: the source address is incremented.
   */

  template<uint32_t TDataSize=DMA_MemoryDataSize_Byte>
  using DmaMemoryCopyFeature = DmaMemoryCopyBaseFeature<DMA_PeripheralInc_Enable,TDataSize>;
}
// END FILE: ../lib/include/dma/features/DmaMemoryCopyFeature.h
// START FILE: ../lib/include/dma/features/PwmFadeTimerDmaFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * This class implements an automatic fader for PWM channels
   */

  template<class TPeripheralInfo,uint16_t TTimerEvent,uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  class PwmFadeTimerDmaFeature : public TimerDmaFeature<TPeripheralInfo,TTimerEvent,TPriority,TDmaMode> {

    public:
      scoped_array<uint16_t> _compareValues;
      uint16_t _numCompareValues;

    public:
      PwmFadeTimerDmaFeature(Dma& dma);

      void beginFadeByTimer(Timer& timer,const uint8_t *percents,uint16_t numPercents);
      void repeatFadeByTimer(const Timer& timer);
  };


  /*
   * Constructor
   */

  template<class TPeripheralInfo,uint16_t TTimerEvent,uint32_t TPriority,uint32_t TDmaMode>
  inline PwmFadeTimerDmaFeature<TPeripheralInfo,TTimerEvent,TPriority,TDmaMode>::PwmFadeTimerDmaFeature(Dma& dma)
    : TimerDmaFeature<TPeripheralInfo,TTimerEvent,TPriority,TDmaMode>(dma) {
  }


  /**
   * Start the fade using the supplied percentage array. The user can let this array go
   * out of scope after this function is called. The fading will start immediately and
   * and not repeat unless DMA circular mode is selected.
   */

  template<class TPeripheralInfo,uint16_t TTimerEvent,uint32_t TPriority,uint32_t TDmaMode>
  inline void PwmFadeTimerDmaFeature<TPeripheralInfo,TTimerEvent,TPriority,TDmaMode>::beginFadeByTimer(Timer& timer,const uint8_t *percents,uint16_t numPercents) {

    uint16_t i;
    uint32_t period;

    // get the timer period from the base class

    period=timer.getPeriod()+1;

    // allocate space for the percentages

    _compareValues.reset(new uint16_t[numPercents]);
    _numCompareValues=numPercents;

    // convert each percent to a compare value

    for(i=0;i<numPercents;i++) {

      // watch out for overflow

      if(period<0xFFFFFFFF/100)
        _compareValues[i]=static_cast<uint16_t>((period*static_cast<uint32_t>(percents[i]))/100L);
      else
        _compareValues[i]=(period/100L)*static_cast<uint32_t>(percents[i]);
    }

    // set the DMA off

    this->beginWriteByTimer(timer,_compareValues.get(),numPercents);
  }


  /**
   * Repeat (start again) a timer-based fade. This is only valid for when the DMA is not
   * running in circular (continuous) mode.
   */

  template<class TPeripheralInfo,uint16_t TTimerEvent,uint32_t TPriority,uint32_t TDmaMode>
  inline void PwmFadeTimerDmaFeature<TPeripheralInfo,TTimerEvent,TPriority,TDmaMode>::repeatFadeByTimer(const Timer& timer) {
    this->beginWriteByTimer(timer,_compareValues.get(),_numCompareValues);
  }


  /**
   * Types to support easy access to the common use case of using the Update event
   */

  // TIM1

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer1Channel1UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer1Ccr1DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer1Channel2UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer1Ccr2DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer1Channel3UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer1Ccr3DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer1Channel4UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer1Ccr4DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  // TIM2

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer2Channel1UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer2Ccr1DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer2Channel2UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer2Ccr2DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer2Channel3UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer2Ccr3DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer2Channel4UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer2Ccr4DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  // TIM3

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer3Channel1UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer3Ccr1DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer3Channel2UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer3Ccr2DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer3Channel3UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer3Ccr3DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer3Channel4UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer3Ccr4DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

#ifndef STM32PLUS_F0

  // TIM4

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer4Channel1UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer4Ccr1DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer4Channel2UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer4Ccr2DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer4Channel3UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer4Ccr3DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer4Channel4UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer4Ccr4DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  // TIM5

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer5Channel1UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer5Ccr1DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer5Channel2UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer5Ccr2DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer5Channel3UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer5Ccr3DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer5Channel4UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer5Ccr4DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  // TIM7

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer7Channel1UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer7Ccr1DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer7Channel2UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer7Ccr2DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer7Channel3UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer7Ccr3DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer7Channel4UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer7Ccr4DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  // TIM8

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer8Channel1UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer8Ccr1DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer8Channel2UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer8Ccr2DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer8Channel3UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer8Ccr3DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer8Channel4UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer8Ccr4DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

#endif

  // TIM6

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer6Channel1UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer6Ccr1DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer6Channel2UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer6Ccr2DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer6Channel3UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer6Ccr3DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;

  template<uint32_t TPriority=DMA_Priority_High,uint32_t TDmaMode=DMA_Mode_Normal>
  using Timer6Channel4UpdatePwmFadeTimerDmaFeature = PwmFadeTimerDmaFeature<Timer6Ccr4DmaPeripheralInfo,TIM_DMA_Update,TPriority,TDmaMode>;
}
// END FILE: ../lib/include/dma/features/PwmFadeTimerDmaFeature.h
// START FILE: ../lib/include/dma/features/DmaFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for DMA features
   */

  class DmaFeatureBase {

    public:

      enum TransferType {
        TRANSFER_ONESHOT,
        TRANSFER_CIRCULAR
      };

    protected:
      Dma& _dma;
      DMA_InitTypeDef _init;

    public:
      DmaFeatureBase(Dma& dma);

      operator Dma&();
      operator DMA_InitTypeDef&();

      Dma& getDma();
  };


  /**
   * Constructor
   * @param dma
   */

  inline DmaFeatureBase::DmaFeatureBase(Dma& dma)
    : _dma(dma) {
  }


  /**
   * Cast to Dma reference
   */

  inline DmaFeatureBase::operator Dma&() {
    return _dma;
  }


  /*
   * Alternative to the cast operator
   * @return The DMA object
   */

  inline Dma& DmaFeatureBase::getDma() {
    return _dma;
  }


  /**
   * Cast to DMA_InitTypedef to allow modifications
   * before the transfer is started
   */

  inline DmaFeatureBase::operator DMA_InitTypeDef&() {
    return _init;
  }
}
// END FILE: ../lib/include/dma/features/DmaFeatureBase.h
// START FILE: ../lib/include/dma/features/DmaLcdWriter.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Simple carrier class for an implementation of a DMA copier. Used to ensure that we're not restricted
   * to just the common case of the FSMC implementation. i.e. one day DMA-to-GPIO may be implemented
   */

  template<class TDmaCopierImpl>
  class DmaLcdWriter {

    protected:
      TDmaCopierImpl& _impl;

    public:
      DmaLcdWriter(TDmaCopierImpl& impl);

      bool waitUntilComplete();
      void beginCopyToLcd(void *dest,void *source,uint32_t byteCount,uint32_t priority);
  };


  /**
   * Constructor
   * @param impl Reference to the actual implementation
   */

  template<class TDmaCopierImpl>
  inline DmaLcdWriter<TDmaCopierImpl>::DmaLcdWriter(TDmaCopierImpl& impl)
    : _impl(impl) {
  }


  /**
   * Wait until the last transfer completes
   * @return false if the DMA peripheral reports an error
   */

  template<class TDmaCopierImpl>
  inline bool DmaLcdWriter<TDmaCopierImpl>::waitUntilComplete() {
   return _impl.getDma().waitUntilComplete();
  }


  /**
   * Start the DMA copy
   * @param dest Destination register address
   * @param source Source address
   * @param byteCount Number of 8-bit bytes to copy
   * @param priority DMA priority
   */

  template<class TDmaCopierImpl>
  inline void DmaLcdWriter<TDmaCopierImpl>::beginCopyToLcd(void *dest,void *source,uint32_t byteCount,uint32_t priority) {
    _impl.beginCopyToLcd(dest,source,byteCount,priority);
  }
}
// END FILE: ../lib/include/dma/features/DmaLcdWriter.h
// START FILE: ../lib/include/dma/features/DmaMemoryFillFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Do-nothing type to supply the correct template parameters to the base memory copy class
   * for filling memory with a constant value: the source address is not incremented.
   */

  template<uint32_t TDataSize=DMA_MemoryDataSize_Byte>
  using DmaMemoryFillFeature = DmaMemoryCopyBaseFeature<DMA_PeripheralInc_Disable,TDataSize>;
}
// END FILE: ../lib/include/dma/features/DmaMemoryFillFeature.h
// START FILE: ../lib/include/dac/CS43L22/NullCS43L22DataPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Nothing class to allow construction of CS43L22 without a digital data source
   */

  struct NullCS43L22DataPeripheral {

    struct Parameters {
    };

    NullCS43L22DataPeripheral(const Parameters&) {
    }
  };
}

// END FILE: ../lib/include/dac/CS43L22/NullCS43L22DataPeripheral.h
// START FILE: ../lib/include/dac/CS43L22/CS43L22.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Cirrus Logic CS43L22 DAC implementation. The control peripheral is usually an I2C
   * class such as CS43L22ControlI2C. The data peripheral is usually an I2S class, but
   * there is a dummy default for the times when you just want the Analog pass
   * through's and will not be supplying digital data.
   */

  template<class TControlPeripheral,class TDataPeripheral=NullCS43L22DataPeripheral>
  class CS43L22 : public TControlPeripheral,public TDataPeripheral {

    public:

      /**
       * CS43L22 parameters class. This inherits from the parameters classes defined by
       * whatever the base classes require.
       */

      struct Parameters : TControlPeripheral::Parameters, TDataPeripheral::Parameters {

        /**
         * Reference to the reset pin (digital output)
         */

        GpioPinRef resetPin;
      };

    protected:
      GpioPinRef _resetPin;

    public:
      CS43L22(const Parameters& params);

      void reset() const;
  };


  /**
   * Constructor
   * @param params The parameters class containing the reset pin
   */

  template<class TControlPeripheral,class TDataPeripheral>
  inline CS43L22<TControlPeripheral,TDataPeripheral>::CS43L22(const Parameters& params)
    : TControlPeripheral(params),
      TDataPeripheral(params),
      _resetPin(params.resetPin) {
  }


  /**
   * Reset the device
   */

  template<class TControlPeripheral,class TDataPeripheral>
  inline void CS43L22<TControlPeripheral,TDataPeripheral>::reset() const {

    // minimum reset hold time = 1ms

    _resetPin.reset();
    MillisecondTimer::delay(2);
    _resetPin.set();
  }
}
// END FILE: ../lib/include/dac/CS43L22/CS43L22.h
// START FILE: ../lib/include/dac/CS43L22/CS43L22ControlI2C.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Template class for the CS43L22 I2C controller. Inherits all the I2C functionality
   * from the peripheral it's parameterised with
   */

  template<class TI2CPeripheral>
  class CS43L22ControlI2C : public TI2CPeripheral {

    public:

      enum {
        I2C_BUS_ADDRESS = 0x94
      };

      enum Command {
        ID                        = 1,
        POWER_CTL1                = 2,
        POWER_CTL2                = 4,
        CLOCKING_CTL              = 5,
        INTERFACE_CTL1            = 6,
        INTERFACE_CTL2            = 7,
        PASSTHROUGH_A             = 8,
        PASSTHROUGH_B             = 9,
        ANALOG_ZC_SR              = 0xa,
        PASSTHROUGH_GANG_CTL      = 0xc,
        PLAYBACK_CTL1             = 0xd,
        MISC_CTL                  = 0xe,
        PLAYBACK_CTL2             = 0xf,
        PASSTHROUGH_A_VOL         = 0x14,
        PASSTHROUGH_B_VOL         = 0x15,
        PCMA_VOL                  = 0x1a,
        PCMB_VOL                  = 0x1b,
        BEEP_FREQ_ON_TIME         = 0x1c,
        BEEP_VOL_OFF_TIME         = 0x1d,
        BEEP_TONE_CFG             = 0x1e,
        TONE_CTL                  = 0x1f,
        MASTER_A_VOL              = 0x20,
        MASTER_B_VOL              = 0x21,
        HEADPHONE_A_VOL           = 0x22,
        HEADPHONE_B_VOL           = 0x23,
        SPEAKER_A_VOL             = 0x24,
        SPEAKER_B_VOL             = 0x25,
        CHANNEL_MIXER_AND_SWAP    = 0x26,
        LIMIT_CTL1_THRESHOLDS     = 0x27,
        LIMIT_CTL2_RELEASE_RATE   = 0x28,
        LIMITER_ATTACK_RATE       = 0x29,
        OVERFLOW_AND_CLOCK_STATUS = 0x2e,
        BATTERY_COMPENSATION      = 0x2f,
        VP_BATTERY_LEVEL          = 0x30,
        SPEAKER_STATUS            = 0x31,
        CHARGE_PUMP_FREQUENCY     = 0x34
      };

      enum Source {
        ANALOG_1 = 1,
        ANALOG_2 = 2,
        ANALOG_3 = 4,
        ANALOG_4 = 8
      };

    protected:
      uint8_t convertVolume(uint8_t rawVolume) const;

    public:
      CS43L22ControlI2C(const typename TI2CPeripheral::Parameters& params);

      // initialise the device

      bool initialise() const;

      // pass through selection

      bool enablePassThroughA(Source source) const;
      bool enablePassThroughB(Source source) const;

      // power control

      bool powerOn() const;
      bool powerOff() const;

      // speaker/headphone power selection

      bool speakersOn() const;
      bool speakersOff() const;

      bool headphonesOn() const;
      bool headphonesOff() const;

      // volume controls

      bool masterVolume(uint8_t volume) const;
      bool headphonesVolume(uint8_t volume) const;
      bool speakersVolume(uint8_t volume) const;
      bool passThroughAVolume(uint8_t volume) const;
      bool passThroughBVolume(uint8_t volume) const;

      // beep generation

      bool beepSingle() const;
  };


  /**
   * Constructor
   * @param params The parameters class containing the I2C initialisation parameters.
   */

  template<class TI2CPeripheral>
  inline CS43L22ControlI2C<TI2CPeripheral>::CS43L22ControlI2C(const typename TI2CPeripheral::Parameters& params)
    : TI2CPeripheral(params) {

    // set our slave address. we're always a slave so there has to be an I/O feature
    // somewhere in the feature hierarchy that has this method

    this->setSlaveAddress(I2C_BUS_ADDRESS);
  }


  /**
   * Send the device initialisation sequence
   * @return true if it worked
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::initialise() const {

    return

        // turn the device power off

        powerOff()  &&

        // all outputs off

        speakersOff() &&
        headphonesOff() &&

        // auto-detect speed, MCLK/2

        this->writeByte(CLOCKING_CTL,0x81) &&

        // slave Mode, I2S Data Format

        this->writeByte(INTERFACE_CTL1,0x4) &&

        // all passthroughs muted

        this->writeByte(MISC_CTL,4) &&

        // volume levels

        masterVolume(200) &&
        headphonesVolume(200) &&
        speakersVolume(200) &&

        // power on

        powerOn() &&

        this->writeByte(PCMA_VOL,0xa) &&
        this->writeByte(PCMB_VOL,0xa) &&

        // disable the analog soft ramp

        this->writeByte(ANALOG_ZC_SR,0) &&

        // disable the digital soft ramp

        this->writeByte(MISC_CTL, 0x04) &&

        // disable the limiter attack level
        this->writeByte(LIMIT_CTL1_THRESHOLDS,0x00) &&

        // set the frequency of the beep

        this->writeByte(BEEP_FREQ_ON_TIME,0x80);
  }


  /**
   * Configure passthrough A for an analog source
   * @param sources The analog source
   * @return true if it worked
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::enablePassThroughA(Source source) const {

    return this->setMask(PASSTHROUGH_A,(uint8_t)source,0xf) &&   // enable the bits in the passthrough register
           this->setBits(MISC_CTL,0x40) &&                       // set the passthrough A enable bit
           this->resetBits(MISC_CTL,0x10);                       // clear the passthrough A mute bit
  }


  /**
   * Configure passthrough B for an analog source
   * @param sources The analog source
   * @return true if it worked
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::enablePassThroughB(Source source) const {

    return this->setMask(PASSTHROUGH_B,(uint8_t)source,0xf) &&   // enable the bits in the passthrough register
           this->setBits(MISC_CTL,0x80) &&                       // set the passthrough B enable bit
           this->resetBits(MISC_CTL,0x20);                       // clear the passthrough B mute bit
  }


  /**
   * Send a single beep
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::beepSingle() const {

    // toggle BEEP0

    return this->resetBits(BEEP_TONE_CFG,0x40) &&
           this->setBits(BEEP_TONE_CFG,0x40);
  }


  /**
   * power up
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::powerOn() const {
    return this->writeByte(POWER_CTL1,0x9e);
  }


  /**
   * power down
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::powerOff() const {
    return this->writeByte(POWER_CTL1,1);
  }


  /**
   * enable speaker output
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::speakersOn() const {
    return this->setMask(POWER_CTL2,0xa,0xf);
  }


  /**
   * disable speaker output
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::speakersOff() const {
    return this->setMask(POWER_CTL2,0xf,0xf);
  }


  /**
   * enable headphone output
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::headphonesOn() const {
    return this->setMask(POWER_CTL2,0xa0,0xf0);
  }


  /**
   * disable headphone output
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::headphonesOff() const {
    return this->setMask(POWER_CTL2,0xf0,0xf0);
  }


  /**
   * Set the master volume level
   * @param volume the volume value
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::masterVolume(uint8_t volume) const {

    return this->writeByte(MASTER_A_VOL,convertVolume(volume)) &&
           this->writeByte(MASTER_B_VOL,convertVolume(volume));
  }


  /**
   * Set the headphones volume level
   * @param volume the volume value
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::headphonesVolume(uint8_t volume) const {

    return this->writeByte(HEADPHONE_A_VOL,convertVolume(volume)) &&
           this->writeByte(HEADPHONE_B_VOL,convertVolume(volume));
  }

  /**
   * Set the speakers volume level
   * @param volume the volume value
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::speakersVolume(uint8_t volume) const {

    return this->writeByte(SPEAKER_A_VOL,convertVolume(volume)) &&
           this->writeByte(SPEAKER_B_VOL,convertVolume(volume));
  }


  /**
   * Set the passthrough A volume
   * @param volume the volume value
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::passThroughAVolume(uint8_t volume) const {

    return this->writeByte(PASSTHROUGH_A_VOL,convertVolume(volume)) &&
           this->writeByte(PASSTHROUGH_A_VOL,convertVolume(volume));
  }


  /**
   * Set the passthrough B volume
   * @param volume the volume value
   * @return true if succeeded
   */

  template<class TI2CPeripheral>
  inline bool CS43L22ControlI2C<TI2CPeripheral>::passThroughBVolume(uint8_t volume) const {

    return this->writeByte(PASSTHROUGH_B_VOL,convertVolume(volume)) &&
           this->writeByte(PASSTHROUGH_B_VOL,convertVolume(volume));
  }


  /**
   * Scale the volume value just like the ST sample code does
   * @param rawVolume
   * @return The scaled volume value
   */

  template<class TI2CPeripheral>
  inline uint8_t CS43L22ControlI2C<TI2CPeripheral>::convertVolume(uint8_t rawVolume) const {

    // Magic undocumented constant. Thanks ST.
    return rawVolume>0xE6 ? rawVolume-0xE7 : rawVolume+0x19;
  }
}
// END FILE: ../lib/include/dac/CS43L22/CS43L22ControlI2C.h
// START FILE: ../lib/include/dac/DacPinInitialiser.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Convenience template to initialise a DAC pin package
   */

  template<class TPinPackage>
  class DacPinInitialiser {
    public:
      static void initialise();
  };


  /**
   * Initialise the pin package that we were parameterised with
   */

  template<class TPinPackage>
  inline void DacPinInitialiser<TPinPackage>::initialise() {

    GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_OUT,
                                   TPinPackage::Pin_OUT,
                                   Gpio::ANALOG,
                                   GPIO_Speed_50MHz,        // unused
                                   Gpio::PUPD_NONE,
                                   Gpio::PUSH_PULL);
  }
}
// END FILE: ../lib/include/dac/DacPinInitialiser.h
// START FILE: ../lib/include/dac/Dac2.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /*
   * Default pin package: (OUT = PA5)
   */

  struct Dac2DefaultPinPackage {
    enum {
      Port_OUT = GPIOA_BASE,
      Pin_OUT  = GPIO_Pin_5
    };
  };


  /**
   * Main DAC class
   */

  template<class... Features>
  struct Dac2 : DacPeripheral<Dac2DefaultPinPackage,PERIPHERAL_DAC2>,
                Features... {

    Dac2(const Parameters& params=Parameters())
      : DacPeripheral<Dac2DefaultPinPackage,PERIPHERAL_DAC2>(params),
        Features((Dac&)*this)... {
    }
  };
}
// END FILE: ../lib/include/dac/Dac2.h
// START FILE: ../lib/include/dac/features/DacDataAlignmentFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class to enable the 3 DAC data alignment modes
   *
   * @tparam TChannel The DAC channel (DAC_Channel_1/2). Only channel 1 is valid on the F0.
   * @tparam TAlignment The data alignment (DAC_Align_12b_R / DAC_Align_12b_L / DAC_Align_8b_R)
   */

  template<uint32_t TChannel,uint32_t TAlignment>
  class DacDataAlignmentFeature : public DacFeatureBase {

    public:
      enum {
        DUAL_CHANNEL_FEATURE = 0
      };

    public:
      DacDataAlignmentFeature(Dac& dac);

      static uint32_t getAlignment();
      static uint32_t getChannel();
      static void write(uint16_t data);
  };


  /**
   * Constructor
   * @param dac
   */

  template<uint32_t TChannel,uint32_t TAlignment>
  inline DacDataAlignmentFeature<TChannel,TAlignment>::DacDataAlignmentFeature(Dac& dac)
    : DacFeatureBase(dac) {
  }


  /**
   * Get the alignment
   */

  template<uint32_t TChannel,uint32_t TAlignment>
  inline uint32_t DacDataAlignmentFeature<TChannel,TAlignment>::getAlignment() {
    return TAlignment;
  }


  /**
   * Get the channel
   */

  template<uint32_t TChannel,uint32_t TAlignment>
  inline uint32_t DacDataAlignmentFeature<TChannel,TAlignment>::getChannel() {
    return TChannel;
  }


  /**
   * Write data
   */

  template<uint32_t TChannel,uint32_t TAlignment>
  inline void DacDataAlignmentFeature<TChannel,TAlignment>::write(uint16_t data) {

    DAC_SetChannel1Data(TAlignment,data);

#if defined(STM32PLUS_F0)
#else

    // This is a comparison of constants - the optimiser will eliminate the comparison completely

    if(TChannel==DAC_Channel_1)
      DAC_SetChannel1Data(TAlignment,data);
    else
      DAC_SetChannel2Data(TAlignment,data);

#endif
  }


  /**
   * Typedefs for all combinations of cases
   */

  typedef DacDataAlignmentFeature<DAC_Channel_1,DAC_Align_12b_R> DacChannel112BitRightAlignmentFeature;
  typedef DacDataAlignmentFeature<DAC_Channel_1,DAC_Align_12b_L> DacChannel112BitLeftAlignmentFeature;
  typedef DacDataAlignmentFeature<DAC_Channel_1,DAC_Align_8b_R> DacChannel18BitRightAlignmentFeature;

#if !defined(STM32PLUS_F0)
  typedef DacDataAlignmentFeature<DAC_Channel_2,DAC_Align_12b_R> DacChannel212BitRightAlignmentFeature;
  typedef DacDataAlignmentFeature<DAC_Channel_2,DAC_Align_12b_L> DacChannel212BitLeftAlignmentFeature;
  typedef DacDataAlignmentFeature<DAC_Channel_2,DAC_Align_8b_R> DacChannel28BitRightAlignmentFeature;
#endif
}
// END FILE: ../lib/include/dac/features/DacDataAlignmentFeature.h
// START FILE: ../lib/include/dac/features/f1,f4/DacDualChannelFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#if !defined(STM32PLUS_F1) && !defined(STM32PLUS_F4)
#error This class can only be used with the STM32F1 and STM32F4 series
#endif


namespace stm32plus {


  /**
   * Feature class to enable the DAC in dual channel mode
   *
   * @tparam TChannel The DAC channel (DAC_Channel_1/2)
   * @tparam TAlignment The data alignment (DAC_Align_12b_R / DAC_Align_12b_L / DAC_Align_8b_R)
   * @tparam whether this channel represents a dual mode (not a user parameter, leave the default as false)
   */

  template<uint32_t TAlignment>
  class DacDualChannelFeature : public DacFeatureBase {

    public:
      enum {
        DUAL_CHANNEL_FEATURE = 1
      };

    public:
      DacDualChannelFeature(Dac& dac);

      static uint32_t getAlignment();
      static void write(uint16_t data1,uint16_t data2);

      void triggerOn() const;
      void triggerOff() const;
  };


  /**
   * Constructor
   * @param dac
   */

  template<uint32_t TAlignment>
  inline DacDualChannelFeature<TAlignment>::DacDualChannelFeature(Dac& dac)
    : DacFeatureBase(dac) {
  }


  /**
   * Get the alignment
   */

  template<uint32_t TAlignment>
  inline uint32_t DacDualChannelFeature<TAlignment>::getAlignment() {
    return TAlignment;
  }


  /**
   * Write data
   */

  template<uint32_t TAlignment>
  inline void DacDualChannelFeature<TAlignment>::write(uint16_t data1,uint16_t data2) {

    DAC_SetDualChannelData(TAlignment,data1,data2);
  }


  /**
   * Typedefs for all combinations of cases
   */

  typedef DacDualChannelFeature<DAC_Align_12b_R> DacDualChannel12BitRightAlignmentFeature;
  typedef DacDualChannelFeature<DAC_Align_12b_L> DacDualChannel12BitLeftAlignmentFeature;
  typedef DacDualChannelFeature<DAC_Align_8b_R> DacDualChannel8BitRightAlignmentFeature;
}
// END FILE: ../lib/include/dac/features/f1,f4/DacDualChannelFeature.h
// START FILE: ../lib/include/dac/features/DacFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for DAC features
   */

  class DacFeatureBase {
    protected:
      Dac& _dac;

    public:
      DacFeatureBase(Dac& dac);
      operator Dac&();
  };


  /**
   * Constructor
   * @param dac
   */

  inline DacFeatureBase::DacFeatureBase(Dac& dac)
    : _dac(dac) {
  }


  /**
   * Cast to Dac reference
   */

  inline DacFeatureBase::operator Dac&() {
    return _dac;
  }
}
// END FILE: ../lib/include/dac/features/DacFeatureBase.h
// START FILE: ../lib/include/dac/Dac1.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /*
   * Default pin package: (OUT = PA4)
   */

  struct Dac1DefaultPinPackage {
    enum {
      Port_OUT = GPIOA_BASE,
      Pin_OUT  = GPIO_Pin_4
    };
  };


  /**
   * Main DAC class
   */

  template<class... Features>
  struct Dac1 : DacPeripheral<Dac1DefaultPinPackage,PERIPHERAL_DAC1>,
                Features... {

    Dac1(const Parameters& params=Parameters())
      : DacPeripheral<Dac1DefaultPinPackage,PERIPHERAL_DAC1>(params),
        Features((Dac&)*this)... {
    }
  };
}
// END FILE: ../lib/include/dac/Dac1.h
// START FILE: ../lib/include/dac/Dac.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Base class for both DAC peripherals
   */

  class Dac {

    protected:
      uint32_t _channel;

    public:
      Dac(uint32_t channel);

    public:
      uint32_t getChannel() const;

      void enablePeripheral() const;
      void disablePeripheral() const;

      void triggerOn() const;
      void triggerOff() const;

      uint16_t getLastOutput() const;
  };


  /**
   * Constructor
   * @param channel DAC channel (DAC_Channel_1 / DAC_Channel_2)
   */

  inline Dac::Dac(uint32_t channel)
    : _channel(channel) {
  }


  /**
   * Get the channel number
   * @return The channel number (DAC_Channel_1 / DAC_Channel_2)
   */

  inline uint32_t Dac::getChannel() const {
    return _channel;
  }


  /**
   * Enable the peripheral
   */

  inline void Dac::enablePeripheral() const {
    DAC_Cmd(_channel,ENABLE);
  }


  /**
   * Disable the peripheral
   */

  inline void Dac::disablePeripheral() const {
    DAC_Cmd(_channel,DISABLE);
  }


  /**
   * Fire the software trigger
   */

  inline void Dac::triggerOn() const {
    DAC_SoftwareTriggerCmd(_channel,ENABLE);
  }


  /**
   * Disable the software trigger
   */

  inline void Dac::triggerOff() const {
    DAC_SoftwareTriggerCmd(_channel,DISABLE);
  }


  /**
   * Get the last data output to the channel
   * @return
   */

  inline uint16_t Dac::getLastOutput() const {
    return DAC_GetDataOutputValue(_channel);
  }
}
// END FILE: ../lib/include/dac/Dac.h
// START FILE: ../lib/include/dac/DacPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * DAC peripheral class
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  class DacPeripheral : public Dac {

    public:

      struct Parameters {
        uint32_t dac_trigger;
        uint32_t dac_waveGeneration;
        uint32_t dac_lfsrMaskOrTriangleAmplitude;
        uint32_t dac_outputBuffer;

        /**
         * Default parameters:
         *  are no trigger (conversion triggered by loading data to the register)
         *  no wave generation
         *  bit0-11 LFSR unmask/triangle amplitude 1
         *  output buffer enabled
         */

        Parameters(uint32_t trigger=DAC_Trigger_None) {
          dac_trigger=trigger;
          dac_waveGeneration=DAC_WaveGeneration_None;
          dac_lfsrMaskOrTriangleAmplitude=DAC_LFSRUnmask_Bits11_0;
          dac_outputBuffer=DAC_OutputBuffer_Enable;
        }
      };

    protected:

      DacPeripheral(const Parameters& params);
      ~DacPeripheral();

  };


  /*
   * Constructor
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline DacPeripheral<TPinPackage,TPeripheralName>::DacPeripheral(const Parameters& params)
    : Dac(PeripheralTraits<TPeripheralName>::CHANNEL_NUMBER) {

    DAC_InitTypeDef init;

    // clocks on first before any features get initialised

    ClockControl<TPeripheralName>::On();

    // and next the GPIO pins, also before any features get initialised

    DacPinInitialiser<TPinPackage>::initialise();

    // initialise the peripheral

    DAC_StructInit(&init);

    init.DAC_Trigger=params.dac_trigger;
    init.DAC_WaveGeneration=params.dac_waveGeneration;
    init.DAC_LFSRUnmask_TriangleAmplitude=params.dac_lfsrMaskOrTriangleAmplitude;
    init.DAC_OutputBuffer=params.dac_outputBuffer;

    DAC_Init(PeripheralTraits<TPeripheralName>::CHANNEL_NUMBER,&init);

    // enable this channel

    enablePeripheral();
  }


  /*
   * Destructor
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline DacPeripheral<TPinPackage,TPeripheralName>::~DacPeripheral() {

    // disable and clocks off

    disablePeripheral();
    ClockControl<TPeripheralName>::Off();
  }
}
// END FILE: ../lib/include/dac/DacPeripheral.h
// START FILE: ../lib/include/can/Can.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Base class for the CAN peripheral
   */

  class Can {

    public:

      enum {
        E_TX_NO_MAILBOX = 1
      };

    protected:
      CAN_TypeDef *_peripheralAddress;
      CAN_InitTypeDef _init;

    protected:
      Can(CAN_TypeDef *peripheralAddress);

    public:
      void sleep() const;
      void wakeup() const;

      // send remote frame

      bool sendRemoteFrame(uint16_t StdId,uint8_t DLC) const;
      bool sendRemoteFrame(uint16_t StdId,int32_t ExtId,uint8_t DLC) const;

      // send data frame

      bool send(uint16_t StdId,uint8_t DLC,const void *data) const;
      bool send(uint16_t StdId,int32_t ExtId,uint8_t DLC,const void *data) const;

      bool send(CanTxMsg& msg) const;

      bool readyToReceive(uint8_t fifo) const;
      bool receive(uint8_t fifo, CanRxMsg* msg) const;

      operator CAN_TypeDef *();
      operator CAN_InitTypeDef *();
  };


  /**
   * Constructor
   * @param peripheralAddress the CAN base address
   */

  inline Can::Can(CAN_TypeDef *peripheralAddress)
    : _peripheralAddress(peripheralAddress) {
  }


  /**
   * Go to sleep
   */

  inline void Can::sleep() const {
    CAN_Sleep(_peripheralAddress);
  }


  /**
   * Wake up
   */

  inline void Can::wakeup() const {
    CAN_WakeUp(_peripheralAddress);
  }


  /**
   * Get the peripheral address
   * @return The CAN peripheral address
   */

  inline Can::operator CAN_TypeDef *() {
    return _peripheralAddress;
  }


  /**
   * Get the init structure
   * @return The CAN_InitTypeDef structure
   */

  inline Can::operator CAN_InitTypeDef *() {
    return &_init;
  }


  /**
   * Send a message
   * @param StdId
   * @param DLC
   * @return true if it worked
   */

  inline bool Can::sendRemoteFrame(uint16_t StdId,uint8_t DLC) const {

    CanTxMsg msg;

    msg.IDE=CAN_Id_Standard;
    msg.RTR=CAN_RTR_Remote;
    msg.DLC=DLC;
    msg.StdId=StdId;

    return send(msg);
  }


  /**
   * Send a message
   * @param StdId
   * @param ExtId
   * @param DLC
   * @return true if it worked
   */

  inline bool Can::sendRemoteFrame(uint16_t StdId,int32_t ExtId,uint8_t DLC) const {

    CanTxMsg msg;

    msg.IDE=CAN_Id_Extended;
    msg.RTR=CAN_RTR_Remote;
    msg.DLC=DLC;

    msg.StdId=StdId;
    msg.ExtId=ExtId;

    return send(msg);
  }


  /**
   * Send a message
   * @param StdId
   * @param DLC
   * @param data
   * @return true if it worked
   */

  inline bool Can::send(uint16_t StdId,uint8_t DLC,const void *data) const {

    CanTxMsg msg;

    msg.IDE=CAN_Id_Standard;
    msg.RTR=CAN_RTR_Data;
    msg.DLC=DLC;
    msg.StdId=StdId;

    memcpy(msg.Data,data,DLC);

    return send(msg);
  }


  /**
   * Send a message
   * @param StdId
   * @param ExtId
   * @param DLC
   * @param data
   * @return true if it worked
   */

  inline bool Can::send(uint16_t StdId,int32_t ExtId,uint8_t DLC,const void *data) const {

    CanTxMsg msg;

    msg.IDE=CAN_Id_Extended;
    msg.RTR=CAN_RTR_Data;
    msg.DLC=DLC;

    msg.StdId=StdId;
    msg.ExtId=ExtId;

    memcpy(msg.Data,data,DLC);

    return send(msg);
  }


  /**
   * Send a message given a message structure
   * @param msg
   * @return true if it worked
   */

  inline bool Can::send(CanTxMsg& msg) const {

    if(CAN_Transmit(_peripheralAddress,&msg)==CAN_TxStatus_NoMailBox)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_CAN,E_TX_NO_MAILBOX,CAN_TxStatus_NoMailBox);

    return true;
  }


  /**
   * Check if the peripheral is ready to receive
   * @return true if it's ready
   */

  inline bool Can::readyToReceive(uint8_t fifo) const {
    return !!CAN_MessagePending(_peripheralAddress, fifo);
  }


  /**
   * Read a byte from the peripheral
   */

  inline bool Can::receive(uint8_t fifo,CanRxMsg* msg) const {

    while(!readyToReceive(fifo))
      return false;

    CAN_Receive(_peripheralAddress,fifo,msg);
    return true;
  }
}


// END FILE: ../lib/include/can/Can.h
// START FILE: ../lib/include/can/f4/CanAlternateFunctionMapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Specialisation of the AF mapper for this peripheral
   */

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_CAN1,TPort,TPin> {
    enum {
      GPIO_AF=GPIO_AF_CAN1
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_CAN2,TPort,TPin> {
    enum {
      GPIO_AF=GPIO_AF_CAN2
    };
  };
}
// END FILE: ../lib/include/can/f4/CanAlternateFunctionMapper.h
// START FILE: ../lib/include/can/f4/Can1.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


// ensure the MCU series is correct
#if !defined(STM32PLUS_F4)
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Default pin package:
   * (TX,RX) = (PA12,PA11)
   */

  struct Can1DefaultPinPackage {
    enum{
      Port_TX=GPIOA_BASE,
      Port_RX=GPIOA_BASE,

      Pin_TX=GPIO_Pin_12,
      Pin_RX=GPIO_Pin_11
    };
  };


  /**
   * The default, non-remapped pin package
   */

  template<class... Features>
  struct Can1 : CanPeripheral<Can1DefaultPinPackage,PERIPHERAL_CAN1>,
                  Features... {
    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Can1(const Parameters& params)
      : CanPeripheral<Can1DefaultPinPackage,PERIPHERAL_CAN1>(params),
        Features(static_cast<Can&>(*this))... {

      initialisePeripheral();
      RecursiveVoidInit<Can1,Features...>::tinit(this);
    }
  };


  /**
   * Remap #1:
   * (TX,RX) = (PB9,PB8)
   */

  struct Can1Remap1PinPackage {
    enum{
      Port_TX=GPIOB_BASE,
      Port_RX=GPIOB_BASE,

      Pin_TX=GPIO_Pin_9,
      Pin_RX=GPIO_Pin_8
    };
  };


  /**
   * The remapped version of CAN1
   */

  template<class... Features>
  struct Can1_Remap1 : CanPeripheral<Can1Remap1PinPackage,PERIPHERAL_CAN1>,
                  Features...{
    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Can1_Remap1(const Parameters& params)
        : CanPeripheral<Can1Remap1PinPackage,PERIPHERAL_CAN1>(params),
          Features(static_cast<Can&>(*this))...{

      initialisePeripheral();
      RecursiveVoidInit<Can1_Remap1,Features...>::tinit(this);
    }
  };


  /**
   * Remap #2:
   * (TX,RX) = (PD1,PD0)
   */

  struct Can1Remap2PinPackage {
    enum{
      Port_TX=GPIOD_BASE,
      Port_RX=GPIOD_BASE,

      Pin_TX=GPIO_Pin_1,
      Pin_RX=GPIO_Pin_0
    };
  };


  /**
   * The remapped version of CAN1
   */

  template<class... Features>
  struct Can1_Remap2 : CanPeripheral<Can1Remap2PinPackage,PERIPHERAL_CAN1>,
                  Features...{
    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Can1_Remap2(const Parameters& params)
        : CanPeripheral<Can1Remap2PinPackage,PERIPHERAL_CAN1>(params),
          Features(static_cast<Can&>(*this))...{

      initialisePeripheral();
      RecursiveVoidInit<Can1_Remap2,Features...>::tinit(this);
    }
  };
    
}

// END FILE: ../lib/include/can/f4/Can1.h
// START FILE: ../lib/include/can/f4/Can2.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


// ensure the MCU series is correct
#if !defined(STM32PLUS_F4)
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Default pin package:
   * (TX,RX) = (PB13,PB12)
   */

  struct Can2DefaultPinPackage {
    enum{
      Port_RX=GPIOB_BASE,
      Port_TX=GPIOB_BASE,

      Pin_RX=GPIO_Pin_12,
      Pin_TX=GPIO_Pin_13
    };
  };


  /**
   * The default, non-remapped pin package
   */

  template<class... Features>
  struct Can2 : CanPeripheral<Can2DefaultPinPackage,PERIPHERAL_CAN2>,
  	  	  	  	  Features... {
    /**
     * Constructor
     * @param params Initialisation parameters
     */

	  Can2(const Parameters& params)
	    : CanPeripheral<Can2DefaultPinPackage,PERIPHERAL_CAN2>(params),
	      Features(static_cast<Can&>(*this))... {

	    initialisePeripheral();
      RecursiveVoidInit<Can2,Features...>::tinit(this);
	  }
  };


  /**
   * Remap #1:
   * (TX,RX) = (PB6,PB5)
   */

  struct Can2RemapPinPackage {
  	enum{
      Port_RX=GPIOB_BASE,
      Port_TX=GPIOB_BASE,

      Pin_RX=GPIO_Pin_5,
      Pin_TX=GPIO_Pin_6
  	};
  };


  /**
   * The remapped version of CAN2
   */

  template<class... Features>
  struct Can2_Remap : CanPeripheral<Can2RemapPinPackage,PERIPHERAL_CAN2>,
  	  	  	  	  Features...{
    /**
     * Constructor
     * @param params Initialisation parameters
     */

	  Can2_Remap(const Parameters& params)
	      : CanPeripheral<Can2RemapPinPackage,PERIPHERAL_CAN2>(params),
	        Features(static_cast<Can&>(*this))...{

	    initialisePeripheral();
      RecursiveVoidInit<Can2_Remap,Features...>::tinit(this);
		}
  };
    
}

// END FILE: ../lib/include/can/f4/Can2.h
// START FILE: ../lib/include/can/f4/CanPinInitialiser.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


// ensure the MCU series is correct
#if !defined(STM32PLUS_F4)
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Convenience template to initialise a CAN pin package
   */

  template<class TPinPackage,PeripheralName>
  class CanPinInitialiser {
    public:
      static void initialise();
  };


  /**
   * Initialise the pin package that we were parameterised with
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline void CanPinInitialiser<TPinPackage,TPeripheralName>::initialise() {

    GpioPinInitialiser::initialise(
        (GPIO_TypeDef *)TPinPackage::Port_TX,
        TPinPackage::Pin_TX,
        Gpio::ALTERNATE_FUNCTION,
        (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
        Gpio::PUPD_NONE,
        Gpio::PUSH_PULL,
        GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_TX,TPinPackage::Pin_TX>::GPIO_AF);

    GpioPinInitialiser::initialise(
        (GPIO_TypeDef *)TPinPackage::Port_RX,
        TPinPackage::Pin_RX,
				Gpio::ALTERNATE_FUNCTION,
				(GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
				Gpio::PUPD_UP,
				GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_RX,TPinPackage::Pin_RX>::GPIO_AF);
	}
}
// END FILE: ../lib/include/can/f4/CanPinInitialiser.h
// START FILE: ../lib/include/can/CanPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Can peripheral base template. The specific instances of the CAN peripheral
   * inherit from this
   */

    template<class TPinPackage, PeripheralName TPeripheralName>
    class CanPeripheral : public Can {

      public:

        struct Parameters {

        uint16_t can_Prescaler;   /*!< Specifies the length of a time quantum.
                                         It ranges from 1 to 1024. */
        uint8_t can_Mode;         /*!< Specifies the CAN operating mode.
                                         This parameter can be a value of
                                        @ref CAN_operating_mode */
        uint8_t can_SJW;          /*!< Specifies the maximum number of time quanta
                                         the CAN hardware is allowed to lengthen or
                                         shorten a bit to perform resynchronization.
                                         This parameter can be a value of
                                         @ref CAN_synchronisation_jump_width */
        uint8_t can_BS1;          /*!< Specifies the number of time quanta in Bit
                                         Segment 1. This parameter can be a value of
                                         @ref CAN_time_quantum_in_bit_segment_1 */
        uint8_t can_BS2;          /*!< Specifies the number of time quanta in Bit
                                         Segment 2.
                                         This parameter can be a value of
                                         @ref CAN_time_quantum_in_bit_segment_2 */
        FunctionalState can_TTCM; /*!< Enable or disable the time triggered
                                         communication mode. This parameter can be set
                                         either to ENABLE or DISABLE. */

        FunctionalState can_ABOM;  /*!< Enable or disable the automatic bus-off
                                          management. This parameter can be set either
                                          to ENABLE or DISABLE. */

        FunctionalState can_AWUM;  /*!< Enable or disable the automatic wake-up mode.
                                          This parameter can be set either to ENABLE or
                                          DISABLE. */

        FunctionalState can_NART;  /*!< Enable or disable the no-automatic
                                          retransmission mode. This parameter can be
                                          set either to ENABLE or DISABLE. */

        FunctionalState can_RFLM;  /*!< Enable or disable the Receive FIFO Locked mode.
                                          This parameter can be set either to ENABLE
                                          or DISABLE. */

        FunctionalState can_TXFP;  /*!< Enable or disable the transmit FIFO priority.
                                          This parameter can be set either to ENABLE
                                                or DISABLE. */

        Parameters(uint32_t baudrate=100000,uint32_t samplepoint=500) {

          uint32_t T1;
          uint32_t T2;

          uint32_t Tsum;
          RCC_ClocksTypeDef Clocks;
          RCC_GetClocksFreq(&Clocks);

          if( Clocks.PCLK1_Frequency%baudrate != 0 ){
        	//Configuration failed
        	return;
          }

          Tsum = Clocks.PCLK1_Frequency/baudrate;

          while( Tsum > 20 ){
            if( Tsum % 11 == 0 ) Tsum/=11;
            else if( Tsum % 7 == 0 ) Tsum/=7;
            else if( Tsum % 5 == 0 ) Tsum/=5;
            else if( Tsum % 3 == 0 ) Tsum/=3;
            else if( Tsum % 2 == 0 ) Tsum/=2;
            else{
              if( Tsum == 23 ) break;
              //Configuration failed
              return;
            }
          }

          Tsum -= 1;

          T1 = (uint32_t)(Tsum*samplepoint+499)/1000;
          T2 = Tsum - T1;

          if( T1 == 0 ){
            T1 += 1;
            T2 -= 1;
          }
          else if( T2 == 0 ){
            T1 -= 1;
            T2 += 1;
          }

          if( T1 > 16){
            T1 = 16;
            T2 = Tsum-16;
          }
          else if( T2 > 8){
            T2 = 8;
            T1 = Tsum-8;
          }

          Tsum=T1+T2+1;
          can_Prescaler=Clocks.PCLK1_Frequency/(baudrate*Tsum);
          can_BS1=T1-1;
          can_BS2=T2-1;
          can_Mode = CAN_Mode_Normal;
          can_SJW = CAN_SJW_1tq;
          can_TTCM = DISABLE;
          can_ABOM = DISABLE;
          can_AWUM = ENABLE;
          can_NART = DISABLE;
          can_RFLM = DISABLE;
          can_TXFP = ENABLE;
        }
      };

      CanPeripheral(const Parameters& params);
      ~CanPeripheral();

      protected:
        void initialisePeripheral();
    };


    /**
     * Constructor
     * @param params
     */

    template<class TPinPackage, PeripheralName TPeripheralName>
    inline CanPeripheral<TPinPackage,TPeripheralName>::CanPeripheral(const Parameters& params)
        : Can((CAN_TypeDef * )PeripheralTraits<TPeripheralName>::PERIPHERAL_BASE) {

      // clocks on first before any features get initialised

      ClockControl<TPeripheralName>::On();
      CanPinInitialiser<TPinPackage,TPeripheralName>::initialise();

      // initialise the peripheral

      _init.CAN_ABOM=params.can_ABOM;
      _init.CAN_AWUM=params.can_AWUM;
      _init.CAN_BS1=params.can_BS1;
      _init.CAN_BS2=params.can_BS2;
      _init.CAN_Mode=params.can_Mode;
      _init.CAN_NART=params.can_NART;
      _init.CAN_Prescaler=params.can_Prescaler;
      _init.CAN_RFLM=params.can_RFLM;
      _init.CAN_SJW=params.can_SJW;
      _init.CAN_TTCM=params.can_TTCM;
      _init.CAN_TXFP=params.can_TXFP;
    }


    /**
   * Destructor, disable clocks
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline CanPeripheral<TPinPackage,TPeripheralName>::~CanPeripheral(){

    // clocks off

    ClockControl<TPeripheralName>::Off();
  }


  /*
   * Initialise the peripheral
   */

  template<class TPinPackage, PeripheralName TPeripheralName>
    inline void CanPeripheral<TPinPackage,TPeripheralName>::initialisePeripheral() {

    // initialise

    CAN_Init((CAN_TypeDef *)PeripheralTraits<TPeripheralName>::PERIPHERAL_BASE,&_init);
  }
}
// END FILE: ../lib/include/can/CanPeripheral.h
// START FILE: ../lib/include/can/CanEventSource.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * CAN event types
   */

  enum class CanEventType : uint8_t {
    EVENT_SLEEP,
    EVENT_WAKEUP,
    EVENT_ERROR,
    EVENT_LAST_ERROR_CODE,
    EVENT_BUS_OFF,
    EVENT_ERROR_PASSIVE,
    EVENT_ERROR_WARNING,
    EVENT_FIFO1_OVR,
    EVENT_FIFO1_FULL,
    EVENT_FIFO1_MESSAGE_PENDING,
    EVENT_FIFO0_OVR,
    EVENT_FIFO0_FULL,
    EVENT_FIFO0_MESSAGE_PENDING,
    EVENT_TRANSMIT_MAILBOX_EMPTY
  };


  /**
   * The signature for CAN events: void myHandler(CanEventType cet,uint8_t canNumber);
   */

  DECLARE_EVENT_SIGNATURE(CanInterrupt,void(CanEventType));


  /**
   * Base structure that holds just the event subscriber/publisher for the ADC
   */

  struct CanEventSource {
    DECLARE_EVENT_SOURCE(CanInterrupt);
  };
}
// END FILE: ../lib/include/can/CanEventSource.h
// START FILE: ../lib/include/can/CanFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for CAN features
   */

  class CanFeatureBase {

    protected:
			Can& _can;

		public:
			CanFeatureBase(Can& can);
			operator Can&();
	};


  /**
   * Constructor
   * @param can reference to the CAN peripheral
   */

	inline CanFeatureBase::CanFeatureBase(Can& can)
		: _can(can){
	}


	/**
	 * operator to return the CAN peripheral reference
	 */

	inline CanFeatureBase::operator stm32plus::Can &() {
	  return _can;
	}
}
// END FILE: ../lib/include/can/CanFeatureBase.h
// START FILE: ../lib/include/can/features/f4/Can1InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#if !defined(STM32PLUS_F4)
#error This class can only be used with the STM32F4 series
#endif


/*
 * Forward declare the IRQ handler names
 */

extern "C" void CAN1_TX_IRQHandler();  /*!< USB Device High Priority or CAN1 TX Interrupts       */
extern "C" void CAN1_RX0_IRQHandler(); /*!< USB Device Low Priority or CAN1 RX0 Interrupts       */
extern "C" void CAN1_RX1_IRQHandler();        /*!< CAN1 RX1 Interrupt                                   */
extern "C" void CAN1_SCE_IRQHandler();        /*!< CAN1 SCE Interrupt                                   */


namespace stm32plus {


  /**
   * CAN feature to handle interrupts. There's only one CAN on the F1 HD therefore
   * this is a concrete class
   */

  class Can1InterruptFeature : public CanEventSource,
                               public CanFeatureBase {
    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

    protected:
      uint16_t _interruptMask;
      uint8_t _nvicPriority;
      uint8_t _nvicSubPriority;

    public:
      static CanEventSource *_canInstance;

    public:
      Can1InterruptFeature(Can& can);
      ~Can1InterruptFeature();

      void setNvicPriorities(uint8_t priority,uint8_t subPriority=0);

      void enableInterrupts(uint16_t interruptMask);
      void disableInterrupts(uint16_t interruptMask);

      void clearPendingInterruptsFlag(uint16_t interruptMask) const;
      void initialise() {}
  };


  /**
   * Constructor
   */

  inline Can1InterruptFeature::Can1InterruptFeature(Can& can) :
      CanFeatureBase(can) {

    _interruptMask=0;
    _nvicPriority=_nvicSubPriority=0;
    _canInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  inline Can1InterruptFeature::~Can1InterruptFeature() {
    if(_interruptMask!=0)
      disableInterrupts(_interruptMask);
  }

  /**
   * Set the NVIC priority and subpriority numbers.  This function just remembers your
   * numbers. The actual setting of the priority happens in enableInterrupts()
   * @param priority
   * @param subPriority
   */

  inline void Can1InterruptFeature::setNvicPriorities(uint8_t priority,uint8_t subPriority) {
    _nvicPriority=priority;
    _nvicSubPriority=subPriority;
  }


  /**
   * Enable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. CAN_IT_TME / CAN_IT_FMP0 / CAN_IT_FF0
   */

  inline void Can1InterruptFeature::enableInterrupts(uint16_t interruptMask) {

    _interruptMask|=interruptMask;
    _forceLinkage=&CAN1_TX_IRQHandler;

    Nvic::configureIrq(CAN1_TX_IRQn,ENABLE,_nvicPriority,_nvicSubPriority);
    Nvic::configureIrq(CAN1_RX0_IRQn,ENABLE,_nvicPriority,_nvicSubPriority);
    Nvic::configureIrq(CAN1_RX1_IRQn,ENABLE,_nvicPriority,_nvicSubPriority);
    Nvic::configureIrq(CAN1_SCE_IRQn,ENABLE,_nvicPriority,_nvicSubPriority);

    CAN_ITConfig(_can,interruptMask,ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. I2C_IT_TXE / I2C_IT_RXNE
   */

  inline void Can1InterruptFeature::disableInterrupts(uint16_t interruptMask) {
    _interruptMask&=~interruptMask;
    CAN_ITConfig(_can,interruptMask,DISABLE);
  }


  /**
   * Clear the pending bit(s) for interrupt
   * @param interruptMask The bitmask of interrupts, e.g. I2C_IT_TXE / I2C_IT_RXNE
   */

  inline void Can1InterruptFeature::clearPendingInterruptsFlag(uint16_t interruptMask) const {
    CAN_ClearITPendingBit(_can,interruptMask);
  }
}
// END FILE: ../lib/include/can/features/f4/Can1InterruptFeature.h
// START FILE: ../lib/include/can/features/f4/Can2InterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#if !defined(STM32PLUS_F4)
#error This class can only be used with the STM32F4 series
#endif


/*
 * Forward declare the IRQ handler names
 */

extern "C" void CAN2_TX_IRQHandler();  /*!< USB Device High Priority or CAN2 TX Interrupts       */
extern "C" void CAN2_RX0_IRQHandler(); /*!< USB Device Low Priority or CAN2 RX0 Interrupts       */
extern "C" void CAN2_RX1_IRQHandler();        /*!< CAN2 RX1 Interrupt                                   */
extern "C" void CAN2_SCE_IRQHandler();        /*!< CAN2 SCE Interrupt                                   */


namespace stm32plus {


  /**
   * CAN feature to handle interrupts. There's only one CAN on the F1 HD therefore
   * this is a concrete class
   */

  class Can2InterruptFeature : public CanEventSource,
                               public CanFeatureBase {
    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

    protected:
      uint16_t _interruptMask;
      uint8_t _nvicPriority;
      uint8_t _nvicSubPriority;

    public:
      static CanEventSource *_canInstance;

    public:
      Can2InterruptFeature(Can& can);
      ~Can2InterruptFeature();

      void setNvicPriorities(uint8_t priority,uint8_t subPriority=0);

      void enableInterrupts(uint16_t interruptMask);
      void disableInterrupts(uint16_t interruptMask);

      void clearPendingInterruptsFlag(uint16_t interruptMask) const;
      void initialise() {}
  };


  /**
   * Constructor
   */

  inline Can2InterruptFeature::Can2InterruptFeature(Can& can) :
      CanFeatureBase(can) {

    _interruptMask=0;
    _nvicPriority=_nvicSubPriority=0;
    _canInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  inline Can2InterruptFeature::~Can2InterruptFeature() {
    if(_interruptMask!=0)
      disableInterrupts(_interruptMask);
  }

  /**
   * Set the NVIC priority and subpriority numbers.  This function just remembers your
   * numbers. The actual setting of the priority happens in enableInterrupts()
   * @param priority
   * @param subPriority
   */

  inline void Can2InterruptFeature::setNvicPriorities(uint8_t priority,uint8_t subPriority) {
    _nvicPriority=priority;
    _nvicSubPriority=subPriority;
  }


  /**
   * Enable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. CAN_IT_TME / CAN_IT_FMP0 / CAN_IT_FF0
   */

  inline void Can2InterruptFeature::enableInterrupts(uint16_t interruptMask) {

    _interruptMask|=interruptMask;
    _forceLinkage=&CAN2_TX_IRQHandler;

    Nvic::configureIrq(CAN2_TX_IRQn,ENABLE,_nvicPriority,_nvicSubPriority);
    Nvic::configureIrq(CAN2_RX0_IRQn,ENABLE,_nvicPriority,_nvicSubPriority);
    Nvic::configureIrq(CAN2_RX1_IRQn,ENABLE,_nvicPriority,_nvicSubPriority);
    Nvic::configureIrq(CAN2_SCE_IRQn,ENABLE,_nvicPriority,_nvicSubPriority);

    CAN_ITConfig(_can,interruptMask,ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. I2C_IT_TXE / I2C_IT_RXNE
   */

  inline void Can2InterruptFeature::disableInterrupts(uint16_t interruptMask) {
    _interruptMask&=~interruptMask;
    CAN_ITConfig(_can,interruptMask,DISABLE);
  }


  /**
   * Clear the pending bit(s) for interrupt
   * @param interruptMask The bitmask of interrupts, e.g. I2C_IT_TXE / I2C_IT_RXNE
   */

  inline void Can2InterruptFeature::clearPendingInterruptsFlag(uint16_t interruptMask) const {
    CAN_ClearITPendingBit(_can,interruptMask);
  }
}
// END FILE: ../lib/include/can/features/f4/Can2InterruptFeature.h
// START FILE: ../lib/include/can/features/Can1FilterBypassFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class for bypass CAN filter
   */

  struct Can1FilterBypassFeature : public CanFeatureBase {

	  /**
	   * Constructor
	   * @param can reference to the can peripheral
	   */

	  Can1FilterBypassFeature(Can& can)
	    : CanFeatureBase(can) {
	  }


	  /**
	   * Post CAN_Init() initialisation
	   */

	  void initialise() {

      CAN_FilterInitTypeDef CANFilterInitStruct;

      CANFilterInitStruct.CAN_FilterNumber=0;
      CANFilterInitStruct.CAN_FilterMode=CAN_FilterMode_IdMask;
      CANFilterInitStruct.CAN_FilterScale=CAN_FilterScale_32bit;
      CANFilterInitStruct.CAN_FilterIdHigh=0x0000;
      CANFilterInitStruct.CAN_FilterIdLow=0x0000;
      CANFilterInitStruct.CAN_FilterMaskIdHigh=0x0000;
      CANFilterInitStruct.CAN_FilterMaskIdLow=0x0000;
      CANFilterInitStruct.CAN_FilterFIFOAssignment=0;
      CANFilterInitStruct.CAN_FilterActivation=ENABLE;

      CAN_FilterInit(&CANFilterInitStruct);
	  }
  };
}
// END FILE: ../lib/include/can/features/Can1FilterBypassFeature.h
// START FILE: ../lib/include/can/features/CanLoopbackModeFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Feature class to enable silent mode
   */

  struct CanLoopbackModeFeature : CanFeatureBase {

	  /**
	   * Constructor
	   * @param can reference to the CAN peripheral
	   */

    CanLoopbackModeFeature(Can& can)
	    : CanFeatureBase(can) {
	    ((CAN_InitTypeDef *)can)->CAN_Mode|=CAN_Mode_LoopBack;
	  }


	  /**
	   * Post CAN_Init() initialisation
	   */

	  void initialise() {
	  }
  };
}
// END FILE: ../lib/include/can/features/CanLoopbackModeFeature.h
// START FILE: ../lib/include/can/features/Can2FilterBypassFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class for bypass CAN filter
   */

  struct Can2FilterBypassFeature : public CanFeatureBase {

	  /**
	   * Constructor
	   * @param can reference to the can peripheral
	   */

	  Can2FilterBypassFeature(Can& can)
	    : CanFeatureBase(can) {
	  }


	  /**
	   * Post CAN_Init() initialisation
	   */

	  void initialise() {

      CAN_FilterInitTypeDef CANFilterInitStruct;

      CANFilterInitStruct.CAN_FilterNumber=14;
      CANFilterInitStruct.CAN_FilterMode=CAN_FilterMode_IdMask;
      CANFilterInitStruct.CAN_FilterScale=CAN_FilterScale_32bit;
      CANFilterInitStruct.CAN_FilterIdHigh=0x0000;
      CANFilterInitStruct.CAN_FilterIdLow=0x0000;
      CANFilterInitStruct.CAN_FilterMaskIdHigh=0x0000;
      CANFilterInitStruct.CAN_FilterMaskIdLow=0x0000;
      CANFilterInitStruct.CAN_FilterFIFOAssignment=0;
      CANFilterInitStruct.CAN_FilterActivation=ENABLE;

      CAN_FilterInit(&CANFilterInitStruct);
	  }
  };
}
// END FILE: ../lib/include/can/features/Can2FilterBypassFeature.h
// START FILE: ../lib/include/can/features/CanSilentModeFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Feature class to enable silent mode
   */

  struct CanSilentModeFeature : CanFeatureBase {

    /**
	   * Constructor
	   * @param can reference to the CAN peripheral
	   */

    CanSilentModeFeature(Can& can)
	    : CanFeatureBase(can) {
      ((CAN_InitTypeDef *)can)->CAN_Mode |= CAN_Mode_Silent;
	  }


    /**
	   * Post CAN_Init() initialisation
	   */

	  void initialise() {
	  }
  };
}
// END FILE: ../lib/include/can/features/CanSilentModeFeature.h
// START FILE: ../lib/include/spi/f4/Spi3.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct Spi3_Custom : SpiPeripheral<TPinPackage,PERIPHERAL_SPI3>,
                       Features... {

    Spi3_Custom(const typename SpiPeripheral<TPinPackage,PERIPHERAL_SPI3>::Parameters& params)
      : SpiPeripheral<TPinPackage,PERIPHERAL_SPI3>(params),
        Features(static_cast<Spi&>(*this))... {
    }
  };


  /*
   * Default pin package:
   */

  struct Spi3DefaultPinPackage {
    enum {
      Port_NSS =GPIOA_BASE,
      Port_SCK =GPIOB_BASE,
      Port_MISO=GPIOB_BASE,
      Port_MOSI=GPIOB_BASE,

      Pin_NSS  = GPIO_Pin_15,
      Pin_SCK  = GPIO_Pin_3,
      Pin_MISO = GPIO_Pin_4,
      Pin_MOSI = GPIO_Pin_5
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Spi3 : SpiPeripheral<Spi3DefaultPinPackage,PERIPHERAL_SPI3>,
                Features... {

    Spi3(const Parameters& params)
      : SpiPeripheral<Spi3DefaultPinPackage,PERIPHERAL_SPI3>(params),
        Features(static_cast<Spi&>(*this))... {
    }
  };


  /**
   * NSS is on PA[15]. The others move to PB
   */

  struct Spi3Remap1PinPackage {
    enum {
      Port_NSS=GPIOA_BASE,
      Port_SCK=GPIOC_BASE,
      Port_MISO=GPIOC_BASE,
      Port_MOSI=GPIOC_BASE,

      Pin_NSS  = GPIO_Pin_4,
      Pin_SCK  = GPIO_Pin_10,
      Pin_MISO = GPIO_Pin_11,
      Pin_MOSI = GPIO_Pin_12
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Spi3_Remap1 : SpiPeripheral<Spi3Remap1PinPackage,PERIPHERAL_SPI3>,
                       Features... {

    Spi3_Remap1(const Parameters& params)
      : SpiPeripheral<Spi3Remap1PinPackage,PERIPHERAL_SPI3>(params),
        Features(static_cast<Spi&>(*this))... {
    }
  };
}

// END FILE: ../lib/include/spi/f4/Spi3.h
// START FILE: ../lib/include/spi/f4/SpiPinInitialiser.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Convenience template to initialise an SPI pin package
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  class SpiPinInitialiser {
    public:
      static void initialise(uint16_t mode,uint16_t direction);
  };


  /**
   * Initialise the pin package that we were parameterised with
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline void SpiPinInitialiser<TPinPackage,TPeripheralName>::initialise(uint16_t mode,uint16_t direction) {

    GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_SCK,
                                   TPinPackage::Pin_SCK,
                                   Gpio::ALTERNATE_FUNCTION,
                                   (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                   Gpio::PUPD_DOWN,
                                   Gpio::PUSH_PULL,
                                   GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_SCK,TPinPackage::Pin_SCK>::GPIO_AF);

    // in uni-directional mode slave MOSI is free

    if(mode==SPI_Mode_Master || direction==SPI_Direction_2Lines_FullDuplex)
      GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_MOSI,
                                     TPinPackage::Pin_MOSI,
                                     Gpio::ALTERNATE_FUNCTION,
                                     (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                     Gpio::PUPD_DOWN,
                                     Gpio::PUSH_PULL,
                                     GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_MOSI,TPinPackage::Pin_MOSI>::GPIO_AF);

    // in uni-directional mode master MISO is free

    if(mode==SPI_Mode_Slave || direction==SPI_Direction_2Lines_FullDuplex)
      GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_MISO,
                                     TPinPackage::Pin_MISO,
                                     Gpio::ALTERNATE_FUNCTION,
                                     (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                     Gpio::PUPD_DOWN,
                                     Gpio::PUSH_PULL,
                                     GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_MISO,TPinPackage::Pin_MISO>::GPIO_AF);

    if(mode==SPI_Mode_Master) {

      GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_NSS,
                                     TPinPackage::Pin_NSS,
                                     Gpio::OUTPUT,
                                     (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                     Gpio::PUPD_NONE,
                                     Gpio::PUSH_PULL);
    }
    else {

      GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_NSS,
                                     TPinPackage::Pin_NSS,
                                     Gpio::INPUT,
                                     (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                     Gpio::PUPD_NONE,
                                     Gpio::PUSH_PULL);
    }
  }
}
// END FILE: ../lib/include/spi/f4/SpiPinInitialiser.h
// START FILE: ../lib/include/spi/f4/SpiDeviceIo.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /*
   * Methods for sending and receiving 8 and 16-bit data. These are the same on the F4
   */

  struct SpiDeviceIo {

    /*
     * Senders
     */

    void sendData8(SPI_TypeDef *peripheralAddress,uint8_t data) const {
      SPI_I2S_SendData(peripheralAddress,data);
    }

    void sendData16(SPI_TypeDef *peripheralAddress,uint16_t data) const {
      SPI_I2S_SendData(peripheralAddress,data);
    }

    /*
     * Receivers
     */

    uint8_t receiveData8(SPI_TypeDef *peripheralAddress) const {
      return SPI_I2S_ReceiveData(peripheralAddress);
    }

    uint16_t receiveData16(SPI_TypeDef *peripheralAddress) const {
      return SPI_I2S_ReceiveData(peripheralAddress);
    }
  };
}
// END FILE: ../lib/include/spi/f4/SpiDeviceIo.h
// START FILE: ../lib/include/spi/f4/SpiPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * SPI peripheral base class
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  class SpiPeripheral : public Spi {

    public:

      /**
       * Parameters class
       */

      struct Parameters {
        uint16_t spi_direction;             ///< (SPI_Direction_2Lines_FullDuplex) / SPI_Direction_2Lines_RxOnly / SPI_Direction_1Line_Rx / SPI_Direction_1Line_Tx
        uint16_t spi_mode;                  ///< (SPI_Mode_Master) / SPI_Mode_Slave
        uint16_t spi_baudRatePrescaler;     ///< SPI_BaudRatePrescaler_2 / 4 / 8 / (16) / 32 / 64 / 128 / 256
        uint16_t spi_firstBit;              ///< (SPI_FirstBit_MSB) / SPI_FirstBit_LSB
        uint16_t spi_cpol;                  ///< (SPI_CPOL_High) SPI_CPOL_Low
        uint16_t spi_cpha;                  ///< (SPI_CPHA_2Edge) / SPI_CPHA_1Edge
        uint16_t spi_polynomial;            ///< default is 7
        uint16_t spi_dataSize;              ///< (SPI_DataSize_8b) / SPI_DataSize_16b (more available on the F0)

        /**
         * Constructor, set suitable defaults for master mode. Generally you'll want to set at
         * least spi_baudRatePrescaler to a suitable speed and check that the other defaults are OK.
         */

        Parameters() {
          spi_dataSize=SPI_DataSize_8b;
          spi_direction=SPI_Direction_2Lines_FullDuplex;
          spi_mode=SPI_Mode_Master;
          spi_baudRatePrescaler=SPI_BaudRatePrescaler_16;
          spi_firstBit=SPI_FirstBit_MSB;
          spi_cpol=SPI_CPOL_High;
          spi_cpha=SPI_CPHA_2Edge;
          spi_polynomial=7;
        }
      };

    protected:
      SpiPeripheral(const Parameters& params);
      ~SpiPeripheral();
  };


  /**
   * Constructor
   * @param params The initialisation parameters
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline SpiPeripheral<TPinPackage,TPeripheralName>::SpiPeripheral(const Parameters& params)
    : Spi((SPI_TypeDef *)PeripheralTraits<TPeripheralName>::PERIPHERAL_BASE,
          (GPIO_TypeDef *)TPinPackage::Port_NSS,
          TPinPackage::Pin_NSS,
          params.spi_direction) {

    SPI_InitTypeDef init;

    // clocks on first before any features get initialised

    ClockControl<TPeripheralName>::On();

    // and next the GPIO pins, also before any features get initialised

    SpiPinInitialiser<TPinPackage,TPeripheralName>::initialise(params.spi_mode,params.spi_direction);

    // initialise the peripheral

    SPI_StructInit(&init);

    init.SPI_Direction=params.spi_direction;
    init.SPI_Mode=params.spi_mode;
    init.SPI_DataSize=params.spi_dataSize;
    init.SPI_CPOL=params.spi_cpol;
    init.SPI_CPHA=params.spi_cpha;
    init.SPI_NSS=SPI_NSS_Soft;
    init.SPI_BaudRatePrescaler=params.spi_baudRatePrescaler;
    init.SPI_FirstBit=params.spi_firstBit;
    init.SPI_CRCPolynomial=params.spi_polynomial;

    SPI_Init(_peripheralAddress,&init);

    // NSS is soft, ensure it's high to begin with

    setNss(true);

    // enable SPI if we're doing 4-wire full duplex in 3-wire mode enable/disable is manual

    if(params.spi_direction==SPI_Direction_2Lines_FullDuplex)
      enablePeripheral();
  }


  /**
   * Destructor
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline SpiPeripheral<TPinPackage,TPeripheralName>::~SpiPeripheral() {

    // disable peripheral

    disablePeripheral();

    // clocks off

    ClockControl<TPeripheralName>::Off();
  }
}
// END FILE: ../lib/include/spi/f4/SpiPeripheral.h
// START FILE: ../lib/include/spi/f4/Spi1.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct Spi1_Custom : SpiPeripheral<TPinPackage,PERIPHERAL_SPI1>,
                       Features... {

    Spi1_Custom(const typename SpiPeripheral<TPinPackage,PERIPHERAL_SPI1>::Parameters& params)
      : SpiPeripheral<TPinPackage,PERIPHERAL_SPI1>(params),
        Features(static_cast<Spi&>(*this))... {
    }
  };


  /*
   * Default pin package:
   */

  struct Spi1DefaultPinPackage {
    enum {
      Port_NSS=GPIOA_BASE,
      Port_SCK=GPIOA_BASE,
      Port_MISO=GPIOA_BASE,
      Port_MOSI=GPIOA_BASE,

      Pin_NSS  = GPIO_Pin_4,
      Pin_SCK  = GPIO_Pin_5,
      Pin_MISO = GPIO_Pin_6,
      Pin_MOSI = GPIO_Pin_7
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Spi1 : SpiPeripheral<Spi1DefaultPinPackage,PERIPHERAL_SPI1>,
                Features... {

    Spi1(const Parameters& params)
      : SpiPeripheral<Spi1DefaultPinPackage,PERIPHERAL_SPI1>(params),
        Features(static_cast<Spi&>(*this))... {
    }
  };


  /**
   * NSS is on PA[15]. The others move to PB
   */

  struct Spi1Remap1PinPackage {
    enum {
      Port_NSS=GPIOA_BASE,
      Port_SCK=GPIOB_BASE,
      Port_MISO=GPIOB_BASE,
      Port_MOSI=GPIOB_BASE,

      Pin_NSS  = GPIO_Pin_15,
      Pin_SCK  = GPIO_Pin_3,
      Pin_MISO = GPIO_Pin_4,
      Pin_MOSI = GPIO_Pin_5
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Spi1_Remap1 : SpiPeripheral<Spi1Remap1PinPackage,PERIPHERAL_SPI1>,
                       Features... {

    Spi1_Remap1(const Parameters& params)
      : SpiPeripheral<Spi1Remap1PinPackage,PERIPHERAL_SPI1>(params),
        Features(static_cast<Spi&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/spi/f4/Spi1.h
// START FILE: ../lib/include/spi/f4/SpiAlternateFunctionMapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Specialisation of the AF mapper for this peripheral
   */

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_SPI1,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_SPI1
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_SPI2,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_SPI2
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_SPI3,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_SPI3
    };
  };
}
// END FILE: ../lib/include/spi/f4/SpiAlternateFunctionMapper.h
// START FILE: ../lib/include/spi/Spi2.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct Spi2_Custom : SpiPeripheral<TPinPackage,PERIPHERAL_SPI2>,
                       Features... {

    Spi2_Custom(const typename SpiPeripheral<TPinPackage,PERIPHERAL_SPI2>::Parameters& params)
      : SpiPeripheral<TPinPackage,PERIPHERAL_SPI2>(params),
        Features(static_cast<Spi&>(*this))... {
    }
  };


  /*
   * Default pin package:
   */

  struct Spi2DefaultPinPackage {
    enum {
      Port_NSS=GPIOB_BASE,
      Port_SCK=GPIOB_BASE,
      Port_MISO=GPIOB_BASE,
      Port_MOSI=GPIOB_BASE,

      Pin_NSS  = GPIO_Pin_12,
      Pin_SCK  = GPIO_Pin_13,
      Pin_MISO = GPIO_Pin_14,
      Pin_MOSI = GPIO_Pin_15
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Spi2 : SpiPeripheral<Spi2DefaultPinPackage,PERIPHERAL_SPI2>,
                Features... {

    Spi2(const Parameters& params)
      : SpiPeripheral<Spi2DefaultPinPackage,PERIPHERAL_SPI2>(params),
        Features(static_cast<Spi&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/spi/Spi2.h
// START FILE: ../lib/include/spi/Spi.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for all SPI peripherals. Supports synchronous sending and receiving of
   * data encoded into 8 or 16-bit values. The SPI peripheral on the F0 can be initialised
   * to send/receive bit streams that are no a multiple of 8.
   *
   * This class inherits from the very small device specifc IO class that handles the differences
   * in the ST peripheral library between devices.
   */

  class Spi : public SpiDeviceIo {

    protected:
      SPI_TypeDef *_peripheralAddress;
      GPIO_TypeDef *_nssPort;
      int _nssPin;
      uint16_t _direction;

    public:
      enum {
        E_SPI_ERROR = 1
      };

    protected:
      Spi(SPI_TypeDef *address,
          GPIO_TypeDef* nssPort,
          int nssPin,
          uint16_t direction);

    public:
      bool readyToReceive() const;

      bool receive(uint8_t& byte) const;
      bool receive(uint8_t *data,uint32_t numBytes);
      bool receive(uint16_t& halfWord) const;
      bool receive(uint16_t *data,uint32_t numHalfWords);

      bool readyToSend() const;
      bool send(uint8_t dataToSend) const;
      bool send(const uint8_t *dataToSend,uint32_t numBytes,uint8_t *dataReceived=nullptr) const;
      bool send(uint16_t dataToSend) const;
      bool send(const uint16_t *dataToSend,uint32_t numHalfWords,uint16_t *dataReceived=nullptr) const;

      void waitForIdle() const;
      void set1WireReadMode() const;
      void set1WireWriteMode() const;

      void setNss(bool value) const;
      operator SPI_TypeDef *() const;
      bool hasError() const;

      void enablePeripheral() const;
      void disablePeripheral() const;
  };


  /**
   * Constructor
   * @param[in] address The peripheral address, e.g. SPI1
   * @param[in] nssPort The chip select port
   * @param[in] nssPin The chip select pin - we control it manually
   */

  inline Spi::Spi(
      SPI_TypeDef *address,
      GPIO_TypeDef * nssPort,
      int nssPin,
      uint16_t direction)
        : _nssPort(nssPort) {

    _peripheralAddress=address;
    _nssPin=nssPin;
    _direction=direction;
  }


  /**
   * Enable the peripheral
   */

  inline void Spi::enablePeripheral() const {
    SPI_Cmd(_peripheralAddress,ENABLE);
  }


  /**
   * Disable the peripheral
   */

  inline void Spi::disablePeripheral() const {
    SPI_Cmd(_peripheralAddress,DISABLE);
  }


  /**
   * Cast this class to the SPI peripheral address.
   * @return The SPI peripheral address.
   */

  inline Spi::operator SPI_TypeDef *() const {
    return _peripheralAddress;
  }


  /**
   * Check if the device has an error status
   */

  inline bool Spi::hasError() const {

    FlagStatus status;

    if((status=SPI_I2S_GetFlagStatus(_peripheralAddress,SPI_FLAG_CRCERR | SPI_FLAG_MODF | SPI_I2S_FLAG_OVR))!=0)
      return !errorProvider.set(ErrorProvider::ERROR_PROVIDER_SPI,E_SPI_ERROR,status);

    return false;
  }


  /**
   * Set or reset the NSS (chip select) pin
   * @param value true = high, false = low
   */

  inline void Spi::setNss(bool value) const {
    if(value)
      GPIO_SetBits(_nssPort,_nssPin);
    else
      GPIO_ResetBits(_nssPort,_nssPin);
  }


  /**
   * Check if the peripheral is ready to receive
   * @return true if it's ready
   */

  inline bool Spi::readyToReceive() const {
    return !!SPI_I2S_GetFlagStatus(_peripheralAddress,SPI_I2S_FLAG_RXNE);
  }


  /**
   * Read a byte from the peripheral
   * @param byte[out] The byte read out
   */

  inline bool Spi::receive(uint8_t& byte) const {

    while(!readyToReceive())
      if(hasError())
        return false;

    byte=receiveData8(_peripheralAddress);
    return true;
  }


  /**
   * Read a half-word from the peripheral
   * @param hword[out] The half-word that was read out
   */

  inline bool Spi::receive(uint16_t& hword) const {

    // wait until ready to receive or there's an error

    while(!readyToReceive())
      if(hasError())
        return false;

    // read the word

    hword=receiveData16(_peripheralAddress);
    return true;
  }


  /**
   * This overload reads a number of bytes from the peripheral. It transmits dummy zero bytes to
   * cause the clock to tick and data to be received.
   * @param data The data buffer
   * @param numBytes The number of bytes to read
   * @return true if it worked
   */

  inline bool Spi::receive(uint8_t *data,uint32_t numBytes) {

    static const uint16_t zero=0;

    while(numBytes--) {

      // wait for ready to send

      while(!readyToSend())
        if(hasError())
          return false;

      // send the dummy byte, i.e. cause the SPI clock to tick

      sendData8(_peripheralAddress,zero);

      while(SPI_I2S_GetFlagStatus(_peripheralAddress,SPI_I2S_FLAG_RXNE)==RESET)
        if(hasError())
          return false;

      // read the byte to clear RXNE and save/discard

      *data++=receiveData8(_peripheralAddress);
    }

    return true;
  }


  /**
   * This overload reads a number of half-words from the peripheral. It transmits dummy zero bits to
   * cause the clock to tick and data to be received.
   * @param data The data buffer
   * @param numHalfWords The number of half-words to read
   * @return true if it worked
   */

  inline bool Spi::receive(uint16_t *data,uint32_t numHalfWords) {

    static const uint16_t zero=0;

    while(numHalfWords--) {

      // wait for ready to send

      while(!readyToSend())
        if(hasError())
          return false;

      // send the dummy byte, i.e. cause the SPI clock to tick

      sendData16(_peripheralAddress,zero);

      while(SPI_I2S_GetFlagStatus(_peripheralAddress,SPI_I2S_FLAG_RXNE)==RESET)
        if(hasError())
          return false;

      // read the byte to clear RXNE and save/discard

      *data++=receiveData16(_peripheralAddress);
    }

    return true;
  }


  /**
   * Check for TXE
   * @return true if ready to send
   */

  inline bool Spi::readyToSend() const {
    return !!SPI_I2S_GetFlagStatus(_peripheralAddress,SPI_I2S_FLAG_TXE);
  }


  /**
   * Send a single byte.
   * @param dataToSend The byte to send
   * @return true if it worked, false on error
   */

  inline bool Spi::send(uint8_t dataToSend) const {

    // wait for ready to send

    while(!readyToSend())
      if(hasError())
        return false;

    // send the byte

    sendData8(_peripheralAddress,dataToSend);
    return true;
  }


  /**
   * Send a block of bytes, blocking. Optionally receive data at the same time
   * @param dataToSend The buffer of bytes to send
   * @param numBytes The number of bytes to send
   * @param[out] dataReceived Where to store the data received. Set to nullptr if you're not receiving any data.
   */

  inline bool Spi::send(const uint8_t *dataToSend,uint32_t numBytes,uint8_t *dataReceived) const {

    while(numBytes--) {

      send(*dataToSend++);

      if(_direction==SPI_Direction_2Lines_FullDuplex) {

        // in duplex mode and we want data, wait for it to come

        while(SPI_I2S_GetFlagStatus(_peripheralAddress,SPI_I2S_FLAG_RXNE)==RESET)
          if(hasError())
            return false;

        // read the byte to clear RXNE and save

        if(dataReceived!=nullptr)
          *dataReceived++=receiveData8(_peripheralAddress);
        else
          receiveData8(_peripheralAddress);
      }
    }

    return true;
  }


  /**
   * Send a single half-word.
   * @param dataToSend The hald-word to send
   * @return true if it worked, false on error
   */

  inline bool Spi::send(uint16_t dataToSend) const {
      // wait for ready to send

      while(!readyToSend())
        if(hasError())
          return false;

      // send the half-word

      sendData16(_peripheralAddress,dataToSend);
      return true;
  }


  /**
   * Send a block of half-words, blocking. Optionally receive data at the same time
   * @param dataToSend The buffer of half-words to send
   * @param numHalfWords The number of half-words to send
   * @param[out] dataReceived Where to store the data received. Set to nullptr if you're not receiving any data.
   */

  inline bool Spi::send(const uint16_t *dataToSend,uint32_t numHalfWords,uint16_t *dataReceived) const {

    while(numHalfWords--) {

      send(*dataToSend++);

      if(_direction==SPI_Direction_2Lines_FullDuplex) {

        // in duplex mode and we want data, wait for it to come

        while(SPI_I2S_GetFlagStatus(_peripheralAddress,SPI_I2S_FLAG_RXNE)==RESET)
          if(hasError())
            return false;

        // read the byte to clear RXNE and save it

        if(dataReceived!=nullptr)
          *dataReceived++=receiveData16(_peripheralAddress);
        else
          receiveData16(_peripheralAddress);
      }
    }

    return true;
  }


  /**
   * Wait for the peripheral to become idle. If transmitting then the peripheral becomes
   * idle when the last word written to the TX register has been shifted out to the bus.
   */

  inline void Spi::waitForIdle() const {
    while(SPI_I2S_GetFlagStatus(_peripheralAddress,SPI_I2S_FLAG_BSY)==SET);
  }


  /**
   * Set read mode when in bi-directional 1-wire mode
   */

  inline void Spi::set1WireReadMode() const {
    SPI_BiDirectionalLineConfig(_peripheralAddress,SPI_Direction_Rx);
  }


  /**
   * Set write mode when in bi-directional 1-wire mode
   */

  inline void Spi::set1WireWriteMode() const {
    SPI_BiDirectionalLineConfig(_peripheralAddress,SPI_Direction_Tx);
  }
}
// END FILE: ../lib/include/spi/Spi.h
// START FILE: ../lib/include/spi/SpiPollingInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Implementation of an input stream for the SPI peripheral.
   * The stream methods can be used to read data from the SPI in polling mode.
   */

  class SpiPollingInputStream : public InputStream {

    protected:
      Spi& _spi;

    public:
      SpiPollingInputStream(Spi& usart);
      virtual ~SpiPollingInputStream() {}

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;

      /**
       * Doesn't do anything.
       * @return always true
       */

      virtual bool close() override {
        return true;
      }

      /**
       * Not supported.
       * @return always false and E_OPERATION_NOT_SUPPORTED
       */

      virtual bool reset() override {
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_SPI_INPUT_STREAM,E_OPERATION_NOT_SUPPORTED);
      }
  };
}
// END FILE: ../lib/include/spi/SpiPollingInputStream.h
// START FILE: ../lib/include/spi/features/SpiFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for SPI features
   */

  class SpiFeatureBase {
    protected:
      Spi& _spi;

    public:
      SpiFeatureBase(Spi& spi);
      operator Spi&();
  };


  /**
   * Constructor
   * @param spi
   */

  inline SpiFeatureBase::SpiFeatureBase(Spi& spi)
    : _spi(spi) {
  }


  /**
   * Cast to Spi reference
   */

  inline SpiFeatureBase::operator Spi&() {
    return _spi;
  }
}
// END FILE: ../lib/include/spi/features/SpiFeatureBase.h
// START FILE: ../lib/include/spi/features/SpiInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Forward declare the IRQ handler names
 */

extern "C" void SPI1_IRQHandler();
extern "C" void SPI2_IRQHandler();
extern "C" void SPI3_IRQHandler();


namespace stm32plus {

  /**
   * Helper class to enable only the desired interrupts in the NVIC. This will
   * be fully specialised for each Spi peripheral
   * @tparam TSpiNumber The number of the Spi peripheral (1..3)
   */

  template<uint8_t TSpiNumber>
  class SpiInterruptFeatureEnabler {

    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

    public:
      static void enable(uint8_t priority,uint8_t subPriority);
  };


  /**
   * SPI feature to handle interrupts.
   * @tparam TSpiNumber The number of the Spi peripheral (1..5)
   */

  template<uint8_t TSpiNumber>
  class SpiInterruptFeature : public SpiEventSource,
                              public SpiFeatureBase {

    protected:
      uint16_t _interruptMask;
      uint8_t _nvicPriority;
      uint8_t _nvicSubPriority;

    public:
      static SpiEventSource *_spiInstance;

    public:
      SpiInterruptFeature(Spi& spi);
      ~SpiInterruptFeature();

      void setNvicPriorities(uint8_t priority,uint8_t subPriority=0);

      void enableInterrupts(uint16_t interruptMask);
      void disableInterrupts(uint16_t interruptMask);

      void clearPendingInterruptsFlag(uint16_t interruptMask) const;
  };


  /**
   * Typedefs for easy use
   */

  typedef SpiInterruptFeature<1> Spi1InterruptFeature;
  typedef SpiInterruptFeature<2> Spi2InterruptFeature;
  typedef SpiInterruptFeature<3> Spi3InterruptFeature;


  /**
   * Template static data member initialisation
   */

  template<uint8_t TSpiNumber>
  SpiEventSource *SpiInterruptFeature<TSpiNumber> ::_spiInstance;


  /**
   * Constructor, initialises the interrupt mask for this class to zero.
   */

  template<uint8_t TSpiNumber>
  inline SpiInterruptFeature<TSpiNumber>::SpiInterruptFeature(Spi& spi)
    : SpiFeatureBase(spi) {
    _interruptMask=0;
    _nvicPriority=_nvicSubPriority=0;
    _spiInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  template<uint8_t TSpiNumber>
  inline SpiInterruptFeature<TSpiNumber>::~SpiInterruptFeature() {
    if(_interruptMask!=0)
      disableInterrupts(_interruptMask);
  }


  /**
   * Set the NVIC priority and subpriority numbers.  This function just remembers your
   * numbers. The actual setting of the priority happens in enableInterrupts()
   * @param priority
   * @param subPriority
   */

  template<uint8_t TSpiNumber>
  inline void SpiInterruptFeature<TSpiNumber>::setNvicPriorities(uint8_t priority,uint8_t subPriority) {
    _nvicPriority=priority;
    _nvicSubPriority=subPriority;
  }


  /**
   * Enable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. SPI_I2S_IT_TXE / SPI_I2S_IT_RXNE / SPI_I2S_IT_ERR
   */

  template<uint8_t TSpiNumber>
  inline void SpiInterruptFeature<TSpiNumber>::enableInterrupts(uint16_t interruptMask) {

    _interruptMask|=interruptMask;
    SpiInterruptFeatureEnabler<TSpiNumber>::enable(_nvicPriority,_nvicSubPriority);
    SPI_I2S_ITConfig(_spi,interruptMask,ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. SPI_I2S_IT_TXE / SPI_I2S_IT_RXNE / SPI_I2S_IT_ERR
   */

  template<uint8_t TSpiNumber>
  inline void SpiInterruptFeature<TSpiNumber>::disableInterrupts(uint16_t interruptMask) {
    _interruptMask&=~interruptMask;
    SPI_I2S_ITConfig(_spi,interruptMask,DISABLE);
  }


  /**
   * Clear the selected pending interrupt flags
   * @param interruptMask The bitmask of interrupts, e.g. SPI_I2S_IT_TXE / SPI_I2S_IT_RXNE / SPI_I2S_IT_ERR
   */

  template<uint8_t TSpiNumber>
  inline void SpiInterruptFeature<TSpiNumber>::clearPendingInterruptsFlag(uint16_t interruptMask) const {
    SPI_I2S_ClearITPendingBit(_spi,interruptMask);
  }


  /**
   * Enabler specialisation, Spi 1
   */

  template<>
  inline void SpiInterruptFeatureEnabler<1>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&SPI1_IRQHandler;
    Nvic::configureIrq(SPI1_IRQn,ENABLE,priority,subPriority);
  }

  /**
   * Enabler specialisation, Spi 2
   */

  template<>
  inline void SpiInterruptFeatureEnabler<2>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&SPI2_IRQHandler;
    Nvic::configureIrq(SPI2_IRQn,ENABLE,priority,subPriority);
  }

#if !(defined(STM32PLUS_F1_MD) || defined(STM32PLUS_F1_MD_VL) || defined(STM32PLUS_F0))

  /**
   * Enabler specialisation, Spi 3
   */

  template<>
  inline void SpiInterruptFeatureEnabler<3>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&SPI3_IRQHandler;
    Nvic::configureIrq(SPI3_IRQn,ENABLE,priority,subPriority);
  }
#endif

}
// END FILE: ../lib/include/spi/features/SpiInterruptFeature.h
// START FILE: ../lib/include/spi/SpiPollingOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Implementation of an output stream for the SPI peripheral.
   * Writing to this stream causes data to be transmitted over SPI.
   */

  class SpiPollingOutputStream : public OutputStream {

    protected:
      Spi& _spi;

    public:
      SpiPollingOutputStream(Spi& usart);
      virtual ~SpiPollingOutputStream() {}

      // overrides from OutputStream

      virtual bool write(uint8_t c) override;
      virtual bool write(const void *buffer,uint32_t size) override;

      /**
       * Always true.
       * @return always true
       */

      virtual bool flush() override {
        return true;
      }

      /**
       * Always true.
       * @return always true
       */

      virtual bool close() override {
        return true;
      }
  };
}
// END FILE: ../lib/include/spi/SpiPollingOutputStream.h
// START FILE: ../lib/include/spi/SpiEventSource.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * SPI event types
   */

  enum class SpiEventType : uint8_t {
    EVENT_RECEIVE,
    EVENT_READY_TO_TRANSMIT
  };


  /**
   * The signature for SPI events: void myHandler(SpiEventType set);
   */

  DECLARE_EVENT_SIGNATURE(SpiInterrupt,void(SpiEventType));


  /**
   * Base structure that holds just the event subscriber/publisher for SPI
   */

  struct SpiEventSource {
    DECLARE_EVENT_SOURCE(SpiInterrupt);
  };
}
// END FILE: ../lib/include/spi/SpiEventSource.h
// START FILE: ../lib/include/hash/f4/SHA1.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#if !defined(STM32PLUS_F4_HAS_CRYPTO)
#error Incorrect MCU - this file is for the F4 devices that have hardware crypto
#endif


namespace stm32plus {


  /**
   * SHA1 implementation for the F4 processor. Basic polling operation is supported here.
   * After construction, use it like this.
   *
   * 1. Call update() zero or more times to add 32-bits of data to the hash computation.
   * 2. Call finish() for the last 32 bits or less of data that you have and receive the digest.
   * 3. To use again, call reset() and go back to step (1).
   */

  class SHA1 {

    public:
      enum {
        E_TIMED_OUT = 1,          ///< The digest operation timed out
      };

    public:
      SHA1();
      ~SHA1();

      void reset() const;
      bool hash(const void *data,uint32_t dataSize,void *hash,uint32_t timeout=0) const;
  };


  /**
   * Constructor, start the peripheral clock
   */

  inline SHA1::SHA1() {

    // clock on

    ClockControl<PERIPHERAL_HASH>::On();

    // reset and init

    reset();
  }


  /**
   * Destructor, stop the peripheral clock
   */

  inline SHA1::~SHA1() {

    // de-init and clock off

    HASH_DeInit();
    ClockControl<PERIPHERAL_HASH>::Off();
  }


  /**
   * Reset the peripheral and get it ready for a new round of hashing
   */

  inline void SHA1::reset() const {

    HASH_InitTypeDef hinit;

    // close down the peripheral

    HASH_DeInit();

    // set it up

    hinit.HASH_AlgoSelection=HASH_AlgoSelection_SHA1;
    hinit.HASH_AlgoMode=HASH_AlgoMode_HASH;
    hinit.HASH_DataType=HASH_DataType_8b;

    HASH_Init(&hinit);
  }


  /**
   * Do the hashing, get the result. After this is called you will need to call 'reset' to use
   * this class for new hash computations.
   * @param data Pointer to the data to hash
   * @param byteSize How many bytes in the 'data' pointer.
   * @param hash A pointer to at least 20 bytes of memory to receive the hash
   * @param timeout How long to wait for the computation, 0 = forever. 0 is the default.
   * @return true if it worked, false if we timed out waiting
   */

  inline bool SHA1::hash(const void *data,uint32_t dataSize,void *hash,uint32_t timeout) const {

    uint32_t start,count;
    const uint32_t *ptr;
    HASH_MsgDigest digest;

    // tell the peripheral how much is valid in the last word

    HASH_SetLastWordValidBitsNbr((dataSize % 4)*8);

    // update the digest

    ptr=reinterpret_cast<const uint32_t *>(data);
    count=dataSize/4;
    if(dataSize % 4)
      count++;

    while(count--)
      HASH_DataIn(*ptr++);

    // start the digest process

    HASH_StartDigest();

    // wait for BUSY to go low

    if(timeout)
      start=MillisecondTimer::millis();

    while(HASH_GetFlagStatus(HASH_FLAG_BUSY)!=RESET) {
      if(timeout && MillisecondTimer::hasTimedOut(start,timeout))
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_HASH,E_TIMED_OUT);
    }

    // Read the message digest

    HASH_GetDigest(&digest);
    memcpy(hash,digest.Data,20);

    return true;
  }
}
// END FILE: ../lib/include/hash/f4/SHA1.h
// START FILE: ../lib/include/hash/software/SHA1.h
/*
 Copyright (c) 2011, Micael Hildenborg
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 * Neither the name of Micael Hildenborg nor the
 names of its contributors may be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY Micael Hildenborg ''AS IS'' AND ANY
 EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL Micael Hildenborg BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 Contributors:
 Gustav
 Several members in the gamedev.se forum.
 Gregory Petrosyan
 ...and lastly Andy Brown for adapting it to the stm32plus framework for devices
 that don't have this in hardware
 */

#pragma once

#if defined(STM32PLUS_F4) && defined(STM32PLUS_F4_HARDWARE_CRYPTO)
#error Incorrect MCU - this file is for the F1 or the F4 without hardware crypto
#endif

namespace stm32plus {


  /**
   * Adaptation of the SHA1 algorithm credited in the comment above.
   */

  class SHA1 {

    protected:

      /*
       * Rotate an integer value to left.
       */

      uint32_t rol(const uint32_t value,const uint32_t steps) {
        return ((value << steps) | (value >> (32 - steps)));
      }


      /*
       * Sets the first 16 integers in the buffert to zero.
       * Used for clearing the W buffert.
       */

      void clearWBuffert(uint32_t* buffert) {
        for(int pos=16;--pos >= 0;) {
          buffert[pos]=0;
        }
      }

      void innerHash(uint32_t* result,uint32_t* w) {

        uint32_t a=result[0];
        uint32_t b=result[1];
        uint32_t c=result[2];
        uint32_t d=result[3];
        uint32_t e=result[4];

        int round=0;

  #define sha1macro(func,val) \
        { \
          const uint32_t t = rol(a, 5) + (func) + e + val + w[round]; \
          e = d; \
          d = c; \
          c = rol(b, 30); \
          b = a; \
          a = t; \
        }

        while(round < 16) {
          sha1macro((b & c) | (~b & d),0x5a827999)
          ++round;
        }
        while(round < 20) {
          w[round]=rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]),1);
          sha1macro((b & c) | (~b & d),0x5a827999)
          ++round;
        }
        while(round < 40) {
          w[round]=rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]),1);
          sha1macro(b ^ c ^ d,0x6ed9eba1)
          ++round;
        }
        while(round < 60) {
          w[round]=rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]),1);
          sha1macro((b & c) | (b & d) | (c & d),0x8f1bbcdc)
          ++round;
        }
        while(round < 80) {
          w[round]=rol((w[round - 3] ^ w[round - 8] ^ w[round - 14] ^ w[round - 16]),1);
          sha1macro(b ^ c ^ d,0xca62c1d6)
          ++round;
        }

  #undef sha1macro

        result[0]+=a;
        result[1]+=b;
        result[2]+=c;
        result[3]+=d;
        result[4]+=e;
      }

    public:

      void hash(const void* src,const int bytelength,uint8_t* hash) {

        // Init the result array.
        uint32_t result[5]= { 0x67452301,0xefcdab89,0x98badcfe,0x10325476,0xc3d2e1f0 };

        // Cast the void src pointer to be the byte array we can work with.
        const uint8_t* sarray=(const uint8_t*)src;

        // The reusable round buffer
        uint32_t w[80];

        // Loop through all complete 64byte blocks.
        const int endOfFullBlocks=bytelength - 64;
        int endCurrentBlock;
        int currentBlock=0;

        while(currentBlock <= endOfFullBlocks) {
          endCurrentBlock=currentBlock + 64;

          // Init the round buffer with the 64 byte block data.
          for(int roundPos=0;currentBlock < endCurrentBlock;currentBlock+=4) {
            // This line will swap endian on big endian and keep endian on little endian.
            w[roundPos++]=(uint32_t)sarray[currentBlock + 3] | (((uint32_t)sarray[currentBlock + 2]) << 8) | (((uint32_t)sarray[currentBlock + 1]) << 16) | (((uint32_t)sarray[currentBlock]) << 24);
          }
          innerHash(result,w);
        }

        // Handle the last and not full 64 byte block if existing.
        endCurrentBlock=bytelength - currentBlock;
        clearWBuffert(w);
        int lastBlockBytes=0;
        for(;lastBlockBytes < endCurrentBlock;++lastBlockBytes) {
          w[lastBlockBytes >> 2]|=(uint32_t)sarray[lastBlockBytes + currentBlock] << ((3 - (lastBlockBytes & 3)) << 3);
        }
        w[lastBlockBytes >> 2]|=0x80 << ((3 - (lastBlockBytes & 3)) << 3);
        if(endCurrentBlock >= 56) {
          innerHash(result,w);
          clearWBuffert(w);
        }
        w[15]=bytelength << 3;
        innerHash(result,w);

        // Store hash in result pointer, and make sure we get in in the correct order on both endian models.
        for(int hashByte=20;--hashByte >= 0;) {
          hash[hashByte]=(result[hashByte >> 2] >> (((3 - hashByte) & 0x3) << 3)) & 0xff;
        }
      }
  };
}

// END FILE: ../lib/include/hash/software/SHA1.h
// START FILE: ../lib/include/hash/HashPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Peripheral class for the hash processor. Needs to be parameterised with
   * the implementation of the hash function and an optional list of additional
   * features that you'd like to have baked in.
   *
   * For simplistic synchronous use there are typedefs such as SHA1HashPeripheral<>
   * that will get you a type that does SHA1 synchronously with no DMA and no
   * interrupts
   */

  template<class THashImpl,class... Features>
  struct HashPeripheral : THashImpl,Features... {
  };


  /**
   * Typedefs for the peripheral operating the available hash algorithms. Got to
   * love the C++0x 'template using' feature.
   */

  template<class... Features> using SHA1HashPeripheral=HashPeripheral<SHA1,Features...>;
}
// END FILE: ../lib/include/hash/HashPeripheral.h
// START FILE: ../lib/include/gpio/f4/GpioPort.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Template access to a set of functions that map the GPIO address to the clock
   */

  namespace gpioHelper {

    template<uint32_t> uint32_t getPeripheral();          ///< generic template - never used
    template<> inline uint32_t getPeripheral<GPIOA_BASE>() { return RCC_AHB1Periph_GPIOA; }
    template<> inline uint32_t getPeripheral<GPIOB_BASE>() { return RCC_AHB1Periph_GPIOB; }
    template<> inline uint32_t getPeripheral<GPIOC_BASE>() { return RCC_AHB1Periph_GPIOC; }
    template<> inline uint32_t getPeripheral<GPIOD_BASE>() { return RCC_AHB1Periph_GPIOD; }
    template<> inline uint32_t getPeripheral<GPIOE_BASE>() { return RCC_AHB1Periph_GPIOE; }

    template<> inline uint32_t getPeripheral<GPIOH_BASE>() { return RCC_AHB1Periph_GPIOH; }

#if defined(STM32PLUS_F4_HAS_GPIOF_G_I)
    template<> inline uint32_t getPeripheral<GPIOF_BASE>() { return RCC_AHB1Periph_GPIOF; }
    template<> inline uint32_t getPeripheral<GPIOG_BASE>() { return RCC_AHB1Periph_GPIOG; }
    template<> inline uint32_t getPeripheral<GPIOI_BASE>() { return RCC_AHB1Periph_GPIOI; }
#endif

#if defined(STM32PLUS_F4_HAS_GPIOJ_K)
    template<> inline uint32_t getPeripheral<GPIOJ_BASE>() { return RCC_AHB1Periph_GPIOJ; }
    template<> inline uint32_t getPeripheral<GPIOK_BASE>() { return RCC_AHB1Periph_GPIOK; }
#endif
  }


  /**
   * Template for a GPIO implementation that manages a set of pins
   */

  template<uint32_t TPortAddress,class... Features>
  class GpioPort : public GpioPortBase,
                   public Features... {

    protected:

      /**
       * Init clock and return port address
       * @return the peripheral port address
       */

      GPIO_TypeDef *initClock() {
        RCC_AHB1PeriphClockCmd(gpioHelper::getPeripheral<TPortAddress>(),ENABLE);
        return (GPIO_TypeDef *)TPortAddress;
      }


    public:

      /**
       * Constructor
       * @param addr The peripheral address (GPIOA, GPIOB, ...)
       */

      GpioPort() :
        GpioPortBase(initClock()),
        Features((GpioPortBase&)*this)... {
      }


      /**
       * Array operator. Return a reference to the selected pin. It is not generally safe to store the
       * reference returned by this function between calls to this index operator because subsequent
       * calls can change the pin used by that reference.
       * @param selectedPin The pin to select
       * @return A reference to the pin that you can call operations such as set(), reset() on.
       */

      Gpio& operator[](uint8_t selectedPin) {
        _pinHandlers[selectedPin]->setSelectedPin(selectedPin);
        return *(_pinHandlers[selectedPin]);
      }


      /**
       * Set some pins directly
       * @param pinIds The pin bitmap in peripheral library format
       */

      void set(uint16_t pinIds) const {
        GPIO_SetBits((GPIO_TypeDef *)TPortAddress,pinIds);
      }


      /**
       * Reset some pins directly
       * @param pinIds The pin bitmap in peripheral library format
       */

      void reset(uint16_t pinIds) const {
        GPIO_ResetBits((GPIO_TypeDef *)TPortAddress,pinIds);
      }


      /**
       * Write a value direct to the port
       * @param value The bitmask to write
       */

      void write(uint16_t value) const {
        GPIO_Write((GPIO_TypeDef *)TPortAddress,value);
      }


      /**
       * Get an STL compatible forward iterator pointing to the first pin
       * @return an iterator
       */

      GpioIterator begin() {
        return GpioIterator(_pinHandlers,_peripheralAddress,_low);
      }


      /**
       * Get an STL compatible forward iterator pointing just beyond the last pin
       * @return a forward iterator
       */

      GpioIterator end() {
        return GpioIterator(_pinHandlers,_peripheralAddress,16);
      }
  };
}
// END FILE: ../lib/include/gpio/f4/GpioPort.h
// START FILE: ../lib/include/gpio/f4/features/DigitalInputFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Template feature class to support initialisation of input pins on the F4.
   * Multiple pins can be initialised in one instantiation
   */

  template<GPIOSpeed_TypeDef TSpeed=GPIO_Speed_50MHz,
           Gpio::GpioPullUpDownType TPullUpDownType=Gpio::PUPD_NONE,
           uint8_t... TPins>
  class DigitalInputFeature : public Gpio {

    public:

    /**
     * Constructor
     * @param port the port reference
     */

      DigitalInputFeature(GpioPortBase& port)
        : Gpio(port) {

        uint32_t pins;

        // recurse to get the pin mask

        pins=0;
        GpioPinMerge<TPins...>(pins);

        // do the initialisation

        initialise(pins,TSpeed,TPullUpDownType);
      }


      /**
       * Alternative to template initialisation - initialise programatically
       * @param speed
       * @param TPullUpDownType
       * @param pinIds
       */

      void initialise(uint16_t pinIds,
                      GPIOSpeed_TypeDef speed=GPIO_Speed_50MHz,
                      Gpio::GpioPullUpDownType pullUpDownType=Gpio::PUPD_NONE) {
        uint8_t i;
        GPIO_InitTypeDef init;

        this->_pinIds=pinIds;

        init.GPIO_Speed=speed;
        init.GPIO_Mode=GPIO_Mode_IN;
        init.GPIO_PuPd=pullUpDownType==PUPD_NONE ? GPIO_PuPd_NOPULL : (pullUpDownType==PUPD_UP ? GPIO_PuPd_UP : GPIO_PuPd_DOWN);
        init.GPIO_Pin=pinIds;

        GPIO_Init(_peripheralAddress,&init);

        // set ourselves as the pin handler in the port base

        for(i=0;i<16;i++)
          if((pinIds & (1<<i))!=0)
            _portBase.setPinHandler(i,this);
      }
  };


  /**
   * Default digital input helper
   */

  template<uint8_t... TPins>
  using DefaultDigitalInputFeature=DigitalInputFeature<GPIO_Speed_50MHz,Gpio::PUPD_NONE,TPins...>;
}
// END FILE: ../lib/include/gpio/f4/features/DigitalInputFeature.h
// START FILE: ../lib/include/gpio/f4/features/AlternateFunctionFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Template feature class to support initialisation of alternate function pins on the F4.
   * Multiple pins can be initialised in one instantiation
   */

  template<uint8_t TAfSelection,
           GPIOSpeed_TypeDef TSpeed=GPIO_Speed_50MHz,
           Gpio::GpioOutputType TOutputType=Gpio::PUSH_PULL,
           Gpio::GpioPullUpDownType TPullUpDownType=Gpio::PUPD_NONE,
           uint8_t... TPins>
  class AlternateFunctionFeature : public Gpio {

    public:

    /**
     * Constructor
     * @param port the port reference
     */

      AlternateFunctionFeature(GpioPortBase& port)
        : Gpio(port) {

        uint32_t pins;

        // recurse to get the pin mask

        pins=0;
        GpioPinMerge<TPins...>(pins);

        // do the initialisation in the non-template base

        initialiseAF(pins,TAfSelection,TSpeed,TOutputType,TPullUpDownType);
      }
  };


  /**
   * Default alternate function helper. This provides default port speed settings and is only
   * compatible with the F4.
   */

  template<uint8_t TAfSelection,uint8_t... TPins>
  using DefaultAlternateFunctionFeature=AlternateFunctionFeature<TAfSelection,GPIO_Speed_50MHz,Gpio::PUSH_PULL,Gpio::PUPD_NONE,TPins...>;


  /**
   * Types for each of the peripherals supporting AFIO. These are the compatibility types and will work
   * on any MCU. Some of the examples use these to guarantee compatibility.
   */

  template<uint8_t... TPins> using DefaultTim1AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM1,TPins...>;
  template<uint8_t... TPins> using DefaultTim2AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM2,TPins...>;
  template<uint8_t... TPins> using DefaultTim3AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM3,TPins...>;
  template<uint8_t... TPins> using DefaultTim4AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM4,TPins...>;
  template<uint8_t... TPins> using DefaultTim5AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM5,TPins...>;
  template<uint8_t... TPins> using DefaultTim8AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM8,TPins...>;
  template<uint8_t... TPins> using DefaultTim9AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM9,TPins...>;
  template<uint8_t... TPins> using DefaultTim10AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM10,TPins...>;
  template<uint8_t... TPins> using DefaultTim11AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM11,TPins...>;
  template<uint8_t... TPins> using DefaultTim12AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM12,TPins...>;
  template<uint8_t... TPins> using DefaultTim13AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM13,TPins...>;
  template<uint8_t... TPins> using DefaultTim14AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_TIM14,TPins...>;

  template<uint8_t... TPins> using DefaultI2C1AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_I2C1,TPins...>;
  template<uint8_t... TPins> using DefaultI2C2AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_I2C2,TPins...>;
  template<uint8_t... TPins> using DefaultI2C3AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_I2C3,TPins...>;

  template<uint8_t... TPins> using DefaultSpi1AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_SPI1,TPins...>;
  template<uint8_t... TPins> using DefaultSpi2AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_SPI2,TPins...>;
  template<uint8_t... TPins> using DefaultSpi3AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_SPI3,TPins...>;

  template<uint8_t... TPins> using DefaultUsart1AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_USART1,TPins...>;
  template<uint8_t... TPins> using DefaultUsart2AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_USART2,TPins...>;
  template<uint8_t... TPins> using DefaultUsart3AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_USART3,TPins...>;
  template<uint8_t... TPins> using DefaultUart4AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_UART4,TPins...>;
  template<uint8_t... TPins> using DefaultUart5AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_UART5,TPins...>;
  template<uint8_t... TPins> using DefaultUsart6AlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_USART6,TPins...>;

  // FSMC/FMC depending on device

#if defined(STM32F40_41xxx)
  template<uint8_t... TPins> using DefaultFsmcAlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_FSMC,TPins...>;
#endif

#if defined(STM32F427_437xx) || defined(STM32F429_439xx)
  template<uint8_t... TPins> using DefaultFmcAlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_FMC,TPins...>;
#endif

  template<uint8_t... TPins> using DefaultSdioAlternateFunctionFeature=DefaultAlternateFunctionFeature<GPIO_AF_SDIO,TPins...>;
}
// END FILE: ../lib/include/gpio/f4/features/AlternateFunctionFeature.h
// START FILE: ../lib/include/gpio/f4/features/DigitalOutputFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Template feature class to support initialisation of output pins on the F4.
   * Multiple pins can be initialised in one instantiation.
   *
   * 16 as the "no-pin" constant and uint32_t as the pin id data type is a workaround for
   * a bogus gcc shift-size warning (gcc bug 44811)
   */

  template<GPIOSpeed_TypeDef TSpeed=GPIO_Speed_50MHz,
           Gpio::GpioOutputType TOutputType=Gpio::PUSH_PULL,
           Gpio::GpioPullUpDownType TPullUpDownType=Gpio::PUPD_NONE,
           uint8_t... TPins>
  class DigitalOutputFeature : public Gpio {

    public:

    /**
     * Constructor
     * @param port the port reference
     */

      DigitalOutputFeature(GpioPortBase& port)
        : Gpio(port) {

        uint32_t pins;

        // recurse to get the pin mask

        pins=0;
        GpioPinMerge<TPins...>(pins);

        // do the initialisation

        initialise(pins,TSpeed,TOutputType,TPullUpDownType);
      }


      /**
       * Alternative to template initialisation - initialise programatically
       * @param speed
       * @param TOutputType
       * @param TPullUpDownType
       * @param pinIds
       */

      void initialise(uint16_t pinIds,
                      GPIOSpeed_TypeDef speed=GPIO_Speed_50MHz,
                      Gpio::GpioOutputType outputType=Gpio::PUSH_PULL,
                      Gpio::GpioPullUpDownType pullUpDownType=Gpio::PUPD_NONE) {
        uint8_t i;
        GPIO_InitTypeDef init;

        (void)pullUpDownType;

        this->_pinIds=pinIds;

        init.GPIO_Speed=speed;
        init.GPIO_Mode=GPIO_Mode_OUT;
        init.GPIO_OType=outputType==Gpio::PUSH_PULL ? GPIO_OType_PP : GPIO_OType_OD;
        init.GPIO_PuPd=pullUpDownType==PUPD_NONE ? GPIO_PuPd_NOPULL : (pullUpDownType==PUPD_UP ? GPIO_PuPd_UP : GPIO_PuPd_DOWN);
        init.GPIO_Pin=pinIds;

        GPIO_Init(_peripheralAddress,&init);

        // set ourselves as the pin handler in the port base

        for(i=0;i<16;i++)
          if((pinIds & (1<<i))!=0)
            _portBase.setPinHandler(i,this);
      }
  };


  /**
   * Default digital output helper
   */

  template<uint8_t... TPins>
  using DefaultDigitalOutputFeature=DigitalOutputFeature<GPIO_Speed_50MHz,Gpio::PUSH_PULL,Gpio::PUPD_NONE,TPins...>;
}
// END FILE: ../lib/include/gpio/f4/features/DigitalOutputFeature.h
// START FILE: ../lib/include/gpio/f4/features/AnalogInputFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Template feature class to support initialisation of analog input pins on the F4.
   * Multiple pins can be initialised in one instantiation
   */

  template<uint8_t... TPins>
  class AnalogInputFeature : public Gpio {

    public:

    /**
     * Constructor
     * @param port the port reference
     */

      AnalogInputFeature(GpioPortBase& port)
        : Gpio(port) {

        uint32_t pins;

        // recurse to get the pin mask

        pins=0;
        GpioPinMerge<TPins...>(pins);

        // do the initialisation

        initialise(pins);
      }


      /**
       * Alternative to template initialisation - initialise programatically
       * @param pinIds
       */

      void initialise(uint16_t pinIds) {

        uint8_t i;
        GPIO_InitTypeDef init;

        this->_pinIds=pinIds;

        init.GPIO_Mode=GPIO_Mode_AN;
        init.GPIO_Pin=pinIds;

        GPIO_Init(_peripheralAddress,&init);

        // set ourselves as the pin handler in the port base

        for(i=0;i<16;i++)
          if((pinIds & (1<<i))!=0)
            _portBase.setPinHandler(i,this);
      }
  };
}
// END FILE: ../lib/include/gpio/f4/features/AnalogInputFeature.h
// START FILE: ../lib/include/gpio/f4/GpioPinMap.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {
  namespace gpio {

    struct PA0 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PA1 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PA2 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PA3 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PA4 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PA5 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PA6 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PA7 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PA8 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PA9 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PA10 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PA11 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PA12 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PA13 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PA14 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PA15 {
      enum {
        Port=GPIOA_BASE,
        Pin=GPIO_Pin_15
      };
    };

    struct PB0 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PB1 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PB2 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PB3 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PB4 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PB5 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PB6 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PB7 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PB8 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PB9 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PB10 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PB11 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PB12 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PB13 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PB14 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PB15 {
      enum {
        Port=GPIOB_BASE,
        Pin=GPIO_Pin_15
      };
    };

    struct PC0 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PC1 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PC2 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PC3 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PC4 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PC5 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PC6 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PC7 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PC8 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PC9 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PC10 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PC11 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PC12 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PC13 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PC14 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PC15 {
      enum {
        Port=GPIOC_BASE,
        Pin=GPIO_Pin_15
      };
    };

    struct PD0 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PD1 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PD2 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PD3 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PD4 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PD5 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PD6 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PD7 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PD8 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PD9 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PD10 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PD11 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PD12 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PD13 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PD14 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PD15 {
      enum {
        Port=GPIOD_BASE,
        Pin=GPIO_Pin_15
      };
    };

    struct PE0 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PE1 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PE2 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PE3 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PE4 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PE5 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PE6 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PE7 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PE8 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PE9 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PE10 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PE11 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PE12 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PE13 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PE14 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PE15 {
      enum {
        Port=GPIOE_BASE,
        Pin=GPIO_Pin_15
      };
    };

#if defined(STM32PLUS_F4_HAS_GPIOF_G_I)

    struct PF0 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PF1 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PF2 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PF3 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PF4 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PF5 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PF6 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PF7 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PF8 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PF9 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PF10 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PF11 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PF12 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PF13 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PF14 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PF15 {
      enum {
        Port=GPIOF_BASE,
        Pin=GPIO_Pin_15
      };
    };

    struct PG0 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PG1 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PG2 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PG3 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PG4 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PG5 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PG6 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PG7 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PG8 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PG9 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PG10 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PG11 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PG12 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PG13 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PG14 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PG15 {
      enum {
        Port=GPIOG_BASE,
        Pin=GPIO_Pin_15
      };
    };

#endif

    struct PH0 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PH1 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PH2 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PH3 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PH4 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PH5 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PH6 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PH7 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PH8 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PH9 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PH10 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PH11 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PH12 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PH13 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PH14 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PH15 {
      enum {
        Port=GPIOH_BASE,
        Pin=GPIO_Pin_15
      };
    };

#if defined(STM32PLUS_F4_HAS_GPIOF_G_I)

    struct PI0 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PI1 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PI2 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PI3 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PI4 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PI5 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PI6 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PI7 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PI8 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PI9 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PI10 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PI11 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PI12 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PI13 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PI14 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PI15 {
      enum {
        Port=GPIOI_BASE,
        Pin=GPIO_Pin_15
      };
    };

#endif
#if defined(STM32PLUS_F4_HAS_GPIOJ_K)

    struct PJ0 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PJ1 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PJ2 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PJ3 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PJ4 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PJ5 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PJ6 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PJ7 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PJ8 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PJ9 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PJ10 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PJ11 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PJ12 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PJ13 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PJ14 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PJ15 {
      enum {
        Port=GPIOJ_BASE,
        Pin=GPIO_Pin_15
      };
    };

    struct PK0 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_0
      };
    };

    struct PK1 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_1
      };
    };

    struct PK2 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_2
      };
    };

    struct PK3 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_3
      };
    };

    struct PK4 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_4
      };
    };

    struct PK5 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_5
      };
    };

    struct PK6 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_6
      };
    };

    struct PK7 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_7
      };
    };

    struct PK8 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_8
      };
    };

    struct PK9 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_9
      };
    };

    struct PK10 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_10
      };
    };

    struct PK11 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_11
      };
    };

    struct PK12 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_12
      };
    };

    struct PK13 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_13
      };
    };

    struct PK14 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_14
      };
    };

    struct PK15 {
      enum {
        Port=GPIOK_BASE,
        Pin=GPIO_Pin_15
      };
    };

#endif

  }
}
// END FILE: ../lib/include/gpio/f4/GpioPinMap.h
// START FILE: ../lib/include/gpio/f4/GpioPorts.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /*
   * Convenience typedefs to declare ports by letter
   */

  template<class... Features> using GpioA=GpioPort<GPIOA_BASE,Features...>;
  template<class... Features> using GpioB=GpioPort<GPIOB_BASE,Features...>;
  template<class... Features> using GpioC=GpioPort<GPIOC_BASE,Features...>;
  template<class... Features> using GpioD=GpioPort<GPIOD_BASE,Features...>;
  template<class... Features> using GpioE=GpioPort<GPIOE_BASE,Features...>;
  template<class... Features> using GpioH=GpioPort<GPIOH_BASE,Features...>;

#if defined(STM32PLUS_F4_HAS_GPIOF_G_I)
  template<class... Features> using GpioF=GpioPort<GPIOF_BASE,Features...>;
  template<class... Features> using GpioG=GpioPort<GPIOG_BASE,Features...>;
  template<class... Features> using GpioI=GpioPort<GPIOI_BASE,Features...>;
#endif

#if defined(STM32PLUS_F4_HAS_GPIOJ_K)
  template<class... Features> using GpioJ=GpioPort<GPIOJ_BASE,Features...>;
  template<class... Features> using GpioK=GpioPort<GPIOK_BASE,Features...>;
#endif
}
// END FILE: ../lib/include/gpio/f4/GpioPorts.h
// START FILE: ../lib/include/gpio/f4/Gpio.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * @brief Base class for holding common pin functionality. Inherits from the
   * GPIO_InitTypeDef structure
   */

  class Gpio {

    protected:
      GpioPortBase& _portBase;
      GPIO_TypeDef *_peripheralAddress;

      uint16_t _pinIds;
      uint16_t _selectedPin;

    public:

      /**
       * Possible mode types
       */

      enum GpioModeType {
        OUTPUT,
        INPUT,
        ANALOG,
        ALTERNATE_FUNCTION
      };

      /**
       * Possible output types
       */

      enum GpioOutputType {
        OPEN_DRAIN,//!< OPEN_DRAIN
        PUSH_PULL  //!< PUSH_PULL
      };

      /**
       * Possible pull-up / down types
       */

      enum GpioPullUpDownType {
        PUPD_NONE,//!< PP_NONE
        PUPD_UP,  //!< PP_UP
        PUPD_DOWN //!< PP_DOWN
      };

    protected:
      void getPortAndPinSource(uint8_t& portSource,uint8_t& pinSource) const;

    public:
      Gpio(GpioPortBase& portBase);

      void set() const;
      void reset() const;
      void setAll() const;
      void resetAll() const;
      void setState(bool state) const;
      void setStateAll(bool state) const;
      bool read() const;
      void enableExti() const;

      volatile uint16_t *getSetRegister() const;
      volatile uint16_t *getResetRegister() const;
      volatile uint32_t *getOutputRegister() const;

      void initialiseAF(uint16_t pinIds,
                        uint8_t afSelection,
                        GPIOSpeed_TypeDef speed=GPIO_Speed_50MHz,
                        Gpio::GpioOutputType outputType=Gpio::PUSH_PULL,
                        Gpio::GpioPullUpDownType pullUpDownType=Gpio::PUPD_NONE);

      void setSelectedPin(uint8_t pinNumber);
      uint16_t getSelectedPin() const;

      GPIO_TypeDef *getPeripheralAddress() const;

      static GpioModeType getMode(GPIO_TypeDef *peripheralAddress,uint16_t pin);
      GpioModeType getMode() const;
  };


  /**
   * These two functions are for the variadic parameter pack expansion. When called they will
   * do compile-time recursion to compute the 32-bit pin bit mask from a variadic pack of
   * pin numbers (0..15)
   */

  namespace  {

    /**
     * Recursion termination condition
     */

    template<uint8_t TPin>
    void GpioPinMerge(uint32_t& pins) {
      pins|=1 << TPin;
    }


    /**
     * General recursive caller
     */

    template<uint8_t First,uint8_t Next,uint8_t... Rest>
    void GpioPinMerge(uint32_t& pins) {
      pins|=1 << First;
      GpioPinMerge<Next,Rest...>(pins);
    }
  }


  /**
   * Constructor
   * @param port
   */

  inline Gpio::Gpio(GpioPortBase& portBase)
    : _portBase(portBase),
      _peripheralAddress(portBase.getPeripheralAddress()) {
  }


  /**
   * Get the currently selected pin id
   * @return The pin ID
   */

  inline uint16_t Gpio::getSelectedPin() const {
    return _selectedPin;
  }


  /**
   * Cast to the port typedef
   */

  inline GPIO_TypeDef *Gpio::getPeripheralAddress() const {
    return _peripheralAddress;
  }


  /**
   * Set the selected pin number to one of those that you initialised this class with
   * @param pinNumber The pin number (0..15)
   */

  inline void Gpio::setSelectedPin(uint8_t pinNumber) {
    _selectedPin=1 << pinNumber;
  }


  /**
   * Set the selected pin to HIGH.
   */

  inline void Gpio::set() const {
    GPIO_WriteBit(_peripheralAddress,_selectedPin,Bit_SET);
  }


  /**
   * Set all pins managed by this class to HIGH
   */

  inline void Gpio::setAll() const {
    GPIO_WriteBit(_peripheralAddress,_pinIds,Bit_SET);
  }


  /**
   * Set the selected pin to LOW.
   */

  inline void Gpio::reset() const {
    GPIO_WriteBit(_peripheralAddress,_selectedPin,Bit_RESET);
  }


  /**
   * Set all the pins managed by this class to LOW.
   */

  inline void Gpio::resetAll() const {
    GPIO_WriteBit(_peripheralAddress,_pinIds,Bit_RESET);
  }


  /**
   * Allow setting/resetting of the selected pin from a variable.
   * @param[in] state The new state of the pin.
   */

  inline void Gpio::setState(bool state) const {
    GPIO_WriteBit(_peripheralAddress,_selectedPin,state ? Bit_SET : Bit_RESET);
  }


  /**
   * Allow setting/resetting of all pins managed by this class from a variable.
   * @param[in] state The new state of the pin.
   */

  inline void Gpio::setStateAll(bool state) const {
    GPIO_WriteBit(_peripheralAddress,_pinIds,state ? Bit_SET : Bit_RESET);
  }


  /**
   * Read the selected pin state.
   * @return The pin state.
   */

  inline bool Gpio::read() const {
    return GPIO_ReadInputDataBit(_peripheralAddress,_selectedPin);
  }


  /**
   * Enable EXTI for this port/selected pin
   */

  inline void Gpio::enableExti() const {

    uint8_t portSource,pinSource;

    getPortAndPinSource(portSource,pinSource);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,ENABLE);
    SYSCFG_EXTILineConfig(portSource,pinSource);
  }


  /**
   * Get the port and pin source for EXTI
   * @param[out] portSource The port source
   * @param[out] pinSource The pin source
   */

  inline void Gpio::getPortAndPinSource(uint8_t& portSource,uint8_t& pinSource) const {

    switch(reinterpret_cast<uint32_t>(_peripheralAddress)) {
      case GPIOA_BASE: portSource=EXTI_PortSourceGPIOA; break;
      case GPIOB_BASE: portSource=EXTI_PortSourceGPIOB; break;
      case GPIOC_BASE: portSource=EXTI_PortSourceGPIOC; break;
      case GPIOD_BASE: portSource=EXTI_PortSourceGPIOD; break;
      case GPIOE_BASE: portSource=EXTI_PortSourceGPIOE; break;
      case GPIOH_BASE: portSource=EXTI_PortSourceGPIOH; break;

#if defined(STM32PLUS_F4_HAS_GPIOF_G_I)
      case GPIOF_BASE: portSource=EXTI_PortSourceGPIOF; break;
      case GPIOG_BASE: portSource=EXTI_PortSourceGPIOG; break;
      case GPIOI_BASE: portSource=EXTI_PortSourceGPIOI; break;
#endif

#if defined(STM32PLUS_F4_HAS_GPIOJ_K)
      case GPIOJ_BASE: portSource=EXTI_PortSourceGPIOJ; break;
      case GPIOK_BASE: portSource=EXTI_PortSourceGPIOK; break;
#endif
      default: portSource=0; break;
    }

    switch(_selectedPin) {
      case GPIO_Pin_0: pinSource=EXTI_PinSource0; break;
      case GPIO_Pin_1: pinSource=EXTI_PinSource1; break;
      case GPIO_Pin_2: pinSource=EXTI_PinSource2; break;
      case GPIO_Pin_3: pinSource=EXTI_PinSource3; break;
      case GPIO_Pin_4: pinSource=EXTI_PinSource4; break;
      case GPIO_Pin_5: pinSource=EXTI_PinSource5; break;
      case GPIO_Pin_6: pinSource=EXTI_PinSource6; break;
      case GPIO_Pin_7: pinSource=EXTI_PinSource7; break;
      case GPIO_Pin_8: pinSource=EXTI_PinSource8; break;
      case GPIO_Pin_9: pinSource=EXTI_PinSource9; break;
      case GPIO_Pin_10: pinSource=EXTI_PinSource10; break;
      case GPIO_Pin_11: pinSource=EXTI_PinSource11; break;
      case GPIO_Pin_12: pinSource=EXTI_PinSource12; break;
      case GPIO_Pin_13: pinSource=EXTI_PinSource13; break;
      case GPIO_Pin_14: pinSource=EXTI_PinSource14; break;
      case GPIO_Pin_15: pinSource=EXTI_PinSource15; break;
      default: pinSource=0; break;
    }
  }


  /**
   * Get the register for setting bits.
   * @return The register address
   */

  inline volatile uint16_t *Gpio::getSetRegister() const {
    return reinterpret_cast<volatile uint16_t *>(&_peripheralAddress->BSRRL);
  }


  /**
   * Get the register for clearing bits.
   * @return The register address
   */

  inline volatile uint16_t *Gpio::getResetRegister() const {
    return reinterpret_cast<volatile uint16_t *>(&_peripheralAddress->BSRRH);
  }


  /**
   * Get the register for writing data. As per the docs only 32-bit
   * access is permitted.
   * @return
   */

  inline volatile uint32_t *Gpio::getOutputRegister() const {
    return reinterpret_cast<volatile uint32_t *>(&_peripheralAddress->ODR);
  }


  /**
   * Alternative to template initialisation - initialise programatically
   * @param speed
   * @param TOutputType
   * @param TPullUpDownType
   * @param pinIds
   * @param afSelection
   */

  inline void Gpio::initialiseAF(uint16_t pinIds,
                                 uint8_t afSelection,
                                 GPIOSpeed_TypeDef speed,
                                 Gpio::GpioOutputType outputType,
                                 Gpio::GpioPullUpDownType pullUpDownType) {
    uint8_t source;
    uint32_t bit;
    GPIO_InitTypeDef init;

    (void)pullUpDownType;     // unused

    _pinIds=pinIds;

    init.GPIO_Speed=speed;
    init.GPIO_Mode=GPIO_Mode_AF;
    init.GPIO_OType=outputType==Gpio::PUSH_PULL ? GPIO_OType_PP : GPIO_OType_OD;
    init.GPIO_PuPd=pullUpDownType==PUPD_NONE ? GPIO_PuPd_NOPULL : (pullUpDownType==PUPD_UP ? GPIO_PuPd_UP : GPIO_PuPd_DOWN);
    init.GPIO_Pin=pinIds;

    GPIO_Init(_peripheralAddress,&init);

    // need to configure each of the selected pins for AF

    for(bit=1,source=0;bit<=0x8000;bit<<=1,source++) {
      if((pinIds & bit)!=0) {
        GPIO_PinAFConfig(_peripheralAddress,source,afSelection);
        _portBase.setPinHandler(source,this);
      }
    }
  }


  /**
   * Get the pin mode type (input,output,analog,alternate function)
   * @param peripheralAddress the peripheral register address
   * @param pin the pin bitmask
   * @return The mode type
   */

  inline Gpio::GpioModeType Gpio::getMode(GPIO_TypeDef *peripheralAddress,uint16_t pin) {

    uint8_t pinIndex;

    pinIndex=bithacks::firstSetBit(pin);

    switch((peripheralAddress->MODER >> (pinIndex*2)) & 0x3) {

      case 0:
        return Gpio::INPUT;

      case 1:
        return Gpio::OUTPUT;

      case 2:
        return Gpio::ALTERNATE_FUNCTION;

      case 3:
      default:
        return Gpio::ANALOG;
    }
  }


  /**
   * Get the pin mode type (input,output,analog,alternate function)
   * @return the mode type
   */

  inline Gpio::GpioModeType Gpio::getMode() const {
    return getMode(_peripheralAddress,_selectedPin);
  }
}
// END FILE: ../lib/include/gpio/f4/Gpio.h
// START FILE: ../lib/include/gpio/GpioPinInitialiser.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  namespace GpioPinInitialiser {

    /**
     * Initialisation for non-AF pins
     */

    void initialise(GPIO_TypeDef *port,
                    uint16_t pins,
                    Gpio::GpioModeType mode,
                    GPIOSpeed_TypeDef speed=GPIO_Speed_50MHz,
                    Gpio::GpioPullUpDownType pupdType=Gpio::PUPD_NONE,
                    Gpio::GpioOutputType outputType=Gpio::PUSH_PULL);

    /**
     * Initialisation for analog pins
     */

    void initialise(GPIO_TypeDef *port,uint16_t pins);


    /**
     * Initialisation for AF input pins
     */

    void initialise(GPIO_TypeDef *port,
                    uint16_t pin,
                    Gpio::GpioModeType mode,
                    GPIOSpeed_TypeDef speed,
                    Gpio::GpioPullUpDownType pupdType,
                    uint8_t afSelection);

    /**
     * Initialisation for AF input/output pins
     */

    void initialise(GPIO_TypeDef *port,
                    uint16_t pin,
                    Gpio::GpioModeType mode,
                    GPIOSpeed_TypeDef speed,
                    Gpio::GpioPullUpDownType pupdType,
                    Gpio::GpioOutputType outputType,
                    uint8_t afSelection);

    /**
     * Initialiser for analog input pins
     */

    void initialise(GPIO_TypeDef *port,uint16_t pins);
  }
}
// END FILE: ../lib/include/gpio/GpioPinInitialiser.h
// START FILE: ../lib/include/gpio/GpioPortBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {


  class Gpio;

  /**
   * Base class for the GpioPort template class
   */

  class GpioPortBase {

    public:
      Gpio *_pinHandlers[16];
      GPIO_TypeDef *_peripheralAddress;
      uint8_t _low;

    public:
      GpioPortBase(GPIO_TypeDef *peripheralAddress);

      void setPinHandler(uint8_t index,Gpio *pinHandler);
      GPIO_TypeDef *getPeripheralAddress() const;
  };


  /**
   * Constructor
   * @param peripheralAddress
   */

  inline GpioPortBase::GpioPortBase(GPIO_TypeDef *peripheralAddress)
    : _peripheralAddress(peripheralAddress) {
    memset(_pinHandlers,'\0',sizeof(_pinHandlers));
    _low=15;
  }


  /**
   * Set the pin handler for the pin at a given position
   * @param index The position (0..15)
   * @param pinHandler The handler for that position
   */

  inline void GpioPortBase::setPinHandler(uint8_t index,Gpio *pinHandler) {

    _pinHandlers[index]=pinHandler;

    if(index<_low)
      _low=index;
  }


  /**
   * Cast to the GPIO peripheral address
   */

  inline GPIO_TypeDef *GpioPortBase::getPeripheralAddress() const {
    return _peripheralAddress;
  }
}
// END FILE: ../lib/include/gpio/GpioPortBase.h
// START FILE: ../lib/include/gpio/GpioPinRef.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {


  /**
   * Simple wrapper class for a port and a pin. Useful for when a class would need to store a reference
   * to a Gpio object but cannot because the Gpio references returned by Gpio.operator[] are generally
   * not safe to hold on to.
   *
   * It's always safe to do a bitwise copy of this class
   */

  class GpioPinRef {

    protected:
      GPIO_TypeDef *_peripheralAddress;
      uint16_t _pin;

    public:
      GpioPinRef() {}
      GpioPinRef(const Gpio& gpio);
      GpioPinRef(GPIO_TypeDef *peripheralAddress,uint16_t pin);

      void set() const;
      void reset() const;
      void setState(bool state) const;
      bool read() const;

      GPIO_TypeDef *getPeripheralAddress() const;
      uint16_t getPin() const;
      uint8_t getPinIndex() const;

      GpioPinRef& operator=(const GpioPinRef& src);
      GpioPinRef& operator=(const Gpio& src);

      bool operator==(const GpioPinRef& src) const;
      bool operator!=(const GpioPinRef& src) const;

      Gpio::GpioModeType getMode() const;
  };


  /**
   * Constructor
   * @param gpio The Gpio class
   */

  inline GpioPinRef::GpioPinRef(const Gpio& gpio) {
    _peripheralAddress=gpio.getPeripheralAddress();
    _pin=gpio.getSelectedPin();
  }


  /**
   * Constructor
   * @param peripheralAddress GPIO port base
   * @param pin peripheral library compatible pin number
   */

  inline GpioPinRef::GpioPinRef(GPIO_TypeDef *peripheralAddress,uint16_t pin)
    : _peripheralAddress(peripheralAddress),
      _pin(pin) {
  }


  /**
   * Return the port
   * @return The GPIO_TypeDef port address
   */

  inline GPIO_TypeDef* GpioPinRef::getPeripheralAddress() const {
    return _peripheralAddress;
  }


  /**
   * Return the pin. This is the pin bit mask (1,2,4,8,16...)
   * @return The pin bit mask.
   */

  inline uint16_t GpioPinRef::getPin() const {
    return _pin;
  }


  /**
   * Set the pin to HIGH
   */

  inline void GpioPinRef::set() const {
    GPIO_WriteBit(_peripheralAddress,_pin,Bit_SET);
  }


  /**
   * Set the selected pin to LOW.
   */

  inline void GpioPinRef::reset() const {
    GPIO_WriteBit(_peripheralAddress,_pin,Bit_RESET);
  }


  /**
   * Set the pin state
   */

  inline void GpioPinRef::setState(bool state) const {
    GPIO_WriteBit(_peripheralAddress,_pin,state ? Bit_SET : Bit_RESET);
  }


  /**
   * Read the selected pin state.
   * @return The pin state.
   */

  inline bool GpioPinRef::read() const {
    return GPIO_ReadInputDataBit(_peripheralAddress,_pin);
  }


  /**
   * Assignment operator from GpioPinRef
   * @param src the object to copy from
   * @return self
   */

  inline GpioPinRef& GpioPinRef::operator=(const GpioPinRef& src) {
    _peripheralAddress=src.getPeripheralAddress();
    _pin=src.getPin();
    return *this;
  }



  /**
   * Assignment operator from Gpio
   * @param src the object to copy from
   * @return self
   */

  inline GpioPinRef& GpioPinRef::operator=(const Gpio& src) {
    _peripheralAddress=src.getPeripheralAddress();
    _pin=src.getSelectedPin();
    return *this;
  }


  /**
   * Equality comparison operator
   * @param src the object to compare to
   * @return true if equal
   */

  inline bool GpioPinRef::operator==(const GpioPinRef& src) const {
    return _peripheralAddress==src._peripheralAddress && _pin==src._pin;
  }


  /**
   * Inequality comparison operator
   * @param src the object to compare to
   * @return true if not equal
   */

  inline bool GpioPinRef::operator!=(const GpioPinRef& src) const {
    return _peripheralAddress!=src._peripheralAddress || _pin!=src._pin;
  }


  /**
   * Get the pin index (0..15)
   * @return the pin index in the port
   */

  inline uint8_t GpioPinRef::getPinIndex() const {
    return bithacks::firstSetBit(_pin);
  }


  /**
   * Get the pin mode type (input,output,analog,alternate function)
   * @return the mode type
   */

  inline Gpio::GpioModeType GpioPinRef::getMode() const {
    return Gpio::getMode(_peripheralAddress,_pin);
  }
}
// END FILE: ../lib/include/gpio/GpioPinRef.h
// START FILE: ../lib/include/gpio/GpioIterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {


  /**
   * STL compatible forward iterator that can be used to iterate over GpioPinRef
   * instances in a port. Instances of this iterator should be obtained from the
   * GpioPort object using the begin() and end() methods. Basic usage example:
   *
   *   GpioC<DefaultDigitalInputFeature<1,7,13>,DefaultDigitalOutputFeature<8,9,15>> pc;
   *
   *    for(auto it=pc.begin();it!=pc.end();it++) {
   *      if(it->getMode()==Gpio::OUTPUT) {
   *        // do something
   *      }
   *    }
   *
   *  This iterator is compatible with algorithms in the <algorithm> and <util/StdExt.h> header
   *  that take a forward iterator. In common with the STL iterators you are expected to
   *  be diligent in checking the start and end position using begin() and end() because
   *  the increment and decrement operators will not check for you.
   */

  struct GpioIterator {

    Gpio **_pinHandlers;
    GPIO_TypeDef *_peripheralAddress;
    uint8_t _index;
    GpioPinRef _current;


    /**
     * Default constructor
     */

    GpioIterator() {}


    /**
     * Construct with initial parameters
     * @param pinHandlers The base of the sparse array of Gpio pointers
     * @param peripheralAddress The GPIO peripheral address
     * @param index The initial index for this iterator
     */

    GpioIterator(Gpio **pinHandlers,GPIO_TypeDef *peripheralAddress,uint8_t index) {
      _pinHandlers=pinHandlers;
      _peripheralAddress=peripheralAddress;
      _index=index;
    }


    /**
     * Copy constructor
     * @param it The iterator to copy from
     */

    GpioIterator(const GpioIterator& it) {
      _pinHandlers=it._pinHandlers;
      _peripheralAddress=it._peripheralAddress;
      _index=it._index;
    }


    /**
     * Dereference operator
     * @return reference to GpioPinRef object at position
     */

    GpioPinRef& operator*() {
      Gpio& r(*_pinHandlers[_index]);
      r.setSelectedPin(_index);
      _current=r;
      return _current;
    }


    /**
     * Pointer operator
     * @return address of the current object at the index
     */

    GpioPinRef *operator->() {
      return &(operator*());
    }


    /**
     * Increment the iterator
     * @return self reference
     */

    GpioIterator& operator++() {
      increment();
      return *this;
    }


    /**
     * Increment the iterator
     * @return self reference
     */

    GpioIterator& operator++(int) {
      GpioIterator& tmp=*this;
      increment();
      return tmp;
    }


    /**
     * Decrement the iterator
     * @return self reference
     */

    GpioIterator& operator--() {
      decrement();
      return *this;
    }


    /**
     * Decrement the iterator
     * @return self reference
     */

    GpioIterator& operator--(int) {
      GpioIterator& tmp=*this;
      increment();
      return tmp;
    }


    /**
     * Equality comparison
     * @param rhs the other iterator
     * @return true if the iterators are logically equivalent
     */

    bool operator==(const GpioIterator& rhs) const {
      return _peripheralAddress==rhs._peripheralAddress && _index==rhs._index;
    }


    /**
     * Inequality comparison
     * @param rhs the other iterator
     * @return true if the iterators are not logically equivalent
     */

    bool operator!=(const GpioIterator& rhs) const {
      return _peripheralAddress!=rhs._peripheralAddress || _index!=rhs._index;
    }


    /**
     * Increment the iterator to the next active pin
     */

    void increment() {
      do {
        _index++;
      } while(_pinHandlers[_index]==nullptr && _index!=16);
    }


    /**
     * Decrement the iterator to the next active pin
     */

    void decrement() {
      do {
      _index--;
      } while(_pinHandlers[_index]==nullptr);
    }
  };
}
// END FILE: ../lib/include/gpio/GpioIterator.h
// START FILE: ../lib/include/gpio/GpioAlternateFunctionMapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Forward declaration of the function mapper template. The specialisations provide
   * the necessary level of abstraction, which on the F4 is only at the peripheral level.
   * Other MCUs (F3) need to be abstracted down to the pin level. The F1 does not have
   * any advanced mapping support so we just include a dummy implementation so that
   * the call signatures to the GpioPinInitialiser methods are compatible with all MCUs
   */

  template<PeripheralName TPeripheralName,uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper;
}
// END FILE: ../lib/include/gpio/GpioAlternateFunctionMapper.h
// START FILE: ../lib/include/device/BlockDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {

  /**
   * @brief Base class for block devices
   *
   * Block devices are expected to be able to read and write data in
   * units of 'blocks'. The size of a block is defined by the device.
   */

  class BlockDevice {
    public:

      /**
       * Error codes
       */

      enum {
        /// first sector on device is not an MBR
        E_INVALID_MBR=1,

        /// device does not have an MBR
        E_NO_MBR=2
      };


      /**
       * Type of format of this block device. Describes whether or not
       * it has an MBR
       */

      enum formatType {
        /// device has no MBR, the one-and-only partition starts at sector 0
        formatNoMbr,

        /// device has an MBR with a partition table
        formatMbr,

        /// unknown or unsupported format
        formatUnknown
      };

    public:

      /**
       * Virtual destructor, do nothing
       */

      virtual ~BlockDevice() {
      }


      /**
       * Get the total number of blocks on this device.
       * @return The number of blocks on the device
       */

      virtual uint32_t getTotalBlocksOnDevice()=0;


      /**
       * Get the block size in bytes.
       * @return The block size.
       */

      virtual uint32_t getBlockSizeInBytes()=0;

      /**
       * Read a single block from the device.
       * @param[in,out] dest Caller supplied memory buffer to hold the block.
       * @param[in] blockIndex The zero-based block index to read.
       * @return false if it fails
       */

      virtual bool readBlock(void *dest,uint32_t blockIndex)=0;

      /**
       * Read multiple blocks from the device.
       * @param[in,out] dest Caller supplied memory buffer to hold the blocks.
       * @param[in] blockIndex The zero-based first block index to read.
       * @param[in] numBlocks The number of blocks to read.
       * @return false if it fails
       */

      virtual bool readBlocks(void *dest,uint32_t blockIndex,uint32_t numBlocks)=0;

      /**
       * Write a single block to the device.
       * @param[in] src The memory buffer that the device sources data from
       * @param[in] blockIndex The zero-based block index to write.
       */

      virtual bool writeBlock(const void *src,uint32_t blockIndex)=0;

      /**
       * Write multiple blocks to the device.
       * @param[in] src The memory buffer that the device sources data from
       * @param[in] blockIndex The zero-based first block index to write.
       * @param[in] numBlocks The number of blocks to write.
       */

      virtual bool writeBlocks(const void *src,uint32_t blockIndex,uint32_t numBlocks)=0;


      /**
       * Get the type of this block device.
       * @return The format type, i.e. whether this is device has an MBR or whether it behaves like a large floppy.
       */

      virtual formatType getFormatType()=0;


      /**
       * Get the MBR off this device, if it has one
       * @see getFormatType()
       * @return false if it fails.
       */

      virtual bool getMbr(Mbr *mbr);
  };
}
// END FILE: ../lib/include/device/BlockDevice.h
// START FILE: ../lib/include/device/CachedBlockDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {

  /**
   * @brief Specialisation of BlockDevice to provide in-memory caching.
   *
   * This class subclasses BlockDevice and provides in-memory caching of recently
   * used blocks. The cache is write-through. A user of this class must ensure
   * that he has enough RAM in his device to support the desired cache size.
   */

  class CachedBlockDevice : public BlockDevice {

    protected:

      struct CacheEntry {
          uint32_t BlockIndex;
          uint32_t CacheIndex;
      };

      BlockDevice& _device;
      uint32_t _numCachedBlocks;
      uint8_t **_cachedBlocks;
      CacheEntry *_cacheIndex;
      uint32_t _blockSize;

      static constexpr uint32_t FREE_CACHE_ENTRY=0xFFFFFFFF;

    protected:
      void writeToCache(const void *data,uint32_t blockIndex);
      void moveToFront(uint32_t index);

    public:
      CachedBlockDevice(BlockDevice& bd,uint32_t numCachedBlocks);
      virtual ~CachedBlockDevice();

      // overrides from BlockDevice

      virtual uint32_t getBlockSizeInBytes() override;

      virtual bool readBlock(void *dest,uint32_t blockIndex) override;
      virtual bool readBlocks(void *dest,uint32_t blockIndex,uint32_t numBlocks) override;

      virtual bool writeBlock(const void *src,uint32_t blockIndex) override;
      virtual bool writeBlocks(const void *src,uint32_t blockIndex,uint32_t numBlocks) override;

      virtual uint32_t getTotalBlocksOnDevice() override;

      virtual formatType getFormatType() override;
  };
}

// END FILE: ../lib/include/device/CachedBlockDevice.h
// START FILE: ../lib/include/device/BlockDeviceInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * An input stream class that reads from a block device.
   */

  class BlockDeviceInputStream : public InputStream {

    protected:
      BlockDevice& _device;
      ByteMemblock _block;
      uint32_t _originalBlockIndex;
      uint32_t _blockIndex;
      uint32_t _indexInBlock;

    protected:
      int16_t requireBytes();

    public:
      enum {
        E_INVALID_SEEK_POSITION = 1
      };

    public:
      BlockDeviceInputStream(BlockDevice& device,uint32_t firstBlock);
      virtual ~BlockDeviceInputStream() {}

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool close() override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;
      virtual bool reset() override;
  };
}
// END FILE: ../lib/include/device/BlockDeviceInputStream.h
// START FILE: ../lib/include/device/BlockDeviceOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * An output stream class that writes to a block device. Optionally
   * writes back for every write or only when a block is full
   */

  class BlockDeviceOutputStream : public OutputStream {

    protected:
      BlockDevice& _device;
      ByteMemblock _block;
      uint32_t _blockIndex;
      uint32_t _indexInBlock;
      bool _buffered;

    protected:
      bool checkFillBuffer(uint32_t toWrite);
      bool checkFlush();

    public:
      /**
       * Error codes
       */

      enum {
        /// We've run out of blocks
        E_DEVICE_FULL=1
      };

    public:
      BlockDeviceOutputStream(BlockDevice& device,uint32_t firstBlock,bool buffered);
      virtual ~BlockDeviceOutputStream();

      // overrides from OutputStream

      virtual bool write(uint8_t c) override;
      virtual bool write(const void *buffer,uint32_t size) override;
      virtual bool close() override;
      virtual bool flush() override;
  };
}
// END FILE: ../lib/include/device/BlockDeviceOutputStream.h
// START FILE: ../lib/include/rcc/f4/PeripheralBusSpeed.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Get the bus speed for SDIO
   */

  template<>
  struct PeripheralBusSpeed<PERIPHERAL_SDIO> {
    static uint32_t getBusSpeed() {
      // it's hardcoded on the F4 (See RM0090: "SDIO functional description")
      return 48000000;
    }
  };
}
// END FILE: ../lib/include/rcc/f4/PeripheralBusSpeed.h
// START FILE: ../lib/include/rcc/f4/ClockControl.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * ADC2
   */

  template<>
  struct ClockControl<PERIPHERAL_ADC2> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2,DISABLE);
    }
  };

  /**
   * ADC3
   */

  template<>
  struct ClockControl<PERIPHERAL_ADC3> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3,DISABLE);
    }
  };

  /*
   * CAN1
   */

  template<>
  struct ClockControl<PERIPHERAL_CAN1> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1,DISABLE);
    }
  };

  /*
   * CAN2
   */

  template<>
  struct ClockControl<PERIPHERAL_CAN2> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN2,DISABLE);
    }
  };

  /*
   * DAC2
   */

  template<>
  struct ClockControl<PERIPHERAL_DAC2> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC,DISABLE);
    }
  };

  /**
   * CRC
   */

  template<>
  struct ClockControl<PERIPHERAL_CRC> {

    static void On() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_CRC,ENABLE);
    }

    static void Off() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_CRC,DISABLE);
    }
  };

  /**
   * DMA1
   */

  template<>
  struct ClockControl<PERIPHERAL_DMA1> {

    static void On() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1,ENABLE);
    }

    static void Off() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1,DISABLE);
    }
  };

  /**
   * DMA2
   */

  template<>
  struct ClockControl<PERIPHERAL_DMA2> {

    static void On() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2,ENABLE);
    }

    static void Off() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2,DISABLE);
    }
  };


  /*
   * Ethernet MAC
   */

  template<>
  struct ClockControl<PERIPHERAL_MAC> {

    // configure Tx, Rx. PTP is not enabled here.

    static void On() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx | RCC_AHB1Periph_ETH_MAC_Rx,ENABLE);
    }

    static void Off() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx | RCC_AHB1Periph_ETH_MAC_Rx,DISABLE);
    }
  };

  template<>
  struct ClockControl<PERIPHERAL_MAC_REMAP> {

    // configure Tx, Rx. PTP is not enabled here.

    static void On() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx | RCC_AHB1Periph_ETH_MAC_Rx,ENABLE);
    }

    static void Off() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_ETH_MAC | RCC_AHB1Periph_ETH_MAC_Tx | RCC_AHB1Periph_ETH_MAC_Rx,DISABLE);
    }
  };


  /**
   * FSMC/FMC
   */

#if defined(STM32F40_41xxx)

  template<>
  struct ClockControl<PERIPHERAL_FSMC> {

    static void On() {
      RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC,ENABLE);
    }

    static void Off() {
      RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FSMC,DISABLE);
    }
  };
#endif

#if defined(STM32F427_437xx) || defined(STM32F429_439xx)

  template<>
  struct ClockControl<PERIPHERAL_FMC> {

    static void On() {
      RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC,ENABLE);
    }

    static void Off() {
      RCC_AHB3PeriphClockCmd(RCC_AHB3Periph_FMC,DISABLE);
    }
  };
#endif

  /**
   * Hash
   */

  template<>
  struct ClockControl<PERIPHERAL_HASH> {

    static void On() {
      RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_HASH,ENABLE);
    }

    static void Off() {
      RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_HASH,DISABLE);
    }
  };

  /*
   * I2C3
   */

  template<>
  struct ClockControl<PERIPHERAL_I2C3> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C3,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C3,DISABLE);
    }
  };

  /**
   * I2S2
   */

  template<>
  struct ClockControl<PERIPHERAL_I2S2> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE);
      RCC_PLLI2SCmd(ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,DISABLE);
      RCC_PLLI2SCmd(DISABLE);
    }
  };

  /**
   * I2S3
   */

  template<>
  struct ClockControl<PERIPHERAL_I2S3> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3,ENABLE);
      RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S);
      RCC_PLLI2SCmd(ENABLE);
      RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3,DISABLE);
      RCC_PLLI2SCmd(DISABLE);
    }
  };

  /**
   * USB OTG FS
   */

  template<>
  struct ClockControl<PERIPHERAL_OTG_FS> {

    static void On() {
      RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS,ENABLE);
    }

    static void Off() {
      RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS,DISABLE);
    }
  };

  /**
   * USB OTG HS
   */

  template<>
  struct ClockControl<PERIPHERAL_OTG_HS> {

    static void On() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_OTG_HS,ENABLE);
    }

    static void Off() {
      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_OTG_HS,DISABLE);
    }
  };

  /**
   * POWER
   */

  template<>
  struct ClockControl<PERIPHERAL_POWER> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,DISABLE);
    }
  };

  /**
   * RNG
   */

  template<>
  struct ClockControl<PERIPHERAL_RNG> {

    static void On() {
      RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG,ENABLE);
    }

    static void Off() {
      RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_RNG,DISABLE);
    }
  };


  /**
   * SDIO
   */

  template<>
  struct ClockControl<PERIPHERAL_SDIO> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SDIO,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SDIO,DISABLE);
    }
  };

  /**
   * SPI1
   */

  template<>
  struct ClockControl<PERIPHERAL_SPI1> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,DISABLE);
    }
  };

  /**
   * SPI3
   */

  template<>
  struct ClockControl<PERIPHERAL_SPI3> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3,DISABLE);
    }
  };

  /**
   * SPI1_REMAP
   */

  template<>
  struct ClockControl<PERIPHERAL_SPI1_REMAP> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,DISABLE);
    }
  };

  /**
   * SPI3_REMAP
   */

  template<>
  struct ClockControl<PERIPHERAL_SPI3_REMAP> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3,DISABLE);
    }
  };

  /**
   * SYSCFG
   */

  template<>
  struct ClockControl<PERIPHERAL_SYSCFG> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,DISABLE);
    }
  };

  /*
   * TIM4
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER4> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,DISABLE);
    }
  };

  /*
   * TIM5
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER5> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5,DISABLE);
    }
  };

  /*
   * TIM7
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER7> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7,DISABLE);
    }
  };

  /*
   * TIM8
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER8> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8,DISABLE);
    }
  };

  /*
   * TIM9
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER9> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM9,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM9,DISABLE);
    }
  };

  /*
   * TIM10
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER10> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM10,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM10,DISABLE);
    }
  };

  /*
   * TIM11
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER11> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM11,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM11,DISABLE);
    }
  };

  /*
   * TIM12
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER12> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM12,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM12,DISABLE);
    }
  };

  /*
   * TIM13
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER13> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM13,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM13,DISABLE);
    }
  };

  /**
   * USART1
   */

  template<>
  struct ClockControl<PERIPHERAL_USART1> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1,DISABLE);
    }
  };

  /**
   * USART2
   */

  template<>
  struct ClockControl<PERIPHERAL_USART2> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,DISABLE);
    }
  };

  /**
   * USART3
   */

  template<>
  struct ClockControl<PERIPHERAL_USART3> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3,DISABLE);
    }
  };

  /**
   * UART4
   */

  template<>
  struct ClockControl<PERIPHERAL_UART4> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4,DISABLE);
    }
  };

  /**
   * UART5
   */

  template<>
  struct ClockControl<PERIPHERAL_UART5> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5,DISABLE);
    }
  };

  /**
   * USART6
   */

  template<>
  struct ClockControl<PERIPHERAL_USART6> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART6,DISABLE);
    }
  };
}
// END FILE: ../lib/include/rcc/f4/ClockControl.h
// START FILE: ../lib/include/rcc/PeripheralBusSpeed.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {

  template<PeripheralName TPeripheral>
  struct PeripheralBusSpeed;
}
// END FILE: ../lib/include/rcc/PeripheralBusSpeed.h
// START FILE: ../lib/include/rcc/ClockControl.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic definition of the clock control class. There is a specialisation
   * for each supported peripheral
   */

  template<PeripheralName TPeripheral>
  struct ClockControl;

  /**
   * ADC1
   */

  template<>
  struct ClockControl<PERIPHERAL_ADC1> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,DISABLE);
    }
  };

  /*
   * DAC1
   */

  template<>
  struct ClockControl<PERIPHERAL_DAC1> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_DAC,DISABLE);
    }
  };


  /*
   * I2C1
   */

  template<>
  struct ClockControl<PERIPHERAL_I2C1> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1,DISABLE);
    }
  };

  /*
   * I2C2
   */

  template<>
  struct ClockControl<PERIPHERAL_I2C2> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2,DISABLE);
    }
  };

  /**
   * SPI2
   */

  template<>
  struct ClockControl<PERIPHERAL_SPI2> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,DISABLE);
    }
  };


  /*
   * TIM1
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER1> {

    static void On() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1,ENABLE);
    }

    static void Off() {
      RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1,DISABLE);
    }
  };

  /*
   * TIM2
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER2> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,DISABLE);
    }
  };

  /*
   * TIM3
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER3> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,DISABLE);
    }
  };


  /*
   * TIM6
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER6> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6,DISABLE);
    }
  };


  /*
   * TIM14
   */

  template<>
  struct ClockControl<PERIPHERAL_TIMER14> {

    static void On() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM14,ENABLE);
    }

    static void Off() {
      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM14,DISABLE);
    }
  };
}

// END FILE: ../lib/include/rcc/ClockControl.h
// START FILE: ../lib/include/rcc/RccBusInformation.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Utility class to get the prescaler values for buses
   */

  class RccBusInformation {

    public:

      /**
       * Get the value of the APB prescaler
       * @return
       */

      static uint16_t getAPBPrescaler();

      /**
       * Get the value of the APB2 prescaler
       * @return
       */

      static uint16_t getAPB2Prescaler();

      /**
       * Get the value of the APB1 prescaler
       * @return
       */

      static uint16_t getAPB1Prescaler();

      /**
       * Get the value of the AHB prescaler
       * @return
       */

      static uint16_t getAHBPrescaler();
  };
}
// END FILE: ../lib/include/rcc/RccBusInformation.h
// START FILE: ../lib/include/crc/LittleEndianCrc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic template implementation of the CRC peripheral. This peripheral is the
   * same on the F1 and F4 so there are no specialisations.
   *
   * The CRC unit operates on 32 bit words and you are most likely to be operating on
   * a byte stream, hence this class takes bytes as input.
   *
   * reset() is called on construction and you can call it whenever afterwards. You then
   * call addNewData() as many times as you have bytes to use and then call finish to
   * flush any remaining bytes (with configurable padding). Both finish() and addNewData()
   * return the current CRC value. The only valid method call after finish() has been
   * called is reset()
   *
   * The little endian implementation operates in the default mode of the CRC unit.
   */

  template<>
  class CrcPeripheral<Endian::LITTLE_ENDIAN_MCU> : public CrcBase {

    public:
      struct Parameters {
        uint8_t crc_padding;

        Parameters(uint8_t padding=0) {
          crc_padding=padding;
        }
      };

    public:
      CrcPeripheral(const Parameters& params);
      uint32_t addNewData(uint8_t nextByte);
      uint32_t calculateWordBuffer(uint32_t *buffer,uint32_t count) const;

      uint32_t finish() const;
      uint32_t currentCrc() const;
  };


  /**
   * typedefs for easy use
   */

  typedef CrcPeripheral<Endian::LITTLE_ENDIAN_MCU> CrcLittleEndian;


  /**
   * Constructor. Initialise state variables
   * @param padding The byte to pad the final word with when your input stream size is not a multiple of 32 bits.
   */

  inline CrcPeripheral<Endian::LITTLE_ENDIAN_MCU>::CrcPeripheral(const Parameters& params)
    : CrcBase(params.crc_padding) {
  }


  /**
   * Add a new data byte to the calculation and return the current value of the calculation. The current value will change
   * every 4 bytes because of the 32-bit resolution of the peripheral
   * @param nextByte The next byte to add to the calculation
   * @return The current value of the CRC.
   */

  inline uint32_t CrcPeripheral<Endian::LITTLE_ENDIAN_MCU>::addNewData(uint8_t nextByte) {

    // shift down the current word to make space for the new data and OR it in

    _currentWord>>=8;
    _currentWord|=static_cast<uint32_t>(nextByte) << 24;

    if(_currentIndex++==3) {

      uint32_t crc;

      crc=CRC_CalcCRC(_currentWord);
      _currentWord=_padding;
      _currentIndex=0;

      return crc;
    }

    return currentCrc();
  }


  /**
   * Calculate the CRC of an whole buffer of 32-bit words
   * @param buffer The start of the buffer
   * @param count The number of words
   * @return The CRC
   */

  inline uint32_t CrcPeripheral<Endian::LITTLE_ENDIAN_MCU>::calculateWordBuffer(uint32_t *buffer,uint32_t count) const {
    return CRC_CalcBlockCRC(buffer,count);
  }


  /**
   * Finish the stream, writing any remaining bytes including the padding
   * @return The final CRC value
   */

  inline uint32_t CrcPeripheral<Endian::LITTLE_ENDIAN_MCU>::finish() const {

    // if there are no pending bytes then return the current CRC value
    // otherwise add the pending word and return the updated CRC

    if(_currentIndex==0)
      return currentCrc();
    else
      return CRC_CalcCRC(_currentWord);
  }


  /**
   * Return the current CRC value
   * @return The current CRC
   */

  inline uint32_t CrcPeripheral<Endian::LITTLE_ENDIAN_MCU>::currentCrc() const {
    return CRC_GetCRC();
  }
}
// END FILE: ../lib/include/crc/LittleEndianCrc.h
// START FILE: ../lib/include/crc/CrcPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic template implementation of the CRC peripheral.
   *
   * The CRC unit operates on 32 bit words and you are most likely to be operating on
   * a byte stream, hence this class takes bytes as input.
   *
   * reset() is called on construction and you can call it whenever afterwards. You then
   * call addNewData() as many times as you have bytes to use and then call finish to
   * flush any remaining bytes (with configurable padding). Both finish() and addNewData()
   * return the current CRC value. The only valid method call after finish() has been
   * called is reset()
   */

  template<Endian TEndian>
  class CrcPeripheral;
}
// END FILE: ../lib/include/crc/CrcPeripheral.h
// START FILE: ../lib/include/crc/CrcOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once



namespace stm32plus {


  /**
   * Template class for a CRC output stream.
   */

  template<class TCrc>
  class CrcOutputStream : public OutputStream {

    protected:
      TCrc& _crc;

    public:

      CrcOutputStream(TCrc& crc);
      virtual ~CrcOutputStream() {}

      // overrides from OutputStream

      virtual bool write(uint8_t c) override;
      virtual bool write(const void *buffer,uint32_t size) override;
      virtual bool flush() override;
      virtual bool close() override;
  };


  /**
   * Constructor
   * @param crc The CRC peripheral type
   */

  template<class TCrc>
  inline CrcOutputStream<TCrc>::CrcOutputStream(TCrc& crc)
    : _crc(crc) {
  }


  /**
   * Write a byte
   * @param c The byte
   * @return always true
   */

  template<class TCrc>
  inline bool CrcOutputStream<TCrc>::write(uint8_t c) {
    _crc.addNewData(c);
    return true;
  }


  /**
   * Write a buffer of bytes
   * @param buffer the buffer
   * @param size The number of bytes
   * @return Always true
   */

  template<class TCrc>
  inline bool CrcOutputStream<TCrc>::write(const void *buffer,uint32_t size) {

    const uint8_t *ptr=reinterpret_cast<const uint8_t *>(buffer);

    while(size--)
      _crc.addNewData(*ptr++);

    return true;
  }


  /**
   * Always true.
   * @return always true
   */

  template<class TCrc>
  inline bool CrcOutputStream<TCrc>::flush() {
    return true;
  }


  /**
   * Always true. Calls finish() on the underlying CRC
   * @return always true
   */

  template<class TCrc>
  inline bool CrcOutputStream<TCrc>::close() {
    _crc.finish();
    return true;
  }
}
// END FILE: ../lib/include/crc/CrcOutputStream.h
// START FILE: ../lib/include/crc/BigEndianCrc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic template implementation of the CRC peripheral. This peripheral is the
   * same on the F1 and F4 so there are no specialisations.
   *
   * The CRC unit operates on 32 bit words and you are most likely to be operating on
   * a byte stream, hence this class takes bytes as input.
   *
   * reset() is called on construction and you can call it whenever afterwards. You then
   * call addNewData() as many times as you have bytes to use and then call finish to
   * flush any remaining bytes (with configurable padding). Both finish() and addNewData()
   * return the current CRC value. The only valid method call after finish() has been
   * called is reset()
   *
   * The big endian implementation operates in a mode that's compatible with the CRC calculation units
   * in PC based utilities such as ZIP - each word is bit-reversed before sending to the unit
   * and reversed on finish
   */

  template<>
  class CrcPeripheral<Endian::BIG_ENDIAN_MCU> : public CrcBase {

    public:
      struct Parameters {
        uint8_t crc_padding;

        Parameters(uint8_t padding=0) {
          crc_padding=padding;
        }
      };

    public:
      CrcPeripheral(const Parameters& params);
      uint32_t addNewData(uint8_t nextByte);

      static uint32_t reverse(uint32_t data);

      uint32_t finish() const;
      uint32_t currentCrc() const;
  };

  /**
   * Typedef for easy use
   */

  typedef CrcPeripheral<Endian::BIG_ENDIAN_MCU> CrcBigEndian;


  /**
   * Constructor. Initialise state variables
   * @param padding The byte to pad the final word with when your input stream size is not a multiple of 32 bits.
   */

  inline CrcPeripheral<Endian::BIG_ENDIAN_MCU>::CrcPeripheral(const Parameters& params)
    : CrcBase(params.crc_padding) {
  }


  /**
   * Add a new data byte to the calculation and return the current value of the calculation. The current value will change
   * every 4 bytes because of the 32-bit resolution of the peripheral
   * @param nextByte The next byte to add to the calculation
   * @return The current value of the CRC.
   */

  inline uint32_t CrcPeripheral<Endian::BIG_ENDIAN_MCU>::addNewData(uint8_t nextByte) {

    // shift down the current word to make space for the new data and OR it in

    _currentWord>>=8;
    _currentWord|=static_cast<uint32_t>(nextByte) << 24;

    if(_currentIndex++==3) {

      uint32_t crc;

      crc=CRC_CalcCRC(reverse(_currentWord));
      _currentWord=_padding;
      _currentIndex=0;

      return crc;
    }

    return currentCrc();
  }


  /**
   * Reverse the bits in the parameter
   * @param data
   * @return The parameter, with bits reversed
   */

  inline uint32_t CrcPeripheral<Endian::BIG_ENDIAN_MCU>::reverse(register uint32_t data) {

#if(__CORTEX_M >= 0x03)

    // we can do this with an intrinsic on the cortex m3 or greater
    asm volatile( "rbit %0, %0" :: "g" (data) );

#else

    data = (((data & 0xaaaaaaaa) >> 1) | ((data & 0x55555555) << 1));
        data = (((data & 0xcccccccc) >> 2) | ((data & 0x33333333) << 2));
        data = (((data & 0xf0f0f0f0) >> 4) | ((data & 0x0f0f0f0f) << 4));
        data = (((data & 0xff00ff00) >> 8) | ((data & 0x00ff00ff) << 8));
        return ((data >> 16) | (data << 16));

#endif

    return data;
  }


  /**
   * Finish the stream, writing any remaining bytes including the padding
   * @return The final CRC value
   */

  inline uint32_t CrcPeripheral<Endian::BIG_ENDIAN_MCU>::finish() const {

    // if there are no pending bytes then return the current CRC value
    // otherwise add the pending word and return the updated CRC

    if(_currentIndex==0)
      return currentCrc();
    else
      return reverse(CRC_CalcCRC(_currentWord));
  }


  /**
   * Return the current CRC value
   * @return The current CRC
   */

  inline uint32_t CrcPeripheral<Endian::BIG_ENDIAN_MCU>::currentCrc() const {
    return reverse(CRC_GetCRC());
  }
}
// END FILE: ../lib/include/crc/BigEndianCrc.h
// START FILE: ../lib/include/crc/CrcBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Base class for the CRC peripheral. Contains most of the implementation. See CrcPeripheral class for
   * usage documentation. Everything in this class is endian-independent.
   *
   * The CRC unit operates on 32 bit words and you are most likely to be operating on
   * a byte stream, hence this class takes bytes as input.
   *
   * reset() is called on construction and you can call it whenever afterwards. You then
   * call addNewData() as many times as you have bytes to use and then call finish to
   * flush any remaining bytes (with configurable padding). Both finish() and addNewData()
   * return the current CRC value. The only valid method call after finish() has been
   * called is reset()
   */

  class CrcBase {
    protected:
      uint32_t _currentWord;
      uint8_t _currentIndex;
      uint32_t _padding;

    public:
      CrcBase(uint8_t padding=0);
      ~CrcBase();

      void reset();
      uint32_t finish() const;

      uint32_t currentCrc() const;
  };


  /**
   * Constructor. Initialise state variables
   * @param padding The byte to pad the final word with when your input stream size is not a multiple of 32 bits.
   */

  inline CrcBase::CrcBase(uint8_t padding) {

    ClockControl<PERIPHERAL_CRC>::On();

    _padding=padding | padding << 8 | padding << 16 | padding << 24;
    reset();
  }


  /*
   * Destructor
   */

  inline CrcBase::~CrcBase() {
    ClockControl<PERIPHERAL_CRC>::Off();
  }


  /**
   * Reset the CRC calculation ready for re-use
   */

  inline void CrcBase::reset() {

    _currentIndex=0;
    _currentWord=_padding;

    CRC_ResetDR();
  }
}
// END FILE: ../lib/include/crc/CrcBase.h
// START FILE: ../lib/include/usb/f4/UsbEventSource.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

namespace stm32plus {
  namespace usb {


    /*
     * The event signature for USB device events
     */

    DECLARE_EVENT_SIGNATURE(Usb,void(UsbEventDescriptor&));
    DECLARE_EVENT_SIGNATURE(UsbError,void(UsbErrorEvent&));


    /*
     * Base structure that holds just the event subscriber/publisher for USB devices
     */

    struct UsbEventSource {
      DECLARE_EVENT_SOURCE(Usb);
      DECLARE_EVENT_SOURCE(UsbError);


      /**
       * Set an error in the error provider and raise an event
       */

      bool setError(int provider,uint32_t code,uint32_t cause=0) const {
        UsbErrorEventSender.raiseEvent(UsbErrorEvent(provider,code,cause));
        return false;
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/UsbEventSource.h
// START FILE: ../lib/include/usb/f4/phy/events/OtgFsInterruptEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class to notify that an OTG interrupt has happened
     */

    struct OtgFsInterruptEvent : UsbEventDescriptor {

      OtgFsInterruptEvent()
        : UsbEventDescriptor(EventType::OTG_FS_INTERRUPT) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/phy/events/OtgFsInterruptEvent.h
// START FILE: ../lib/include/usb/f4/phy/features/InternalFsPhyInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Forward declare the IRQ handler name
 */

extern "C" void OTG_FS_IRQHandler();


namespace stm32plus {
  namespace usb {


    /**
     * Interrupt feature for the OTG FS PHY. This is automatically included by the FS PHY
     * implementation. There's no need to include it in the PHY feature list yourself.
     */

    class InternalFsPhyInterruptFeature {

      public:

        /**
         * Parameters structure
         */

        struct Parameters {
          uint8_t fsphy_nvicPriority;      // primary interrupt priority
          uint8_t fsphy_nvicSubPriority;   // secondary priority

          Parameters() {
            fsphy_nvicPriority=5;
            fsphy_nvicSubPriority=0;
          }
        };

        static UsbEventSource *_usbEventSource;

      protected:
        typedef void (*FPTR)();       // this trick will force the linker to include the ISR
        static FPTR _forceLinkage;

        Parameters _params;

      public:
        bool initialise(const Parameters& params);

      protected:
        InternalFsPhyInterruptFeature(UsbEventSource& eventSource);
        ~InternalFsPhyInterruptFeature();

        void phyEnableInterrupts() const;
        void phyDisableInterrupts() const;
    };


    /**
     * Constructor, enable the interrupts
     */

    inline InternalFsPhyInterruptFeature::InternalFsPhyInterruptFeature(UsbEventSource& eventSource) {

      // force IRQ linkage

      _forceLinkage=&OTG_FS_IRQHandler;
      _usbEventSource=&eventSource;
    }


    /**
     * Initialise the class
     * @return true
     */

    inline bool InternalFsPhyInterruptFeature::initialise(const Parameters& params) {
      _params=params;
      return true;
    }


    /**
     * Destructor, unsubscribe
     * @param eventDescriptor
     */

    inline InternalFsPhyInterruptFeature::~InternalFsPhyInterruptFeature() {

      // disable interrupts

      phyDisableInterrupts();
    }


    /**
     * Enable interrupts
     */

    inline void InternalFsPhyInterruptFeature::phyEnableInterrupts() const {
      Nvic::configureIrq(OTG_FS_IRQn,ENABLE,_params.fsphy_nvicPriority,_params.fsphy_nvicSubPriority);
    }


    /**
     * Disable the interrupts
     */

    inline void InternalFsPhyInterruptFeature::phyDisableInterrupts() const {
      Nvic::configureIrq(OTG_FS_IRQn,DISABLE,_params.fsphy_nvicPriority,_params.fsphy_nvicSubPriority);
    }
  }
}
// END FILE: ../lib/include/usb/f4/phy/features/InternalFsPhyInterruptFeature.h
// START FILE: ../lib/include/usb/f4/phy/features/PhyFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Simple base class for PHY features. Enables access to the events
     * raised by the stack.
     */

    class PhyFeatureBase {
      protected:
        UsbEventSource& _eventSource;

      protected:
        PhyFeatureBase(UsbEventSource& eventSource);
    };


    /**
     * Constructor
     * @param eventSource The event source
     */

    inline PhyFeatureBase::PhyFeatureBase(UsbEventSource& eventSource)
      : _eventSource(eventSource) {
    }
  }
}
// END FILE: ../lib/include/usb/f4/phy/features/PhyFeatureBase.h
// START FILE: ../lib/include/usb/f4/phy/features/FsLowPowerFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB low power feature for the OTG FS PHY. This feature subscribes to the
     * EXTI line 18 (USB FS wakeup) event and wakes up the MCU when it happens. This relies
     * on you having a SetSysClock() "C" method in your system startup file.
     */

    class FsLowPowerFeature : public PhyFeatureBase {

      protected:
        ExtiUsbFsWakeup _wakeup;

      public:
        struct Parameters {
        };

      private:
        void onWakeupEvent(uint8_t extiLine);
        void onUsbEvent(UsbEventDescriptor& event);

      protected:
        FsLowPowerFeature(UsbEventSource& eventSource);
        ~FsLowPowerFeature();

      public:
        bool initialise(const Parameters& params);
    };


    /**
     * Constructor
     * @param params the config parameters
     */

    inline FsLowPowerFeature::FsLowPowerFeature(UsbEventSource& eventSource)
      : PhyFeatureBase(eventSource),
        _wakeup(EXTI_Mode_Interrupt,EXTI_Trigger_Rising) {

      // clear anything pending

      _wakeup.clearPendingInterrupt();

      // subscribe to wakeup events

      _wakeup.ExtiInterruptEventSender.insertSubscriber(
          ExtiInterruptEventSourceSlot::bind(this,&FsLowPowerFeature::onWakeupEvent)
      );

      // subscribe to USB events

      _eventSource.UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&FsLowPowerFeature::onUsbEvent)
      );
    }


    /**
     * Initialise the class
     * @param parameters reference
     * @return true
     */

    inline bool FsLowPowerFeature::initialise(const Parameters& /* params */) {
      return true;
    }


    /**
     * Destructor, disable EXTI interrupts
     */

    inline FsLowPowerFeature::~FsLowPowerFeature() {

      ExtiInterruptEnabler<18>::disable();

      // unsubscribe from wakeup events

      _wakeup.ExtiInterruptEventSender.removeSubscriber(
          ExtiInterruptEventSourceSlot::bind(this,&FsLowPowerFeature::onWakeupEvent)
      );

      // unsubscribe from USB events

      _eventSource.UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&FsLowPowerFeature::onUsbEvent)
      );
    }


    /**
     * Interrupt callback from the EXTI interrupt
     */

      extern "C" void SetSysClock();

    inline void FsLowPowerFeature::onWakeupEvent(uint8_t /* extiLine */) {

      // reset SLEEPDEEP bit of cortex system control register

      SCB->SCR &= (uint32_t)~((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));

      SetSysClock();

      // ungate PHY clock

      *reinterpret_cast<volatile uint32_t *>(USB_OTG_FS_PERIPH_BASE+USB_OTG_PCGCCTL_BASE) &= ~USB_OTG_PCGCCTL_STOPCLK;
    }


    /**
     * Event handler for usb events
     * @param event The event descriptor
     */

    inline void FsLowPowerFeature::onUsbEvent(UsbEventDescriptor& event) {

      switch(event.eventType) {

        case UsbEventDescriptor::EventType::DEVICE_IRQ_SUSPEND:
          *reinterpret_cast<volatile uint32_t *>(USB_OTG_FS_PERIPH_BASE+USB_OTG_PCGCCTL_BASE) |= USB_OTG_PCGCCTL_STOPCLK;
          break;

        case UsbEventDescriptor::EventType::DEVICE_IRQ_RESUME:
          *reinterpret_cast<volatile uint32_t *>(USB_OTG_FS_PERIPH_BASE+USB_OTG_PCGCCTL_BASE) &= ~USB_OTG_PCGCCTL_STOPCLK;
          break;

        default:
          break;
      }
    }
  }
}
// END FILE: ../lib/include/usb/f4/phy/features/FsLowPowerFeature.h
// START FILE: ../lib/include/usb/f4/phy/InternalFsPhy.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Internal full-speed PHY implementation. Inherits from the event source class and the
     * PHY optional features. The PHY interrupt feature is always inherited because the FS
     * PHY always operates in interrupt mode.
     */

    template<class... Features>
    class InternalFsPhy : public UsbEventSource,
                          public InternalFsPhyInterruptFeature,
                          public Features... {

      public:
        struct Parameters : InternalFsPhyInterruptFeature::Parameters,
                            Features::Parameters... {

          uint16_t phy_rxFifoSize;      // default is 0x80

          Parameters() {
            phy_rxFifoSize=0x80;
          }
        };

      protected:
        USB_OTG_GlobalTypeDef *_phyRegisters;

      public:
        InternalFsPhy();
        ~InternalFsPhy();

        bool initialise(Parameters& params);

        bool phySupportsDma() const;
        bool phySupportsLowPower() const;
        uint32_t getPhyInterface() const;
        uint32_t getPhySpeed() const;
    };


    /**
     * Constructor
     */

    template<class... Features>
    inline InternalFsPhy<Features...>::InternalFsPhy()
      : InternalFsPhyInterruptFeature(static_cast<UsbEventSource&>(*this)),
        Features(static_cast<UsbEventSource&>(*this))...,
        _phyRegisters(USB_OTG_FS) {
    }


    /**
     * Initialise
     * @param params The parameters class
     * @return true
     */

    template<class... Features>
    inline bool InternalFsPhy<Features...>::initialise(Parameters& params) {

      // initialise upwards

      if(!InternalFsPhyInterruptFeature::initialise(params) ||
         !RecursiveBoolInitWithParams<InternalFsPhy,Features...>::tinit(this,params))
          return false;

      // configure DM/DP Pins

      GpioPinInitialiser::initialise(
          GPIOA,
          GPIO_Pin_11 | GPIO_Pin_12,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)OtgFsPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GPIO_AF_OTG_FS);

      // configure VBUS Pin

      GpioPinInitialiser::initialise(
          GPIOA,
          GPIO_Pin_9,
          Gpio::INPUT,
          (GPIOSpeed_TypeDef)OtgFsPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          GPIO_AF_OTG_FS);

      // configure ID pin

      GpioPinInitialiser::initialise(
          GPIOA,
          GPIO_Pin_10,
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)OtgFsPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_UP,
          Gpio::OPEN_DRAIN,
          GPIO_AF_OTG_FS);

      // PHY clock on

      ClockControl<PERIPHERAL_OTG_FS>::On();

      // enable interrupts

      this->phyEnableInterrupts();

      return true;
    }


    /**
     * Destructor
     */

    template<class... Features>
    inline InternalFsPhy<Features...>::~InternalFsPhy() {

      // PHY clock off

      ClockControl<PERIPHERAL_OTG_FS>::Off();
    }


    /**
     * Return true if the PHY supports DMA
     * @return false
     */

    template<class... Features>
    inline bool InternalFsPhy<Features...>::phySupportsDma() const {
      return false;
    }


    /**
     * Return true if the PHY supports low power mode
     * @return true if FsLowPowerFeature is included as a feature
     */

    template<class... Features>
    inline bool InternalFsPhy<Features...>::phySupportsLowPower() const {

      // this is a compile-time check

      return std::is_base_of<FsLowPowerFeature,InternalFsPhy<Features...>>::value;
    }


    /**
     * Get the type of interface (embedded/ULPI)
     * @return PCD_PHY_EMBEDDED
     */

    template<class... Features>
    inline uint32_t InternalFsPhy<Features...>::getPhyInterface() const {
      return PCD_PHY_EMBEDDED;
    }


    /**
     * Get the interface speed
     * @return PCD_SPEED_FULL
     */

    template<class... Features>
    inline uint32_t InternalFsPhy<Features...>::getPhySpeed() const {
      return PCD_SPEED_FULL;
    }
  }
}

// END FILE: ../lib/include/usb/f4/phy/InternalFsPhy.h
// START FILE: ../lib/include/usb/f4/UsbEventDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

namespace stm32plus {
  namespace usb {

    /*
     * Base class for all USB events
     */

    struct UsbEventDescriptor {

      enum class EventType {
        DEVICE_INIT,
        DEVICE_DEINIT,
        DEVICE_START,
        DEVICE_STOP,
        DEVICE_OPEN_ENDPOINT,
        DEVICE_CLOSE_ENDPOINT,
        DEVICE_FLUSH_ENDPOINT,
        DEVICE_STALL_ENDPOINT,
        DEVICE_CLEAR_STALL_ENDPOINT,
        DEVICE_IS_STALL_ENDPOINT,
        DEVICE_SET_USB_ADDRESS,
        DEVICE_TRANSMIT,
        DEVICE_PREPARE_RECEIVE,
        DEVICE_GET_RX_DATA_SIZE,
        DEVICE_GET_DEVICE_DESCRIPTOR,
        DEVICE_GET_LANGUAGE_DESCRIPTOR,
        DEVICE_GET_STRING_DESCRIPTOR,

        DEVICE_IRQ_RESET,
        DEVICE_IRQ_SUSPEND,
        DEVICE_IRQ_RESUME,
        DEVICE_IRQ_SETUP_STAGE,
        DEVICE_IRQ_CONNECT,
        DEVICE_IRQ_DISCONNECT,
        DEVICE_IRQ_DATA_OUT_STAGE,
        DEVICE_IRQ_DATA_IN_STAGE,

        OTG_FS_INTERRUPT,

        CLASS_INIT,
        CLASS_DEINIT,
        CLASS_SETUP,
        CLASS_DATA_IN,
        CLASS_DATA_OUT,
        CLASS_EP0_READY,
        CLASS_SOF,
        CLASS_EP0_TX_SENT,
        CLASS_GET_CONFIGURATION_DESCRIPTOR,
        CLASS_GET_DEVICE_QUALIFIER_DESCRIPTOR,

        HID_KEYBOARD_LED_STATE,

        CDC_DATA_RECEIVED,
        CDC_CONTROL,

        MSC_BOT_GET_MAX_LUN,
        MSC_BOT_RESET,
        MSC_BOT_IS_READY,
        MSC_BOT_IS_WRITE_PROTECTED,
        MSC_BOT_READ,
        MSC_BOT_WRITE,
        MSC_BOT_GET_ENQUIRY_PAGE,
        MSC_BOT_GET_CAPACITY,

        USB_ERROR
      };

      EventType eventType;

      UsbEventDescriptor(EventType type)
        : eventType(type) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/UsbEventDescriptor.h
// START FILE: ../lib/include/usb/f4/device/Device.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * USB Device template. This is an intermediate template in the hierarchy. Inherits from UsbDeviceEventSource
     * to provide event subscription for device-specific events. Subclasses such as UsbHidDevice inherit from
     * this template to provide device-class specific functionality.
     */

    template<class TPhy>
    class Device : public Core<TPhy> {

      protected:
        PCD_HandleTypeDef _pcdHandle;
        USBD_HandleTypeDef _deviceHandle;
        USBD_DescriptorsTypeDef _deviceDescriptorCallbacks;
        scoped_ptr<LanguageDescriptor> _languageDescriptor;
        DeviceDescriptor _deviceDescriptor;
        DeviceQualifierDescriptor _qualifierDescriptor;
        scoped_array<uint16_t> _unicodeString;      // very basic 8-bit to UTF-16 holder
        uint8_t _numEndpoints;                      // endpoint classes will increment this

      public:

        /**
         * Error codes
         */

        enum {
          E_INIT = 1,
          E_START = 2,
          E_UNCONFIGURED = 3,
          E_BUSY = 4
        };


        /**
         * Parameters structure - device specific detail
         */

        struct Parameters : Core<TPhy>::Parameters {

          uint16_t device_vid;          // no default
          uint16_t device_pid;          // no default
          uint16_t device_usb_version;  // defaults to 0x0200 (USB 2.0)
          uint16_t device_version;      // your device version. default 01.00
          uint16_t device_id;           // this device id (default is 0)
          const uint16_t *device_language_ids;  // default is 0x0409
          uint16_t device_language_count;       // default is 1
          bool device_use_dedicated_endpoint1;  // default is false
          bool device_vbus_sensing;     // default is true
          uint32_t device_endpoint0_max_packet_size;  // default is 0x40

          Parameters() {

            static const uint16_t englishUs=0x0409;

            device_usb_version=0x0200;
            device_version=0x0100;
            device_id=0;
            device_use_dedicated_endpoint1=false;
            device_endpoint0_max_packet_size=0x40;
            device_vbus_sensing=true;
            device_language_ids=&englishUs;
            device_language_count=1;
          }
        };

        static Device<TPhy> *_instance;    // this is how the global callbacks get back in

      protected:
        void onEvent(UsbEventDescriptor& event);
        void onResetIrqEvent();
        void onGetDeviceQualifierDescriptor(DeviceClassSdkGetDeviceQualifierDescriptorEvent& event);

      public:
        Device();
        ~Device();

        bool initialise(Parameters& params);

        bool isConfigured() const;

        USBD_HandleTypeDef& getDeviceHandle();
        DeviceDescriptor& getDeviceDescriptor();
        PCD_HandleTypeDef& getPcdHandle();

        void incrementNumEndpoints();

        // re-entry points from the SDK

        uint8_t *onGetDeviceDescriptor(USBD_SpeedTypeDef speed,uint16_t *length);
        uint8_t *onGetLangIdStrDescriptor(USBD_SpeedTypeDef speed,uint16_t *length);
        uint8_t *onGetDisplayStrDescriptor(USBD_SpeedTypeDef speed,uint16_t *length,uint8_t stringIndex);
    };


    /*
     * Template static member initialisation
     */

    template<class TPhy>
    Device<TPhy> *Device<TPhy>::_instance=nullptr;


    /*
     * Internal global callbacks needed by the SDK device API
     */

    namespace usb_device_internal {

      template<class TPhy>
      inline uint8_t *GetDeviceDescriptor(USBD_SpeedTypeDef speed,uint16_t *length) {
        return Device<TPhy>::_instance->onGetDeviceDescriptor(speed,length);
      }

      template<class TPhy>
      inline uint8_t *GetLangIdStrDescriptor(USBD_SpeedTypeDef speed,uint16_t *length) {
        return Device<TPhy>::_instance->onGetLangIdStrDescriptor(speed,length);
      }

      template<class TPhy>
      inline uint8_t *GetManufacturerStrDescriptor(USBD_SpeedTypeDef speed,uint16_t *length) {
        return Device<TPhy>::_instance->onGetDisplayStrDescriptor(speed,length,USBD_IDX_MFC_STR);
      }

      template<class TPhy>
      inline uint8_t *GetProductStrDescriptor(USBD_SpeedTypeDef speed,uint16_t *length) {
        return Device<TPhy>::_instance->onGetDisplayStrDescriptor(speed,length,USBD_IDX_PRODUCT_STR);
      }

      template<class TPhy>
      inline uint8_t *GetSerialStrDescriptor(USBD_SpeedTypeDef speed,uint16_t *length) {
        return Device<TPhy>::_instance->onGetDisplayStrDescriptor(speed,length,USBD_IDX_SERIAL_STR);
      }

      template<class TPhy>
      inline uint8_t *GetConfigurationStrDescriptor(USBD_SpeedTypeDef speed,uint16_t *length) {
        return Device<TPhy>::_instance->onGetDisplayStrDescriptor(speed,length,USBD_IDX_CONFIG_STR);
      }

      template<class TPhy>
      inline uint8_t *GetInterfaceStrDescriptor(USBD_SpeedTypeDef speed,uint16_t *length) {
        return Device<TPhy>::_instance->onGetDisplayStrDescriptor(speed,length,USBD_IDX_INTERFACE_STR);
      }
    }


    /**
     * Constructor
     * @param params The parameters structure
     */

    template<class TPhy>
    inline Device<TPhy>::Device()
      : _pcdHandle(),
        _deviceHandle() {

      // static member initialisation

      _instance=this;

      // reset the endpoint counter

      _numEndpoints=0;

      // this is how the "LL" callbacks raise events

      _deviceHandle.pUserData=static_cast<UsbEventSource *>(this);

      // fill in the SDK device descriptor callbacks

      _deviceDescriptorCallbacks.GetDeviceDescriptor=usb_device_internal::GetDeviceDescriptor<TPhy>;
      _deviceDescriptorCallbacks.GetLangIDStrDescriptor=usb_device_internal::GetLangIdStrDescriptor<TPhy>;
      _deviceDescriptorCallbacks.GetManufacturerStrDescriptor=usb_device_internal::GetManufacturerStrDescriptor<TPhy>;
      _deviceDescriptorCallbacks.GetProductStrDescriptor=usb_device_internal::GetProductStrDescriptor<TPhy>;
      _deviceDescriptorCallbacks.GetSerialStrDescriptor=usb_device_internal::GetSerialStrDescriptor<TPhy>;
      _deviceDescriptorCallbacks.GetConfigurationStrDescriptor=usb_device_internal::GetConfigurationStrDescriptor<TPhy>;
      _deviceDescriptorCallbacks.GetInterfaceStrDescriptor=usb_device_internal::GetInterfaceStrDescriptor<TPhy>;

      // subscribe to USB events

      this->UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&Device<TPhy>::onEvent)
        );
    }


    /**
     * Initialise the class
     * @param params The parameters
     * @return true if it worked
     */

    template<class TPhy>
    bool Device<TPhy>::initialise(Parameters& params) {

      USBD_StatusTypeDef status;

      // initialise upwards

      if(!Core<TPhy>::initialise(params))
        return false;

      // set up the device descriptor

      _deviceDescriptor.bcdDevice=params.device_version;
      _deviceDescriptor.bcdUSB=params.device_usb_version;
      _deviceDescriptor.idVendor=params.device_vid;
      _deviceDescriptor.idProduct=params.device_pid;

      // set up the language descriptor

      _languageDescriptor.reset(new LanguageDescriptor(params.device_language_ids,params.device_language_count));

      // set up the PCD handle

      _pcdHandle.Instance=this->_phyRegisters;

      _pcdHandle.Init.dev_endpoints=_numEndpoints;
      _pcdHandle.Init.use_dedicated_ep1=params.device_use_dedicated_endpoint1 ? ENABLE : DISABLE;
      _pcdHandle.Init.ep0_mps=params.device_endpoint0_max_packet_size;
      _pcdHandle.Init.vbus_sensing_enable=params.device_vbus_sensing ? ENABLE : DISABLE;
      _pcdHandle.Init.dma_enable=this->phySupportsDma();
      _pcdHandle.Init.low_power_enable=this->phySupportsLowPower() ? ENABLE : DISABLE;
      _pcdHandle.Init.phy_itface=this->getPhyInterface();
      _pcdHandle.Init.Sof_enable=0;
      _pcdHandle.Init.speed=this->getPhySpeed();

      // link the driver to the stack

      _pcdHandle.pData=&_deviceHandle;
      _deviceHandle.pData=&_pcdHandle;

      // initialise SDK

      if((status=USBD_Init(&_deviceHandle,&_deviceDescriptorCallbacks,params.device_id))!=USBD_OK)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_USB_DEVICE,E_INIT,status);

      // both FS and HS PHYs manage a shared RX FIFO

      HAL_PCD_SetRxFiFo(&_pcdHandle,params.phy_rxFifoSize);
      return true;
    }


    /**
     * Check if this device is configured, i.e. connected to the host and fully
     * ready to use. Note that there is a race condition if you call this as a pre-check to
     * sending a report. Better to send the report and check the return value, ignoring errors
     * that indicate unconfigured.
     * @return true if the device is configured and ready to use
     */

    template<class TPhy>
    inline bool Device<TPhy>::isConfigured() const {
      return _deviceHandle.dev_state==USBD_STATE_CONFIGURED;
    }


    /**
     * Destructor
     */

    template<class TPhy>
    inline Device<TPhy>::~Device() {

      // unsubscribe from USB events

      this->UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&Device<TPhy>::onEvent)
        );
    }


    /**
     * Event handler for device events
     * @param event The event descriptor
     */

    template<class TPhy>
    inline void Device<TPhy>::onEvent(UsbEventDescriptor& event) {

      switch(event.eventType) {

        case UsbEventDescriptor::EventType::OTG_FS_INTERRUPT:
          HAL_PCD_IRQHandler(&_pcdHandle);    // handle the OTG interrupt
          break;

        case UsbEventDescriptor::EventType::DEVICE_INIT:
          static_cast<DeviceSdkNotifyEvent&>(event).retval=HAL_PCD_Init(&_pcdHandle);
          break;

        case UsbEventDescriptor::EventType::DEVICE_DEINIT:
          static_cast<DeviceSdkNotifyEvent&>(event).retval=HAL_PCD_DeInit(&_pcdHandle);
          break;

        case UsbEventDescriptor::EventType::DEVICE_SET_USB_ADDRESS:
          static_cast<DeviceSdkNotifyEvent&>(event).retval=HAL_PCD_SetAddress(&_pcdHandle,_deviceHandle.dev_address);
          break;

        case UsbEventDescriptor::EventType::DEVICE_START:
          static_cast<DeviceSdkNotifyEvent&>(event).retval=HAL_PCD_Start(&_pcdHandle);
          break;

        case UsbEventDescriptor::EventType::DEVICE_STOP:
          static_cast<DeviceSdkNotifyEvent&>(event).retval=HAL_PCD_Stop(&_pcdHandle);
          break;

        case UsbEventDescriptor::EventType::DEVICE_OPEN_ENDPOINT: {
            DeviceSdkOpenEndpointEvent& openEvent(static_cast<DeviceSdkOpenEndpointEvent&>(event));
            openEvent.retval=HAL_PCD_EP_Open(&_pcdHandle,openEvent.endpointAddress,openEvent.maximumPacketSize,static_cast<uint8_t>(openEvent.endpointType));
          }
          break;

        case UsbEventDescriptor::EventType::DEVICE_CLOSE_ENDPOINT: {
            DeviceSdkEndpointEvent& epEvent(static_cast<DeviceSdkEndpointEvent&>(event));
            epEvent.retval=HAL_PCD_EP_Close(&_pcdHandle,epEvent.endpointAddress);
          }
          break;

        case UsbEventDescriptor::EventType::DEVICE_FLUSH_ENDPOINT: {
            DeviceSdkEndpointEvent& epEvent(static_cast<DeviceSdkEndpointEvent&>(event));
            epEvent.retval=HAL_PCD_EP_Flush(&_pcdHandle,epEvent.endpointAddress);
          }
          break;

        case UsbEventDescriptor::EventType::DEVICE_STALL_ENDPOINT: {
            DeviceSdkEndpointEvent& epEvent(static_cast<DeviceSdkEndpointEvent&>(event));
            epEvent.retval=HAL_PCD_EP_SetStall(&_pcdHandle,epEvent.endpointAddress);
          }
          break;

        case UsbEventDescriptor::EventType::DEVICE_CLEAR_STALL_ENDPOINT: {
            DeviceSdkEndpointEvent& epEvent(static_cast<DeviceSdkEndpointEvent&>(event));
            epEvent.retval=HAL_PCD_EP_ClrStall(&_pcdHandle,epEvent.endpointAddress);
          }
          break;

        case UsbEventDescriptor::EventType::DEVICE_IS_STALL_ENDPOINT: {
            DeviceSdkIsStalledEndpointEvent& epEvent(static_cast<DeviceSdkIsStalledEndpointEvent&>(event));

            if((epEvent.endpointAddress & 0x80)==0x80)
              epEvent.isStalled=_pcdHandle.IN_ep[epEvent.endpointAddress & 0x7F].is_stall;
            else
              epEvent.isStalled=_pcdHandle.OUT_ep[epEvent.endpointAddress & 0x7F].is_stall;
          }
          break;

        case UsbEventDescriptor::EventType::DEVICE_TRANSMIT: {
            DeviceSdkDataEndpointEvent& dataEvent(static_cast<DeviceSdkDataEndpointEvent&>(event));
            dataEvent.retval=HAL_PCD_EP_Transmit(&_pcdHandle,dataEvent.endpointAddress,dataEvent.data,dataEvent.size);
          }
          break;

        case UsbEventDescriptor::EventType::DEVICE_PREPARE_RECEIVE: {
            DeviceSdkDataEndpointEvent& dataEvent(static_cast<DeviceSdkDataEndpointEvent&>(event));
            dataEvent.retval=HAL_PCD_EP_Receive(&_pcdHandle,dataEvent.endpointAddress,dataEvent.data,dataEvent.size);
          }
          break;

        case UsbEventDescriptor::EventType::DEVICE_GET_RX_DATA_SIZE: {
            DeviceSdkGetLastTransferredSizeEndpointEvent& dataEvent(static_cast<DeviceSdkGetLastTransferredSizeEndpointEvent&>(event));
            dataEvent.lastTransferred=HAL_PCD_EP_GetRxCount(&_pcdHandle,dataEvent.endpointAddress);
          }
          break;

        case UsbEventDescriptor::EventType::DEVICE_IRQ_RESET:
          onResetIrqEvent();
          break;

        case UsbEventDescriptor::EventType::DEVICE_IRQ_SUSPEND:
          USBD_LL_Suspend(&_deviceHandle);
          break;

        case UsbEventDescriptor::EventType::DEVICE_IRQ_RESUME:
          USBD_LL_Resume(&_deviceHandle);
          break;

        case UsbEventDescriptor::EventType::DEVICE_IRQ_SETUP_STAGE:
          USBD_LL_SetupStage(&_deviceHandle,reinterpret_cast<uint8_t *>(_pcdHandle.Setup));
          break;

        case UsbEventDescriptor::EventType::DEVICE_IRQ_CONNECT:
          USBD_LL_DevConnected(&_deviceHandle);
          break;

        case UsbEventDescriptor::EventType::DEVICE_IRQ_DISCONNECT:
          USBD_LL_DevDisconnected(&_deviceHandle);
          break;

        case UsbEventDescriptor::EventType::DEVICE_IRQ_DATA_IN_STAGE: {
            uint8_t endpointNumber=static_cast<DeviceSdkDataInStageInterruptEvent&>(event).endpointNumber;
            USBD_LL_DataInStage(&_deviceHandle,endpointNumber,_pcdHandle.IN_ep[endpointNumber].xfer_buff);
          }
          break;

        case UsbEventDescriptor::EventType::DEVICE_IRQ_DATA_OUT_STAGE: {
            uint8_t endpointNumber=static_cast<DeviceSdkDataOutStageInterruptEvent&>(event).endpointNumber;
            USBD_LL_DataOutStage(&_deviceHandle,endpointNumber,_pcdHandle.OUT_ep[endpointNumber].xfer_buff);
          }
          break;

        case UsbEventDescriptor::EventType::CLASS_GET_DEVICE_QUALIFIER_DESCRIPTOR:
          onGetDeviceQualifierDescriptor(static_cast<DeviceClassSdkGetDeviceQualifierDescriptorEvent&>(event));
          break;

        default:
          break;
      }
    }


    /**
     * Get the device qualifier descriptor
     * @param event The event class to receive the descriptor pointer
     */

    template<class TPhy>
    inline void Device<TPhy>::onGetDeviceQualifierDescriptor(DeviceClassSdkGetDeviceQualifierDescriptorEvent& event) {

      event.descriptor=&_qualifierDescriptor;
      event.length=sizeof(_qualifierDescriptor);
    }


    /**
     * USB reset IRQ handler
     */

    template<class TPhy>
    inline void Device<TPhy>::onResetIrqEvent() {

      USBD_SpeedTypeDef speed;

      switch(_pcdHandle.Init.speed) {

        case PCD_SPEED_HIGH:
          speed = USBD_SPEED_HIGH;
          break;

        case PCD_SPEED_FULL:
          speed=USBD_SPEED_FULL;
          break;

        default:
          speed=USBD_SPEED_FULL;
          break;
      }

      // set the speed and reset

      USBD_LL_SetSpeed(&_deviceHandle,speed);
      USBD_LL_Reset(&_deviceHandle);
    }


    /**
     * Get the USB device descriptor (SDK callback). This happens when connected. An event is raised that
     * allows the caller to modify the device descriptor dynamically based on the speed of the connection
     * @param speed The connection speed
     * @param length Will get set to 18
     * @return The device descriptor pointer
     */

    template<class TPhy>
    inline uint8_t *Device<TPhy>::onGetDeviceDescriptor(USBD_SpeedTypeDef speed,uint16_t *length) {

      // give anyone a chance to change the descriptor based on the connection speed

      this->UsbEventSender.raiseEvent(DeviceGetDeviceDescriptorEvent(speed,_deviceDescriptor));

      // return the descriptor

      *length=USB_LEN_DEV_DESC;
      return reinterpret_cast<uint8_t *>(&_deviceDescriptor);
    }


    /**
     * Get the USB language descriptor (SDK callback). This happens when connected. An event is raised that
     * allows the caller to modify the language descriptor dynamically.
     * @param speed The connection speed
     * @param length Will get set to 18
     * @return The device descriptor pointer
     */

    template<class TPhy>
    inline uint8_t *Device<TPhy>::onGetLangIdStrDescriptor(USBD_SpeedTypeDef speed,uint16_t *length) {

      // give anyone a chance to change the descriptor based on the connection speed

      this->UsbEventSender.raiseEvent(DeviceGetLanguageDescriptorEvent(speed,*_languageDescriptor));

      // return the descriptor

      *length=_languageDescriptor->getDescriptor()[0];
      return _languageDescriptor->getDescriptor();
    }


    /**
     * Get the USB language descriptor (SDK callback). This happens when connected. An event is raised that
     * allows the caller to modify the language descriptor dynamically.
     * @param speed The connection speed
     * @param length Will get set to 18
     * @return The device descriptor pointer
     */

    template<class TPhy>
    inline uint8_t *Device<TPhy>::onGetDisplayStrDescriptor(USBD_SpeedTypeDef speed,uint16_t *length,uint8_t stringIndex) {

      DeviceGetDisplayStringDescriptorEvent event(speed,stringIndex);

      // send the event that will be picked up by one of the feature classes that implements
      // the required string

      this->UsbEventSender.raiseEvent(event);

      // subscriber sets these, or if not that's OK too

      *length=event.length;
      return event.descriptor;
    }


    /**
     * Get the device handle
     * @return a reference to the SDK device handle
     */

    template<class TPhy>
    inline USBD_HandleTypeDef& Device<TPhy>::getDeviceHandle() {
      return _deviceHandle;
    }


    /**
     * Get the PCD handle
     * @return a reference to the SDK PCD handle
     */

    template<class TPhy>
    inline PCD_HandleTypeDef& Device<TPhy>::getPcdHandle() {
      return _pcdHandle;
    }


    /**
     * Increment the number of endpoints by 1
     */

    template<class TPhy>
    inline void Device<TPhy>::incrementNumEndpoints() {
      _numEndpoints++;
    }


    /**
     * Get the device descriptor reference
     * @return The device descriptor
     */

    template<class TPhy>
    inline DeviceDescriptor& Device<TPhy>::getDeviceDescriptor() {
      return _deviceDescriptor;
    }


    namespace usb_device_internal {

      /*
       * Helpers to dispatch events that have common parameters
       */

      inline USBD_StatusTypeDef notifyEvent(USBD_HandleTypeDef *pdev,UsbEventDescriptor::EventType eventType) {

        DeviceSdkNotifyEvent event(eventType);

        reinterpret_cast<UsbEventSource *>(pdev->pUserData)->UsbEventSender.raiseEvent(event);
        return event.retval;
      }

      inline USBD_StatusTypeDef endpointEvent(USBD_HandleTypeDef *pdev,UsbEventDescriptor::EventType eventType,uint8_t ep_addr) {

        DeviceSdkEndpointEvent event(eventType,ep_addr);

        reinterpret_cast<UsbEventSource *>(pdev->pUserData)->UsbEventSender.raiseEvent(event);
        return event.retval;
      }
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/Device.h
// START FILE: ../lib/include/usb/f4/device/ConfigurationDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB configuration descriptor
     */

    struct ConfigurationDescriptor {

      enum {
        SELF_POWERED = 0x40,
        REMOTE_WAKEUP = 0x20
      };

      DescriptorHeader header;

      uint16_t wTotalLength;       // Total length in bytes of data returned
      uint8_t bNumInterfaces;      // Number of Interfaces
      uint8_t bConfigurationValue; // Value to use as an argument to select this configuration
      uint8_t iConfiguration;      // Index of String Descriptor describing this configuration
      uint8_t bmAttributes;        // D7 Reserved, set to 1. (USB 1.0 Bus Powered) D6 Self Powered. D5 Remote Wakeup. D4..0 Reserved, set to 0.
      uint8_t bMaxPower;           // Maximum Power Consumption in 2mA units

      ConfigurationDescriptor()
        : header(sizeof(ConfigurationDescriptor),USB_DESC_TYPE_CONFIGURATION) {

        // defaults for some

        bConfigurationValue=1;
        iConfiguration=0;
        bmAttributes=0x80 | SELF_POWERED | REMOTE_WAKEUP;
        bMaxPower=0x32;             // 100mA

        static_assert(sizeof(ConfigurationDescriptor)==9,"Compiler error: sizeof(ConfigurationDescriptor)!=9");
      }
    } __attribute__((packed));
  }
}


// END FILE: ../lib/include/usb/f4/device/ConfigurationDescriptor.h
// START FILE: ../lib/include/usb/f4/device/DeviceClass.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * A non-exhaustive list of device class codes
     */

    enum class DeviceClass : uint8_t {
      AUDIO = 0x1,
      COMMUNICATIONS_CDC_CONTROL = 0x2,
      HID = 0x3,
      PHYSICAL = 0x5,
      IMAGE = 0x6,
      PRINTER = 0x7,
      MASS_STORAGE = 0x8,
      HUB = 0x9,
      CDC_DATA
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/DeviceClass.h
// START FILE: ../lib/include/usb/f4/device/hid/KeyboardReportDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * The mouse report descriptor bytes
     */

    extern const uint8_t KeyboardReportDescriptor[63];
  }
}

// END FILE: ../lib/include/usb/f4/device/hid/KeyboardReportDescriptor.h
// START FILE: ../lib/include/usb/f4/device/hid/MouseHidDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Endpoint used by this device
     */

    template<class TDevice> using MouseHidDeviceEndpoint1=InterruptInEndpointFeature<1,TDevice>;

    /**
     * Declare the structure that gets sent back when the host asks for the whole
     * configuration descriptor
     */

    struct MouseConfigurationDescriptor {
      ConfigurationDescriptor configuration;
      InterfaceDescriptor interface;
      HidClassDescriptor hid;
      EndpointDescriptor endpoint;
    } __attribute__((packed));

    /**
     * Derivation of HidDevice to handle a HID mouse. This device type declares the following:
     *   1x Configuration descriptor
     *   1x Interface
     *   1x Inbound interrupt endpoint
     *
     * The 3-byte HID report is for a simple 3-button mouse using the BOOT protocol. The format
     * of the 3-bytes is:
     *
     *  0: B7..3=unused. B2=left button. B1=middle button. B0=right button.
     *  1: X-axis relative movement as signed integer.
     *  2: Y-axis relative movement as signed integer.
     */

    template<class TPhy,template <class> class... Features>
    class MouseHidDevice : public HidDevice<TPhy,
                                            MouseConfigurationDescriptor,
                                            MouseHidDeviceEndpoint1,
                                            Features...> {

      protected:

        typedef HidDevice<TPhy,
                          MouseConfigurationDescriptor,
                          MouseHidDeviceEndpoint1,
                          Features...> HidDeviceBase;

        /**
         * Constants
         */

        enum {
          MOUSE_HID_REPORT_SIZE = 3
        };


      public:

        /**
         * Customisable parameters for this HID device
         */

        struct Parameters : HidDeviceBase::Parameters {

          uint8_t hid_mouse_poll_interval;      // default is 10

          Parameters() {
            hid_mouse_poll_interval = 10;
          }
        };

      protected:
        void onEvent(UsbEventDescriptor& event);

        void onHidInit();
        void onHidDeInit();
        void onHidGetConfigurationDescriptor(DeviceClassSdkGetConfigurationDescriptorEvent& event);

      public:
        MouseHidDevice();
        ~MouseHidDevice();

        bool initialise(Parameters& params);

        bool sendMouseReport(uint8_t buttons,int8_t x,int8_t y);
        bool isTransmitting() const;
    };


    /**
     * Constructor
     */

    template<class TPhy,template <class> class... Features>
    inline MouseHidDevice<TPhy,Features...>::MouseHidDevice()
      : HidDeviceBase(MouseReportDescriptor,sizeof(MouseReportDescriptor)) {

      // subscribe to USB events

      this->UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&MouseHidDevice<TPhy,Features...>::onEvent)
        );
    }


    /**
     * Destructor
     */

    template<class TPhy,template <class> class... Features>
    inline MouseHidDevice<TPhy,Features...>::~MouseHidDevice() {

      // unsubscribe from USB events

      this->UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&MouseHidDevice<TPhy,Features...>::onEvent)
        );
    }


    /**
     * Initialise the class
     * @param param The parameters structure
     * @return true if it worked
     */

    template<class TPhy,template <class> class... Features>
    inline bool MouseHidDevice<TPhy,Features...>::initialise(Parameters& params) {

      USBD_StatusTypeDef status;

      // initialise upwards

      if(!HidDeviceBase::initialise(params))
        return false;

      // set up the configuration descriptor (see constructor for defaults)

      this->_configurationDescriptor.configuration.wTotalLength=sizeof(this->_configurationDescriptor);
      this->_configurationDescriptor.configuration.bNumInterfaces=1;

      // if ConfigurationTextFeature is in the hierarchy then we've got a configuration string (compile-time check)

      if(std::is_base_of<ConfigurationTextFeature<Device<TPhy>>,MouseHidDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.configuration.iConfiguration=USBD_IDX_CONFIG_STR;

      // set up the interface descriptor (see constructor for defaults)

      this->_configurationDescriptor.interface.bInterfaceNumber=0;
      this->_configurationDescriptor.interface.bNumEndpoints=1;
      this->_configurationDescriptor.interface.bInterfaceClass=static_cast<uint8_t>(DeviceClass::HID);
      this->_configurationDescriptor.interface.bInterfaceSubClass=static_cast<uint8_t>(HidSubClass::BOOT);
      this->_configurationDescriptor.interface.bInterfaceProtocol=static_cast<uint8_t>(HidProtocol::MOUSE);

      // if InterfaceTextFeature is in the hierarchy then we've got an interface string (compile-time check)

      if(std::is_base_of<InterfaceTextFeature<Device<TPhy>>,MouseHidDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.interface.iInterface=USBD_IDX_INTERFACE_STR;

      // set up the hid class descriptor (see constructor for defaults)

      this->_configurationDescriptor.hid.bNumDescriptors=1;
      this->_configurationDescriptor.hid.wItemLength=sizeof(MouseReportDescriptor);

      // set up the endpoint descriptor

      this->_configurationDescriptor.endpoint.bEndpointAddress=EndpointDescriptor::IN | 1;
      this->_configurationDescriptor.endpoint.bmAttributes=EndpointDescriptor::INTERRUPT;
      this->_configurationDescriptor.endpoint.wMaxPacketSize=MOUSE_HID_REPORT_SIZE;       // mouse reports are 3 bytes
      this->_configurationDescriptor.endpoint.bInterval=params.hid_mouse_poll_interval;   // default is 10 frames

      // set up the qualifier descriptor (see constructor for defaults)

      this->_qualifierDescriptor.bMaxPacketSize0=0x40;
      this->_qualifierDescriptor.bNumConfigurations=1;

      // start the device

      if((status=USBD_Start(&this->_deviceHandle))!=USBD_OK)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_USB_DEVICE,this->E_START,status);

      // OK

      return true;
    }


    /**
     * Event handler for device events
     * @param event The event descriptor
     */

    template<class TPhy,template <class> class... Features>
    inline void MouseHidDevice<TPhy,Features...>::onEvent(UsbEventDescriptor& event) {

      switch(event.eventType) {

        case UsbEventDescriptor::EventType::CLASS_INIT:
          onHidInit();
          break;

        case UsbEventDescriptor::EventType::CLASS_DEINIT:
          onHidDeInit();
          break;

        case UsbEventDescriptor::EventType::CLASS_GET_CONFIGURATION_DESCRIPTOR:
          onHidGetConfigurationDescriptor(static_cast<DeviceClassSdkGetConfigurationDescriptorEvent&>(event));
          break;

        default:
          break;
      }
    }


    /**
     * HID initialisation
     */

    template<class TPhy,template <class> class... Features>
    inline void MouseHidDevice<TPhy,Features...>::onHidInit() {

      USBD_LL_OpenEP(&this->_deviceHandle,EndpointDescriptor::IN | 1,EndpointDescriptor::INTERRUPT,MOUSE_HID_REPORT_SIZE);
    }


    /**
     * De-initialise the HID device
     */

    template<class TPhy,template <class> class... Features>
    inline void MouseHidDevice<TPhy,Features...>::onHidDeInit() {

      // close the endpoint

      USBD_LL_CloseEP(&this->_deviceHandle,EndpointDescriptor::IN | 1);
    }


    /**
     * Get the configuration descriptor
     * @param event The event class to receive the descriptor and provide type of descriptor being requested
     */

    template<class TPhy,template <class> class... Features>
    inline void MouseHidDevice<TPhy,Features...>::onHidGetConfigurationDescriptor(DeviceClassSdkGetConfigurationDescriptorEvent& event) {

      if(event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::HIGH_SPEED ||
         event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::FULL_SPEED ||
         event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::OTHER_SPEED) {

        // set up the values in the event

        event.length=sizeof(this->_configurationDescriptor);
        event.descriptor=reinterpret_cast<uint8_t *>(&this->_configurationDescriptor);
      }
    }


    /**
     * Send a 3-byte HID report to the host
     * @param data The data to send
     * @return true if it worked
     */

    template<class TPhy,template <class> class... Features>
    inline bool MouseHidDevice<TPhy,Features...>::sendMouseReport(uint8_t buttons,int8_t x,int8_t y) {

      // data must remain in scope until IRQ indicates transmission complete

      static uint8_t data[3];

      data[0]=buttons;
      data[1]=x;
      data[2]=y;

      // wait for any previous send to complete

      while(isTransmitting());

      // send the report

      return static_cast<MouseHidDeviceEndpoint1<Device<TPhy>>&>(*this).transmit(data,MOUSE_HID_REPORT_SIZE);
    }


    /**
     * Check if is transmitting
     * @return true if is transmitting
     */

    template<class TPhy,template <class> class... Features>
    inline bool MouseHidDevice<TPhy,Features...>::isTransmitting() const {
      return static_cast<const MouseHidDeviceEndpoint1<Device<TPhy>>&>(*this).isTransmitting();
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/hid/MouseHidDevice.h
// START FILE: ../lib/include/usb/f4/device/hid/events/HidKeyboardLedStateEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Sent by the device to the application to notify it that the state of the LEDs
     * on the HID keyboard has changed. Methods are provided to test the bits that
     * map to the individual LEDs
     */

    struct HidKeyboardLedStateEvent : UsbEventDescriptor {

      uint8_t status;

      HidKeyboardLedStateEvent(uint8_t s)
        : UsbEventDescriptor(EventType::HID_KEYBOARD_LED_STATE),
          status(s) {
      }


      /**
       * Check for num lock
       * @return true if set
       */

      bool isNumLock() const {
        return (status & 1)!=0;
      }


      /**
       * Check for caps lock
       * @return true if set
       */

      bool isCapsLock() const {
        return (status & 2)!=0;
      }


      /**
       * Check for scroll lock
       * @return true if set
       */

      bool isScrollLock() const {
        return (status & 4)!=0;
      }


      /**
       * Check for compose
       * @return true if set
       */

      bool isCompose() const {
        return (status & 8)!=0;
      }


      /**
       * Check for kana
       * @return true if set
       */

      bool isKana() const {
        return (status & 16)!=0;
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/hid/events/HidKeyboardLedStateEvent.h
// START FILE: ../lib/include/usb/f4/device/hid/KeyboardHidDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Endpoints used by this device
     */

    template<class TDevice> using KeyboardHidDeviceKeysEndpoint=InterruptInEndpointFeature<1,TDevice>;
    template<class TDevice> using KeyboardHidDeviceLedsEndpoint=InterruptOutEndpointFeature<2,TDevice>;

    /**
     * Declare the structure that gets sent back when the host asks for the whole
     * configuration descriptor
     */

    struct KeyboardConfigurationDescriptor {
      ConfigurationDescriptor configuration;
      InterfaceDescriptor interface;
      HidClassDescriptor hid;
      EndpointDescriptor inEndpoint;
      EndpointDescriptor outEndpoint;
    } __attribute__((packed));

    /**
     * Derivation of HidDevice to handle a HID keyboard using the BOOT protocol. This device type
     * declares the following:
     *
     *   1x Configuration descriptor
     *   1x Interface
     *   1x Inbound interrupt endpoint (key presses inbound to the host)
     *   1x Outbound interrupt endpoint (LED status outbound from the host)
     *
     * The 8-byte report sent to the host has the following format:
     *
     *          Bit7      Bit6      Bit5        Bit4       Bit3     Bit2     Bit1       Bit0
     *   Byte0  Right GUI Right Alt Right Shift Right Ctrl Left GUI Left Alt Left Shift Left Ctrl
     *   Byte1                                     Reserved
     *   Byte2                                   Key_array[0]
     *   Byte3                                   Key_array[1]
     *   Byte4                                   Key_array[2]
     *   Byte5                                   Key_array[3]
     *   Byte6                                   Key_array[4]
     *   Byte7                                   Key_array[5]
     *
     * The 1-byte sent by the host to this device has the following format:
     *
     *         Bit7  Bit6  Bit5  Bit4  Bit3     Bit2        Bit1       Bit0
     *   Byte0                   Kana  Compose  Scroll Lock Caps Lock  Num Lock
     */

     template<class TPhy,template <class> class... Features>
     class KeyboardHidDevice : public HidDevice<TPhy,
                                               KeyboardConfigurationDescriptor,
                                               KeyboardHidDeviceKeysEndpoint,
                                               KeyboardHidDeviceLedsEndpoint,
                                               Features...> {

       public:

         typedef HidDevice<TPhy,
                           KeyboardConfigurationDescriptor,
                           KeyboardHidDeviceKeysEndpoint,
                           KeyboardHidDeviceLedsEndpoint,
                           Features...> HidDeviceBase;

         /**
          * Constants
          */

         enum {
           KEYBOARD_HID_KEYS_REPORT_SIZE = 8,    // must be 8 to be accepted by BOOT protocol
           KEYBOARD_HID_LED_REPORT_SIZE = 1
         };


         /**
          * Customisable parameters for this HID device
          */

         struct Parameters : HidDeviceBase::Parameters {

           uint8_t hid_keyboard_in_poll_interval;     // default is 10
           uint8_t hid_keyboard_out_poll_interval;    // default is 10

           Parameters() {
             hid_keyboard_in_poll_interval=10;
             hid_keyboard_out_poll_interval=10;
           }
         };

      protected:
        uint8_t _outReportBuffer[KEYBOARD_HID_LED_REPORT_SIZE];

      protected:
        void onEvent(UsbEventDescriptor& event);

        void onHidInit();
        void onHidDeInit();
        void onHidSetup(DeviceClassSdkSetupEvent& event);
        void onHidGetConfigurationDescriptor(DeviceClassSdkGetConfigurationDescriptorEvent& event);
        void onHidDataOut();
        void onHidEp0RxReady();

      public:
        KeyboardHidDevice();
        ~KeyboardHidDevice();

        bool initialise(Parameters& params);

        bool sendKeyboardReport(uint8_t key,uint8_t modifiers=0);
        bool isTransmitting() const;
    };


    /**
     * Constructor
     */

    template<class TPhy,template <class> class... Features>
    inline KeyboardHidDevice<TPhy,Features...>::KeyboardHidDevice()
      : HidDeviceBase(KeyboardReportDescriptor,sizeof(KeyboardReportDescriptor)) {

      // subscribe to USB events

      this->UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&KeyboardHidDevice<TPhy,Features...>::onEvent)
        );
    }


    /**
     * Destructor
     */

    template<class TPhy,template <class> class... Features>
    inline KeyboardHidDevice<TPhy,Features...>::~KeyboardHidDevice() {

      // unsubscribe from USB events

      this->UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&KeyboardHidDevice<TPhy,Features...>::onEvent)
        );
    }


    /**
     * Initialise the class
     * @param param The parameters structure
     * @return true if it worked
     */

    template<class TPhy,template <class> class... Features>
    inline bool KeyboardHidDevice<TPhy,Features...>::initialise(Parameters& params) {

      USBD_StatusTypeDef status;

      // initialise upwards

      if(!HidDeviceBase::initialise(params))
        return false;

      // set up the configuration descriptor (see constructor for defaults)

      this->_configurationDescriptor.configuration.wTotalLength=sizeof(this->_configurationDescriptor);
      this->_configurationDescriptor.configuration.bNumInterfaces=1;

      // if ConfigurationTextFeature is in the hierarchy then we've got a configuration string (compile-time check)

      if(std::is_base_of<ConfigurationTextFeature<Device<TPhy>>,KeyboardHidDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.configuration.iConfiguration=USBD_IDX_CONFIG_STR;

      // set up the interface descriptor (see constructor for defaults)

      this->_configurationDescriptor.interface.bInterfaceNumber=0;
      this->_configurationDescriptor.interface.bNumEndpoints=2;
      this->_configurationDescriptor.interface.bInterfaceClass=static_cast<uint8_t>(DeviceClass::HID);
      this->_configurationDescriptor.interface.bInterfaceSubClass=static_cast<uint8_t>(HidSubClass::BOOT);
      this->_configurationDescriptor.interface.bInterfaceProtocol=static_cast<uint8_t>(HidProtocol::KEYBOARD);

      // if InterfaceTextFeature is in the hierarchy then we've got an interface string (compile-time check)

      if(std::is_base_of<InterfaceTextFeature<Device<TPhy>>,KeyboardHidDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.interface.iInterface=USBD_IDX_INTERFACE_STR;

      // set up the hid class descriptor (see constructor for defaults)

      this->_configurationDescriptor.hid.bNumDescriptors=1;
      this->_configurationDescriptor.hid.wItemLength=sizeof(KeyboardReportDescriptor);

      // set up the IN endpoint descriptor

      this->_configurationDescriptor.inEndpoint.bEndpointAddress=EndpointDescriptor::IN | 1;
      this->_configurationDescriptor.inEndpoint.bmAttributes=EndpointDescriptor::INTERRUPT;
      this->_configurationDescriptor.inEndpoint.wMaxPacketSize=KEYBOARD_HID_KEYS_REPORT_SIZE;    // key reports are 8 bytes
      this->_configurationDescriptor.inEndpoint.bInterval=params.hid_keyboard_in_poll_interval;  // default is 10ms

      // set up the OUT endpoint descriptor

      this->_configurationDescriptor.outEndpoint.bEndpointAddress=EndpointDescriptor::OUT | 2;
      this->_configurationDescriptor.outEndpoint.bmAttributes=EndpointDescriptor::INTERRUPT;
      this->_configurationDescriptor.outEndpoint.wMaxPacketSize=KEYBOARD_HID_LED_REPORT_SIZE;         // LED reports are 1 byte
      this->_configurationDescriptor.outEndpoint.bInterval=params.hid_keyboard_out_poll_interval;     // default is 10ms

      // set up the qualifier descriptor (see constructor for defaults)

      this->_qualifierDescriptor.bMaxPacketSize0=0x40;
      this->_qualifierDescriptor.bNumConfigurations=1;

      // start the device

      if((status=USBD_Start(&this->_deviceHandle))!=USBD_OK)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_USB_DEVICE,this->E_START,status);

      // OK

      return true;
    }


    /**
     * Event handler for device events
     * @param event The event descriptor
     */

    template<class TPhy,template <class> class... Features>
    inline void KeyboardHidDevice<TPhy,Features...>::onEvent(UsbEventDescriptor& event) {

      switch(event.eventType) {

        case UsbEventDescriptor::EventType::CLASS_INIT:
          onHidInit();
          break;

        case UsbEventDescriptor::EventType::CLASS_DEINIT:
          onHidDeInit();
          break;

        case UsbEventDescriptor::EventType::CLASS_DATA_OUT:
          onHidDataOut();
          break;

        case UsbEventDescriptor::EventType::CLASS_EP0_READY:
          onHidEp0RxReady();
          break;

        case UsbEventDescriptor::EventType::CLASS_GET_CONFIGURATION_DESCRIPTOR:
          onHidGetConfigurationDescriptor(static_cast<DeviceClassSdkGetConfigurationDescriptorEvent&>(event));
          break;

        case UsbEventDescriptor::EventType::CLASS_SETUP:
          onHidSetup(static_cast<DeviceClassSdkSetupEvent&>(event));
          break;

        default:
          break;
      }
    }


    /**
     * HID initialisation
     */

    template<class TPhy,template <class> class... Features>
    inline void KeyboardHidDevice<TPhy,Features...>::onHidInit() {

      USBD_LL_OpenEP(&this->_deviceHandle,EndpointDescriptor::IN | 1,EndpointDescriptor::INTERRUPT,KEYBOARD_HID_KEYS_REPORT_SIZE);
      USBD_LL_OpenEP(&this->_deviceHandle,EndpointDescriptor::OUT | 2,EndpointDescriptor::INTERRUPT,KEYBOARD_HID_LED_REPORT_SIZE);

      // prepare OUT endpoint to receive the first packet

      USBD_LL_PrepareReceive(&this->_deviceHandle,EndpointDescriptor::OUT | 2,_outReportBuffer,sizeof(_outReportBuffer));
    }


    /**
     * De-initialise the HID device
     */

    template<class TPhy,template <class> class... Features>
    inline void KeyboardHidDevice<TPhy,Features...>::onHidDeInit() {

      // close endpoints

      USBD_LL_CloseEP(&this->_deviceHandle,EndpointDescriptor::IN | 1);
      USBD_LL_CloseEP(&this->_deviceHandle,EndpointDescriptor::OUT | 2);
    }


    /**
     * Get the configuration descriptor
     * @param event The event class to receive the descriptor and provide type of descriptor being requested
     */

    template<class TPhy,template <class> class... Features>
    inline void KeyboardHidDevice<TPhy,Features...>::onHidGetConfigurationDescriptor(DeviceClassSdkGetConfigurationDescriptorEvent& event) {

      if(event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::HIGH_SPEED ||
         event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::FULL_SPEED ||
         event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::OTHER_SPEED) {

        // set up the values in the event

        event.length=sizeof(this->_configurationDescriptor);
        event.descriptor=reinterpret_cast<uint8_t *>(&this->_configurationDescriptor);
      }
    }


    /**
     * Data out event
     */

    template<class TPhy,template <class> class... Features>
    inline void KeyboardHidDevice<TPhy,Features...>::onHidDataOut() {

      // fire the LED state event

      this->UsbEventSender.raiseEvent(HidKeyboardLedStateEvent(_outReportBuffer[0]));

      // call the prepare-receive method to initiate the next read

      USBD_LL_PrepareReceive(
          &this->_deviceHandle,
          EndpointDescriptor::OUT | 2,
          _outReportBuffer,
          sizeof(_outReportBuffer));
    }


    /**
     * Control endpoint ready handler
     */

    template<class TPhy,template <class> class... Features>
    inline void KeyboardHidDevice<TPhy,Features...>::onHidEp0RxReady() {

      // has a report arrived?

      if(this->_isReportAvailable) {

        // send the data event

        DeviceClassSdkDataOutEvent event(EndpointDescriptor::OUT | 2);
        this->UsbEventSender.raiseEvent(event);

        // clear the available flag

        this->_isReportAvailable=false;
      }
    }


    /**
     * Handle the HID setup requests
     * @param event the event containg value being requested
     */

    template<class TPhy,template <class> class... Features>
    inline void KeyboardHidDevice<TPhy,Features...>::onHidSetup(DeviceClassSdkSetupEvent& event) {

      // check for fail

      if(event.status!=USBD_OK)
        return;

      // process the setup event handled here

      if((event.request.bmRequest & USB_REQ_TYPE_MASK)==USB_REQ_TYPE_CLASS) {

        switch(static_cast<HidClassRequestType>(event.request.bRequest)) {

          case HidClassRequestType::SET_REPORT:
            this->_isReportAvailable=true;
            USBD_CtlPrepareRx(&this->_deviceHandle,_outReportBuffer,event.request.wLength);
            break;

          case HidClassRequestType::GET_REPORT:
            break;

          default:
            break;
        }
      }
    }


    /**
     * Send a single keycode to the host with optional modifiers. The keycode is a USB keycode,
     * not an ASCII character.
     * send the zero report that indicates the key has been released
     * @param key The key to send
     * @param modifiers The state of the modifier keys
     * @return true if it worked
     */

    template<class TPhy,template <class> class... Features>
    inline bool KeyboardHidDevice<TPhy,Features...>::sendKeyboardReport(uint8_t key,uint8_t modifiers) {

      // data must remain in scope until IRQ indicates transmission complete

      static uint8_t report[KEYBOARD_HID_KEYS_REPORT_SIZE];

      report[1]=report[3]=report[4]=report[5]=report[6]=report[7]='\0';
      report[0]=modifiers;
      report[2]=key;

      KeyboardHidDeviceKeysEndpoint<Device<TPhy>>& endpoint=static_cast<KeyboardHidDeviceKeysEndpoint<Device<TPhy>>&>(*this);

      // wait for previous send to complete by IRQ notification

      while(isTransmitting());

      // send the actual report

      if(!endpoint.transmit(report,KEYBOARD_HID_KEYS_REPORT_SIZE))
        return false;

      // send the zero report

      report[0]=report[2]='\0';

      // wait for the IRQ to reset the busy flag

      while(isTransmitting());

      // send the zero report (key up)

      return endpoint.transmit(report,KEYBOARD_HID_KEYS_REPORT_SIZE);
    }


    /**
     * Check if is transmitting
     * @return true if is transmitting
     */

    template<class TPhy,template <class> class... Features>
    inline bool KeyboardHidDevice<TPhy,Features...>::isTransmitting() const {
      return static_cast<const KeyboardHidDeviceKeysEndpoint<Device<TPhy>>&>(*this).isTransmitting();
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/hid/KeyboardHidDevice.h
// START FILE: ../lib/include/usb/f4/device/hid/HidProtocol.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Protocol types for HID devices
     */

    enum class HidProtocol : uint8_t {
      NONE      = 0,        //!< NONE
      KEYBOARD  = 1,        //!< KEYBOARD
      MOUSE     = 2         //!< MOUSE
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/hid/HidProtocol.h
// START FILE: ../lib/include/usb/f4/device/hid/HidClassDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB HID class descriptor
     */

    struct HidClassDescriptor {

      /**
       * HID descriptor type enumeration
       */

      enum {
        HID_DESCRIPTOR_TYPE   = 0x21,
        HID_REPORT_DESCRIPTOR = 0x22
      };

      DescriptorHeader header;

      uint16_t bcdHID;            // HID version number
      uint8_t bCountryCode;       // Country code
      uint8_t bNumDescriptors;    // Number of descriptors
      uint8_t bDescriptorType;    // Descriptor type
      uint16_t wItemLength;       // Length of the report descriptor

      HidClassDescriptor()
        : header(sizeof(HidClassDescriptor),HID_DESCRIPTOR_TYPE) {

        static_assert(sizeof(HidClassDescriptor)==9,"Compiler error: sizeof(EndpointDescriptor)!=9");

        bcdHID=0x0111;    // default version 1.11
        bCountryCode=0;
        bDescriptorType=HID_REPORT_DESCRIPTOR;
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/hid/HidClassDescriptor.h
// START FILE: ../lib/include/usb/f4/device/hid/HidSubClass.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Subclass codes for HID devices
     */

    enum class HidSubClass : uint8_t {
      NONE = 0,     //!< NONE
      BOOT = 1,     //!< BOOT
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/hid/HidSubClass.h
// START FILE: ../lib/include/usb/f4/device/hid/HidClassRequestType.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /*
     * Class request types
     */

    enum class HidClassRequestType : uint8_t {
      SET_PROTOCOL = 0x0B,
      GET_PROTOCOL = 0x03,
      SET_IDLE     = 0x0A,
      GET_IDLE     = 0x02,
      SET_REPORT   = 0x09,
      GET_REPORT   = 0x01
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/hid/HidClassRequestType.h
// START FILE: ../lib/include/usb/f4/device/hid/HidDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Template class for USB HID devices
     * @tparam TPhy the PHY implementation
     * @tparam TConfigurationDescriptor A structure that holds the complete config descriptor
     * @tparam Features... The device feature classes
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    class HidDevice : public Device<TPhy>,
                      public ControlEndpointFeature<Device<TPhy>>,
                      public Features<Device<TPhy>>... {


      public:

        /*
         * Parameters for the HID device
         */

        struct Parameters : Device<TPhy>::Parameters,
                            ControlEndpointFeature<Device<TPhy>>::Parameters,
                            Features<Device<TPhy>>::Parameters... {
        };

      protected:
        volatile uint8_t _hidProtocol;
        volatile uint8_t _hidIdleState;
        volatile uint8_t _hidAltSetting;
        volatile bool _isReportAvailable;

        TConfigurationDescriptor  _configurationDescriptor;
        const uint8_t *_reportDescriptor;
        uint16_t _reportDescriptorLength;

      protected:
        void onEvent(UsbEventDescriptor& event);
        void onHidSetupEvent(DeviceClassSdkSetupEvent& event);

      public:
        HidDevice(const uint8_t *reportDescriptor,uint16_t reportDescriptorLength);
        ~HidDevice();

        bool initialise(Parameters& params);
    };


    /**
     * Constructor
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline HidDevice<TPhy,TConfigurationDescriptor,Features...>::HidDevice(const uint8_t *reportDescriptor,uint16_t reportDescriptorLength)
      : ControlEndpointFeature<Device<TPhy>>(static_cast<Device<TPhy>&>(*this)),
        Features<Device<TPhy>>(static_cast<Device<TPhy>&>(*this))...,
        _reportDescriptor(reportDescriptor),
        _reportDescriptorLength(reportDescriptorLength) {

      _isReportAvailable=false;

      // subscribe to USB events

      this->UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&HidDevice<TPhy,TConfigurationDescriptor,Features...>::onEvent)
        );
    }


    /**
     * Destructor
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline HidDevice<TPhy,TConfigurationDescriptor,Features...>::~HidDevice() {

      // unsubscribe from USB events

      this->UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&HidDevice<TPhy,TConfigurationDescriptor,Features...>::onEvent)
        );
    }


    /**
     * Initialise the class
     * @param params The parameters class
     * @return true if it worked
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline bool HidDevice<TPhy,TConfigurationDescriptor,Features...>::initialise(Parameters& params) {

      // initialise upwards

      if(!Device<TPhy>::initialise(params) ||
         !ControlEndpointFeature<Device<TPhy>>::initialise(params) ||
         !RecursiveBoolInitWithParams<HidDevice,Features<Device<TPhy>>...>::tinit(this,params))
        return false;

      // link UsbEventSource class into the SDK structure

      USBD_RegisterClass(&this->_deviceHandle,static_cast<UsbEventSource *>(this));
      return true;
    }


    /**
     * Event handler for device events
     * @param event The event descriptor
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline void HidDevice<TPhy,TConfigurationDescriptor,Features...>::onEvent(UsbEventDescriptor& event) {

      // handle the setup event

      if(event.eventType==UsbEventDescriptor::EventType::CLASS_SETUP)
        onHidSetupEvent(static_cast<DeviceClassSdkSetupEvent&>(event));
    }


    /**
     * Handle a HID setup event
     * @param event the setup event
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline void HidDevice<TPhy,TConfigurationDescriptor,Features...>::onHidSetupEvent(DeviceClassSdkSetupEvent& event) {

      // handle device class requests

      if((event.request.bmRequest & USB_REQ_TYPE_MASK)==USB_REQ_TYPE_CLASS) {

        // handle the common stuff

        switch(static_cast<HidClassRequestType>(event.request.bRequest)) {

          case HidClassRequestType::SET_PROTOCOL:
            _hidProtocol=event.request.wValue;
            break;

          case HidClassRequestType::GET_PROTOCOL:
            USBD_CtlSendData(&this->_deviceHandle,(uint8_t *)&_hidProtocol,1);
            break;

          case HidClassRequestType::SET_IDLE:
            _hidIdleState=event.request.wValue >> 8;
            break;

          case HidClassRequestType::GET_IDLE:
            USBD_CtlSendData(&this->_deviceHandle,(uint8_t *)&_hidIdleState,1);
            break;

          default:
            break;
        }
      }
      else if((event.request.bmRequest & USB_REQ_TYPE_MASK)==USB_REQ_TYPE_STANDARD) {

        switch(event.request.bRequest) {

          case USB_REQ_GET_DESCRIPTOR:
            if(event.request.wValue >> 8 == HidClassDescriptor::HID_REPORT_DESCRIPTOR) {

              USBD_CtlSendData(&this->_deviceHandle,
                               const_cast<uint8_t *>(_reportDescriptor),
                               std::min<uint16_t>(_reportDescriptorLength,event.request.wLength));

            } else if(event.request.wValue >> 8 == HidClassDescriptor::HID_DESCRIPTOR_TYPE) {

              USBD_CtlSendData(&this->_deviceHandle,
                               reinterpret_cast<uint8_t *>(&_configurationDescriptor.hid),
                               std::min<uint16_t>(sizeof(_configurationDescriptor.hid),event.request.wLength));
            }

            break;

          case USB_REQ_GET_INTERFACE:
            USBD_CtlSendData(&this->_deviceHandle,(uint8_t *)&_hidAltSetting,1);
            break;

          case USB_REQ_SET_INTERFACE:
            _hidAltSetting=event.request.wValue;
            break;

          default:
            break;
        }
      }
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/hid/HidDevice.h
// START FILE: ../lib/include/usb/f4/device/hid/MouseReportDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * The mouse report descriptor bytes
     */

    extern const uint8_t MouseReportDescriptor[50];
  }
}

// END FILE: ../lib/include/usb/f4/device/hid/MouseReportDescriptor.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkDisconnectInterruptEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for the HAL_PCD_DisconnectCallback reset IRQ handler
     */

    struct DeviceSdkDisconnectInterruptEvent : UsbEventDescriptor {
      DeviceSdkDisconnectInterruptEvent()
        : UsbEventDescriptor(EventType::DEVICE_IRQ_DISCONNECT) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkDisconnectInterruptEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkIsStalledEndpointEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for checking if an endpoint is stalled. Default is false. Change
     * isStalled to true to indicate stalled.
     */

    struct DeviceSdkIsStalledEndpointEvent : DeviceSdkEndpointEvent {

      bool isStalled;

      DeviceSdkIsStalledEndpointEvent(uint8_t ep_addr)
        : DeviceSdkEndpointEvent(EventType::DEVICE_IS_STALL_ENDPOINT,ep_addr),
          isStalled(false) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkIsStalledEndpointEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkGetLastTransferredSizeEndpointEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for an SDK event asking for the last transferred packet size. The
     * default is zero so lastTransferred should be changed to the actual value
     */

    struct DeviceSdkGetLastTransferredSizeEndpointEvent : UsbEventDescriptor {

      uint8_t endpointAddress;
      uint32_t lastTransferred;

      DeviceSdkGetLastTransferredSizeEndpointEvent(uint8_t ep_addr)
        : UsbEventDescriptor(EventType::DEVICE_GET_RX_DATA_SIZE),
          endpointAddress(ep_addr),
          lastTransferred(0) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkGetLastTransferredSizeEndpointEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkConnectInterruptEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for the HAL_PCD_ConnectCallback IRQ handler
     */

    struct DeviceSdkConnectInterruptEvent : UsbEventDescriptor {
      DeviceSdkConnectInterruptEvent()
        : UsbEventDescriptor(EventType::DEVICE_IRQ_CONNECT) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkConnectInterruptEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkNotifyEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for SDK events that just tell us something has happened
     */

    struct DeviceSdkNotifyEvent : UsbEventDescriptor {

      HalUsbStatus retval;

      DeviceSdkNotifyEvent(EventType eventType)
        : UsbEventDescriptor(eventType) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkNotifyEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkDataEndpointEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for the transmit/prepare-to-receive events
     */

    struct DeviceSdkDataEndpointEvent : DeviceSdkEndpointEvent {

      uint8_t *data;
      uint16_t size;

      DeviceSdkDataEndpointEvent(EventType eventType,uint8_t ep_addr,uint8_t *buffer,uint16_t buffer_size)
        : DeviceSdkEndpointEvent(eventType,ep_addr),
          data(buffer),
          size(buffer_size) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkDataEndpointEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceGetDisplayStringDescriptorEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Get an optional string descriptor. The appropriate feature class will
     * process this event
     */

    struct DeviceGetDisplayStringDescriptorEvent : UsbEventDescriptor {

      /*
       * Inputs
       */

      USBD_SpeedTypeDef speed;
      uint8_t stringIndex;

      /*
       * Outputs
       */

      uint8_t *descriptor;
      uint16_t length;


      DeviceGetDisplayStringDescriptorEvent(USBD_SpeedTypeDef s,uint8_t stringIndex)
        : UsbEventDescriptor(EventType::DEVICE_GET_STRING_DESCRIPTOR),
          speed(s),
          stringIndex(stringIndex),
          descriptor(nullptr),
          length(0) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceGetDisplayStringDescriptorEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkOpenEndpointEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for opening and endpoint
     */

    struct DeviceSdkOpenEndpointEvent : DeviceSdkEndpointEvent {

      uint16_t maximumPacketSize;
      EndpointType endpointType;

      DeviceSdkOpenEndpointEvent(uint8_t ep_addr,EndpointType ep_type,uint16_t ep_mps)
        : DeviceSdkEndpointEvent(EventType::DEVICE_OPEN_ENDPOINT,ep_addr),
          maximumPacketSize(ep_mps),
          endpointType(ep_type) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkOpenEndpointEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkSuspendInterruptEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for the HAL_PCD_ResumeCallback IRQ handler
     */

    struct DeviceSdkResumeInterruptEvent : UsbEventDescriptor {
      DeviceSdkResumeInterruptEvent()
        : UsbEventDescriptor(EventType::DEVICE_IRQ_RESUME) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkSuspendInterruptEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkDataInStageInterruptEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for the HAL_PCD_DataInStageCallback IRQ handler
     */

    struct DeviceSdkDataInStageInterruptEvent : UsbEventDescriptor {

      uint8_t endpointNumber;

      DeviceSdkDataInStageInterruptEvent(uint8_t epnum)
        : UsbEventDescriptor(EventType::DEVICE_IRQ_DATA_IN_STAGE),
          endpointNumber(epnum) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkDataInStageInterruptEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkResetInterruptEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for the HAL_PCD_ResetCallback reset IRQ handler
     */

    struct DeviceSdkResetInterruptEvent : UsbEventDescriptor {
      DeviceSdkResetInterruptEvent()
        : UsbEventDescriptor(EventType::DEVICE_IRQ_RESET) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkResetInterruptEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceGetDeviceDescriptorEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Sent when connected and device descriptor is being asked for. Subscriber
     * can modify descriptor if required.
     */

    struct DeviceGetDeviceDescriptorEvent : UsbEventDescriptor {

      USBD_SpeedTypeDef speed;
      DeviceDescriptor& descriptor;

      DeviceGetDeviceDescriptorEvent(USBD_SpeedTypeDef s,DeviceDescriptor& desc)
        : UsbEventDescriptor(EventType::DEVICE_GET_DEVICE_DESCRIPTOR),
          speed(s),
          descriptor(desc) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceGetDeviceDescriptorEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkResumeInterruptEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for the HAL_PCD_ResumeCallback IRQ handler
     */

    struct DeviceSdkSuspendInterruptEvent : UsbEventDescriptor {
      DeviceSdkSuspendInterruptEvent()
        : UsbEventDescriptor(EventType::DEVICE_IRQ_SUSPEND) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkResumeInterruptEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkEndpointEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for SDK events that just tell us something has happened to an endpoint
     */

    struct DeviceSdkEndpointEvent : UsbEventDescriptor {

      HalUsbStatus retval;
      uint8_t endpointAddress;

      DeviceSdkEndpointEvent(EventType eventType,uint8_t ep_addr)
        : UsbEventDescriptor(eventType),
          endpointAddress(ep_addr) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkEndpointEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkDataOutStageInterruptEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for the HAL_PCD_DataOutStageCallback IRQ handler
     */

    struct DeviceSdkDataOutStageInterruptEvent : UsbEventDescriptor {

      uint8_t endpointNumber;

      DeviceSdkDataOutStageInterruptEvent(uint8_t epnum)
        : UsbEventDescriptor(EventType::DEVICE_IRQ_DATA_OUT_STAGE),
          endpointNumber(epnum) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkDataOutStageInterruptEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceGetLanguageDescriptorEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Sent when connected and language descriptor is being asked for. Subscriber
     * can modify descriptor if required.
     */

    struct DeviceGetLanguageDescriptorEvent : UsbEventDescriptor {

      USBD_SpeedTypeDef speed;
      LanguageDescriptor& descriptor;

      DeviceGetLanguageDescriptorEvent(USBD_SpeedTypeDef s,LanguageDescriptor& desc)
        : UsbEventDescriptor(EventType::DEVICE_GET_LANGUAGE_DESCRIPTOR),
          speed(s),
          descriptor(desc) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceGetLanguageDescriptorEvent.h
// START FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkDataInEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for device class data in
     */

    struct DeviceClassSdkDataInEvent : UsbEventDescriptor {

      uint8_t endpointNumber;
      USBD_StatusTypeDef status;

      DeviceClassSdkDataInEvent(uint8_t epnum)
        : UsbEventDescriptor(EventType::CLASS_DATA_IN),
          endpointNumber(epnum),
          status(USBD_OK) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkDataInEvent.h
// START FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkEp0TxSentEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for device class control endpoint tx sent
     */

    struct DeviceClassSdkEp0TxSentEvent : UsbEventDescriptor {

      USBD_StatusTypeDef status;

      DeviceClassSdkEp0TxSentEvent()
        : UsbEventDescriptor(EventType::CLASS_EP0_TX_SENT),
          status(USBD_OK) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkEp0TxSentEvent.h
// START FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkDataOutEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for device class data out from the host
     */

    struct DeviceClassSdkDataOutEvent : UsbEventDescriptor {

      uint8_t endpointNumber;
      USBD_StatusTypeDef status;

      DeviceClassSdkDataOutEvent(uint8_t epnum)
        : UsbEventDescriptor(EventType::CLASS_DATA_OUT),
          endpointNumber(epnum),
          status(USBD_OK) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkDataOutEvent.h
// START FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkGetDeviceQualifierDescriptorEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for device class qualifier descriptor retrieval
     */

    struct DeviceClassSdkGetDeviceQualifierDescriptorEvent : UsbEventDescriptor {

      DeviceQualifierDescriptor *descriptor;
      uint16_t length;

      DeviceClassSdkGetDeviceQualifierDescriptorEvent()
        : UsbEventDescriptor(EventType::CLASS_GET_DEVICE_QUALIFIER_DESCRIPTOR),
          descriptor(nullptr),
          length(0) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkGetDeviceQualifierDescriptorEvent.h
// START FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkSofEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for device class SOF received
     */

    struct DeviceClassSdkSofEvent : UsbEventDescriptor {

      USBD_StatusTypeDef status;

      DeviceClassSdkSofEvent()
        : UsbEventDescriptor(EventType::CLASS_SOF),
          status(USBD_OK) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkSofEvent.h
// START FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkSetupEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for the class setup event
     */

    struct DeviceClassSdkSetupEvent : UsbEventDescriptor {

      USBD_StatusTypeDef status;
      USBD_SetupReqTypedef& request;

      DeviceClassSdkSetupEvent(USBD_SetupReqTypedef& req)
        : UsbEventDescriptor(EventType::CLASS_SETUP),
          status(USBD_OK),
          request(req) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkSetupEvent.h
// START FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkGetConfigurationDescriptorEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for class config descriptor retrieval
     */

    struct DeviceClassSdkGetConfigurationDescriptorEvent : UsbEventDescriptor {

      enum class Type : uint8_t {
        HIGH_SPEED,
        FULL_SPEED,
        OTHER_SPEED,
        USER
      };

      Type type;
      uint8_t *descriptor;
      uint16_t length;

      DeviceClassSdkGetConfigurationDescriptorEvent(Type t)
        : UsbEventDescriptor(EventType::CLASS_GET_CONFIGURATION_DESCRIPTOR),
          type(t),
          descriptor(nullptr),
          length(0) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkGetConfigurationDescriptorEvent.h
// START FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkDeInitEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for device class deinitialisation
     */

    struct DeviceClassSdkDeInitEvent : UsbEventDescriptor {

      uint8_t _configurationIndex;
      USBD_StatusTypeDef status;

      DeviceClassSdkDeInitEvent(uint8_t cfgidx)
        : UsbEventDescriptor(EventType::CLASS_DEINIT),
          _configurationIndex(cfgidx),
          status(USBD_OK) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkDeInitEvent.h
// START FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkEp0ReadyEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for device class control endpoint ready
     */

    struct DeviceClassSdkEp0ReadyEvent : UsbEventDescriptor {

      USBD_StatusTypeDef status;

      DeviceClassSdkEp0ReadyEvent()
        : UsbEventDescriptor(EventType::CLASS_EP0_READY),
          status(USBD_OK) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkEp0ReadyEvent.h
// START FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkInitEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for device class initialisation
     */

    struct DeviceClassSdkInitEvent : UsbEventDescriptor {

      uint8_t _configurationIndex;
      USBD_StatusTypeDef status;

      DeviceClassSdkInitEvent(uint8_t cfgidx)
        : UsbEventDescriptor(EventType::CLASS_INIT),
          _configurationIndex(cfgidx),
          status(USBD_OK) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/class/DeviceClassSdkInitEvent.h
// START FILE: ../lib/include/usb/f4/device/events/DeviceSdkSetupStageInterruptEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Event class for the HAL_PCD_ResumeCallback IRQ handler
     */

    struct DeviceSdkSetupStageInterruptEvent : UsbEventDescriptor {
      DeviceSdkSetupStageInterruptEvent()
        : UsbEventDescriptor(EventType::DEVICE_IRQ_SETUP_STAGE) {
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/events/DeviceSdkSetupStageInterruptEvent.h
// START FILE: ../lib/include/usb/f4/device/cdc/CdcProtocol.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Protocol types for CDC devices
     */

    enum class CdcProtocol : uint8_t {
      NONE = 0x00,
      COMMON_AT_COMMANDS = 0x01,
      PCCA101_AT_COMMANDS = 0x02,
      PCCA101_ANNEX_O_AT_COMMANDS = 0x03,
      GSM_0707_AT_COMMANDS = 0x04,
      GPP_27007_AT_COMMANDS = 0x05,
      TIA_CDMA_AT_COMMANDS = 0x06,
      ETHERNET_EMULATION_MODE = 0x07,

      EXTERNAL = 0xFE,
      VENDOR = 0xFF
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/CdcProtocol.h
// START FILE: ../lib/include/usb/f4/device/cdc/CdcCallManagementFunctionalDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB CDC call management functional descriptor. See specification document:
     * "Universal Serial Bus Class Definitions for Communications Devices"
     */

    struct CdcCallManagementFunctionalDescriptor : CdcFunctionalDescriptor {

      uint8_t bmCapabilities;
      uint8_t bDataInterface;

      CdcCallManagementFunctionalDescriptor()
        : CdcFunctionalDescriptor(CdcFunctionalDescriptor::CALL_MANAGEMENT,sizeof(CdcCallManagementFunctionalDescriptor)) {

        static_assert(sizeof(CdcCallManagementFunctionalDescriptor)==5,"Compiler error: sizeof(CdcCallManagementFunctionalDescriptor)!=5");
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/CdcCallManagementFunctionalDescriptor.h
// START FILE: ../lib/include/usb/f4/device/cdc/events/CdcDataReceivedEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Sent by the device code to notify the application that some data has been
     * received by the CDC device.
     */

    struct CdcDataReceivedEvent : UsbEventDescriptor {

      uint8_t *data;
      uint32_t size;

      CdcDataReceivedEvent(uint8_t *d,uint32_t s)
        : UsbEventDescriptor(EventType::CDC_DATA_RECEIVED),
          data(d),
          size(s) {
      }
    };
  }
}

// END FILE: ../lib/include/usb/f4/device/cdc/events/CdcDataReceivedEvent.h
// START FILE: ../lib/include/usb/f4/device/cdc/events/CdcControlEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Sent by the device code to the application to notify it that a control
     * event has happened.
     */

    struct CdcControlEvent : UsbEventDescriptor {

      CdcControlCommand opcode;
      const uint8_t *data;
      uint8_t size;

      CdcControlEvent(CdcControlCommand op,const uint8_t *d,uint8_t s)
        : UsbEventDescriptor(EventType::CDC_CONTROL),
          opcode(op),
          data(d),
          size(s) {
      }
    };
  }
}

// END FILE: ../lib/include/usb/f4/device/cdc/events/CdcControlEvent.h
// START FILE: ../lib/include/usb/f4/device/cdc/CdcFunctionalDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB CDC functional descriptor base
     */

    struct CdcFunctionalDescriptor {

      /**
       * CDC functional descriptor type enumeration
       */

      enum {
        HEADER = 0x00,
        CALL_MANAGEMENT = 0x01,
        ABSTRACT_CONTROL_MANAGEMENT = 0x02,
        DIRECT_LINE_MANAGEMENT = 0x03,
        TELEPHONE_RINGER = 0x04,
        TELEPHONE_CALL_AND_LINE_STATE_REPORTING_CAPABILITIES = 0x05,
        UNION = 0x06,
        COUNTRY_SELECTION = 0x07,
        TELEPHONE_OPERATIONAL_MODES = 0x08,
        USB_TERMINAL = 0x09,
        NETWORK_CHANNEL_TERMINAL = 0x0a,
        PROTOCOL_UNIT = 0x0b,
        EXTENSION_UNIT = 0x0c,
        MULTI_CHANNEL_MANAGEMENT = 0x0d,
        CAPI_CONTROL_MANAGEMENT = 0x0e,
        ETHERNET_NETWORKING = 0x0f,
        ATM_NETWORKING = 0x10,
        WIRELESS_HANDSET_CONTROL_MODEL = 0x11
      };

      DescriptorHeader header;
      uint8_t bDescriptorSubtype;

      CdcFunctionalDescriptor(uint8_t subtype,uint8_t len)
        : header(len,0x24),
          bDescriptorSubtype(subtype) {       // CS_INTERFACE = 0x24
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/CdcFunctionalDescriptor.h
// START FILE: ../lib/include/usb/f4/device/cdc/CdcAbstractControlManagementFunctionalDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB CDC abstract control management functional descriptor. See specification document:
     * "Universal Serial Bus Class Definitions for Communications Devices"
     */

    struct CdcAbstractControlManagementFunctionalDescriptor : CdcFunctionalDescriptor {

      uint8_t bmCapabilities;

      CdcAbstractControlManagementFunctionalDescriptor()
        : CdcFunctionalDescriptor(CdcFunctionalDescriptor::ABSTRACT_CONTROL_MANAGEMENT,sizeof(CdcAbstractControlManagementFunctionalDescriptor)) {

        static_assert(sizeof(CdcAbstractControlManagementFunctionalDescriptor)==4,"Compiler error: sizeof(CdcAbstractControlManagementFunctionalDescriptor)!=4");
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/CdcAbstractControlManagementFunctionalDescriptor.h
// START FILE: ../lib/include/usb/f4/device/cdc/CdcControlCommand.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * CDC control commands enumeration
     */

    enum class CdcControlCommand : uint8_t {

      SEND_ENCAPSULATED_COMMAND = 0x00, //!< CDC_SEND_ENCAPSULATED_COMMAND
      GET_ENCAPSULATED_RESPONSE = 0x01, //!< CDC_GET_ENCAPSULATED_RESPONSE
      SET_COMM_FEATURE          = 0x02, //!< CDC_SET_COMM_FEATURE
      GET_COMM_FEATURE          = 0x03, //!< CDC_GET_COMM_FEATURE
      CLEAR_COMM_FEATURE        = 0x04, //!< CDC_CLEAR_COMM_FEATURE
      SET_LINE_CODING           = 0x20, //!< CDC_SET_LINE_CODING
      GET_LINE_CODING           = 0x21, //!< CDC_GET_LINE_CODING
      SET_CONTROL_LINE_STATE    = 0x22, //!< CDC_SET_CONTROL_LINE_STATE
      SEND_BREAK                = 0x23, //!< CDC_SEND_BREAK

      NONE = 0xff
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/CdcControlCommand.h
// START FILE: ../lib/include/usb/f4/device/cdc/CdcLineCoding.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * CDC line coding structure
     */

    struct CdcLineCoding {

      uint32_t dwDTERate;             // bits/second
      uint8_t  bCharFormat;
      uint8_t  bParityType;
      uint8_t  bDataBits;             // 5/6/7/8/16

      enum {
        CHARFORMAT_1_STOP_BIT = 0,
        CHARFORMAT_1_5_STOP_BITS = 1,
        CHARFORMAT_2_STOP_BITS = 2
      };

      enum {
        PARITY_NONE  = 0,
        PARITY_ODD   = 1,
        PARITY_EVEN  = 2,
        PARITY_MARK  = 3,
        PARITY_SPACE = 4
      };

      CdcLineCoding() {

        static_assert(sizeof(CdcLineCoding)==7,"Compiler error: sizeof(LineCoding)!=7");

        // set a default of 9600/8/N/1

        dwDTERate=9600;
        bCharFormat=CHARFORMAT_1_STOP_BIT;
        bParityType=PARITY_NONE;
        bDataBits=8;
      }

    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/CdcLineCoding.h
// START FILE: ../lib/include/usb/f4/device/cdc/CdcDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Template base class for USB CDC devices. The usual control endpoint 0 is inherited
     * as is the mandatory IN interrupt endpoint for notifications to the host at address 1.
     * Subclasses should provide the endpoints they require in the features list. e.g. bulk
     * IN/OUT endpoints.
     *
     * @tparam TPhy the PHY implementation
     * @tparam TConfigurationDescriptor A structure that holds the complete config descriptor
     * @tparam Features... The device feature classes
     */

    template<class TPhy> using CdcDeviceInterruptInEndpoint=InterruptInEndpointFeature<2,Device<TPhy>>;

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    class CdcDevice : public Device<TPhy>,
                      public ControlEndpointFeature<Device<TPhy>>,
                      public CdcDeviceInterruptInEndpoint<TPhy>,
                      public Features<Device<TPhy>>... {


      public:

        /*
         * Parameters for the CDC device
         */

        struct Parameters : Device<TPhy>::Parameters,
                            ControlEndpointFeature<Device<TPhy>>::Parameters,
                            CdcDeviceInterruptInEndpoint<TPhy>::Parameters,
                            Features<Device<TPhy>>::Parameters... {

          uint8_t cdc_cmd_poll_interval;        // default is 16ms
          uint8_t cdc_cmd_buffer_size;          // default is 16 bytes
          uint8_t cdc_cmd_max_ep_packet_size;   // default is 16 bytes

          Parameters() {
            cdc_cmd_poll_interval=16;
            cdc_cmd_buffer_size=16;
            cdc_cmd_max_ep_packet_size=16;
          }
        };

      protected:

        enum {
          COMMAND_EP_ADDRESS = EndpointDescriptor::IN | 2     // command endpoint address
        };

        TConfigurationDescriptor  _configurationDescriptor;
        CdcControlCommand _opCode;
        uint8_t _commandSize;
        scoped_array<uint8_t> _commandBuffer;

      protected:
        void onEvent(UsbEventDescriptor& event);
        void onCdcSetup(DeviceClassSdkSetupEvent& event);

      public:
        CdcDevice();
        ~CdcDevice();

        bool initialise(Parameters& params);
    };


    /**
     * Constructor
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline CdcDevice<TPhy,TConfigurationDescriptor,Features...>::CdcDevice()
      : ControlEndpointFeature<Device<TPhy>>(static_cast<Device<TPhy>&>(*this)),
        CdcDeviceInterruptInEndpoint<TPhy>(static_cast<Device<TPhy>&>(*this)),
        Features<Device<TPhy>>(static_cast<Device<TPhy>&>(*this))... {

      // subscribe to USB events

      this->UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&CdcDevice<TPhy,TConfigurationDescriptor,Features...>::onEvent)
        );
    }


    /**
     * Destructor
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline CdcDevice<TPhy,TConfigurationDescriptor,Features...>::~CdcDevice() {

      // unsubscribe from USB events

      this->UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&CdcDevice<TPhy,TConfigurationDescriptor,Features...>::onEvent)
        );
    }


    /**
     * Initialise the class
     * @param params The parameters class
     * @return true if it worked
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline bool CdcDevice<TPhy,TConfigurationDescriptor,Features...>::initialise(Parameters& params) {

      // initialise upwards

      if(!Device<TPhy>::initialise(params) ||
         !ControlEndpointFeature<Device<TPhy>>::initialise(params) ||
         !CdcDeviceInterruptInEndpoint<TPhy>::initialise(params) ||
         !RecursiveBoolInitWithParams<CdcDevice,Features<Device<TPhy>>...>::tinit(this,params))
        return false;

      // create the command buffer

      _commandBuffer.reset(new uint8_t[params.cdc_cmd_buffer_size]);

      // set up the command endpoint descriptor

      _configurationDescriptor.commandEndpoint.bEndpointAddress=COMMAND_EP_ADDRESS;
      _configurationDescriptor.commandEndpoint.bmAttributes=EndpointDescriptor::INTERRUPT;
      _configurationDescriptor.commandEndpoint.wMaxPacketSize=params.cdc_cmd_max_ep_packet_size;
      _configurationDescriptor.commandEndpoint.bInterval=params.cdc_cmd_poll_interval;        // default is 16ms

      // link UsbEventSource class into the SDK structure

      USBD_RegisterClass(&this->_deviceHandle,static_cast<UsbEventSource *>(this));
      return true;
    }


    /**
     * Event handler for device events
     * @param event The event descriptor
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline void CdcDevice<TPhy,TConfigurationDescriptor,Features...>::onEvent(UsbEventDescriptor& event) {

      // check for handled events

      switch(event.eventType) {

        case UsbEventDescriptor::EventType::CLASS_INIT:
          USBD_LL_OpenEP(&this->_deviceHandle,COMMAND_EP_ADDRESS,EndpointDescriptor::INTERRUPT,_configurationDescriptor.commandEndpoint.wMaxPacketSize);
          break;

        case UsbEventDescriptor::EventType::CLASS_DEINIT:
          USBD_LL_CloseEP(&this->_deviceHandle,COMMAND_EP_ADDRESS);
          break;

        case UsbEventDescriptor::EventType::CLASS_SETUP:
          onCdcSetup(static_cast<DeviceClassSdkSetupEvent&>(event));
          break;

        default:
          break;
      }
    }


    /**
     * Handle the CDC setup requests
     * @param event the event containg value being requested
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline void CdcDevice<TPhy,TConfigurationDescriptor,Features...>::onCdcSetup(DeviceClassSdkSetupEvent& event) {

      // interested in class requests

      if((event.request.bmRequest & USB_REQ_TYPE_MASK)!=USB_REQ_TYPE_CLASS)
        return;

      if(event.request.wLength) {

        if((event.request.bmRequest & 0x80)!=0) {

          // raise the control event - this one requires a response

          this->UsbEventSender.raiseEvent(
              CdcControlEvent(static_cast<CdcControlCommand>(event.request.bRequest),
                              _commandBuffer.get(),
                              event.request.wLength)
            );

          // send the response message on the control endpoint

          USBD_CtlSendData(&this->_deviceHandle,_commandBuffer.get(),event.request.wLength);
        }
        else {

          // there is incoming data associated with this

          _opCode=static_cast<CdcControlCommand>(event.request.bRequest);
          _commandSize=event.request.wLength;

          USBD_CtlPrepareRx(&this->_deviceHandle,_commandBuffer.get(),_commandSize);
        }
      }
      else {

        // raise the control event - no response is expected

        this->UsbEventSender.raiseEvent(
            CdcControlEvent(
                static_cast<CdcControlCommand>(event.request.bRequest),
                nullptr,
                0));
      }
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/CdcDevice.h
// START FILE: ../lib/include/usb/f4/device/cdc/ComPortCdcDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Endpoints used by this device. The interrupt IN endpoint for notifying the host
     * is supplied by the parent class
     */

    template<class TDevice> using ComPortCdcDeviceDataInEndpoint=BulkInEndpointFeature<1,TDevice>;
    template<class TDevice> using ComPortCdcDeviceDataOutEndpoint=BulkOutEndpointFeature<1,TDevice>;


    /**
     * Declare the structure that gets sent back when the host asks for the whole
     * configuration descriptor
     */

    struct ComPortCdcConfigurationDescriptor {
      ConfigurationDescriptor configuration;
      InterfaceAssociationDescriptor assoc;

      InterfaceDescriptor itf0;
      CdcHeaderFunctionalDescriptor cdcHeader;
      CdcCallManagementFunctionalDescriptor cdcCallManagement;
      CdcAbstractControlManagementFunctionalDescriptor cdcAcm;
      CdcOneSlaveUnionFunctionalDescriptor cdcUnion;
      EndpointDescriptor commandEndpoint;

      InterfaceDescriptor itf1;
      EndpointDescriptor outEndpoint;
      EndpointDescriptor inEndpoint;

    } __attribute__((packed));


    /**
     * Derivation of CdcDevice to provide a CDC virtual COM port device.
     *
     *   1x Configuration descriptor
     *   2x Interfaces
     *   1x Inbound bulk data endpoint
     *   1x Outbound bulk data endpoint
     *   1x Inbound command endpoint
     */

     template<class TPhy,template <class> class... Features>
     class ComPortCdcDevice : public CdcDevice<TPhy,
                                               ComPortCdcConfigurationDescriptor,
                                               ComPortCdcDeviceDataInEndpoint,
                                               ComPortCdcDeviceDataOutEndpoint,
                                               Features...> {

       public:

         typedef CdcDevice<TPhy,
                           ComPortCdcConfigurationDescriptor,
                           ComPortCdcDeviceDataInEndpoint,
                           ComPortCdcDeviceDataOutEndpoint,
                           Features...> CdcDeviceBase;

         /**
          * Customisable parameters for this CDC device
          */

         struct Parameters : CdcDeviceBase::Parameters {

           uint16_t cdc_com_port_in_max_packet_size;       // default is 64 bytes
           uint16_t cdc_com_port_out_max_packet_size;      // default is 64 bytes
           uint16_t cdc_com_port_rx_buffer_size;           // default is 1024

           Parameters() {
             cdc_com_port_in_max_packet_size=64;
             cdc_com_port_out_max_packet_size=64;
             cdc_com_port_rx_buffer_size=1024;
           }
         };

       protected:

         enum {
           DATA_IN_EP_ADDRESS = EndpointDescriptor::IN | 1,     // data in endpoint address
           DATA_OUT_EP_ADDRESS = EndpointDescriptor::OUT | 1,   // data out endpoint address
         };

         uint16_t _maxInPacketSize;
         uint16_t _maxOutPacketSize;
         scoped_array<uint8_t> _rxBuffer;
         uint16_t _rxBufferSize;

      protected:
        void onEvent(UsbEventDescriptor& event);

        void onCdcInit();
        void onCdcDeInit();
        void onCdcGetConfigurationDescriptor(DeviceClassSdkGetConfigurationDescriptorEvent& event);
        void onCdcDataOut(DeviceClassSdkDataOutEvent& event);
        void onCdcEp0RxReady();

      public:
        ComPortCdcDevice();
        ~ComPortCdcDevice();

        bool initialise(Parameters& params);

        bool transmit(const void *data,uint16_t len);
        bool isTransmittingData() const;
        void beginReceive();
    };


    /**
     * Constructor
     */

    template<class TPhy,template <class> class... Features>
    inline ComPortCdcDevice<TPhy,Features...>::ComPortCdcDevice() {

      // subscribe to USB events

      this->UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&ComPortCdcDevice<TPhy,Features...>::onEvent)
        );
    }


    /**
     * Destructor
     */

    template<class TPhy,template <class> class... Features>
    inline ComPortCdcDevice<TPhy,Features...>::~ComPortCdcDevice() {

      // unsubscribe from USB events

      this->UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&ComPortCdcDevice<TPhy,Features...>::onEvent)
        );
    }


    /**
     * Initialise the class
     * @param param The parameters structure
     * @return true if it worked
     */

    template<class TPhy,template <class> class... Features>
    inline bool ComPortCdcDevice<TPhy,Features...>::initialise(Parameters& params) {

      USBD_StatusTypeDef status;

      // initialise upwards

      if(!CdcDeviceBase::initialise(params))
        return false;

      // create TX/RX buffers

      _rxBuffer.reset(new uint8_t[params.cdc_com_port_rx_buffer_size]);

      // remember some params

      _maxInPacketSize=params.cdc_com_port_in_max_packet_size;
      _maxOutPacketSize=params.cdc_com_port_out_max_packet_size;
      _rxBufferSize=params.cdc_com_port_rx_buffer_size;

      // set up the configuration descriptor (see constructor for defaults)

      this->_configurationDescriptor.configuration.wTotalLength=sizeof(this->_configurationDescriptor);
      this->_configurationDescriptor.configuration.bNumInterfaces=2;
      this->_configurationDescriptor.configuration.bmAttributes=0x80 | ConfigurationDescriptor::SELF_POWERED;

      // if ConfigurationTextFeature is in the hierarchy then we've got a configuration string (compile-time check)

      if(std::is_base_of<ConfigurationTextFeature<Device<TPhy>>,ComPortCdcDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.configuration.iConfiguration=USBD_IDX_CONFIG_STR;

      // set up the interface association descriptor

      this->_configurationDescriptor.assoc.bFirstInterface=0;
      this->_configurationDescriptor.assoc.bInterfaceCount=2;
      this->_configurationDescriptor.assoc.bFunctionClass=2;
      this->_configurationDescriptor.assoc.bFunctionSubClass=2;
      this->_configurationDescriptor.assoc.bFunctionProtocol=1;
      this->_configurationDescriptor.assoc.iFunction=0;

      // set up interface descriptor 0 (see constructor for defaults)

      this->_configurationDescriptor.itf0.bInterfaceNumber=0;
      this->_configurationDescriptor.itf0.bNumEndpoints=1;
      this->_configurationDescriptor.itf0.bInterfaceClass=static_cast<uint8_t>(DeviceClass::COMMUNICATIONS_CDC_CONTROL);
      this->_configurationDescriptor.itf0.bInterfaceSubClass=static_cast<uint8_t>(CdcSubClass::ABSTRACT_CONTROL_MODEL);
      this->_configurationDescriptor.itf0.bInterfaceProtocol=static_cast<uint8_t>(CdcProtocol::COMMON_AT_COMMANDS);

      // if InterfaceTextFeature is in the hierarchy then we've got an interface string (compile-time check)

      if(std::is_base_of<InterfaceTextFeature<Device<TPhy>>,ComPortCdcDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.itf0.iInterface=USBD_IDX_INTERFACE_STR;

      // set up the call management functional descriptor

      this->_configurationDescriptor.cdcCallManagement.bmCapabilities=0;
      this->_configurationDescriptor.cdcCallManagement.bDataInterface=1;      // interface #1 does the data

      // set up the ACM functional descriptor

      this->_configurationDescriptor.cdcAcm.bmCapabilities=0x02;

      // set up the union functional descriptor

      this->_configurationDescriptor.cdcUnion.bMasterInterface=0;
      this->_configurationDescriptor.cdcUnion.bSlaveInterface=1;

      // set up interface descriptor 1 (see constructor for defaults)

      this->_configurationDescriptor.itf1.bInterfaceNumber=1;
      this->_configurationDescriptor.itf1.bNumEndpoints=2;
      this->_configurationDescriptor.itf1.bInterfaceClass=static_cast<uint8_t>(DeviceClass::CDC_DATA);
      this->_configurationDescriptor.itf1.bInterfaceSubClass=0;
      this->_configurationDescriptor.itf1.bInterfaceProtocol=0;

      // if InterfaceTextFeature is in the hierarchy then we've got an interface string (compile-time check)

      if(std::is_base_of<InterfaceTextFeature<Device<TPhy>>,ComPortCdcDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.itf1.iInterface=USBD_IDX_INTERFACE_STR;

      // set up the OUT endpoint descriptor

      this->_configurationDescriptor.outEndpoint.bEndpointAddress=DATA_OUT_EP_ADDRESS;
      this->_configurationDescriptor.outEndpoint.bmAttributes=EndpointDescriptor::BULK;
      this->_configurationDescriptor.outEndpoint.wMaxPacketSize=params.cdc_com_port_out_max_packet_size;         // LED reports are 1 byte

      // set up the IN endpoint descriptor

      this->_configurationDescriptor.inEndpoint.bEndpointAddress=DATA_IN_EP_ADDRESS;
      this->_configurationDescriptor.inEndpoint.bmAttributes=EndpointDescriptor::BULK;
      this->_configurationDescriptor.inEndpoint.wMaxPacketSize=params.cdc_com_port_in_max_packet_size;

      // set up the qualifier descriptor (see constructor for defaults)

      this->_qualifierDescriptor.bMaxPacketSize0=0x40;
      this->_qualifierDescriptor.bNumConfigurations=1;

      // start the device

      if((status=USBD_Start(&this->_deviceHandle))!=USBD_OK)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_USB_DEVICE,this->E_START,status);

      // OK

      return true;
    }


    /**
     * Event handler for device events
     * @param event The event descriptor
     */

    template<class TPhy,template <class> class... Features>
    inline void ComPortCdcDevice<TPhy,Features...>::onEvent(UsbEventDescriptor& event) {

      switch(event.eventType) {

        case UsbEventDescriptor::EventType::CLASS_INIT:
          onCdcInit();
          break;

        case UsbEventDescriptor::EventType::CLASS_DEINIT:
          onCdcDeInit();
          break;

        case UsbEventDescriptor::EventType::CLASS_DATA_OUT:
          onCdcDataOut(static_cast<DeviceClassSdkDataOutEvent&>(event));
          break;

        case UsbEventDescriptor::EventType::CLASS_EP0_READY:
          onCdcEp0RxReady();
          break;

        case UsbEventDescriptor::EventType::CLASS_GET_CONFIGURATION_DESCRIPTOR:
          onCdcGetConfigurationDescriptor(static_cast<DeviceClassSdkGetConfigurationDescriptorEvent&>(event));
          break;

        default:
          break;
      }
    }


    /**
     * CDC initialisation. Opens the data endpoints and initiates the first beginReceive() call.
     */

    template<class TPhy,template <class> class... Features>
    inline void ComPortCdcDevice<TPhy,Features...>::onCdcInit() {

      // reset state

      this->_opCode=CdcControlCommand::NONE;

      // open data endpoints

      USBD_LL_OpenEP(&this->_deviceHandle,DATA_IN_EP_ADDRESS,EndpointDescriptor::BULK,_maxInPacketSize);
      USBD_LL_OpenEP(&this->_deviceHandle,DATA_OUT_EP_ADDRESS,EndpointDescriptor::BULK,_maxOutPacketSize);

      // prepare OUT endpoint to receive the first packet

      beginReceive();
    }


    /**
     * De-initialise the CDC device
     */

    template<class TPhy,template <class> class... Features>
    inline void ComPortCdcDevice<TPhy,Features...>::onCdcDeInit() {

      // close data endpoints

      USBD_LL_CloseEP(&this->_deviceHandle,DATA_IN_EP_ADDRESS);
      USBD_LL_CloseEP(&this->_deviceHandle,DATA_OUT_EP_ADDRESS);
    }


    /**
     * Get the configuration descriptor
     * @param event The event class to receive the descriptor and provide type of descriptor being requested
     */

    template<class TPhy,template <class> class... Features>
    inline void ComPortCdcDevice<TPhy,Features...>::onCdcGetConfigurationDescriptor(DeviceClassSdkGetConfigurationDescriptorEvent& event) {

      if(event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::HIGH_SPEED ||
         event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::FULL_SPEED ||
         event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::OTHER_SPEED) {

        // set up the values in the event

        event.length=sizeof(this->_configurationDescriptor);
        event.descriptor=reinterpret_cast<uint8_t *>(&this->_configurationDescriptor);
      }
    }


    /**
     * Data out event
     */

    template<class TPhy,template <class> class... Features>
    inline void ComPortCdcDevice<TPhy,Features...>::onCdcDataOut(DeviceClassSdkDataOutEvent& event) {

      uint32_t size;

      // get the received size

      size=USBD_LL_GetRxDataSize(&this->_deviceHandle,event.endpointNumber);

      // notify the application code

      this->UsbEventSender.raiseEvent(CdcDataReceivedEvent(_rxBuffer.get(),size));
    }


    /**
     * Control endpoint ready handler
     */

    template<class TPhy,template <class> class... Features>
    inline void ComPortCdcDevice<TPhy,Features...>::onCdcEp0RxReady() {

      if(this->_opCode!=CdcControlCommand::NONE) {

        // notify the application

        this->UsbEventSender.raiseEvent(CdcControlEvent(this->_opCode,this->_commandBuffer.get(),this->_commandSize));
        this->_opCode=CdcControlCommand::NONE;
      }
    }


    /**
     * Transmit some data. This is a blocking call. It will wait until any previous
     * transmission is complete before sending the data. 'data' must remain in scope
     * until the transmission has completed.
     * @param data The data buffer to send
     * @param len The size of the data buffer
     * @return true if it worked
     */

    template<class TPhy,template <class> class... Features>
    inline bool ComPortCdcDevice<TPhy,Features...>::transmit(const void *data,uint16_t len) {

      ComPortCdcDeviceDataInEndpoint<Device<TPhy>>& endpoint=static_cast<ComPortCdcDeviceDataInEndpoint<Device<TPhy>>&>(*this);

      // wait for previous send to complete by IRQ notification

      while(endpoint.isTransmitting());

      // send this data

      return endpoint.transmit(data,len);
    }


    /**
     * Check if the bulk IN endpoint is transmitting
     * @return true if the endpoint is transmitting
     */

    template<class TPhy,template <class> class... Features>
    inline bool ComPortCdcDevice<TPhy,Features...>::isTransmittingData() const {
      return static_cast<const ComPortCdcDeviceDataInEndpoint<Device<TPhy>>&>(*this).isTransmitting();
    }


    /**
     * Prepare to receive the next packet. This must be called after each packet has been
     * received and processed to initiate the reception of the next packet.
     */

    template<class TPhy,template <class> class... Features>
    inline void ComPortCdcDevice<TPhy,Features...>::beginReceive() {

      USBD_LL_PrepareReceive(
          &this->_deviceHandle,
          DATA_OUT_EP_ADDRESS,
          _rxBuffer.get(),
          _rxBufferSize);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/ComPortCdcDevice.h
// START FILE: ../lib/include/usb/f4/device/cdc/CdcSubClass.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Subclass codes for CDC devices
     */

    enum class CdcSubClass : uint8_t {
      RESERVED = 0,
      DIRECT_LINE_CONTROL_MODEL = 0x1,
      ABSTRACT_CONTROL_MODEL = 0x2,
      TELEPHONE_CONTROL_MODEL = 0x3,
      MULTI_CHANNEL_CONTROL_MODEL = 0x4,
      CAPI_CONTROL_MODEL = 0x5,
      ETHERNET_NETWORKING_CONTROL_MODEL = 0x6,
      ATM_NETWORKING_CONTROL_MODEL = 0x7,
      WIRELESS_HANDSET_CONTROL_MODEL = 0x8,
      DEVICE_MANAGEMENT = 0x9,
      MOBILE_DIRECT_LINE_MODEL = 0xa,
      OBEX = 0xb
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/CdcSubClass.h
// START FILE: ../lib/include/usb/f4/device/cdc/CdcHeaderFunctionalDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB CDC header functional descriptor. See specification document:
     * "Universal Serial Bus Class Definitions for Communications Devices"
     */

    struct CdcHeaderFunctionalDescriptor : CdcFunctionalDescriptor {

      uint16_t bcdCDC;

      CdcHeaderFunctionalDescriptor()
        : CdcFunctionalDescriptor(CdcFunctionalDescriptor::HEADER,sizeof(CdcHeaderFunctionalDescriptor)),
          bcdCDC(0x0110) {      // version 1.10

        static_assert(sizeof(CdcHeaderFunctionalDescriptor)==5,"Compiler error: sizeof(CdcHeaderFunctionalDescriptor)!=5");
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/CdcHeaderFunctionalDescriptor.h
// START FILE: ../lib/include/usb/f4/device/cdc/CdcOneSlaveUnionFunctionalDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB CDC union functional descriptor. See specification document:
     * "Universal Serial Bus Class Definitions for Communications Devices"
     */

    struct CdcOneSlaveUnionFunctionalDescriptor : CdcFunctionalDescriptor {

      uint8_t bMasterInterface;
      uint8_t bSlaveInterface;

      CdcOneSlaveUnionFunctionalDescriptor()
        : CdcFunctionalDescriptor(CdcFunctionalDescriptor::UNION,sizeof(CdcOneSlaveUnionFunctionalDescriptor)) {

        static_assert(sizeof(CdcOneSlaveUnionFunctionalDescriptor)==5,"Compiler error: sizeof(CdcOneSlaveUnionFunctionalDescriptor)!=5");
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/cdc/CdcOneSlaveUnionFunctionalDescriptor.h
// START FILE: ../lib/include/usb/f4/device/DescriptorHeader.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * USB Descriptor header. They all start with a byte length followed by
     * a descriptor type constant
     */

    struct DescriptorHeader {

      uint8_t bLength;
      uint8_t bDescriptorType;

      DescriptorHeader(uint8_t len,uint8_t type)
        : bLength(len),
          bDescriptorType(type) {
      }

    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/DescriptorHeader.h
// START FILE: ../lib/include/usb/f4/device/msc/MscSubClass.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * MSC subclass codes
     */

    enum class MscSubClass : uint8_t {
      NOT_REPORTED = 0,
      RBC = 1,
      ATAPI = 2,
      UFI = 4,
      SCSI_TRANSPARENT = 6,
      LSDFS = 7,
      IEEE1667 = 8,
      VENDOR = 0xff
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscSubClass.h
// START FILE: ../lib/include/usb/f4/device/msc/MscScsi.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * SCSI interaction class. Handles all the mechanics of processing the SCSI
     * commands that actually manipulate the disk and its data
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    class MscScsi {

      public:

        /**
         * Parameters structure
         */

        struct Parameters {

          uint16_t msc_media_packet_size;      // default is 8192 bytes

           Parameters() {
             msc_media_packet_size=8192;
           }
        };

      protected:

        enum {
          SENSE_LIST_DEPTH = 4
        };

        /*
         * Response packet sizes
         */

        enum {
         READ_FORMAT_CAPACITY_DATA_LEN = 0x0C,
         READ_CAPACITY10_DATA_LEN      = 0x08,
         MODE_SENSE10_DATA_LEN         = 0x08,
         MODE_SENSE6_DATA_LEN          = 0x04,
         REQUEST_SENSE_DATA_LEN        = 0x12,
         STANDARD_INQUIRY_DATA_LEN     = 0x24
        };

        MscScsiSense _sense[SENSE_LIST_DEPTH];
        uint8_t _senseHead;
        uint8_t _senseTail;

        uint16_t _blkSize;
        uint32_t _blkNbr;

        uint32_t _blkAddr;
        uint32_t _blkLen;

        uint16_t _packetSize;
        uint16_t _maxPacketSize;
        scoped_array<uint8_t> _packetData;

        MscBotState& _botState;
        UsbEventSource& _eventSource;
        USBD_HandleTypeDef& _deviceHandle;

      protected:
        bool processRead(uint8_t lun,MscBotCommandStatusWrapper& csw);
        bool processWrite(uint8_t lun,MscBotCommandBlockWrapper& cbw,MscBotCommandStatusWrapper& csw);
        bool checkAddressRange(uint8_t lun,uint32_t blk_offset,uint16_t blk_nbr);

      public:
        MscScsi(MscBotState& botState,UsbEventSource& eventSource,USBD_HandleTypeDef& deviceHandle);
        bool initialise(const Parameters& params);

        void onInit();

        bool processCmd(uint8_t lun,uint8_t *params,MscBotCommandBlockWrapper& cbw,MscBotCommandStatusWrapper& csw);
        bool testUnitReady(uint8_t lun,MscBotCommandBlockWrapper& cbw);
        bool requestSense(uint8_t *params);
        bool inquiry(uint8_t lun,uint8_t *params);
        bool startStopUnit();
        bool modeSense6(uint8_t lun);
        bool modeSense10();
        bool readFormatCapacity(uint8_t lun);
        bool readCapacity10(uint8_t lun);
        bool read10(uint8_t lun,uint8_t *params,MscBotCommandBlockWrapper& cbw,MscBotCommandStatusWrapper& csw);
        bool write10(uint8_t lun,uint8_t *params,MscBotCommandBlockWrapper& cbw,MscBotCommandStatusWrapper& csw);
        bool verify10(uint8_t lun,uint8_t *params);
        void senseCode(uint8_t lun,uint8_t sKey,uint8_t asc);

        uint16_t getDataSize() const;
        uint8_t *getData() const;
    };


    /**
     * Constructor
     * @param botState The BOT state machine state
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline MscScsi<TInEndpointAddress,TOutEndpointAddress>::MscScsi(MscBotState& botState,UsbEventSource& eventSource,USBD_HandleTypeDef& deviceHandle)
      : _botState(botState),
        _eventSource(eventSource),
        _deviceHandle(deviceHandle) {
    }


    /**
     * Initialise the class
     * @param params The parameters
     * @return true
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::initialise(const Parameters& params) {

      _maxPacketSize=params.msc_media_packet_size;
      _packetData.reset(new uint8_t[_maxPacketSize]);

      return true;
    }


    /**
     * Re-initialise the class
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline void MscScsi<TInEndpointAddress,TOutEndpointAddress>::onInit() {
      _senseHead=_senseTail=0;
    }


    /**
     * Process the SCSI command
     * @param lun logical unit number
     * @param params command and parameters
     * @return true if it worked
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::processCmd(uint8_t lun,uint8_t *params,MscBotCommandBlockWrapper& cbw,MscBotCommandStatusWrapper& csw) {

      switch(static_cast<MscScsiCommand>(params[0])) {

        case MscScsiCommand::TEST_UNIT_READY:
          return testUnitReady(lun,cbw);

        case MscScsiCommand::REQUEST_SENSE:
          return requestSense(params);

        case MscScsiCommand::INQUIRY:
          return inquiry(lun,params);

        case MscScsiCommand::START_STOP_UNIT:
          return startStopUnit();

        case MscScsiCommand::ALLOW_MEDIUM_REMOVAL:
          return startStopUnit();

        case MscScsiCommand::MODE_SENSE6:
          return modeSense6(lun);

        case MscScsiCommand::MODE_SENSE10:
          return modeSense10();

        case MscScsiCommand::READ_FORMAT_CAPACITIES:
          return readFormatCapacity(lun);

        case MscScsiCommand::READ_CAPACITY10:
          return readCapacity10(lun);

        case MscScsiCommand::READ10:
          return read10(lun,params,cbw,csw);

        case MscScsiCommand::WRITE10:
          return write10(lun,params,cbw,csw);

        case MscScsiCommand::VERIFY10:
          return verify10(lun,params);

        default:
          senseCode(lun,MscScsiSense::ILLEGAL_REQUEST,MscScsiSense::INVALID_CDB);
          return false;
      }
    }


    /**
     * Process SCSI Test Unit Ready Command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval true if it worked
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::testUnitReady(uint8_t lun,MscBotCommandBlockWrapper& cbw) {

      // case 9 : Hi > D0

      if(cbw.dDataLength) {

        senseCode(cbw.bLUN,MscScsiSense::ILLEGAL_REQUEST,MscScsiSense::INVALID_CDB);
        return false;
      }

      // send the 'is ready' event

      MscBotIsReadyEvent event(lun);
      _eventSource.UsbEventSender.raiseEvent(event);

      if(event.isReady) {
        _packetSize=0;
        return true;
      }
      else {

        senseCode(lun,MscScsiSense::NOT_READY,MscScsiSense::MEDIUM_NOT_PRESENT);

        _botState=MscBotState::NO_DATA;
        return false;
      }
    }


    /**
     * @brief  Process Request Sense command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval true if it worked
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::requestSense(uint8_t *params) {

      uint8_t *ptr;

      // clear out the data

      ptr=_packetData.get();
      memset(ptr,'\0',REQUEST_SENSE_DATA_LEN);

      // create the packet

      ptr[0]=0x70;
      ptr[7]=REQUEST_SENSE_DATA_LEN-6;

      if(_senseHead!=_senseTail) {

        ptr[2]=_sense[_senseHead].Skey;
        ptr[12]=_sense[_senseHead].w.b.ASCQ;
        ptr[13]=_sense[_senseHead].w.b.ASC;

        _senseHead++;

        if(_senseHead==SENSE_LIST_DEPTH)
          _senseHead=0;
      }

      _packetSize=REQUEST_SENSE_DATA_LEN;

      if(params[4]<REQUEST_SENSE_DATA_LEN)
        _packetSize=params[4];

      return true;
    }


    /**
     * Process Inquiry command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval true if it worked
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::inquiry(uint8_t lun,uint8_t *params) {

      static const uint8_t page00[7] = { 0,0,0,3,0,0x80,0x83 };

      if(params[1] & 0x01) {

        // Evpd is set

        memcpy(_packetData.get(),page00,sizeof(page00));
        _packetSize=7;
      }
      else {

        // send the event that gets the page data

        MscBotGetEnquiryPageEvent event(lun);
        _eventSource.UsbEventSender.raiseEvent(event);

        // packet size is in the page data

        _packetSize=event.enquiryPage[4]+5;

        // trim to limit and copy

        if(params[4]<_packetSize)
          _packetSize=params[4];

        memcpy(_packetData.get(),event.enquiryPage,_packetSize);
      }

      return true;
    }


    /**
     * Process Start Stop Unit command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval true
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::startStopUnit() {

      _packetSize=0;
      return true;
    }


    /**
     * Process Mode Sense6 command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval true
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::modeSense6(uint8_t lun) {

      uint8_t *ptr;

      // get the write-protection status

      MscBotIsWriteProtectedEvent writeProtectedEvent(lun);
      _eventSource.UsbEventSender.raiseEvent(writeProtectedEvent);

      ptr=_packetData.get();

      ptr[0]=3;     // bytes to follow
      ptr[1]=0;     // 00h for SBC devices
      ptr[2]=writeProtectedEvent.isWriteProtected ? 0x80 : 0;
      ptr[3]=0;     // no block descriptors

      _packetSize=4;
      return true;
    }


    /**
     * @brief  Process Mode Sense10 command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval status
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::modeSense10() {

      static const uint8_t data[8]={ 0,6,0,0,0,0,0,0 };

      memcpy(_packetData.get(),data,sizeof(data));
      _packetSize=sizeof(data);
      return true;
    }


    /**
     * Process Read Format Capacity command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval true/false
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::readFormatCapacity(uint8_t lun) {

      MscBotGetCapacityEvent event(lun);
      uint8_t *ptr;

      _eventSource.UsbEventSender.raiseEvent(event);

      if(event.ready) {

        ptr=_packetData.get();

        _blkSize=event.blockSize;
        _blkNbr=event.blockCount;

        ptr[0]=0;
        ptr[1]=0;
        ptr[2]=0;

        ptr[3]=16;                  // 2 descriptors

        ptr[4]=ptr[12]=_blkNbr >> 24;       // number of blocks
        ptr[5]=ptr[13]=_blkNbr >> 16;
        ptr[6]=ptr[14]=_blkNbr >> 8;
        ptr[7]=ptr[15]=_blkNbr;

        ptr[8]=2;                   // formatted media
        ptr[9]=ptr[17]=_blkSize >> 16;
        ptr[10]=ptr[18]=_blkSize >> 8;
        ptr[11]=ptr[19]=_blkSize;

        ptr[16]=0;                  // addressable blocks

        _packetSize=20;
        return true;
      }
      else {
        senseCode(lun,MscScsiSense::NOT_READY,MscScsiSense::MEDIUM_NOT_PRESENT);
        return false;
      }
    }


    /**
     * Process Read Capacity 10 command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval true/false
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::readCapacity10(uint8_t lun) {

      MscBotGetCapacityEvent event(lun);
      uint8_t *ptr;

      _eventSource.UsbEventSender.raiseEvent(event);

      if(event.ready) {

        _blkSize=event.blockSize;
        _blkNbr=event.blockCount;

        ptr=_packetData.get();

        ptr[0]=(_blkNbr-1) >> 24;
        ptr[1]=(_blkNbr-1) >> 16;
        ptr[2]=(_blkNbr-1) >> 8;
        ptr[3]=_blkNbr-1;

        ptr[4]=_blkSize >> 24;
        ptr[5]=_blkSize >> 16;
        ptr[6]=_blkSize >> 8;
        ptr[7]=_blkSize;

        _packetSize=8;
        return true;
      }
      else {
        senseCode(lun,MscScsiSense::NOT_READY,MscScsiSense::MEDIUM_NOT_PRESENT);
        return false;
      }
    }


    /**
     * @brief  SCSI_Read10
     *         Process Read10 command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval status
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::read10(uint8_t lun,uint8_t *params,MscBotCommandBlockWrapper& cbw,MscBotCommandStatusWrapper& csw) {

      if(_botState==MscBotState::IDLE) {

        // case 10 : Ho <> Di

        if((cbw.bmFlags & 0x80)!=0x80) {

          senseCode(cbw.bLUN,MscScsiSense::ILLEGAL_REQUEST,MscScsiSense::INVALID_CDB);
          return false;
        }

        // send the 'is ready' event

        MscBotIsReadyEvent event(lun);
        _eventSource.UsbEventSender.raiseEvent(event);

        if(!event.isReady) {

          senseCode(lun,MscScsiSense::NOT_READY,MscScsiSense::MEDIUM_NOT_PRESENT);
          return false;
        }

        // get block address and length

        _blkAddr=(params[2] << 24) | (params[3] << 16) | (params[4] << 8) | params[5];
        _blkLen=(params[7] << 8) | params[8];

        if(!checkAddressRange(lun,_blkAddr,_blkLen))
          return false;

        // set the data-in state

        _botState=MscBotState::DATA_IN;

        // convert to byte addresses

        _blkAddr*=_blkSize;
        _blkLen*=_blkSize;

        // cases 4,5 : Hi <> Dn

        if(cbw.dDataLength!=_blkLen) {
          senseCode(cbw.bLUN,MscScsiSense::ILLEGAL_REQUEST,MscScsiSense::INVALID_CDB);
          return false;
        }
      }

      // do the read operation

      _packetSize=_maxPacketSize;
      return processRead(lun,csw);
    }


    /**
     * Handle Read Process
     * @param lun: Logical unit number
     * @retval true if it worked
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::processRead(uint8_t lun,MscBotCommandStatusWrapper& csw) {

      uint32_t len;

      // send the event to read the data

      len=_blkLen<_maxPacketSize ? _blkLen : _maxPacketSize;

      MscBotReadEvent event(lun,_packetData.get(),_blkAddr/_blkSize,len/_blkSize);

      _eventSource.UsbEventSender.raiseEvent(event);

      if(!event.success) {
        senseCode(lun,MscScsiSense::HARDWARE_ERROR,MscScsiSense::UNRECOVERED_READ_ERROR);
        return false;
      }

      // transmit to the host

      USBD_LL_Transmit(&_deviceHandle,TInEndpointAddress,_packetData.get(),len);

      // update addresses for sequential read

      _blkAddr+=len;
      _blkLen-=len;

      // case 6 : Hi = Di

      csw.dDataResidue-=len;

      if(_blkLen==0)
        _botState=MscBotState::LAST_DATA_IN;

      return true;
    }


    /**
     * Process Write10 command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval true/false
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::write10(uint8_t lun ,uint8_t *params,MscBotCommandBlockWrapper& cbw,MscBotCommandStatusWrapper& csw) {

      if(_botState==MscBotState::IDLE) {

        // case 8 : Hi <> Do

        if((cbw.bmFlags & 0x80)==0x80) {
          senseCode(cbw.bLUN,MscScsiSense::ILLEGAL_REQUEST,MscScsiSense::INVALID_CDB);
          return false;
        }

        // send the 'is ready' event

        MscBotIsReadyEvent readyEvent(lun);
        _eventSource.UsbEventSender.raiseEvent(readyEvent);

        if(!readyEvent.isReady) {
          senseCode(lun,MscScsiSense::NOT_READY,MscScsiSense::MEDIUM_NOT_PRESENT);
          return false;
        }

        // send the 'is write protected' event

        MscBotIsWriteProtectedEvent writeProtectedEvent(lun);
        _eventSource.UsbEventSender.raiseEvent(writeProtectedEvent);

        if(writeProtectedEvent.isWriteProtected) {
          senseCode(lun,MscScsiSense::NOT_READY,MscScsiSense::WRITE_PROTECTED);
          return false;
        }

        // get address and size

        _blkAddr=(params[2] << 24) | (params[3] << 16) | (params[4] << 8) | params[5];
        _blkLen=(params[7] << 8) | params[8];

        // check if LBA address is in the right range

        if(!checkAddressRange(lun,_blkAddr,_blkLen))
          return false;

        // convert to byte addresses

        _blkAddr*=_blkSize;
        _blkLen*=_blkSize;

        // cases 3,11,13 : Hn,Ho <> D0

        if(cbw.dDataLength!=_blkLen) {
          senseCode(cbw.bLUN,MscScsiSense::ILLEGAL_REQUEST,MscScsiSense::INVALID_CDB);
          return false;
        }

        // Prepare EP to receive first data packet

        _botState=MscBotState::DATA_OUT;

        USBD_LL_PrepareReceive(
            &_deviceHandle,
            TOutEndpointAddress,
            _packetData.get(),
            _blkLen<_maxPacketSize ? _blkLen : _maxPacketSize);

        return true;
      }
      else  // write process ongoing
        return processWrite(lun,cbw,csw);
    }


    /**
     * Process ongoing write
     * @param lun The logical unit number
     * @return true/false
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::processWrite(uint8_t lun,MscBotCommandBlockWrapper& cbw,MscBotCommandStatusWrapper& csw) {

      uint32_t len;

      // send the write event

      len=_blkLen<_maxPacketSize ? _blkLen : _maxPacketSize;

      MscBotWriteEvent event(lun,_packetData.get(),_blkAddr/_blkSize,len/_blkSize);

      _eventSource.UsbEventSender.raiseEvent(event);

      if(!event.success) {
        senseCode(lun,MscScsiSense::HARDWARE_ERROR,MscScsiSense::WRITE_FAULT);
        return false;
      }

      // update for sequential write

      _blkAddr+=len;
      _blkLen-=len;

      // case 12 : Ho = Do

      csw.dDataResidue-=len;

      if(_blkLen==0)
        csw.send<TInEndpointAddress,TOutEndpointAddress>(MscBotCswStatus::CMD_PASSED,_botState,_deviceHandle,cbw);
      else {

        // prepare to receive the next packet

        USBD_LL_PrepareReceive(
            &_deviceHandle,
            TOutEndpointAddress,
            _packetData.get(),
            _blkLen<_maxPacketSize ? _blkLen : _maxPacketSize);
      }

      return true;
    }


    /**
     * Process Verify10 command
     * @param  lun: Logical unit number
     * @param  params: Command parameters
     * @retval true/false
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::verify10(uint8_t lun,uint8_t *params) {

      if((params[1] & 0x02)==0x02) {
        senseCode(lun,MscScsiSense::ILLEGAL_REQUEST,MscScsiSense::INVALID_FIELED_IN_COMMAND);
        return false;
      }

      if(!checkAddressRange(lun,_blkAddr,_blkLen))
        return false;

      _packetSize=0;
      return true;
    }


    /**
     * Check address range
     * @param  lun: Logical unit number
     * @param  blk_offset: first block address
     * @param  blk_nbr: number of block to be processed
     * @retval true if it worked
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline bool MscScsi<TInEndpointAddress,TOutEndpointAddress>::checkAddressRange(uint8_t lun,uint32_t blk_offset,uint16_t blk_nbr) {

      if(blk_offset+blk_nbr>_blkNbr) {
        senseCode(lun,MscScsiSense::ILLEGAL_REQUEST,MscScsiSense::ADDRESS_OUT_OF_RANGE);
        return false;
      }

      return true;
    }


    /**
     * @brief  Load the last error code in the error list
     * @param  lun: Logical unit number
     * @param  sKey: Sense Key
     * @param  ASC: Additional Sense Key
     * @retval none
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline void MscScsi<TInEndpointAddress,TOutEndpointAddress>::senseCode(uint8_t /* lun */,uint8_t sKey,uint8_t asc) {

      _sense[_senseTail].Skey=sKey;
      _sense[_senseTail].w.ASC=asc << 8;

      _senseTail++;

      if(_senseTail==MscScsi::SENSE_LIST_DEPTH)
        _senseTail=0;
    }


    /**
     * Get the data packet size
     * @return The data packet size
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline uint16_t MscScsi<TInEndpointAddress,TOutEndpointAddress>::getDataSize() const {
      return _packetSize;
    }


    /**
     * Get the data packet size
     * @return The data packet size
     */

    template<uint8_t TInEndpointAddress,uint8_t TOutEndpointAddress>
    inline uint8_t *MscScsi<TInEndpointAddress,TOutEndpointAddress>::getData() const {
      return _packetData.get();
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscScsi.h
// START FILE: ../lib/include/usb/f4/device/msc/MscScsiSense.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * SCSI sense structure
     */

    struct MscScsiSense {

      enum {
        NO_SENSE        = 0,
        RECOVERED_ERROR = 1,
        NOT_READY       = 2,
        MEDIUM_ERROR    = 3,
        HARDWARE_ERROR  = 4,
        ILLEGAL_REQUEST = 5,
        UNIT_ATTENTION  = 6,
        DATA_PROTECT    = 7,
        BLANK_CHECK     = 8,
        VENDOR_SPECIFIC = 9,
        COPY_ABORTED    = 10,
        ABORTED_COMMAND = 11,
        VOLUME_OVERFLOW = 13,
        MISCOMPARE      = 14
      };

      enum {
        INVALID_CDB                     = 0x20,
        INVALID_FIELED_IN_COMMAND       = 0x24,
        PARAMETER_LIST_LENGTH_ERROR     = 0x1A,
        INVALID_FIELD_IN_PARAMETER_LIST = 0x26,
        ADDRESS_OUT_OF_RANGE            = 0x21,
        MEDIUM_NOT_PRESENT              = 0x3A,
        MEDIUM_HAVE_CHANGED             = 0x28,
        WRITE_PROTECTED                 = 0x27,
        UNRECOVERED_READ_ERROR          = 0x11,
        WRITE_FAULT                     = 0x03
      };

      char Skey;
      union {
        struct _ASCs {
          char ASC;
          char ASCQ;
        } b;
        unsigned int ASC;
        char *pData;
      } w;
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscScsiSense.h
// START FILE: ../lib/include/usb/f4/device/msc/events/MscBotIsWriteProtectedEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Event to get the 'is write protected' state. There is no default, receivers
     * must implement this.
     */

    struct MscBotIsWriteProtectedEvent : UsbEventDescriptor {

      bool isWriteProtected;
      uint8_t lun;

      MscBotIsWriteProtectedEvent(uint8_t l)
        : UsbEventDescriptor(EventType::MSC_BOT_IS_WRITE_PROTECTED),
          lun(l) {
      }
    };
  }
}

// END FILE: ../lib/include/usb/f4/device/msc/events/MscBotIsWriteProtectedEvent.h
// START FILE: ../lib/include/usb/f4/device/msc/events/MscBotReadEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Read data from the LUN. Block address is a block index, not a byte address.
     */

    struct MscBotReadEvent : UsbEventDescriptor {

      bool success;
      uint8_t lun;
      uint8_t *buffer;
      uint32_t blockAddress;
      uint16_t blockCount;

      MscBotReadEvent(uint8_t l,uint8_t *buf,uint32_t blk_addr,uint16_t blk_len)
        : UsbEventDescriptor(EventType::MSC_BOT_READ),
          lun(l),
          buffer(buf),
          blockAddress(blk_addr),
          blockCount(blk_len) {
      }
    };
  }
}

// END FILE: ../lib/include/usb/f4/device/msc/events/MscBotReadEvent.h
// START FILE: ../lib/include/usb/f4/device/msc/events/MscBotResetEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Notify that the BOT device is being reset
     */

    struct MscBotResetEvent : UsbEventDescriptor {

      MscBotResetEvent()
        : UsbEventDescriptor(EventType::MSC_BOT_RESET) {
      }
    };
  }
}

// END FILE: ../lib/include/usb/f4/device/msc/events/MscBotResetEvent.h
// START FILE: ../lib/include/usb/f4/device/msc/events/MscBotGetCapacityEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Sent to request the capacity in terms of block size and number of blocks. Receiver
     * should set the size and count if the disk is online. If no disk is ready then set
     * read to false, otherwise set to true.
     */

    struct MscBotGetCapacityEvent : UsbEventDescriptor {

      uint8_t lun;
      uint16_t blockSize;
      uint32_t blockCount;
      bool ready;

      MscBotGetCapacityEvent(uint8_t l)
        : UsbEventDescriptor(EventType::MSC_BOT_GET_CAPACITY),
          lun(l) {
      }
    };
  }
}

// END FILE: ../lib/include/usb/f4/device/msc/events/MscBotGetCapacityEvent.h
// START FILE: ../lib/include/usb/f4/device/msc/events/MscBotGetInquiryPageEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Sent to request the page data for a SCSI enquiry. The receiver should set enquiryPage to a
     * pointer to the enquiry response. The enquiry response is:

      +=====-========-========-========-========-========-========-========-========+
      |  Bit|   7    |   6    |   5    |   4    |   3    |   2    |   1    |   0    |
      |Byte |        |        |        |        |        |        |        |        |
      |=====+==========================+============================================|
      | 0   | Peripheral Qualifier     |           Peripheral Device Type           |
      |-----+-----------------------------------------------------------------------|
      | 1   |  RMB   |                  Device-Type Modifier                        |
      |-----+-----------------------------------------------------------------------|
      | 2   |   ISO Version   |       ECMA Version       |  ANSI-Approved Version   |
      |-----+-----------------+-----------------------------------------------------|
      | 3   |  AENC  | TrmIOP |     Reserved    |         Response Data Format      |
      |-----+-----------------------------------------------------------------------|
      | 4   |                           Additional Length (n-4)                     |
      |-----+-----------------------------------------------------------------------|
      | 5   |                           Reserved                                    |
      |-----+-----------------------------------------------------------------------|
      | 6   |                           Reserved                                    |
      |-----+-----------------------------------------------------------------------|
      | 7   | RelAdr | WBus32 | WBus16 |  Sync  | Linked |Reserved| CmdQue | SftRe  |
      |-----+-----------------------------------------------------------------------|
      | 8   | (MSB)                                                                 |
      |- - -+---                        Vendor Identification                    ---|
      | 15  |                                                                 (LSB) |
      |-----+-----------------------------------------------------------------------|
      | 16  | (MSB)                                                                 |
      |- - -+---                        Product Identification                   ---|
      | 31  |                                                                 (LSB) |
      |-----+-----------------------------------------------------------------------|
      | 32  | (MSB)                                                                 |
      |- - -+---                        Product Revision Level                   ---|
      | 35  |                                                                 (LSB) |
      |-----+-----------------------------------------------------------------------|
    */

    struct MscBotGetEnquiryPageEvent : UsbEventDescriptor {

      uint8_t lun;
      const uint8_t *enquiryPage;

      MscBotGetEnquiryPageEvent(uint8_t l)
        : UsbEventDescriptor(EventType::MSC_BOT_GET_ENQUIRY_PAGE),
          lun(l) {
      }
    };
  }
}

// END FILE: ../lib/include/usb/f4/device/msc/events/MscBotGetInquiryPageEvent.h
// START FILE: ../lib/include/usb/f4/device/msc/events/MscBotWriteEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Write data to the LUN. Block address is a block index, not a byte address.
     */

    struct MscBotWriteEvent : UsbEventDescriptor {

      bool success;
      uint8_t lun;
      const uint8_t *buffer;
      uint32_t blockAddress;
      uint16_t blockCount;

      MscBotWriteEvent(uint8_t l,const uint8_t *buf,uint32_t blk_addr,uint16_t blk_len)
        : UsbEventDescriptor(EventType::MSC_BOT_WRITE),
          lun(l),
          buffer(buf),
          blockAddress(blk_addr),
          blockCount(blk_len) {
      }
    };
  }
}

// END FILE: ../lib/include/usb/f4/device/msc/events/MscBotWriteEvent.h
// START FILE: ../lib/include/usb/f4/device/msc/events/MscBotGetMaxLunEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Sent to request the maximum logical unit number (LUN). The default is zero.
     */

    struct MscBotGetMaxLunEvent : UsbEventDescriptor {

      uint8_t maxLun;

      MscBotGetMaxLunEvent()
        : UsbEventDescriptor(EventType::MSC_BOT_GET_MAX_LUN),
          maxLun(0) {
      }
    };
  }
}

// END FILE: ../lib/include/usb/f4/device/msc/events/MscBotGetMaxLunEvent.h
// START FILE: ../lib/include/usb/f4/device/msc/events/MscBotIsReadyEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Event to get the 'is ready' status
     */

    struct MscBotIsReadyEvent : UsbEventDescriptor {

      bool isReady;
      uint8_t lun;

      MscBotIsReadyEvent(uint8_t l)
        : UsbEventDescriptor(EventType::MSC_BOT_IS_READY),
          isReady(true),
          lun(l) {
      }
    };
  }
}

// END FILE: ../lib/include/usb/f4/device/msc/events/MscBotIsReadyEvent.h
// START FILE: ../lib/include/usb/f4/device/msc/MscBotStatus.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Status of the BOT
     */

    enum class MscBotStatus : uint8_t  {
      NORMAL,
      RECOVERY,
      ERROR
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscBotStatus.h
// START FILE: ../lib/include/usb/f4/device/msc/MscBotCommandStatusWrapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Command status wrapper (CSW) structure
     */

    struct MscBotCommandStatusWrapper {

      enum {
        SIGNATURE = 0x53425355,
        TRANSMIT_SIZE = 13
      };

      uint32_t dSignature;
      uint32_t dTag;
      uint32_t dDataResidue;
      MscBotCswStatus bStatus;
      uint8_t reservedAlign[3];

      /**
       * Constructor
       */

      MscBotCommandStatusWrapper() {
        static_assert(sizeof(MscBotCommandStatusWrapper)==16,"Compiler error: sizeof(MscBotCommandStatusWrapper)!=16");
        dSignature=SIGNATURE;
      }


      /**
       * Utility function to send the CSW. The CSW is passed bSetween BOT and SCSI objects so a common
       * place to call the send function is required
       * @param status The CSW status
       * @param botState Refence to bot state so it can be updated
       * @param deviceHandle Reference to the device handle
       * @param cbw The CBW object to receive next command
       */

      template<uint8_t TInEpAddress,uint8_t TOutEpAddress>
      void send(MscBotCswStatus status,MscBotState& botState,USBD_HandleTypeDef& deviceHandle,MscBotCommandBlockWrapper& cbw) {

        bStatus=status;
        botState=MscBotState::IDLE;

        // send the status

        USBD_LL_Transmit(
            &deviceHandle,
            TInEpAddress,
            reinterpret_cast<uint8_t *>(this),
            TRANSMIT_SIZE);

        // prepare EP to receive next command

        USBD_LL_PrepareReceive(
            &deviceHandle,
            TOutEpAddress,
            reinterpret_cast<uint8_t *>(&cbw),
            MscBotCommandBlockWrapper::RECEIVE_SIZE);
      }

    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscBotCommandStatusWrapper.h
// START FILE: ../lib/include/usb/f4/device/msc/MscDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Intermediate base class for mass storage device implementations. Provides common
     * functionality for all mass storage device types.
     *
     * @tparam TPhy the PHY implementation
     * @tparam TConfigurationDescriptor A structure that holds the complete config descriptor
     * @tparam Features... The device feature classes
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    class MscDevice : public Device<TPhy>,
                      public ControlEndpointFeature<Device<TPhy>>,
                      public Features<Device<TPhy>>... {


      public:

        /*
         * Parameters for the MSC device
         */

        struct Parameters : Device<TPhy>::Parameters,
                            ControlEndpointFeature<Device<TPhy>>::Parameters,
                            Features<Device<TPhy>>::Parameters... {

          Parameters() {
          }
        };

      protected:
        TConfigurationDescriptor  _configurationDescriptor;

      protected:
        void onEvent(UsbEventDescriptor& event);
        void onGetConfigurationDescriptor(DeviceClassSdkGetConfigurationDescriptorEvent& event);

      public:
        MscDevice();
        ~MscDevice();

        bool initialise(Parameters& params);
    };


    /**
     * Constructor
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline MscDevice<TPhy,TConfigurationDescriptor,Features...>::MscDevice()
      : ControlEndpointFeature<Device<TPhy>>(static_cast<Device<TPhy>&>(*this)),
        Features<Device<TPhy>>(static_cast<Device<TPhy>&>(*this))... {

      // subscribe to USB events

      this->UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&MscDevice<TPhy,TConfigurationDescriptor,Features...>::onEvent)
        );
    }


    /**
     * Destructor
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline MscDevice<TPhy,TConfigurationDescriptor,Features...>::~MscDevice() {

      // unsubscribe from USB events

      this->UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&MscDevice<TPhy,TConfigurationDescriptor,Features...>::onEvent)
        );
    }


    /**
     * Initialise the class
     * @param params The parameters class
     * @return true if it worked
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline bool MscDevice<TPhy,TConfigurationDescriptor,Features...>::initialise(Parameters& params) {

      // initialise upwards

      if(!Device<TPhy>::initialise(params) ||
         !ControlEndpointFeature<Device<TPhy>>::initialise(params) ||
         !RecursiveBoolInitWithParams<MscDevice,Features<Device<TPhy>>...>::tinit(this,params))
        return false;

      // link UsbEventSource class into the SDK structure

      USBD_RegisterClass(&this->_deviceHandle,static_cast<UsbEventSource *>(this));
      return true;
    }


    /**
     * Event handler for device events
     * @param event The event descriptor
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline void MscDevice<TPhy,TConfigurationDescriptor,Features...>::onEvent(UsbEventDescriptor& event) {

      // check for handled events

      switch(event.eventType) {

        case UsbEventDescriptor::EventType::CLASS_GET_CONFIGURATION_DESCRIPTOR:
          onGetConfigurationDescriptor(static_cast<DeviceClassSdkGetConfigurationDescriptorEvent&>(event));
          break;

        default:
          break;
      }
    }


    /**
     * Get the configuration descriptor
     * @param event The event class to receive the descriptor and provide type of descriptor being requested
     */

    template<class TPhy,class TConfigurationDescriptor,template <class> class... Features>
    inline void MscDevice<TPhy,TConfigurationDescriptor,Features...>::onGetConfigurationDescriptor(DeviceClassSdkGetConfigurationDescriptorEvent& event) {

      if(event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::HIGH_SPEED ||
         event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::FULL_SPEED ||
         event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::OTHER_SPEED) {

        // set up the values in the event

        event.length=sizeof(_configurationDescriptor);
        event.descriptor=reinterpret_cast<uint8_t *>(&_configurationDescriptor);
      }
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscDevice.h
// START FILE: ../lib/include/usb/f4/device/msc/MscBotCommandBlockWrapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Command block wrapper (CBW) structure
     */

    struct MscBotCommandBlockWrapper {

      enum {
        SIGNATURE = 0x43425355,
        RECEIVE_SIZE = 31
      };

      uint32_t dSignature;
      uint32_t dTag;
      uint32_t dDataLength;
      uint8_t bmFlags;
      uint8_t bLUN;
      uint8_t bCBLength;
      uint8_t CB[16];
      uint8_t reservedAlign;
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscBotCommandBlockWrapper.h
// START FILE: ../lib/include/usb/f4/device/msc/MscBotClassRequest.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * BOT Device class requests
     */

    enum class MscBotClassRequest : uint8_t {

      GET_MAX_LUN = 0xFE,   //!< get the maximum LUN number
      RESET = 0xFF          //!< reset the device
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscBotClassRequest.h
// START FILE: ../lib/include/usb/f4/device/msc/MscScsiCommand.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * SCSI commands
     */

    enum class MscScsiCommand : uint8_t {
      FORMAT_UNIT            = 0x04,
      INQUIRY                = 0x12,
      MODE_SELECT6           = 0x15,
      MODE_SELECT10          = 0x55,
      MODE_SENSE6            = 0x1A,
      MODE_SENSE10           = 0x5A,
      ALLOW_MEDIUM_REMOVAL   = 0x1E,
      READ6                  = 0x08,
      READ10                 = 0x28,
      READ12                 = 0xA8,
      READ16                 = 0x88,

      READ_CAPACITY10        = 0x25,
      READ_CAPACITY16        = 0x9E,

      REQUEST_SENSE          = 0x03,
      START_STOP_UNIT        = 0x1B,
      TEST_UNIT_READY        = 0x00,
      WRITE6                 = 0x0A,
      WRITE10                = 0x2A,
      WRITE12                = 0xAA,
      WRITE16                = 0x8A,

      VERIFY10               = 0x2F,
      VERIFY12               = 0xAF,
      VERIFY16               = 0x8F,

      SEND_DIAGNOSTIC        = 0x1D,
      READ_FORMAT_CAPACITIES = 0x23
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscScsiCommand.h
// START FILE: ../lib/include/usb/f4/device/msc/MscBotCswStatus.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * CSW status codes
     */

    enum class MscBotCswStatus : uint8_t {

      CMD_PASSED = 0,   //!< CMD_PASSED
      CMD_FAILED = 1,   //!< CMD_FAILED
      PHASE_ERROR = 2   //!< PHASE_ERROR
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscBotCswStatus.h
// START FILE: ../lib/include/usb/f4/device/msc/MscBotState.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * States for the BOT
     */

    enum class MscBotState : uint8_t  {
      IDLE,           //!< IDLE
      DATA_OUT,       //!< DATA_OUT
      DATA_IN,        //!< DATA_IN
      LAST_DATA_IN,   //!< LAST_DATA_IN
      SEND_DATA,      //!< SEND_DATA
      NO_DATA         //!< NO_DATA
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscBotState.h
// START FILE: ../lib/include/usb/f4/device/msc/MscProtocol.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * MSC protocol codes
     */

    enum class MscProtocol : uint8_t {
      CBI_WITH_CCI = 0,
      CBI_WITHOUT_CCI = 1,
      BOT = 0x50,
      UAS = 0x62,
      VENDOR = 0xff
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/MscProtocol.h
// START FILE: ../lib/include/usb/f4/device/msc/BotMscDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Endpoints used by this device. The Bulk Only Transport has one bulk IN and one OUT
     * endpoint.
     */

    template<class TDevice> using BotMscDeviceInEndpoint=BulkInEndpointFeature<1,TDevice>;
    template<class TDevice> using BotMscDeviceOutEndpoint=BulkOutEndpointFeature<2,TDevice>;


    /**
     * Declare the structure that gets sent back when the host asks for the whole
     * configuration descriptor
     */

    struct BotMscDeviceConfigurationDescriptor {
      ConfigurationDescriptor configuration;
      InterfaceDescriptor itf;
      EndpointDescriptor inEndpoint;
      EndpointDescriptor outEndpoint;
    } __attribute__((packed));


    /**
     * Derivation of MscDevice to provide support for the Bulk Only Transport (BOT). BOT
     * is the most common transport used in USB sticks and USB hard disks. The protocol
     * implements a limited SCSI command subset.
     *
     *   1x Configuration descriptor
     *   2x Interfaces
     *   1x Inbound bulk data endpoint
     *   1x Outbound bulk data endpoint
     */

     template<class TPhy,template <class> class... Features>
     class BotMscDevice : public MscDevice<TPhy,
                                           BotMscDeviceConfigurationDescriptor,
                                           BotMscDeviceInEndpoint,
                                           BotMscDeviceOutEndpoint,
                                           Features...> {

       public:

         typedef MscDevice<TPhy,
                           BotMscDeviceConfigurationDescriptor,
                           BotMscDeviceInEndpoint,
                           BotMscDeviceOutEndpoint,
                           Features...> MscDeviceBase;

         /*
          * Endpoint addresses
          */

         enum {
           IN_EP_ADDRESS = EndpointDescriptor::IN | 1,     // IN endpoint address
           OUT_EP_ADDRESS = EndpointDescriptor::OUT | 2,   // OUT endpoint address
         };


         /**
          * Customisable parameters for this MSC BOT device
          */

         struct Parameters : MscDeviceBase::Parameters, MscScsi<IN_EP_ADDRESS,OUT_EP_ADDRESS>::Parameters {

           uint16_t msc_bot_max_packet_size;        // default is 64 bytes

           Parameters() {
             msc_bot_max_packet_size=0x40;
           }
         };

       protected:

         uint8_t _interface;
         uint8_t _maxLun;
         MscBotState _state;
         MscBotStatus _status;
         MscBotCommandBlockWrapper _cbw;
         MscBotCommandStatusWrapper _csw;
         MscScsi<IN_EP_ADDRESS,OUT_EP_ADDRESS> _scsi;

      protected:
        void onEvent(UsbEventDescriptor& event);

        void onInit();
        void onDeInit();
        void onSetup(DeviceClassSdkSetupEvent& event);
        void onSetupClass(DeviceClassSdkSetupEvent& event);
        void onSetupInterfaceAndEndpoint(DeviceClassSdkSetupEvent& event);
        void onGetMaxLun(DeviceClassSdkSetupEvent& event);
        void onBotReset(DeviceClassSdkSetupEvent& event);
        void onClearFeature(DeviceClassSdkSetupEvent& event);
        void onDataIn();
        void onDataOut();

        void decodeCbw();
        void abortTransfer();
        void sendData(uint8_t *buf,uint16_t len);

      public:
        BotMscDevice();
        ~BotMscDevice();

        bool initialise(Parameters& params);
    };


    /**
     * Constructor
     */

    template<class TPhy,template <class> class... Features>
    inline BotMscDevice<TPhy,Features...>::BotMscDevice()
      : _scsi(_state,static_cast<UsbEventSource&>(*this),this->_deviceHandle) {

      // subscribe to USB events

      this->UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&BotMscDevice<TPhy,Features...>::onEvent)
        );
    }


    /**
     * Destructor
     */

    template<class TPhy,template <class> class... Features>
    inline BotMscDevice<TPhy,Features...>::~BotMscDevice() {

      // unsubscribe from USB events

      this->UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&BotMscDevice<TPhy,Features...>::onEvent)
        );
    }


    /**
     * Initialise the class
     * @param param The parameters structure
     * @return true if it worked
     */

    template<class TPhy,template <class> class... Features>
    inline bool BotMscDevice<TPhy,Features...>::initialise(Parameters& params) {

      USBD_StatusTypeDef status;

      // initialise upwards

      if(!MscDeviceBase::initialise(params) || !_scsi.initialise(params))
        return false;

      // set up the configuration descriptor (see constructor for defaults)

      this->_configurationDescriptor.configuration.wTotalLength=sizeof(this->_configurationDescriptor);
      this->_configurationDescriptor.configuration.bNumInterfaces=1;
      this->_configurationDescriptor.configuration.bmAttributes=0x80 | ConfigurationDescriptor::SELF_POWERED;

      // if ConfigurationTextFeature is in the hierarchy then we've got a configuration string (compile-time check)

      if(std::is_base_of<ConfigurationTextFeature<Device<TPhy>>,BotMscDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.configuration.iConfiguration=USBD_IDX_CONFIG_STR;

      // set up the interface descriptor

      this->_configurationDescriptor.itf.bInterfaceNumber=0;
      this->_configurationDescriptor.itf.bNumEndpoints=2;
      this->_configurationDescriptor.itf.bInterfaceClass=static_cast<uint8_t>(DeviceClass::MASS_STORAGE);
      this->_configurationDescriptor.itf.bInterfaceSubClass=static_cast<uint8_t>(MscSubClass::SCSI_TRANSPARENT);
      this->_configurationDescriptor.itf.bInterfaceProtocol=static_cast<uint8_t>(MscProtocol::BOT);

      // if InterfaceTextFeature is in the hierarchy then we've got an interface string (compile-time check)

      if(std::is_base_of<InterfaceTextFeature<Device<TPhy>>,BotMscDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.itf.iInterface=USBD_IDX_INTERFACE_STR;

      // set up the OUT endpoint descriptor

      this->_configurationDescriptor.outEndpoint.bEndpointAddress=OUT_EP_ADDRESS;
      this->_configurationDescriptor.outEndpoint.bmAttributes=EndpointDescriptor::BULK;
      this->_configurationDescriptor.outEndpoint.wMaxPacketSize=params.msc_bot_max_packet_size;         // LED reports are 1 byte

      // set up the IN endpoint descriptor

      this->_configurationDescriptor.inEndpoint.bEndpointAddress=IN_EP_ADDRESS;
      this->_configurationDescriptor.inEndpoint.bmAttributes=EndpointDescriptor::BULK;
      this->_configurationDescriptor.inEndpoint.wMaxPacketSize=params.msc_bot_max_packet_size;

      // set up the qualifier descriptor (see constructor for defaults)

      this->_qualifierDescriptor.bMaxPacketSize0=0x40;
      this->_qualifierDescriptor.bNumConfigurations=1;

      // start the device

      if((status=USBD_Start(&this->_deviceHandle))!=USBD_OK)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_USB_DEVICE,this->E_START,status);

      // OK

      return true;
    }


    /**
     * Event handler for device events
     * @param event The event descriptor
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onEvent(UsbEventDescriptor& event) {
      // check for handled events

      switch(event.eventType) {

        case UsbEventDescriptor::EventType::CLASS_INIT:
          onInit();
          break;

        case UsbEventDescriptor::EventType::CLASS_DEINIT:
          onDeInit();
          break;

        case UsbEventDescriptor::EventType::CLASS_SETUP:
          onSetup(static_cast<DeviceClassSdkSetupEvent&>(event));
          break;

        case UsbEventDescriptor::EventType::CLASS_DATA_IN:
          onDataIn();
          break;

        case UsbEventDescriptor::EventType::CLASS_DATA_OUT:
          onDataOut();
          break;

        default:    // warning supression
          break;
      }
    }


    /**
     * Initialise event
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onInit() {

      // set members

      _state=MscBotState::IDLE;
      _status=MscBotStatus::NORMAL;

      // reset SCSI state

      _scsi.onInit();

      // open the two endpoints

      USBD_LL_OpenEP(
          &this->_deviceHandle,
          IN_EP_ADDRESS,
          EndpointDescriptor::BULK,
          this->_configurationDescriptor.inEndpoint.wMaxPacketSize);

      USBD_LL_OpenEP(
          &this->_deviceHandle,
          OUT_EP_ADDRESS,
          EndpointDescriptor::BULK,
          this->_configurationDescriptor.outEndpoint.wMaxPacketSize);

      // flush the endpoints

      USBD_LL_FlushEP(&this->_deviceHandle,IN_EP_ADDRESS);
      USBD_LL_FlushEP(&this->_deviceHandle,OUT_EP_ADDRESS);

      // prepare EP to receive first BOT command

      static_assert(sizeof(_cbw)==32,"Compiler error: sizeof(MscBotCommandBlockWrapper)!=32");

      USBD_LL_PrepareReceive(
          &this->_deviceHandle,
          OUT_EP_ADDRESS,
          reinterpret_cast<uint8_t *>(&_cbw),
          MscBotCommandBlockWrapper::RECEIVE_SIZE);
    }


    /**
     * DeInitialise event
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onDeInit() {

      // close the two endpoints

      USBD_LL_CloseEP(&this->_deviceHandle,IN_EP_ADDRESS);
      USBD_LL_CloseEP(&this->_deviceHandle,OUT_EP_ADDRESS);

      // state is now idle

      _state=MscBotState::IDLE;
    }


    /**
     * Setup event
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onSetup(DeviceClassSdkSetupEvent& event) {

      switch (event.request.bmRequest & USB_REQ_TYPE_MASK) {

        case USB_REQ_TYPE_CLASS :
          onSetupClass(event);
          break;

        case USB_REQ_TYPE_STANDARD:
          onSetupInterfaceAndEndpoint(event);
          break;
      }
    }


    /**
     * Device class setup event
     * @param event The event details
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onSetupClass(DeviceClassSdkSetupEvent& event) {

      switch(static_cast<MscBotClassRequest>(event.request.bRequest)) {

        case MscBotClassRequest::GET_MAX_LUN:
          onGetMaxLun(event);
          break;

        case MscBotClassRequest::RESET:
          onBotReset(event);
          break;

        default:
          USBD_CtlError(&this->_deviceHandle,&event.request);
          break;
      }
    }


    /**
     * Get the max logical unit number (LUN)
     * @param event The event details
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onGetMaxLun(DeviceClassSdkSetupEvent& event) {

      if(event.request.wValue==0 && event.request.wLength==1 && ((event.request.bmRequest & 0x80)==0x80)) {

        MscBotGetMaxLunEvent event;

        // send the event that the user may respond to

        this->UsbEventSender.raiseEvent(event);

        // copy out the response

        _maxLun=event.maxLun;
        USBD_CtlSendData(&this->_deviceHandle,&_maxLun,1);
      }
      else
        USBD_CtlError(&this->_deviceHandle,&event.request);
    }


    /**
     * Get the max logical unit number (LUN)
     * @param event The event details
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onBotReset(DeviceClassSdkSetupEvent& event) {

      if(event.request.wValue==0 && event.request.wLength==0 && ((event.request.bmRequest & 0x80)!=0x80)) {

        // set members

        _state=MscBotState::IDLE;
        _status=MscBotStatus::RECOVERY;

        // notify the event

        this->UsbEventSender.raiseEvent(MscBotResetEvent());
      }
      else
        USBD_CtlError(&this->_deviceHandle,&event.request);
    }


    /**
     * Setup interface and endpoint event
     * @param event The event details
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onSetupInterfaceAndEndpoint(DeviceClassSdkSetupEvent& event) {

      switch(event.request.bRequest) {

        case USB_REQ_GET_INTERFACE:
          USBD_CtlSendData(&this->_deviceHandle,&_interface,1);
          break;

        case USB_REQ_SET_INTERFACE :
          _interface=event.request.wValue;
          break;

        case USB_REQ_CLEAR_FEATURE:
          onClearFeature(event);
          break;
      }
    }


    /**
     * Clear feature request
     * @param event The event details
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onClearFeature(DeviceClassSdkSetupEvent& event) {

      // flush and close endpoint

      USBD_LL_FlushEP(&this->_deviceHandle,event.request.wIndex);     // flush the FIFO and clear the stall status
      USBD_LL_CloseEP(&this->_deviceHandle,event.request.wIndex);     // re-activate the EP

      if((event.request.wIndex & 0x80)==0x80) {
        USBD_LL_OpenEP(
                &this->_deviceHandle,
                IN_EP_ADDRESS,
                EndpointDescriptor::BULK,
                this->_configurationDescriptor.inEndpoint.wMaxPacketSize);
      }
      else {
        USBD_LL_OpenEP(
            &this->_deviceHandle,
            OUT_EP_ADDRESS,
            EndpointDescriptor::BULK,
            this->_configurationDescriptor.outEndpoint.wMaxPacketSize);
      }

      if(_status==MscBotStatus::ERROR) {

        // bad CBW signature

        USBD_LL_StallEP(&this->_deviceHandle,IN_EP_ADDRESS);
        _status=MscBotStatus::NORMAL;
      }
      else if(((event.request.wIndex & 0x80)==0x80) && _status!=MscBotStatus::RECOVERY)
        _csw.send<IN_EP_ADDRESS,OUT_EP_ADDRESS>(MscBotCswStatus::CMD_FAILED,_state,this->_deviceHandle,_cbw);
    }


    /**
     * Data in event
     * @param event The event details
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onDataIn() {

      switch(_state) {

        case MscBotState::DATA_IN:
          if(!_scsi.processCmd(_cbw.bLUN,_cbw.CB,_cbw,_csw))
            _csw.send<IN_EP_ADDRESS,OUT_EP_ADDRESS>(MscBotCswStatus::CMD_FAILED,_state,this->_deviceHandle,_cbw);
          break;

        case MscBotState::SEND_DATA:
        case MscBotState::LAST_DATA_IN:
          _csw.send<IN_EP_ADDRESS,OUT_EP_ADDRESS>(MscBotCswStatus::CMD_PASSED,_state,this->_deviceHandle,_cbw);
          break;

        default:
          break;
      }
    }


    /**
     * Proccess MSC OUT data
     * @param epnum: endpoint index
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::onDataOut() {

      switch(_state) {

        case MscBotState::IDLE:
          decodeCbw();
          break;

        case MscBotState::DATA_OUT:
          if(!_scsi.processCmd(_cbw.bLUN,_cbw.CB,_cbw,_csw))
            _csw.send<IN_EP_ADDRESS,OUT_EP_ADDRESS>(MscBotCswStatus::CMD_FAILED,_state,this->_deviceHandle,_cbw);
          break;

        default:      // warning supression
          break;
      }
    }


    /**
     * Decode the CBW command and set the BOT state machine
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::decodeCbw() {

      // update the CSW for the response

      _csw.dTag=_cbw.dTag;
      _csw.dDataResidue=_cbw.dDataLength;

      if(USBD_LL_GetRxDataSize(&this->_deviceHandle,OUT_EP_ADDRESS)!=MscBotCommandBlockWrapper::RECEIVE_SIZE ||
         _cbw.dSignature!=MscBotCommandBlockWrapper::SIGNATURE ||
         _cbw.bLUN>1 ||
         _cbw.bCBLength<1 ||
         _cbw.bCBLength>16) {

        _scsi.senseCode(_cbw.bLUN,MscScsiSense::ILLEGAL_REQUEST,MscScsiSense::INVALID_CDB);
        _status=MscBotStatus::ERROR;

        abortTransfer();

      } else {

        if(!_scsi.processCmd(_cbw.bLUN,_cbw.CB,_cbw,_csw)) {

          if(_state==MscBotState::NO_DATA)
            _csw.send<IN_EP_ADDRESS,OUT_EP_ADDRESS>(MscBotCswStatus::CMD_FAILED,_state,this->_deviceHandle,_cbw);
          else
            abortTransfer();
        }
        else if(_state!=MscBotState::DATA_IN && _state!=MscBotState::DATA_OUT && _state!=MscBotState::LAST_DATA_IN) {

          // burst xfer handled internally

          if(_scsi.getDataSize())
            sendData(_scsi.getData(),_scsi.getDataSize());
          else
            _csw.send<IN_EP_ADDRESS,OUT_EP_ADDRESS>(MscBotCswStatus::CMD_PASSED,_state,this->_deviceHandle,_cbw);
        }
      }
    }


    /**
     * @brief  Abort the current transfer
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::abortTransfer() {

      // stall endpoints

      if(_cbw.bmFlags==0 && _cbw.dDataLength!=0 && _status==MscBotStatus::NORMAL)
        USBD_LL_StallEP(&this->_deviceHandle,OUT_EP_ADDRESS);

      USBD_LL_StallEP(&this->_deviceHandle,IN_EP_ADDRESS);

      // prepare to receive next command

      if(_status==MscBotStatus::ERROR)
        USBD_LL_PrepareReceive(
            &this->_deviceHandle,
            OUT_EP_ADDRESS,
            reinterpret_cast<uint8_t *>(&_cbw),
            MscBotCommandBlockWrapper::RECEIVE_SIZE);
    }


    /**
     * Send the requested data
     * @param buf pointer to data buffer
     * @param len Data Length
     */

    template<class TPhy,template <class> class... Features>
    inline void BotMscDevice<TPhy,Features...>::sendData(uint8_t *buf,uint16_t len) {

      // validate length

      if(len>_cbw.dDataLength)
        len=_cbw.dDataLength;

      _csw.dDataResidue-=len;
      _csw.bStatus=MscBotCswStatus::CMD_PASSED;
      _state=MscBotState::SEND_DATA;

      USBD_LL_Transmit(&this->_deviceHandle,IN_EP_ADDRESS,buf,len);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/msc/BotMscDevice.h
// START FILE: ../lib/include/usb/f4/device/InterfaceDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB interface descriptor
     */

    struct InterfaceDescriptor {

      DescriptorHeader header;

      uint8_t bInterfaceNumber;    // Number of Interface
      uint8_t bAlternateSetting;   // Value used to select alternative setting
      uint8_t bNumEndpoints;       // Number of Endpoints used for this interface
      uint8_t bInterfaceClass;     // Class Code (Assigned by USB Org)
      uint8_t bInterfaceSubClass;  // Subclass Code (Assigned by USB Org)
      uint8_t bInterfaceProtocol;  // Protocol Code (Assigned by USB Org)
      uint8_t iInterface;          // Index of String Descriptor Describing this interface

      InterfaceDescriptor()
        : header(sizeof(InterfaceDescriptor),USB_DESC_TYPE_INTERFACE) {

        static_assert(sizeof(InterfaceDescriptor)==9,"Compiler error: sizeof(InterfaceDescriptor)!=9");

        iInterface=0;
        bAlternateSetting=0;
      }
    } __attribute__((packed));
  }
}


// END FILE: ../lib/include/usb/f4/device/InterfaceDescriptor.h
// START FILE: ../lib/include/usb/f4/device/LanguageDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB language descriptor. The standard supports multiple languages but in reality the first
     * code should be 0x0409 (English/US) to maintain compatibility with Windows. There's a practical
     * limit of 126 languages.
     */

    struct LanguageDescriptor {

      scoped_array<uint8_t> _descriptor;

      /**
       * Constructor
       */

      LanguageDescriptor(const uint16_t *wLanguageIds,uint8_t languageCount) {

        uint8_t length;

        // allocate for the language ids plus descriptor size/type

        length=2+(languageCount*2);
        _descriptor.reset(new uint8_t[length]);

        // set up the header

        _descriptor[0]=length;
        _descriptor[1]=USB_DESC_TYPE_STRING;

        // copy in the language ids

        memcpy(&_descriptor[2],wLanguageIds,languageCount*2);
      }


      /**
       * Get a pointer to the descriptor bytes
       * @return The descriptor bytes
       */

      uint8_t *getDescriptor() {
        return &_descriptor[0];
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/LanguageDescriptor.h
// START FILE: ../lib/include/usb/f4/device/EndpointType.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Endpoint type enumeration. This matches the SDK enumeration in usbd_def.h
     */

    enum class EndpointType : uint8_t {
      CONTROL     = 0,
      ISOCHRONOUS = 1,
      BULK        = 2,
      INTERRUPT   = 3
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/EndpointType.h
// START FILE: ../lib/include/usb/f4/device/DeviceDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Device descriptor structure, 18 bytes
     */

    struct DeviceDescriptor {

      DescriptorHeader header;
      uint16_t bcdUSB;
      uint8_t  bDeviceClass;
      uint8_t  bDeviceSubClass;
      uint8_t  bDeviceProtocol;
      uint8_t  bMaxPacketSize;
      uint16_t idVendor;
      uint16_t idProduct;
      uint16_t bcdDevice;
      uint8_t  iManufacturer;
      uint8_t  iProduct;
      uint8_t  iSerialNumber;
      uint8_t bNumConfigurations;

      /**
       * Constructor - set up the constants
       */

      DeviceDescriptor()
        : header(USB_LEN_DEV_DESC,USB_DESC_TYPE_DEVICE) {

        static_assert(sizeof(DeviceDescriptor)==USB_LEN_DEV_DESC,"Compilation error: sizeof(DeviceDescriptor)!=0x12");

        bDeviceClass=0;                                 // use class in interface desc
        bDeviceSubClass=0;                              // as above
        bDeviceProtocol=0;                              // as above
        bMaxPacketSize=USB_MAX_EP0_SIZE;                // max size of endpoint 0
        iManufacturer=0;                                // index of manufacturer string
        iProduct=0;                                     // index of product string
        iSerialNumber=0;                                // index of serial number string
        bNumConfigurations=USBD_MAX_NUM_CONFIGURATION;  // bNumConfigurations

      }
    } __attribute((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/DeviceDescriptor.h
// START FILE: ../lib/include/usb/f4/device/HalUsbdStatus.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Handle the case where a HAL status needs to be translated to a USBD status
     * HAL status in, USBD status out.
     */

    struct HalUsbStatus {

      USBD_StatusTypeDef status;

      /**
       * Constructor
       */

      HalUsbStatus()
        : status(USBD_OK) {
      }


      /**
       * Assign a new status
       * @param newStatus The new status
       * @return self reference
       */

      HalUsbStatus& operator=(HAL_StatusTypeDef newStatus) {

        // translate

        switch(newStatus) {

          case HAL_OK:
            status=USBD_OK;
            break;

          case HAL_BUSY:
            status=USBD_BUSY;
            break;

          default:
            status=USBD_FAIL;
            break;
        }

        return *this;
      }


      /**
       * Return the status
       */

      operator USBD_StatusTypeDef() const {
        return status;
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/device/HalUsbdStatus.h
// START FILE: ../lib/include/usb/f4/device/features/ConfigurationTextFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Provide a configuration string. This is optional
     */

    template<class TDevice>
    class ConfigurationTextFeature : public StringFeatureBase<TDevice> {

      public:
        struct Parameters {
          const char *device_configuration_text;
        };

      protected:
        ConfigurationTextFeature(TDevice& device);

      public:
        bool initialise(const Parameters& params);
    };


    /**
     * Constructor
     * @param device A reference to the USB device
     * @param str The configuration string
     */

    template<class TDevice>
    inline ConfigurationTextFeature<TDevice>::ConfigurationTextFeature(TDevice& device)
      : StringFeatureBase<TDevice>(device,USBD_IDX_CONFIG_STR) {
    }


    /**
     * Initialise the class
     * @param params The parameters
     * @return true
     */

    template<class TDevice>
    inline bool ConfigurationTextFeature<TDevice>::initialise(const Parameters& params) {
      return StringFeatureBase<TDevice>::initialise(params.device_configuration_text);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/ConfigurationTextFeature.h
// START FILE: ../lib/include/usb/f4/device/features/DeviceFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Top-level base for all USB device features. Provides a storage container for the
     * USB device reference
     */

    template<class TDevice>
    class DeviceFeatureBase {

      protected:
        TDevice& _device;

      protected:
        DeviceFeatureBase(TDevice& device);
    };


    /**
     * Constructor
     * @param device A reference to the USB device class
     */

    template<class TDevice>
    inline DeviceFeatureBase<TDevice>::DeviceFeatureBase(TDevice& device)
      : _device(device) {
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/DeviceFeatureBase.h
// START FILE: ../lib/include/usb/f4/device/features/StringFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Intermediate base class to hold the string used for a USB feature. Converts the
     * supplied string into unicode ready for use by the protocol
     */

    template<class TDevice>
    class StringFeatureBase : public DeviceFeatureBase<TDevice> {

      protected:
        uint16_t _length;
        scoped_array<uint8_t> _descriptor;
        uint8_t _stringIndex;

      protected:
        StringFeatureBase(TDevice& device,uint8_t stringIndex);
        ~StringFeatureBase();

        bool initialise(const char *str);

        void onEvent(UsbEventDescriptor& event);
    };


    /**
     * Constructor
     * @param device A reference to the USB device class
     * @param stringIndex Index used by the protocol when it calls back for this string
     */

    template<class TDevice>
    inline StringFeatureBase<TDevice>::StringFeatureBase(TDevice& device,uint8_t stringIndex)
      : DeviceFeatureBase<TDevice>(device) {

      _stringIndex=stringIndex;

      // subscribe to device events

      device.UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&StringFeatureBase<TDevice>::onEvent)
        );
    }


    /**
     * Initialise. This will do a dumb conversion to unicode by assuming that the mapping
     * of 8-bit characters is represented by an equivalent [cc00] unicode character.
     *
     * @param str 8-bit ASCII version of the string. Does not need to remain in
     * scope after this constructor completes.
     */

    template<class TDevice>
    inline bool StringFeatureBase<TDevice>::initialise(const char *str) {

      uint16_t len;

      if(str==nullptr)
        _length=0;
      else {
        _length=strlen(str)*2+2;    // +1 for 16-bit descriptor header, +1 for \0 at end
        _descriptor.reset(new uint8_t[_length]);

        USBD_GetString((uint8_t *)str,&_descriptor[0],&len);
      }
      return true;
    }


    /**
     * Destructor
     */

    template<class TDevice>
    inline StringFeatureBase<TDevice>::~StringFeatureBase() {

      // unsubscribe from device events

      this->_device.UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&StringFeatureBase<TDevice>::onEvent)
        );
    }


    /**
     * Event callback
     * @param event The event object
     */

    template<class TDevice>
    inline void StringFeatureBase<TDevice>::onEvent(UsbEventDescriptor& event) {

      if(event.eventType==UsbEventDescriptor::EventType::DEVICE_GET_STRING_DESCRIPTOR) {

        // convert to the event type that we know it is

        DeviceGetDisplayStringDescriptorEvent & stringEvent(
            static_cast<DeviceGetDisplayStringDescriptorEvent&>(event));

        // if we handle this string index then set the return values as long
        // as someone hasn't got there first

        if(stringEvent.stringIndex==_stringIndex && stringEvent.descriptor==nullptr) {

          stringEvent.descriptor=_descriptor.get();
          stringEvent.length=_length;   // length in bytes incl. \0 terminator
        }
      }
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/StringFeatureBase.h
// START FILE: ../lib/include/usb/f4/device/features/ManufacturerTextFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Provide a manufacturer string. This is optional
     */

    template<class TDevice>
    class ManufacturerTextFeature : public StringFeatureBase<TDevice> {

      public:
        struct Parameters {
          const char *device_manufacturer_text;
        };

      protected:
        ManufacturerTextFeature(TDevice& device);

      public:
        bool initialise(const Parameters& params);
    };


    /**
     * Constructor
     * @param device A reference to the USB device
     * @param str The manufacturer string
     */

    template<class TDevice>
    inline ManufacturerTextFeature<TDevice>::ManufacturerTextFeature(TDevice& device)
      : StringFeatureBase<TDevice>(device,USBD_IDX_MFC_STR) {

      // register this string index with the device descriptor

      device.getDeviceDescriptor().iManufacturer=USBD_IDX_MFC_STR;
    }


    /**
     * Initialise the class
     * @param params The parameters
     * @return true
     */

    template<class TDevice>
    inline bool ManufacturerTextFeature<TDevice>::initialise(const Parameters& params) {
      return StringFeatureBase<TDevice>::initialise(params.device_manufacturer_text);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/ManufacturerTextFeature.h
// START FILE: ../lib/include/usb/f4/device/features/SerialNumberTextFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * Provide a serial number string. This is optional
     */

    template<class TDevice>
    class SerialNumberTextFeature : public StringFeatureBase<TDevice> {

      public:
        struct Parameters {
          const char *device_serial_text;
        };

      protected:
        SerialNumberTextFeature(TDevice& device);

      public:
        bool initialise(const Parameters& params);
    };


    /**
     * Constructor
     * @param device A reference to the USB device
     * @param str The serial number string
     */

    template<class TDevice>
    inline SerialNumberTextFeature<TDevice>::SerialNumberTextFeature(TDevice& device)
      : StringFeatureBase<TDevice>(device,USBD_IDX_SERIAL_STR) {

      // register this string index with the device descriptor

      device.getDeviceDescriptor().iSerialNumber=USBD_IDX_SERIAL_STR;
    }


    /**
     * Initialise the class
     * @param params The parameters
     * @return true
     */

    template<class TDevice>
    inline bool SerialNumberTextFeature<TDevice>::initialise(const Parameters& params) {
      return StringFeatureBase<TDevice>::initialise(params.device_serial_text);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/SerialNumberTextFeature.h
// START FILE: ../lib/include/usb/f4/device/features/endpoints/InterruptOutEndpointFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Class to handle interrupt OUT endpoints
     */

    template<uint8_t TEndpointNumber,class TDevice>
    class InterruptOutEndpointFeature : public OutEndpointFeatureBase<TDevice> {

      public:
        struct Parameters : OutEndpointFeatureBase<TDevice>::Parameters {
        };

      protected:
        InterruptOutEndpointFeature(TDevice& device);

      public:
        bool initialise(Parameters& params);
    };


    /**
     * Constructor
     * @param device Reference to the device
     */

    template<uint8_t TEndpointNumber,class TDevice>
    inline InterruptOutEndpointFeature<TEndpointNumber,TDevice>::InterruptOutEndpointFeature(TDevice& device)
      : OutEndpointFeatureBase<TDevice>(device,TEndpointNumber) {
    }


    /**
     * Initialise the class
     * @param params the parameters
     */

    template<uint8_t TEndpointNumber,class TDevice>
    inline bool InterruptOutEndpointFeature<TEndpointNumber,TDevice>::initialise(Parameters& params) {
      return OutEndpointFeatureBase<TDevice>::initialise(params);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/endpoints/InterruptOutEndpointFeature.h
// START FILE: ../lib/include/usb/f4/device/features/endpoints/InterruptInEndpointFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Class to handle interrupt IN endpoints
     */

    template<uint8_t TEndpointNumber,class TDevice>
    class InterruptInEndpointFeature : public InEndpointFeatureBase<TDevice> {

      public:
        struct Parameters : InEndpointFeatureBase<TDevice>::Parameters {
        };

      protected:
        InterruptInEndpointFeature(TDevice& device);

      public:
        bool initialise(Parameters& params);
    };


    /**
     * Constructor
     * @param device Reference to the device
     */

    template<uint8_t TEndpointNumber,class TDevice>
    inline InterruptInEndpointFeature<TEndpointNumber,TDevice>::InterruptInEndpointFeature(TDevice& device)
      : InEndpointFeatureBase<TDevice>(device,TEndpointNumber) {
    }


    /**
     * Initialise the class
     * @param params the parameters
     */

    template<uint8_t TEndpointNumber,class TDevice>
    inline bool InterruptInEndpointFeature<TEndpointNumber,TDevice>::initialise(Parameters& params) {
      return InEndpointFeatureBase<TDevice>::initialise(params);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/endpoints/InterruptInEndpointFeature.h
// START FILE: ../lib/include/usb/f4/device/features/endpoints/ControlEndpointFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB control endpoint. The special bi-directional endpoint that's always at position zero.
     * This endpoint feature is automatically added to your features so don't add it yourself.
     */

    template<class TDevice>
    class ControlEndpointFeature : public DeviceFeatureBase<TDevice> {

      public:
        struct Parameters {
          uint16_t ctrlep_txFifoSize;     // default is 0x40

          Parameters() {
            ctrlep_txFifoSize=0x40;
          }
        };

      protected:
        ControlEndpointFeature(TDevice& device);

      public:
        bool initialise(const Parameters& params);
    };


    /**
     * Constructor
     * @param the device reference
     */

    template<class TDevice>
    inline ControlEndpointFeature<TDevice>::ControlEndpointFeature(TDevice& device)
      : DeviceFeatureBase<TDevice>(device) {

      // increase endpoints counter

      device.incrementNumEndpoints();
    }


    /**
     * Initialise the class
     * @param params The parameters class
     * @return true;
     */

    template<class TDevice>
    inline bool ControlEndpointFeature<TDevice>::initialise(const Parameters& params) {

      // set the tx fifo size

      HAL_PCD_SetTxFiFo(&this->_device.getPcdHandle(),0,params.ctrlep_txFifoSize);
      return true;
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/endpoints/ControlEndpointFeature.h
// START FILE: ../lib/include/usb/f4/device/features/endpoints/OutEndpointFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Intermediate base class for OUT endpoints
     */

    template<class TDevice>
    class OutEndpointFeatureBase : public DeviceFeatureBase<TDevice> {

      public:
        struct Parameters {
        };

      protected:
        uint8_t _endpointNumber;

      protected:
        OutEndpointFeatureBase(TDevice& device,uint8_t endpointNumber);

      public:
        bool initialise(const Parameters& params);
    };


    /**
     * Constructor
     * @param device Reference to the device
     */

    template<class TDevice>
    inline OutEndpointFeatureBase<TDevice>::OutEndpointFeatureBase(TDevice& device,uint8_t endpointNumber)
      : DeviceFeatureBase<TDevice>(device) {

      _endpointNumber=endpointNumber;

      // increase the endpoint counter

      device.incrementNumEndpoints();
    }


    /**
     * Initialise the class
     * @param params the parameters
     * @return true
     */

    template<class TDevice>
    inline bool OutEndpointFeatureBase<TDevice>::initialise(const Parameters& /* params */) {
      return true;
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/endpoints/OutEndpointFeatureBase.h
// START FILE: ../lib/include/usb/f4/device/features/endpoints/BulkInEndpointFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Class to handle bulk IN endpoints
     */

    template<uint8_t TEndpointNumber,class TDevice>
    class BulkInEndpointFeature : public InEndpointFeatureBase<TDevice> {

      public:
        struct Parameters : InEndpointFeatureBase<TDevice>::Parameters {
        };

      protected:
        BulkInEndpointFeature(TDevice& device);

      public:
        bool initialise(Parameters& params);
    };


    /**
     * Constructor
     * @param device Reference to the device
     */

    template<uint8_t TEndpointNumber,class TDevice>
    inline BulkInEndpointFeature<TEndpointNumber,TDevice>::BulkInEndpointFeature(TDevice& device)
      : InEndpointFeatureBase<TDevice>(device,TEndpointNumber) {
    }


    /**
     * Initialise the class
     * @param params the parameters
     */

    template<uint8_t TEndpointNumber,class TDevice>
    inline bool BulkInEndpointFeature<TEndpointNumber,TDevice>::initialise(Parameters& params) {
      return InEndpointFeatureBase<TDevice>::initialise(params);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/endpoints/BulkInEndpointFeature.h
// START FILE: ../lib/include/usb/f4/device/features/endpoints/InEndpointFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Intermediate base class for IN endpoints
     */

    template<class TDevice>
    class InEndpointFeatureBase : public DeviceFeatureBase<TDevice> {

      public:
        struct Parameters {
          uint16_t ep_txFifoSize;     // TX FIFO size, default is 0x80

          Parameters() {
            ep_txFifoSize=0x80;
          }
        };

        /**
         * Error codes
         */

        enum {
          E_TRANSMIT_FAILED = 0x1
        };

      protected:
        uint8_t _endpointNumber;
        volatile bool _endpointIsTransmitting;

      protected:
        InEndpointFeatureBase(TDevice& device,uint8_t endpointNumber);
        ~InEndpointFeatureBase();

        void onEvent(UsbEventDescriptor& event);

      public:
        bool initialise(const Parameters& params);

        bool isTransmitting() const;
        bool transmit(const void *data,uint16_t size);
    };


    /**
     * Constructor
     * @param device Reference to the device
     */

    template<class TDevice>
    inline InEndpointFeatureBase<TDevice>::InEndpointFeatureBase(TDevice& device,uint8_t endpointNumber)
      : DeviceFeatureBase<TDevice>(device) {

      _endpointNumber=endpointNumber;
      _endpointIsTransmitting=false;

      // subscribe to USB events

      device.UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&InEndpointFeatureBase<TDevice>::onEvent)
        );

      // increase the endpoint counter

      device.incrementNumEndpoints();
    }


    /**
     * Destructor
     */

    template<class TDevice>
    inline InEndpointFeatureBase<TDevice>::~InEndpointFeatureBase() {

      // unsubscribe from USB events

      this->_device.UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&InEndpointFeatureBase<TDevice>::onEvent)
        );
    }


    /**
     * Initialise the class
     * @param params the parameters
     * @return true
     */

    template<class TDevice>
    inline bool InEndpointFeatureBase<TDevice>::initialise(const Parameters& params) {

      // set the FIFO size

      HAL_PCD_SetTxFiFo(&this->_device.getPcdHandle(),_endpointNumber,params.ep_txFifoSize);
      return true;
    }


    /**
     * Event handler for device events
     * @param event The event descriptor
     */

    template<class TDevice>
    inline void InEndpointFeatureBase<TDevice>::onEvent(UsbEventDescriptor& event) {

      // check for handled events

      switch(event.eventType) {

        case UsbEventDescriptor::EventType::CLASS_INIT:
        case UsbEventDescriptor::EventType::CLASS_DEINIT:
          _endpointIsTransmitting=false;
          break;

        case UsbEventDescriptor::EventType::CLASS_DATA_IN:
          if(static_cast<DeviceClassSdkDataInEvent&>(event).endpointNumber==_endpointNumber)
            _endpointIsTransmitting=false;
          break;

        default:      // get a warning if we don't do this
          break;
      }
    }


    /**
     * transmit some data to the host
     * @param data The data to send
     * @param size The number of bytes
     * @return true if it worked
     */

    template<class TDevice>
    inline bool InEndpointFeatureBase<TDevice>::transmit(const void *data,uint16_t size) {

      USBD_StatusTypeDef status;

      // must be configured

      if(this->_device.getDeviceHandle().dev_state!=USBD_STATE_CONFIGURED)
        return this->_device.setError(ErrorProvider::ERROR_PROVIDER_USB_DEVICE,TDevice::E_UNCONFIGURED);

      // must not be transmitting

      if(_endpointIsTransmitting)
        return this->_device.setError(ErrorProvider::ERROR_PROVIDER_USB_DEVICE,TDevice::E_BUSY);

      // this must be set first to avoid a race condition if the transmit succeeds really quickly

      _endpointIsTransmitting=true;

      if((status=USBD_LL_Transmit(
          &this->_device.getDeviceHandle(),
          _endpointNumber | EndpointDescriptor::IN,
          (uint8_t *)data,
          size))!=USBD_OK) {

        _endpointIsTransmitting=false;
        return this->_device.setError(ErrorProvider::ERROR_PROVIDER_USB_IN_ENDPOINT,E_TRANSMIT_FAILED,status);
      }

      // it's OK

      return true;
    }


    /**
     * Check if the endpoint is transmitting
     * @return true if it is transmitting
     */

    template<class TDevice>
    inline bool InEndpointFeatureBase<TDevice>::isTransmitting() const {
      return _endpointIsTransmitting;
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/endpoints/InEndpointFeatureBase.h
// START FILE: ../lib/include/usb/f4/device/features/endpoints/BulkOutEndpointFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Class to handle bulk OUT endpoints
     */

    template<uint8_t TEndpointNumber,class TDevice>
    class BulkOutEndpointFeature : public OutEndpointFeatureBase<TDevice> {

      public:
        struct Parameters : OutEndpointFeatureBase<TDevice>::Parameters {
        };

      protected:
        BulkOutEndpointFeature(TDevice& device);

      public:
        bool initialise(Parameters& params);
    };


    /**
     * Constructor
     * @param device Reference to the device
     */

    template<uint8_t TEndpointNumber,class TDevice>
    inline BulkOutEndpointFeature<TEndpointNumber,TDevice>::BulkOutEndpointFeature(TDevice& device)
      : OutEndpointFeatureBase<TDevice>(device,TEndpointNumber) {
    }


    /**
     * Initialise the class
     * @param params the parameters
     */

    template<uint8_t TEndpointNumber,class TDevice>
    inline bool BulkOutEndpointFeature<TEndpointNumber,TDevice>::initialise(Parameters& params) {
      return OutEndpointFeatureBase<TDevice>::initialise(params);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/endpoints/BulkOutEndpointFeature.h
// START FILE: ../lib/include/usb/f4/device/features/ProductTextFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Provide a product string. This is optional
     */

    template<class TDevice>
    class ProductTextFeature : public StringFeatureBase<TDevice> {

      public:
        struct Parameters {
          const char *device_product_text;
        };

      protected:
        ProductTextFeature(TDevice& device);

      public:
        bool initialise(const Parameters& params);
    };


    /**
     * Constructor
     * @param device A reference to the USB device
     */

    template<class TDevice>
    inline ProductTextFeature<TDevice>::ProductTextFeature(TDevice& device)
      : StringFeatureBase<TDevice>(device,USBD_IDX_PRODUCT_STR) {

      // register this string index with the device descriptor

      device.getDeviceDescriptor().iProduct=USBD_IDX_PRODUCT_STR;
    }


    /**
     * Initialise the class
     * @param params The parameters
     * @return true
     */

    template<class TDevice>
    inline bool ProductTextFeature<TDevice>::initialise(const Parameters& params) {
      return StringFeatureBase<TDevice>::initialise(params.device_product_text);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/ProductTextFeature.h
// START FILE: ../lib/include/usb/f4/device/features/InterfaceTextFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Provide an interface text string. This is optional
     */

    template<class TDevice>
    class InterfaceTextFeature : public StringFeatureBase<TDevice> {

      public:
        struct Parameters {
          const char *device_interface_text;
        };

      protected:
        InterfaceTextFeature(TDevice& device);

      public:
        bool initialise(const Parameters& params);
    };


    /**
     * Constructor
     * @param device A reference to the USB device
     * @param str The interface text
     */

    template<class TDevice>
    inline InterfaceTextFeature<TDevice>::InterfaceTextFeature(TDevice& device)
      : StringFeatureBase<TDevice>(device,USBD_IDX_INTERFACE_STR) {
    }


    /**
     * Initialise the class
     * @param params The parameters
     * @return true
     */

    template<class TDevice>
    inline bool InterfaceTextFeature<TDevice>::initialise(const Parameters& params) {
      return StringFeatureBase<TDevice>::initialise(params.device_interface_text);
    }
  }
}
// END FILE: ../lib/include/usb/f4/device/features/InterfaceTextFeature.h
// START FILE: ../lib/include/usb/f4/device/DeviceQualifierDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB device qualifier descriptor
     */

    struct DeviceQualifierDescriptor {

      DescriptorHeader header;

      /**
       * BCD USB Specification Release Number in Binary-Coded Decimal (i.e., 2.10 is 210H).
       * This field identifies the release of the USB Specification with which the device
       * and its descriptors are compliant.
       * At least V2.00 is required to use this descriptor.
       */

      uint16_t bcdUSB;

      /**
       * Class Class code (assigned by the USB-IF).
       * If this field is reset to zero, each interface within a configuration specifies its own
       * class information and the various interfaces operate independently. If this field is set
       * to a value between 1 and FEH, the device supports different class specifications on
       * different interfaces and the interfaces may not operate independently. This value identifies
       * the class definition used for the aggregate interfaces.
       * If this field is set to FFH, the device class is vendor-specific.
       */

      uint8_t bDeviceClass;

      /**
       * SubClass  Subclass code (assigned by the USB-IF).
       * These codes are qualified by the value of the bDeviceClass field. If the bDeviceClass field
       * is reset to zero, this field must also be reset to zero. If the bDeviceClass field is not set to
       * FFH, all values are reserved for assignment by the USB-IF.
       */

      uint8_t bDeviceSubClass;

      /**
       * Protocol code (assigned by the USB-IF). These codes are qualified by the value of the bDeviceClass
       * and the bDeviceSubClass fields. If a device supports class-specific protocols on a device basis as
       * opposed to an interface basis, this code identifies the protocols that the device uses as
       * defined by the specification of the device class. If this field is reset to zero, the device
       * does not use class-specific protocols on a device basis. However, it may use classspecific
       * protocols on an interface basis. If this field is set to FFH, the device uses a vendor-specific
       * protocol on a device basis.
       */

      uint8_t bDeviceProtocol;

      uint8_t bMaxPacketSize0;      // Maximum packet size for other speed.
      uint8_t bNumConfigurations;   // Number of other-speed configurations.
      uint8_t bReserved;

      DeviceQualifierDescriptor()
        : header(sizeof(DeviceQualifierDescriptor),USB_DESC_TYPE_DEVICE_QUALIFIER) {

        static_assert(sizeof(DeviceQualifierDescriptor)==10,"Compiler error: sizeof(DeviceQualifierDescriptor)!=10");

        bcdUSB=0x0200;
        bReserved=0;
        bDeviceClass=0;
        bDeviceSubClass=0;
        bDeviceProtocol=0;
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/DeviceQualifierDescriptor.h
// START FILE: ../lib/include/usb/f4/device/EndpointDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /**
     * USB endpoint descriptor
     */

    struct EndpointDescriptor {

      DescriptorHeader header;

      /**
       * Endpoint Address
       *    Bits 0..3b Endpoint Number.
       *    Bits 4..6b Reserved. Set to Zero
       *    Bits 7 Direction 0 = Out, 1 = In (Ignored for Control Endpoints)
       */

      enum {
        OUT = 0x00,
        IN  = 0x80
      };

      uint8_t bEndpointAddress;

      /**
       * Bitmap
       *  Bits 0..1 Transfer Type
       *    00 = Control
       *    01 = Isochronous
       *    10 = Bulk
       *    11 = Interrupt
       *  Bits 2..7 are reserved. If Isochronous endpoint,
       *  Bits 3..2 = Synchronisation Type (Iso Mode)
       *    00 = No Synchonisation
       *    01 = Asynchronous
       *    10 = Adaptive
       *    11 = Synchronous
       *  Bits 5..4 = Usage Type (Iso Mode)
       *    00 = Data Endpoint
       *    01 = Feedback Endpoint
       *    10 = Explicit Feedback Data Endpoint
       *    11 = Reserved
       */

      enum {
        CONTROL = 0,
        ISOCHRONOUS = 1,
        BULK = 2,
        INTERRUPT = 3,

        SYNC_NONE = 0,
        SYNC_ASYNC = 1 << 2,
        SYNC_ADAPTIVE = 2 << 2,
        SYNC_SYNC = 3 << 2,

        USAGE_DATA = 0,
        USAGE_FEEDBACK = 1 << 4,
        USAGE_EXPLICIT_FEEDBACK_DATA = 2 << 4
      };

      uint8_t bmAttributes;

      uint16_t wMaxPacketSize;  // Maximum Packet Size this endpoint is capable of sending or receiving
      uint8_t bInterval;        // Interval for polling endpoint data transfers. Value in frame counts. Ignored for Bulk & Control Endpoints. Isochronous must equal 1 and field may range from 1 to 255 for interrupt endpoints.

      EndpointDescriptor()
        : header(sizeof(EndpointDescriptor),USB_DESC_TYPE_ENDPOINT) {

        static_assert(sizeof(EndpointDescriptor)==7,"Compiler error: sizeof(EndpointDescriptor)!=7");

        bInterval=0;
      }
    } __attribute__((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/EndpointDescriptor.h
// START FILE: ../lib/include/usb/f4/device/InterfaceAssociationDescriptor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * Interface association descriptor (interface grouping)
     */

    struct InterfaceAssociationDescriptor {

      DescriptorHeader header;

      uint8_t bFirstInterface;
      uint8_t bInterfaceCount;
      uint8_t bFunctionClass;
      uint8_t bFunctionSubClass;
      uint8_t bFunctionProtocol;
      uint8_t iFunction;

      /**
       * Constructor - set up the constants
       */

      InterfaceAssociationDescriptor()
        : header(8,0xb) {

        static_assert(sizeof(InterfaceAssociationDescriptor)==8,"Compilation error: sizeof(InterfaceAssociationDescriptor)!=8");
      }
    } __attribute((packed));
  }
}
// END FILE: ../lib/include/usb/f4/device/InterfaceAssociationDescriptor.h
// START FILE: ../lib/include/usb/f4/UsbErrorEvent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace usb {


    /**
     * Event descriptor for a USB error. We hold the provider, code and cause
     * variables because early reports using the errorProvider may be overwritten
     * as the error works its way up the stack.
     */

    struct UsbErrorEvent : UsbEventDescriptor {

      int provider;
      uint32_t code;
      uint32_t cause;

      /**
       * Constructor
       * @param provider The error provider code
       * @param code The error code (provider specific)
       * @param cause extended error information, if any
       */

      UsbErrorEvent(int provider,uint32_t code,uint32_t cause=0)
        : UsbEventDescriptor(UsbEventDescriptor::EventType::USB_ERROR),
          provider(provider),
          code(code),
          cause(cause) {
        errorProvider.set(provider,code,cause);
      }
    };
  }
}
// END FILE: ../lib/include/usb/f4/UsbErrorEvent.h
// START FILE: ../lib/include/usb/f4/core/Core.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace usb {

    /*
     * USB core template, inherits from the PHY implementation and is inherited by the
     * role (device/host) class. Any common functionality between devices and hosts will
     * be placed here.
     */

    template<class TPhy>
    class Core : public TPhy {

      public:
        struct Parameters : TPhy::Parameters {
        };

      public:
        bool initialise(Parameters& params);
    };


    /**
     * Initialise the class
     * @param params The parameters
     * @return true if it worked
     */

    template<class TPhy>
    bool Core<TPhy>::initialise(Parameters& params) {

      // no specific implementation, just call upwards

      return TPhy::initialise(params);
    }
  }
}
// END FILE: ../lib/include/usb/f4/core/Core.h
// START FILE: ../lib/include/usart/f4/Usart3.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct Usart3_Custom : UsartPeripheral<TPinPackage,PERIPHERAL_USART3>,
                         Features... {

    Usart3_Custom(const typename UsartPeripheral<TPinPackage,PERIPHERAL_USART3>::Parameters& params)
      : UsartPeripheral<TPinPackage,PERIPHERAL_USART3>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /**
   * Default pin package:
   * (TX,RX,RTS,CTS,CK) = (PB10,PB11,PB14,PB13,PB12)
   */

  struct Usart3DefaultPinPackage {
    enum {
      Port_CK=GPIOB_BASE,     ///< clock port
      Port_TX=GPIOB_BASE,     ///< transmit port
      Port_RX=GPIOB_BASE,     ///< receive port
      Port_CTS=GPIOB_BASE,    ///< CTS port
      Port_RTS=GPIOB_BASE,    ///< RTS port

      Pin_TX=GPIO_Pin_10,     ///< transmit pin
      Pin_RX=GPIO_Pin_11,     ///< receive pin
      Pin_RTS=GPIO_Pin_14,    ///< RTS pin
      Pin_CTS=GPIO_Pin_13,    ///< CTS pin
      Pin_CK=GPIO_Pin_12      ///< clock pin
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Usart3 : UsartPeripheral<Usart3DefaultPinPackage,PERIPHERAL_USART3>,
                  Features... {

    /**
     * Constructor
     * @param params initialisation parameters
     */

    Usart3(const Parameters& params)
      : UsartPeripheral<Usart3DefaultPinPackage,PERIPHERAL_USART3>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /**
   * Remap #1:
   * (TX,RX,RTS,CTS,CK) = (PD8,PD9,PD12,PD11,PD10)
   */

  struct Usart3Remap1PinPackage {
    enum {
      Port_TX=GPIOD_BASE,
      Port_RX=GPIOD_BASE,
      Port_RTS=GPIOD_BASE,
      Port_CTS=GPIOD_BASE,
      Port_CK=GPIOD_BASE,

      Pin_TX=GPIO_Pin_8,
      Pin_RX=GPIO_Pin_9,
      Pin_RTS=GPIO_Pin_12,
      Pin_CTS=GPIO_Pin_11,
      Pin_CK=GPIO_Pin_10
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Usart3_Remap1 : UsartPeripheral<Usart3Remap1PinPackage,PERIPHERAL_USART3>,
                         Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Usart3_Remap1(const Parameters& params)
      : UsartPeripheral<Usart3Remap1PinPackage,PERIPHERAL_USART3>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /**
   * Remap #2:
   * (TX,RX,RTS,CTS,CK) = (PC10,PC11,PB14,PB13,PC12)
   */

  struct Usart3Remap2PinPackage {
    enum {
      Port_TX=GPIOC_BASE,
      Port_RX=GPIOC_BASE,
      Port_RTS=GPIOB_BASE,
      Port_CTS=GPIOB_BASE,
      Port_CK=GPIOC_BASE,

      Pin_TX=GPIO_Pin_10,
      Pin_RX=GPIO_Pin_11,
      Pin_RTS=GPIO_Pin_14,
      Pin_CTS=GPIO_Pin_13,
      Pin_CK=GPIO_Pin_12
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Usart3_Remap2 : UsartPeripheral<Usart3Remap2PinPackage,PERIPHERAL_USART3>,
                         Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Usart3_Remap2(const Parameters& params)
      : UsartPeripheral<Usart3Remap2PinPackage,PERIPHERAL_USART3>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/usart/f4/Usart3.h
// START FILE: ../lib/include/usart/f4/Usart2.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct Usart2_Custom : UsartPeripheral<TPinPackage,PERIPHERAL_USART2>,
                         Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Usart2_Custom(const typename UsartPeripheral<TPinPackage,PERIPHERAL_USART2>::Parameters& params)
      : UsartPeripheral<TPinPackage,PERIPHERAL_USART2>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /**
   * Default pin package:
   * (TX,RX,RTS,CTS,CK) = (PA2,PA3,PA1,PA0,PA4)
   */

  struct Usart2DefaultPinPackage {
    enum {
      Port_CK=GPIOA_BASE,
      Port_TX=GPIOA_BASE,
      Port_RX=GPIOA_BASE,
      Port_CTS=GPIOA_BASE,
      Port_RTS=GPIOA_BASE,

      Pin_TX=GPIO_Pin_2,
      Pin_RX=GPIO_Pin_3,
      Pin_RTS=GPIO_Pin_1,
      Pin_CTS=GPIO_Pin_0,
      Pin_CK=GPIO_Pin_4
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Usart2 : UsartPeripheral<Usart2DefaultPinPackage,PERIPHERAL_USART2>,
                  Features... {

    Usart2(const Parameters& params)
      : UsartPeripheral<Usart2DefaultPinPackage,PERIPHERAL_USART2>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /**
   * Remap #1:
   * (TX,RX,RTS,CTS,CK) = (PB6,PB7,PA12,PA11,PA8)
   */

  struct Usart2Remap1PinPackage {
    enum {
      Port_TX=GPIOD_BASE,
      Port_RX=GPIOD_BASE,
      Port_RTS=GPIOD_BASE,
      Port_CTS=GPIOD_BASE,
      Port_CK=GPIOD_BASE,

      Pin_TX=GPIO_Pin_5,
      Pin_RX=GPIO_Pin_6,
      Pin_RTS=GPIO_Pin_4,
      Pin_CTS=GPIO_Pin_3,
      Pin_CK=GPIO_Pin_7
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Usart2_Remap1 : UsartPeripheral<Usart2Remap1PinPackage,PERIPHERAL_USART2>,
                         Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Usart2_Remap1(const Parameters& params)
      : UsartPeripheral<Usart2Remap1PinPackage,PERIPHERAL_USART2>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/usart/f4/Usart2.h
// START FILE: ../lib/include/usart/f4/UsartPinInitialiser.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Convenience template to initialise a USART pin package
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  class UsartPinInitialiser {
    public:
      static void initialise(uint16_t mode,uint16_t flowControl,bool synchronous);
  };


  /**
   * Initialise the pin package that we were parameterised with
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline void UsartPinInitialiser<TPinPackage,TPeripheralName>::initialise(uint16_t mode,uint16_t flowControl,bool synchronous) {

      if((mode & USART_Mode_Tx)!=0)
        GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_TX,
                                       TPinPackage::Pin_TX,
                                       Gpio::ALTERNATE_FUNCTION,
                                       (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                       Gpio::PUPD_UP,
                                       Gpio::PUSH_PULL,
                                       GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_TX,TPinPackage::Pin_TX>::GPIO_AF);

      if((mode & USART_Mode_Rx)!=0)
        GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_RX,
                                       TPinPackage::Pin_RX,
                                       Gpio::ALTERNATE_FUNCTION,
                                       (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                       Gpio::PUPD_UP,
                                       GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_RX,TPinPackage::Pin_RX>::GPIO_AF);

      if(flowControl==USART_HardwareFlowControl_CTS || flowControl==USART_HardwareFlowControl_RTS_CTS)
        GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_CTS,
                                       TPinPackage::Pin_CTS,
                                       Gpio::ALTERNATE_FUNCTION,
                                       (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                       Gpio::PUPD_NONE,
                                       GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_CTS,TPinPackage::Pin_CTS>::GPIO_AF);

      if(flowControl==USART_HardwareFlowControl_RTS || flowControl==USART_HardwareFlowControl_RTS_CTS)
        GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_RTS,
                                       TPinPackage::Pin_RTS,
                                       Gpio::ALTERNATE_FUNCTION,
                                       (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                       Gpio::PUPD_NONE,
                                       Gpio::PUSH_PULL,
                                       GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_RTS,TPinPackage::Pin_RTS>::GPIO_AF);

      if(synchronous)
        GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_CK,
                                       TPinPackage::Pin_CK,
                                       Gpio::ALTERNATE_FUNCTION,
                                       (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                       Gpio::PUPD_NONE,
                                       Gpio::PUSH_PULL,
                                       GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_CK,TPinPackage::Pin_CK>::GPIO_AF);
  }
}
// END FILE: ../lib/include/usart/f4/UsartPinInitialiser.h
// START FILE: ../lib/include/usart/f4/Usart6.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct Usart6_Custom : UsartPeripheral<TPinPackage,PERIPHERAL_USART6>,
                         Features... {

    Usart6_Custom(const typename UsartPeripheral<TPinPackage,PERIPHERAL_USART6>::Parameters& params)
      : UsartPeripheral<TPinPackage,PERIPHERAL_USART6>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /*
   * Default pin package:
   * (TX,RX,RTS,CTS,CK) = (PC6,PC7,PG8,PG13,PC8)
   */

  struct Usart6DefaultPinPackage {
    enum {
      Port_TX=GPIOC_BASE,
      Port_RX=GPIOC_BASE,
      Port_RTS=GPIOG_BASE,
      Port_CTS=GPIOC_BASE,
      Port_CK=GPIOC_BASE,

      Pin_TX=GPIO_Pin_6,
      Pin_RX=GPIO_Pin_7,
      Pin_RTS=GPIO_Pin_8,
      Pin_CTS=GPIO_Pin_13,
      Pin_CK=GPIO_Pin_8
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Usart6 : UsartPeripheral<Usart6DefaultPinPackage,PERIPHERAL_USART6>,
                  Features... {

    Usart6(const Parameters& params)
      : UsartPeripheral<Usart6DefaultPinPackage,PERIPHERAL_USART6>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /*
   * Remap #1:
   * (TX,RX,RTS,CTS,CK) = (PG7,PG9,PG12,PG15,PC8)
   */

  struct Usart6Remap1PinPackage {
    enum {
      Port_TX=GPIOG_BASE,
      Port_RX=GPIOG_BASE,
      Port_RTS=GPIOG_BASE,
      Port_CTS=GPIOG_BASE,
      Port_CK=GPIOC_BASE,

      Pin_TX=GPIO_Pin_7,
      Pin_RX=GPIO_Pin_9,
      Pin_RTS=GPIO_Pin_12,
      Pin_CTS=GPIO_Pin_15,
      Pin_CK=GPIO_Pin_8
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Usart6_Remap1 : UsartPeripheral<Usart6Remap1PinPackage,PERIPHERAL_USART6>,
                         Features... {

    Usart6_Remap1(const Parameters& params)
      : UsartPeripheral<Usart6Remap1PinPackage,PERIPHERAL_USART6>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/usart/f4/Usart6.h
// START FILE: ../lib/include/usart/f4/Usart1.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct Usart1_Custom : UsartPeripheral<TPinPackage,PERIPHERAL_USART1>,
                         Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Usart1_Custom(const typename UsartPeripheral<TPinPackage,PERIPHERAL_USART1>::Parameters& params)
      : UsartPeripheral<TPinPackage,PERIPHERAL_USART1>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /**
   * Default pin package:
   * (TX,RX,RTS,CTS,CK) = (PA9,PA10,PA12,PA11,PA8)
   */

  struct Usart1DefaultPinPackage {
    enum {
      Port_CK=GPIOA_BASE,
      Port_TX=GPIOA_BASE,
      Port_RX=GPIOA_BASE,
      Port_CTS=GPIOA_BASE,
      Port_RTS=GPIOA_BASE,

      Pin_CK=GPIO_Pin_8,
      Pin_TX=GPIO_Pin_9,
      Pin_RX=GPIO_Pin_10,
      Pin_CTS=GPIO_Pin_11,
      Pin_RTS=GPIO_Pin_12
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Usart1 : UsartPeripheral<Usart1DefaultPinPackage,PERIPHERAL_USART1>,
                  Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Usart1(const Parameters& params)
      : UsartPeripheral<Usart1DefaultPinPackage,PERIPHERAL_USART1>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /**
   * Remap #1:
   * (TX,RX,RTS,CTS,CK) = (PB6,PB7,PA12,PA11,PA8)
   */

  struct Usart1Remap1PinPackage {
    enum {
      Port_TX=GPIOB_BASE,
      Port_RX=GPIOB_BASE,
      Port_RTS=GPIOA_BASE,
      Port_CTS=GPIOA_BASE,
      Port_CK=GPIOA_BASE,

      Pin_TX=GPIO_Pin_6,
      Pin_RX=GPIO_Pin_7,
      Pin_RTS=GPIO_Pin_12,
      Pin_CTS=GPIO_Pin_11,
      Pin_CK=GPIO_Pin_8
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Usart1_Remap1 : UsartPeripheral<Usart1Remap1PinPackage,PERIPHERAL_USART1>,
                         Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Usart1_Remap1(const Parameters& params)
      : UsartPeripheral<Usart1Remap1PinPackage,PERIPHERAL_USART1>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/usart/f4/Usart1.h
// START FILE: ../lib/include/usart/f4/UsartAlternateFunctionMapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Specialisation of the AF mapper for this peripheral. The F4 has the same AF ID
   * regardless of the port so we specialise only on the peripheral
   */

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_USART1,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_USART1
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_USART2,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_USART2
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_USART3,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_USART3
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_UART4,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_UART4
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_UART5,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_UART5
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_USART6,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_USART6
    };
  };
}
// END FILE: ../lib/include/usart/f4/UsartAlternateFunctionMapper.h
// START FILE: ../lib/include/usart/Uart4.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct Uart4_Custom : UsartPeripheral<TPinPackage,PERIPHERAL_UART4>,
                        Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Uart4_Custom(const typename UsartPeripheral<TPinPackage,PERIPHERAL_UART4>::Parameters& params)
      : UsartPeripheral<TPinPackage,PERIPHERAL_UART4>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /**
   * Default pin package:
   * (TX,RX) = (PC10,PC11)
   */

  struct Uart4DefaultPinPackage {
    enum {
      Port_CK=0,
      Port_TX=GPIOC_BASE,
      Port_RX=GPIOC_BASE,
      Port_CTS=0,
      Port_RTS=0,

      Pin_CK=0,
      Pin_TX=GPIO_Pin_10,
      Pin_RX=GPIO_Pin_11,
      Pin_CTS=0,
      Pin_RTS=0
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Uart4 : UsartPeripheral<Uart4DefaultPinPackage,PERIPHERAL_UART4>,
                 Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Uart4(const Parameters& params)
    : UsartPeripheral<Uart4DefaultPinPackage,PERIPHERAL_UART4>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/usart/Uart4.h
// START FILE: ../lib/include/usart/Uart5.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class...Features>
  struct Uart5_Custom : UsartPeripheral<TPinPackage,PERIPHERAL_UART5>,
                        Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Uart5_Custom(const typename UsartPeripheral<TPinPackage,PERIPHERAL_UART5>::Parameters& params)
      : UsartPeripheral<TPinPackage,PERIPHERAL_UART5>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };


  /**
   * Default pin package:
   * (TX,RX,RTS,CTS,CK) = (PA9,PA10,PA12,PA11,PA8)
   */

  struct Uart5DefaultPinPackage {
    enum {
      Port_CK=0,
      Port_TX=GPIOC_BASE,
      Port_RX=GPIOD_BASE,
      Port_CTS=0,
      Port_RTS=0,

      Pin_CK=0,
      Pin_TX=GPIO_Pin_12,
      Pin_RX=GPIO_Pin_2,
      Pin_CTS=0,
      Pin_RTS=0
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct Uart5 : UsartPeripheral<Uart5DefaultPinPackage,PERIPHERAL_UART5>,
                 Features... {

    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Uart5(const Parameters& params)
    : UsartPeripheral<Uart5DefaultPinPackage,PERIPHERAL_UART5>(params),
        Features(static_cast<Usart&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/usart/Uart5.h
// START FILE: ../lib/include/usart/UsartPollingOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Implementation of an output stream for the serial USART.
   * Writing to this stream causes data to be transmitted to the USART.
   */

  class UsartPollingOutputStream : public OutputStream {

    protected:
      Usart& _usart;

    public:
      UsartPollingOutputStream(Usart& usart);
      virtual ~UsartPollingOutputStream() {}

      // overrides from OutputStream

      virtual bool write(uint8_t c) override;
      virtual bool write(const void *buffer,uint32_t size) override;

      /**
       * Always true.
       * @return always true
       */

      virtual bool flush() override {
        return true;
      }

      /**
       * Always true.
       * @return always true
       */

      virtual bool close() override {
        return true;
      }
  };
}
// END FILE: ../lib/include/usart/UsartPollingOutputStream.h
// START FILE: ../lib/include/usart/UsartPollingInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Implementation of an input stream for the serial USART.
   * The stream methods can be used to read data from the USART in polling mode
   */

  class UsartPollingInputStream : public InputStream {

    protected:
      Usart& _usart;

    public:
      UsartPollingInputStream(Usart& usart);
      virtual ~UsartPollingInputStream() {}

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;

      /**
       * Doesn't do anything.
       * @return always true
       */

      virtual bool close() override {
        return true;
      }

      /**
       * Not supported.
       * @return always false and E_OPERATION_NOT_SUPPORTED
       */

      virtual bool reset() override {
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_USART_INPUT_STREAM,E_OPERATION_NOT_SUPPORTED);
      }
  };
}
// END FILE: ../lib/include/usart/UsartPollingInputStream.h
// START FILE: ../lib/include/usart/Usart.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Base class for Usart peripherals. Takes care of the common operations
   * that each peripheral can have
   */

  class Usart {

    public:

      enum {
        /// There was an error using the USART
        E_USART_ERROR=1
      };

    protected:
      USART_TypeDef *_peripheralAddress;

    protected:
      Usart(USART_TypeDef *peripheralAddress);

    public:
      bool hasError(uint32_t& errorCode) const;

      uint8_t receive() const;
      bool dataAvailable() const;

      bool send(uint8_t byte) const;
      bool readyToSend() const;

      void enablePeripheral() const;
      void disablePeripheral() const;

      operator USART_TypeDef *();
  };


  /**
   * Constructor
   */

  inline Usart::Usart(USART_TypeDef *peripheralAddress)
    : _peripheralAddress(peripheralAddress) {
  }


  /**
   * check for an error state
   * @param[out] errorCode The peripheral error code (USART_FLAG_ORE, USART_FLAG_NE, USART_FLAG_FE,USART_FLAG_PE).
   * @return true if there was an error, false if no error.
   */

  inline bool Usart::hasError(uint32_t& errorCode) const {
    errorCode=USART_GetFlagStatus(_peripheralAddress,USART_FLAG_ORE | USART_FLAG_NE | USART_FLAG_FE | USART_FLAG_PE);

    if(errorCode) {
      USART_ReceiveData(_peripheralAddress);    // required to clear error state
      return !errorProvider.set(ErrorProvider::ERROR_PROVIDER_USART,E_USART_ERROR,errorCode);
    }

    // no error

    return false;
  }


  /**
   * Enable the peripheral
   */

  inline void Usart::enablePeripheral() const {
    USART_Cmd(_peripheralAddress,ENABLE);
  }


  /**
   * Disable the peripheral
   */

  inline void Usart::disablePeripheral() const {
    USART_Cmd(_peripheralAddress,DISABLE);
  }


  /**
   * Cast to a USART peripheral structure
   */

  inline Usart::operator USART_TypeDef *() {
    return _peripheralAddress;
  }


  /**
   * Receive a byte, blocking.
   * @return The byte, or 0xff if it failed. Of course the data byte itself may be 0xff. The caller should check
   *  the error provider to see if the 0xff is indicating an error or a data byte.
   */

  inline uint8_t Usart::receive() const {

    uint32_t errorCode;

    do {
      if(hasError(errorCode))
        return 0xff; // caller to check global error status

    } while(!dataAvailable());

    return USART_ReceiveData(_peripheralAddress) & 0xff;
  }


  /**
   * Send a byte and wait until it's gone
   * @param byte The byte to send.
   * @return false if it failed.
   */

  inline bool Usart::send(uint8_t byte) const {

    uint32_t errorCode;

    do {
      if(hasError(errorCode))
        return false;

    } while(!readyToSend());

    USART_SendData(_peripheralAddress,byte);
    return true;
  }


  /**
   * Check if ready to send.
   * @return true if the peripheral is ready to send data.
   */

  inline bool Usart::readyToSend() const {
    return USART_GetFlagStatus(_peripheralAddress,USART_FLAG_TXE)==SET;
  }


  /**
   * Check if there is data available.
   * @return true if there is data available.
   */

  inline bool Usart::dataAvailable() const {
    return USART_GetFlagStatus(_peripheralAddress,USART_FLAG_RXNE)==SET;
  }
}
// END FILE: ../lib/include/usart/Usart.h
// START FILE: ../lib/include/usart/UsartEventSource.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * USART event types
   */

  enum class UsartEventType : uint8_t {
    EVENT_RECEIVE,
    EVENT_READY_TO_TRANSMIT,
    EVENT_TRANSMIT_COMPLETE,
    EVENT_PARITY_ERROR,
    EVENT_IDLE,
    EVENT_LINE_BREAK_DETECT,
    EVENT_ERROR,
    EVENT_CLEAR_TO_SEND,
  };


  /**
   * The signature for USART events: void myHandler(UsartEventType uet);
   */

  DECLARE_EVENT_SIGNATURE(UsartInterrupt,void(UsartEventType));


  /**
   * Base structure that holds just the event subscriber/publisher for the USART
   */

  struct UsartEventSource {
    DECLARE_EVENT_SOURCE(UsartInterrupt);
  };
}
// END FILE: ../lib/include/usart/UsartEventSource.h
// START FILE: ../lib/include/usart/features/f4/UsartInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


/*
 * Forward declare the IRQ handler names
 */

extern "C" void USART1_IRQHandler();
extern "C" void USART2_IRQHandler();
extern "C" void USART3_IRQHandler();
extern "C" void UART4_IRQHandler();
extern "C" void UART5_IRQHandler();
extern "C" void USART6_IRQHandler();


namespace stm32plus {

  /**
   * Helper class to enable only the desired interrupts in the NVIC. This will
   * be fully specialised for each USART peripheral
   * @tparam TUsartNumber The number of the USART peripheral (1..6)
   */

  template<uint8_t TUsartNumber>
  class UsartInterruptFeatureEnabler {

    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

    public:
      static void enable();
  };


  /**
   * DMA feature to handle interrupts
   * @tparam TUsartNumber The number of the USART peripheral (1..6)
   */

  template<uint8_t TUsartNumber>
  class UsartInterruptFeature : public UsartEventSource,
                                public UsartFeatureBase {

    protected:
      uint16_t _interruptMask;

    public:

      enum {
        RECEIVE = USART_IT_RXNE,
        TRANSMIT = USART_IT_TXE
      };

      static UsartEventSource *_usartInstance;

    public:
      UsartInterruptFeature(Usart& usart);
      ~UsartInterruptFeature();

      void enableInterrupts(uint16_t interruptMask);
      void disableInterrupts(uint16_t interruptMask);
      void clearPendingInterruptsFlag(uint16_t interruptMask) const;
  };


  /**
   * Typedefs for each USART
   */

  typedef UsartInterruptFeature<1> Usart1InterruptFeature;
  typedef UsartInterruptFeature<2> Usart2InterruptFeature;
  typedef UsartInterruptFeature<3> Usart3InterruptFeature;
  typedef UsartInterruptFeature<4> Uart4InterruptFeature;
  typedef UsartInterruptFeature<5> Uart5InterruptFeature;
  typedef UsartInterruptFeature<6> Usart6InterruptFeature;


  /**
   * Template static data member initialisation
   */

  template<uint8_t TUsartNumber>
  UsartEventSource *UsartInterruptFeature<TUsartNumber> ::_usartInstance;


  /**
   * Constructor, initialises the interrupt mask for this class to zero.
   */

  template<uint8_t TUsartNumber>
  inline UsartInterruptFeature<TUsartNumber>::UsartInterruptFeature(Usart& usart)
    : UsartFeatureBase(usart) {

    _interruptMask=0;
    _usartInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  template<uint8_t TUsartNumber>
  inline UsartInterruptFeature<TUsartNumber>::~UsartInterruptFeature() {
    if(_interruptMask!=0)
      disableInterrupts(_interruptMask);
  }


  /**
   * Enable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. USART_IT_TXE / USART_IT_RXNE
   */

  template<uint8_t TUsartNumber>
  inline void UsartInterruptFeature<TUsartNumber>::enableInterrupts(uint16_t interruptMask) {

    _interruptMask|=interruptMask;
    UsartInterruptFeatureEnabler<TUsartNumber>::enable();
    USART_ITConfig(_usart,interruptMask,ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. USART_IT_TXE / USART_IT_RXNE
   */

  template<uint8_t TUsartNumber>
  inline void UsartInterruptFeature<TUsartNumber>::disableInterrupts(uint16_t interruptMask) {
    _interruptMask&=~interruptMask;
    USART_ITConfig(_usart,interruptMask,DISABLE);
  }

  /**
   * Clear the selected pending interrupt flags
   * @param interruptMask The bitmask of interrupts, e.g. USART_IT_TC / USART_IT_RXNE
   */

  template<uint8_t TUsartNumber>
  inline void UsartInterruptFeature<TUsartNumber>::clearPendingInterruptsFlag(uint16_t interruptMask) const {
    USART_ClearITPendingBit(_usart,interruptMask);
  }

  /**
   * Enabler specialisation, Usart 1
   */

  template<>
  inline void UsartInterruptFeatureEnabler<1>::enable() {
    _forceLinkage=&USART1_IRQHandler;
    Nvic::configureIrq(USART1_IRQn);
  }

  /**
   * Enabler specialisation, Usart 2
   */

  template<>
  inline void UsartInterruptFeatureEnabler<2>::enable() {
    _forceLinkage=&USART2_IRQHandler;
    Nvic::configureIrq(USART2_IRQn);
  }

  /**
   * Enabler specialisation, Usart 3
   */

  template<>
  inline void UsartInterruptFeatureEnabler<3>::enable() {
    _forceLinkage=&USART3_IRQHandler;
    Nvic::configureIrq(USART3_IRQn);
  }

  /**
   * Enabler specialisation, Uart 4
   */

  template<>
  inline void UsartInterruptFeatureEnabler<4>::enable() {
    _forceLinkage=&UART4_IRQHandler;
    Nvic::configureIrq(UART4_IRQn);
  }

  /**
   * Enabler specialisation, Uart 5
   */

  template<>
  inline void UsartInterruptFeatureEnabler<5>::enable() {
    _forceLinkage=&UART5_IRQHandler;
    Nvic::configureIrq(UART5_IRQn);
  }


  /**
   * Enabler specialisation, Usart 6
   */

  template<>
  inline void UsartInterruptFeatureEnabler<6>::enable() {
    _forceLinkage=&USART6_IRQHandler;
    Nvic::configureIrq(USART6_IRQn);
  }
}
// END FILE: ../lib/include/usart/features/f4/UsartInterruptFeature.h
// START FILE: ../lib/include/usart/features/UsartFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for usart features
   */

  class UsartFeatureBase {
    protected:
      Usart& _usart;

    public:
      UsartFeatureBase(Usart& usart);
      operator Usart&();
  };


  /**
   * Constructor
   * @param usart
   */

  inline UsartFeatureBase::UsartFeatureBase(Usart& usart)
    : _usart(usart) {
  }


  /**
   * Cast to Usart reference
   */

  inline UsartFeatureBase::operator Usart&() {
    return _usart;
  }
}
// END FILE: ../lib/include/usart/features/UsartFeatureBase.h
// START FILE: ../lib/include/usart/UsartPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Base class for USART peripherals. Takes care of the common operations
   * that each peripheral can have.
   *
   * @tparam TPinPackage The class providing the pins (e.g. Usart1DefaultPinPackage)
   * @tparam TPeripheralName The peripheral name from the enumeration
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  class UsartPeripheral : public Usart {

    public:

    /**
     * USART parameters class
     */

    struct Parameters {
      uint32_t usart_baudRate;              ///< Your choice
      uint16_t usart_wordLength;            ///< USART_Word_Length
      uint16_t usart_parity;                ///< USART_Parity
      uint16_t usart_stopBits;              ///< USART_Stop_Bits
      uint16_t usart_flowControl;           ///< USART_HardwareFlowControl
      uint16_t usart_mode;                  ///< USART_Mode
      bool usart_synchronous;               ///< true if there's a USART clock signal

      /**
       * Constructor
       * @param baudRate The baud rate (default is 9600)
       */

      Parameters(uint32_t baudRate=9600) {
        usart_baudRate=baudRate;
        usart_wordLength=USART_WordLength_8b;
        usart_parity=USART_Parity_No;
        usart_stopBits=USART_StopBits_1;
        usart_flowControl=USART_HardwareFlowControl_None;
        usart_mode=USART_Mode_Rx | USART_Mode_Tx;
        usart_synchronous=false;
      }
    };

    public:
      UsartPeripheral(const Parameters& params);
      ~UsartPeripheral();
  };


  /**
   * Constructor
   * @param params The parameters class used to initialise the peripheral
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline UsartPeripheral<TPinPackage,TPeripheralName>::UsartPeripheral(const Parameters& params)
    : Usart((USART_TypeDef *)PeripheralTraits<TPeripheralName>::PERIPHERAL_BASE) {

    USART_InitTypeDef init;

    // clocks on first before any features get initialised

    ClockControl<TPeripheralName>::On();

    // and next the GPIO pins, also before any features get initialised

    UsartPinInitialiser<TPinPackage,TPeripheralName>::initialise(
        params.usart_mode,
        params.usart_baudRate,
        params.usart_synchronous);

    // initialise the peripheral

    USART_StructInit(&init);

    init.USART_BaudRate=params.usart_baudRate;
    init.USART_WordLength=params.usart_wordLength;
    init.USART_Parity=params.usart_parity;
    init.USART_StopBits=params.usart_stopBits;
    init.USART_HardwareFlowControl=params.usart_flowControl;
    init.USART_Mode=params.usart_mode;

    // initialise

    USART_Init((USART_TypeDef *)PeripheralTraits<TPeripheralName>::PERIPHERAL_BASE,&init);

    // enable

    enablePeripheral();
  }


  /**
   * Destructor, disable peripheral and disable clocks
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline UsartPeripheral<TPinPackage,TPeripheralName>::~UsartPeripheral() {

    // disable the peripheral

    disablePeripheral();

    // clocks off

    ClockControl<TPeripheralName>::Off();
  }
}
// END FILE: ../lib/include/usart/UsartPeripheral.h
// START FILE: ../lib/include/eeprom/SerialEeprom.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {

  /**
   * Template implementation of a serial EEPROM. Inherits from InputStream
   * and OutputStream. Provides the functionality for maintaining the stream pointer.
   * Delegates the actual read and write operations to the TImpl class parameter
   * @tparam TImpl The device implementation (this is the CRTP template pattern)
   */

  template<class TImpl>
  class SerialEeprom : public InputStream,
                       public OutputStream {

    protected:
      TImpl& _impl;
      uint32_t _position;

    public:

      /**
       * Error codes
       */

      enum {
        E_INVALID_SEEK_POSITION = 1,    ///< can't seek past the end
        E_INVALID_SIZE = 2              ///< can't write past the end
      };

    public:
      SerialEeprom(TImpl& impl);

      bool seek(uint32_t position);

      // overrides from OutputStream

      virtual bool write(uint8_t c) override;
      virtual bool write(const void *buffer,uint32_t size) override;
      virtual bool close() override { return true; }
      virtual bool flush() override { return true; }

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;
      virtual bool reset() override;
  };


  /**
   * Constructor
   */

  template<class TImpl>
  inline SerialEeprom<TImpl>::SerialEeprom(TImpl& impl)
    : _impl(impl) {

    _position=0;
  }


  /**
   * "seek" to a new position on the EEPROM. This just stores the new position which the
   * implementation class must use the next time it gets asked to do a read or a write.
   * @param[in] position The new position to seek to.
   * @return false if the position is out of range for this device.
   */

  template<class TImpl>
  inline bool SerialEeprom<TImpl>::seek(uint32_t position) {

    if(position<TImpl::SIZE_IN_BYTES) {
      _position=position;
      return true;
    }

    // out of range

    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_SERIAL_EEPROM,E_INVALID_SEEK_POSITION);
  }


  /**
   * Write a single byte
   * @param c The byte to write
   * @return true if it worked
   */

  template<class TImpl>
  inline bool SerialEeprom<TImpl>::write(uint8_t c) {

    // can't write if at the end

    if(_position>=TImpl::SIZE_IN_BYTES)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_SERIAL_EEPROM,OutputStream::E_END_OF_STREAM);

    // do the write

    return _impl.writeByte(c);
  }


  /**
   * Write many bytes
   * @param buffer the source of data
   * @param size the number of bytes to write
   * @return true if it worked
   */

  template<class TImpl>
  inline bool SerialEeprom<TImpl>::write(const void *buffer,uint32_t size) {

    // can't write past the end

    if(_position+size>TImpl::SIZE_IN_BYTES)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_SERIAL_EEPROM,E_INVALID_SIZE);

    // do the write

    return _impl.writeBytes(reinterpret_cast<const uint8_t *>(buffer),size);
  }


  /**
   * Read a single byte
   * @return Either the byte read in the lower 8-bits of the return value or
   * E_END_OF_STREAM / E_STREAM_ERROR. In the case of E_STREAM_ERROR the error
   * provider will have the detailed reason.
   */

  template<class TImpl>
  inline int16_t SerialEeprom<TImpl>::read() {

    uint8_t c;

    // check for the end

    if(_position>=TImpl::SIZE_IN_BYTES)
      return InputStream::E_END_OF_STREAM;

    // try the read

    if(!_impl.readByte(c))
      return InputStream::E_STREAM_ERROR;

    return c;
  }


  /**
   * Read many bytes
   * @param buffer Where to read to
   * @param size The number of bytes to read
   * @param actuallyRead The number of bytes read, which can be less than the total requested
   * if the end of stream is hit. If the pointer is already at the end of stream then zero
   * is returned in actuallyRead.
   * @return false if it fails, and actuallyRead will be undefined
   */

  template<class TImpl>
  inline bool SerialEeprom<TImpl>::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

    // cut down the size if there would be an overflow

    if(_position+size>TImpl::SIZE_IN_BYTES)
      size=TImpl::SIZE_IN_BYTES-_position;

    // do the read

    if(!_impl.readBytes(reinterpret_cast<uint8_t *>(buffer),size))
      return false;

    // update the bytes read

    actuallyRead=size;
    return true;
  }


  /**
   * Skip forward, if possible
   * @param howMuch How far to skip forward
   * @return true if it worked
   */

  template<class TImpl>
  inline bool SerialEeprom<TImpl>::skip(uint32_t howMuch) {

    // check for out of range

    if(_position+howMuch>=TImpl::SIZE_IN_BYTES)
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_SERIAL_EEPROM,E_INVALID_SEEK_POSITION);

    // update the position

    _position+=howMuch;
    return true;
  }


  /**
   * Check if there is at least one byte available
   * @return true if at least one byte is available
   */

  template<class TImpl>
  inline bool SerialEeprom<TImpl>::available() {
    return _position<TImpl::SIZE_IN_BYTES;
  }


  /**
   * Reset the stream pointer to position zero.
   * @return Always returns true
   */

  template<class TImpl>
  inline bool SerialEeprom<TImpl>::reset() {
    _position=0;
    return true;
  }
}
// END FILE: ../lib/include/eeprom/SerialEeprom.h
// START FILE: ../lib/include/eeprom/BR24G32.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {

  /**
   * The ROHM BR24G32 is functionally the same as the ATMEL AT24C32
   */

  template<class TI2C> using BR24G32=AT24Cxx<TI2C,4096>;
}
// END FILE: ../lib/include/eeprom/BR24G32.h
// START FILE: ../lib/include/eeprom/AT24Cxx.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {

  /**
   * Template class that defines the Atmel AT24C32/64 interface.
   *
   * The Atmel AT24C32/64 is a 32768/65536 kbit serial EEPROM IC with an I2C
   * interface. Data can be read or written using single-byte random access or it can
   * be accessed serially in multiples of up to 32 bytes (a page). That is, you may
   * access from where you start up to the end of a page in one burst and then you must
   * update your position to the next page and may then read/write up to another 32 bytes
   * in a burst. This class takes care of all that internal stuff for you.
   *
   * @tparam TI2C The I2C type that you are going to use to communicate with this EEPROM
   */

  template<class TI2C,int TSizeInBytes>
  class AT24Cxx : public TI2C,
                  public SerialEeprom<AT24Cxx<TI2C,TSizeInBytes> > {

    public:
      enum {
        SIZE_IN_BYTES = TSizeInBytes,   ///< 32kbit/64Kbit
        SLAVE_ADDRESS = 0xa0            ///< I2C bus address
      };

    public:
      AT24Cxx(typename TI2C::Parameters& params);

      // methods to support SerialEeprom

      bool writeByte(uint8_t c);
      bool writeBytes(const uint8_t *buffer,uint32_t count);

      bool readByte(uint8_t& c);
      bool readBytes(uint8_t *buffer,uint32_t count);
  };


  /**
   * Derivation for the AT24C32
   * @tparam The I2C configuration that we use
   */

  template<class TI2C> using AT24C32=AT24Cxx<TI2C,4096>;


  /**
   * Derivation for the AT24C64
   * @tparam The I2C configuration that we use
   */

  template<class TI2C> using AT24C64=AT24Cxx<TI2C,8192>;


  /**
   * Constructor. Ensures that the incoming parameters are correct.
   * @param[in] params The parameters class that holds the I2C configuration
   */

  template<class TI2C,int TSizeInBytes>
  inline AT24Cxx<TI2C,TSizeInBytes>::AT24Cxx(typename TI2C::Parameters& params)
    : TI2C(params),
      SerialEeprom<AT24Cxx<TI2C,TSizeInBytes> >(*this) {

    // set the I2C slave address

    this->setSlaveAddress(0xa0);

    // this device has 2-byte addresses

    params.i2c_addressSize=2;
  }


  /**
   * Write a single byte to the device
   * @param c The byte to write
   * @return true if it worked
   */

  template<class TI2C,int TSizeInBytes>
  inline bool AT24Cxx<TI2C,TSizeInBytes>::writeByte(uint8_t c) {

    if(!TI2C::writeBytes(this->_position,&c,1))
      return false;

    this->_position++;
    return true;
  }


  /**
   * Write multiple bytes to the device. We take advantage of the ability to write
   * multiple bytes in one go when those bytes are all in one page.
   * @param[in] buffer The source of data to write
   * @param[in] count The number of bytes to write
   * @return true if it worked
   */

  template<class TI2C,int TSizeInBytes>
  inline bool AT24Cxx<TI2C,TSizeInBytes>::writeBytes(const uint8_t *buffer,uint32_t count) {

    uint32_t toWrite;
    const uint8_t *ptr;

    for(ptr=buffer;count;count-=toWrite) {

      toWrite=std::min<uint8_t>(count,0x20-(this->_position & 0x1f));
      if(!TI2C::writeBytes(this->_position,ptr,toWrite))
        return false;

      ptr+=toWrite;
      this->_position+=toWrite;

      if(count>0)
        MillisecondTimer::delay(10);
    }

    return true;
  }


  /**
   * Read a single byte from the device
   * @param[out] c A reference to the byte to read
   * @return true if it worked
   */

  template<class TI2C,int TSizeInBytes>
  inline bool AT24Cxx<TI2C,TSizeInBytes>::readByte(uint8_t& c) {

    if(!TI2C::readBytes(this->_position,&c,1))
      return false;

    this->_position++;
    return true;
  }


  /**
   * Read multiple bytes from the device. We take advantage of the ability to read
   * out multiple bytes in one go when those bytes are all in one page.
   * @param[out] buffer Where to read the data to
   * @param[in] count The number of bytes to read
   */

  template<class TI2C,int TSizeInBytes>
  inline bool AT24Cxx<TI2C,TSizeInBytes>::readBytes(uint8_t *buffer,uint32_t count) {

    uint32_t toRead;
    uint8_t *ptr;

    for(ptr=buffer;count;count-=toRead) {

      toRead=std::min<uint8_t>(count,0x20-(this->_position & 0x1f));
      if(!TI2C::readBytes(this->_position,ptr,toRead))
        return false;

      ptr+=toRead;
      this->_position+=toRead;
    }

    return true;
  }
}
// END FILE: ../lib/include/eeprom/AT24Cxx.h
// START FILE: ../lib/include/rng/f4/RngEventSource.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * RNG event types
   */

  enum class RngEventType : uint8_t {
    EVENT_DATA_READY,       ///< next random is ready
    EVENT_SEED_ERROR,       ///< error in random seed
    EVENT_CLOCK_ERROR       ///< error in clock
  };


  /**
   * The signature for RNG events: void myHandler(RngEventType ret,uint32_t randomNumber);
   */

  DECLARE_EVENT_SIGNATURE(RngInterrupt,void(RngEventType,uint32_t));


  /**
   * Base structure that holds just the event subscriber/publisher for SPI
   */

  struct RngEventSource {
    DECLARE_EVENT_SOURCE(RngInterrupt);
  };
}
// END FILE: ../lib/include/rng/f4/RngEventSource.h
// START FILE: ../lib/include/rng/f4/features/RngInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


/**
 * Forward declare the IRQ handler name
 */

extern "C" void HASH_RNG_IRQHandler();


namespace stm32plus {

  /**
   * Helper class to enable only the desired interrupts in the NVIC.
   */

  class RngInterruptFeatureEnabler {

    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

    public:
      static void enable(uint8_t priority,uint8_t subPriority);
  };


  /**
   * Enabler specialisation, Rng 1
   */

  inline void RngInterruptFeatureEnabler::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&HASH_RNG_IRQHandler;
    Nvic::configureIrq(HASH_RNG_IRQn,ENABLE,priority,subPriority);
  }


  /**
   * RNG feature to handle interrupts
   */

  class RngInterruptFeature : public RngEventSource {

    protected:
      uint8_t _nvicPriority;
      uint8_t _nvicSubPriority;

    public:
      static RngEventSource *_rngInstance;

    public:
      RngInterruptFeature();
      ~RngInterruptFeature();

      void setNvicPriorities(uint8_t priority,uint8_t subPriority=0);

      void enableInterrupts();
      void disableInterrupts();
  };


  /**
   * Constructor, initialises the interrupt mask for this class to zero.
   */

  inline RngInterruptFeature::RngInterruptFeature() {
    _nvicPriority=_nvicSubPriority=0;
    _rngInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  inline RngInterruptFeature::~RngInterruptFeature() {
    disableInterrupts();
  }


  /**
   * Set the NVIC priority and subpriority numbers.  This function just remembers your
   * numbers. The actual setting of the priority happens in enableInterrupts()
   * @param priority
   * @param subPriority
   */

  inline void RngInterruptFeature::setNvicPriorities(uint8_t priority,uint8_t subPriority) {
    _nvicPriority=priority;
    _nvicSubPriority=subPriority;
  }


  /**
   * Enable the interrupts specified in the mask
   */

  inline void RngInterruptFeature::enableInterrupts() {
    RngInterruptFeatureEnabler::enable(_nvicPriority,_nvicSubPriority);
    RNG_ITConfig(ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   */

  inline void RngInterruptFeature::disableInterrupts() {
    RNG_ITConfig(DISABLE);
  }
}
// END FILE: ../lib/include/rng/f4/features/RngInterruptFeature.h
// START FILE: ../lib/include/rng/f4/Rng.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {
  namespace net {


    /**
     * Random number generator for the F4 series. This uses the hardware RNG
     * to generate a sequence of 32-bit random numbers
     */

    template<class... Features>
    class Rng : public Features... {

      public:

        enum {
          E_SEED = 1,             ///< Random seed error
          E_CLOCK,                ///< Random clock error
          E_SEQUENCE_ERROR        ///< Generated number was the same as the previous one
        };

      protected:
        uint32_t _last;

      public:
        Rng();
        ~Rng();

        bool nextRandom(uint32_t& nextRandom);
    };

    /**
     * Define a feature-less Rng as the default
     */

    typedef Rng<> DefaultRng;


    /**
     * Constructor: enable the clock and start the peripheral
     */

    template<class... Features>
    inline Rng<Features...>::Rng() {

      ClockControl<PERIPHERAL_RNG>::On();
      RNG_Cmd(ENABLE);

      // FIPS-PUB 140-2: the first generated number is to be saved for comparison

      nextRandom(_last);
    }


    /**
     * Destructor
     */

    template<class... Features>
    inline Rng<Features...>::~Rng() {

      RNG_Cmd(DISABLE);
      ClockControl<PERIPHERAL_RNG>::Off();
    }


    /**
     * Generate the next random number.
     * @param nextRandom The next 32-bit random number
     * @return true if it works
     */

    template<class... Features>
    inline bool Rng<Features...>::nextRandom(uint32_t& nextRandom) {

      nextRandom=0;
      while(RNG_GetFlagStatus(RNG_FLAG_DRDY)==RESET) {

        if(RNG_GetFlagStatus(RNG_FLAG_CECS)==SET)
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_RNG,E_CLOCK);

        if(RNG_GetFlagStatus(RNG_FLAG_SECS)==SET)
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_RNG,E_SEED);
      }

      nextRandom=RNG_GetRandomNumber();
      if(nextRandom==_last)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_RNG,E_SEQUENCE_ERROR);

      _last=nextRandom;
      return true;
    }
  }
}
// END FILE: ../lib/include/rng/f4/Rng.h
// START FILE: ../lib/include/iterator/Iterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

/**
 * @brief Iterator base class.
 * @tparam T The type that we are iterating over.
 *
 * Iterators are created pointing into nothing before the first item. A call
 * to next() is required to move to the first item and on through the items until next() returns
 * false. An error may also cause next() to return false. The error provider should be checked to
 * differentiate between end-of-sequence and fail.
 */

  template<typename T> class Iterator {
    public:

      /**
       * Error codes
       */

      enum {
        /// Iteration has reached the end.
        E_END_OF_ENTRIES=1
      };

      /**
       * Virtual destructor. Does nothing.
       */

      virtual ~Iterator() {}

      /**
       * Move to the next item in the sequence, or on to the first item in the sequence if this is the
       * first call to next().
       * @return false if there is an error or the end of sequence is reached. The difference between an error
       * and the end of a sequence can be determined by inspecting the error provider.
       */

      virtual bool next()=0;

      /**
       * Get the current item pointed at by the iterator.
       */

      virtual T current()=0;
  };
}
// END FILE: ../lib/include/iterator/Iterator.h
// START FILE: ../lib/include/iterator/ResetableIterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

/**
 * @brief Extension of iterator to provide reset functionality.
 * @tparam T The type that we are iterating over.
 *
 * Resettng an iterator moves it back to before the first element.
 */

  template<typename T> 
  class ResetableIterator : public Iterator<T> {
    public:

      virtual ~ResetableIterator() {}

    /**
     * Reset the iterator to before the first element.
     */

      virtual void reset()=0;
  };
}
// END FILE: ../lib/include/iterator/ResetableIterator.h
// START FILE: ../lib/include/i2s/f4/I2SAlternateFunctionMapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Specialisation of the AF mapper for this peripheral. The F4 has the same AF ID
   * regardless of the port so we specialise only on the peripheral
   */

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_I2S2,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_SPI2
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_I2S3,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_SPI3
    };
  };
}
// END FILE: ../lib/include/i2s/f4/I2SAlternateFunctionMapper.h
// START FILE: ../lib/include/i2s/f4/I2SPinInitialiser.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Convenience template to initialise an I2S pin package
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  class I2SPinInitialiser {
    public:
      static void initialise(uint16_t mode,uint16_t mclkOutput);
  };


  /**
   * Initialise the pin package that we were parameterised with
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline void I2SPinInitialiser<TPinPackage,TPeripheralName>::initialise(uint16_t /* mode */,uint16_t mclkOutput) {

    GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_WS,
                                   TPinPackage::Pin_WS,
                                   Gpio::ALTERNATE_FUNCTION,
                                   (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                   Gpio::PUPD_NONE,
                                   Gpio::PUSH_PULL,
                                   GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_WS,TPinPackage::Pin_WS>::GPIO_AF);

    GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_CK,
                                   TPinPackage::Pin_CK,
                                   Gpio::ALTERNATE_FUNCTION,
                                   (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                   Gpio::PUPD_NONE,
                                   Gpio::PUSH_PULL,
                                   GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_CK,TPinPackage::Pin_CK>::GPIO_AF);

    GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_SD,
                                   TPinPackage::Pin_SD,
                                   Gpio::ALTERNATE_FUNCTION,
                                   (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                   Gpio::PUPD_NONE,
                                   Gpio::PUSH_PULL,
                                   GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_SD,TPinPackage::Pin_SD>::GPIO_AF);

    // MCLK is AF only for master mode and if selected

    if(mclkOutput==I2S_MCLKOutput_Enable)
      GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_MCLK,
                                     TPinPackage::Pin_MCLK,
                                     Gpio::ALTERNATE_FUNCTION,
                                     (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                     Gpio::PUPD_NONE,
                                     Gpio::PUSH_PULL,
                                     GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_MCLK,TPinPackage::Pin_MCLK>::GPIO_AF);
  }
}
// END FILE: ../lib/include/i2s/f4/I2SPinInitialiser.h
// START FILE: ../lib/include/i2s/features/I2SFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for I2S features
   */

  class I2SFeatureBase {
    protected:
      I2S& _i2s;

    public:
      I2SFeatureBase(I2S& _i2s);
      operator I2S&();
  };


  /**
   * Constructor
   * @param spi
   */

  inline I2SFeatureBase::I2SFeatureBase(I2S& i2s)
    : _i2s(i2s) {
  }


  /**
   * Cast to I2S reference
   */

  inline I2SFeatureBase::operator I2S&() {
    return _i2s;
  }
}
// END FILE: ../lib/include/i2s/features/I2SFeatureBase.h
// START FILE: ../lib/include/i2s/features/I2SInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Forward declare the IRQ handler names
 */

extern "C" void SPI2_IRQHandler();
extern "C" void SPI3_IRQHandler();


namespace stm32plus {

  /**
   * Helper class to enable only the desired interrupts in the NVIC. This will
   * be fully specialised for each I2S peripheral
   * @tparam TI2SNumber The number of the I2S peripheral (1..3)
   */

  template<uint8_t TI2SNumber>
  class I2SInterruptFeatureEnabler {

    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

    public:
      static void enable(uint8_t priority,uint8_t subPriority);
  };


  /**
   * SPI feature to handle interrupts. This class is the only
   * Observable in the I2S class suite.
   * @tparam TI2SNumber The number of the I2S peripheral (1..5)
   */

  template<uint8_t TI2SNumber>
  class I2SInterruptFeature : public SpiEventSource,
                              public I2SFeatureBase {

    protected:
      uint16_t _interruptMask;
      uint8_t _nvicPriority;
      uint8_t _nvicSubPriority;

    public:
      I2SInterruptFeature(I2S& i2s);
      ~I2SInterruptFeature();

      void setNvicPriorities(uint8_t priority,uint8_t subPriority=0);

      void enableInterrupts(uint16_t interruptMask);
      void disableInterrupts(uint16_t interruptMask);
  };


  /*
   * Typedefs for easy use
   */

  typedef I2SInterruptFeature<2> I2S2InterruptFeature;
  typedef I2SInterruptFeature<3> I2S3InterruptFeature;


  /**
   * Constructor, initialises the interrupt mask for this class to zero.
   */

  template<uint8_t TI2SNumber>
  inline I2SInterruptFeature<TI2SNumber>::I2SInterruptFeature(I2S& i2s)
    : I2SFeatureBase(i2s) {
    _interruptMask=0;
    _nvicPriority=_nvicSubPriority=0;
    SpiInterruptFeature<TI2SNumber>::_spiInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  template<uint8_t TI2SNumber>
  inline I2SInterruptFeature<TI2SNumber>::~I2SInterruptFeature() {
    if(_interruptMask!=0)
      disableInterrupts(_interruptMask);
  }


  /**
   * Set the NVIC priority and subpriority numbers.  This function just remembers your
   * numbers. The actual setting of the priority happens in enableInterrupts()
   * @param priority
   * @param subPriority
   */

  template<uint8_t TI2SNumber>
  inline void I2SInterruptFeature<TI2SNumber>::setNvicPriorities(uint8_t priority,uint8_t subPriority) {
    _nvicPriority=priority;
    _nvicSubPriority=subPriority;
  }


  /**
   * Enable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. SPI_I2S_IT_TXE / SPI_I2S_IT_RXNE / SPI_I2S_IT_ERR
   */

  template<uint8_t TI2SNumber>
  inline void I2SInterruptFeature<TI2SNumber>::enableInterrupts(uint16_t interruptMask) {

    _interruptMask|=interruptMask;
    I2SInterruptFeatureEnabler<TI2SNumber>::enable(_nvicPriority,_nvicSubPriority);
    SPI_I2S_ITConfig(_i2s,interruptMask,ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. SPI_I2S_IT_TXE / SPI_I2S_IT_RXNE / SPI_I2S_IT_ERR
   */

  template<uint8_t TI2SNumber>
  inline void I2SInterruptFeature<TI2SNumber>::disableInterrupts(uint16_t interruptMask) {
    _interruptMask&=~interruptMask;
    SPI_I2S_ITConfig(_i2s,interruptMask,DISABLE);
  }

  /**
   * Enabler specialisation, I2S 2
   */

  template<>
  inline void I2SInterruptFeatureEnabler<2>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&SPI2_IRQHandler;
    Nvic::configureIrq(SPI2_IRQn,ENABLE,priority,subPriority);
  }

#if !defined(STM32PLUS_F1_MD) && !defined(STM32PLUS_F1_MD_VL) && !defined(STM32PLUS_F0)

  /**
   * Enabler specialisation, I2S 3
   */

  template<>
  inline void I2SInterruptFeatureEnabler<3>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&SPI3_IRQHandler;
    Nvic::configureIrq(SPI3_IRQn,ENABLE,priority,subPriority);
  }

#endif

}
// END FILE: ../lib/include/i2s/features/I2SInterruptFeature.h
// START FILE: ../lib/include/i2s/I2SPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * I2S peripheral class
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  class I2SPeripheral : public I2S {

    public:

      /**
       * I2S parameters class
       */

      struct Parameters {
        uint32_t i2s_audioFrequency;
        uint16_t i2s_mode;
        uint16_t i2s_standard;
        uint16_t i2s_dataFormat;
        uint16_t i2s_mclkOutput;
        uint16_t i2s_cpol;

        Parameters(uint32_t audioFrequency=I2S_AudioFreq_44k) {
          i2s_audioFrequency=audioFrequency;
          i2s_mode=I2S_Mode_MasterTx;
          i2s_standard=I2S_Standard_Phillips;
          i2s_dataFormat=I2S_DataFormat_16b;
          i2s_mclkOutput=I2S_MCLKOutput_Enable;
          i2s_cpol=I2S_CPOL_Low;
        }
      };

    protected:

      I2SPeripheral(const struct Parameters& params);
      ~I2SPeripheral();
  };


  /**
   * Constructor
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline I2SPeripheral<TPinPackage,TPeripheralName>::I2SPeripheral(const struct Parameters& params)
    : I2S((SPI_TypeDef *)PeripheralTraits<TPeripheralName>::PERIPHERAL_BASE) {

    I2S_InitTypeDef init;

    // clocks on first before any features get initialised

    ClockControl<TPeripheralName>::On();

    // and next the GPIO pins, also before any features get initialised

    I2SPinInitialiser<TPinPackage,TPeripheralName>::initialise(params.i2s_mode,params.i2s_mclkOutput);

    // initialise the peripheral

    I2S_StructInit(&init);

    init.I2S_Mode=params.i2s_mode;
    init.I2S_Standard=params.i2s_standard;
    init.I2S_DataFormat=params.i2s_dataFormat;
    init.I2S_MCLKOutput=params.i2s_mclkOutput;
    init.I2S_AudioFreq=params.i2s_audioFrequency;
    init.I2S_CPOL=params.i2s_cpol;

    // initialise the peripheral

    I2S_Init(_peripheralAddress,&init);
  }


  /**
   * Destructor
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline I2SPeripheral<TPinPackage,TPeripheralName>::~I2SPeripheral() {

    // disable and clocks off

    disablePeripheral();
    ClockControl<TPeripheralName>::Off();
  }
}
// END FILE: ../lib/include/i2s/I2SPeripheral.h
// START FILE: ../lib/include/i2s/I2S3.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct I2S3_Custom : I2SPeripheral<TPinPackage,PERIPHERAL_I2S3>,
                       Features... {

    I2S3_Custom(const typename I2SPeripheral<TPinPackage,PERIPHERAL_I2S3>::Parameters& params)
      : I2SPeripheral<TPinPackage,PERIPHERAL_I2S3>(params),
        Features(static_cast<I2S&>(*this))... {
    }
  };


  /*
   * Default pin package: (WS,CK,SD,MCLK)=(PA15,PB3,PB5,PC7)
   */

  struct I2S3DefaultPinPackage {
    enum {
      Port_WS   = GPIOA_BASE,
      Port_CK   = GPIOB_BASE,
      Port_SD   = GPIOB_BASE,
      Port_MCLK = GPIOC_BASE,

      Pin_WS   = GPIO_Pin_15,
      Pin_CK   = GPIO_Pin_3,
      Pin_SD   = GPIO_Pin_5,
      Pin_MCLK = GPIO_Pin_7
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct I2S3 : I2SPeripheral<I2S3DefaultPinPackage,PERIPHERAL_I2S3>,
                Features... {

    I2S3(const Parameters& params)
      : I2SPeripheral<I2S3DefaultPinPackage,PERIPHERAL_I2S3>(params),
        Features(static_cast<I2S&>(*this))... {
    }
  };
}

// END FILE: ../lib/include/i2s/I2S3.h
// START FILE: ../lib/include/i2s/I2S.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Base class for all I2S peripherals
   */

  class I2S : public SpiDeviceIo {

    protected:
      SPI_TypeDef *_peripheralAddress;

    public:
      enum {
        E_I2S_ERROR = 1
      };

    protected:
      I2S(SPI_TypeDef *address);

    public:
      bool readyToSend() const;
      bool send(const uint16_t *dataToSend,uint32_t numHalfWords) const;

      bool hasError() const;

      operator SPI_TypeDef *() const;

      void enablePeripheral() const;
      void disablePeripheral() const;
  };


  /**
   * Constructor
   * @param[in] address The peripheral address, e.g. USART1
   * @param[in] nssPort The chip select port
   * @param[in] nssPin The chip select pin - we control it manually
   */

  inline I2S::I2S(SPI_TypeDef *address) {
    _peripheralAddress=address;
  }


  /**
   * Enable the peripheral
   */

  inline void I2S::enablePeripheral() const {
    I2S_Cmd(_peripheralAddress,ENABLE);
  }


  /**
   * Disable the peripheral
   */

  inline void I2S::disablePeripheral() const {
    I2S_Cmd(_peripheralAddress,DISABLE);
  }


  /**
   * Cast this class to the SPI peripheral address.
   * @return The SPI peripheral address.
   */

  inline I2S::operator SPI_TypeDef *() const {
    return _peripheralAddress;
  }


  /**
   * Check if the device has an error status
   */

  inline bool I2S::hasError() const {

    FlagStatus status;

    if((status=SPI_I2S_GetFlagStatus(_peripheralAddress,SPI_FLAG_CRCERR | SPI_FLAG_MODF | SPI_I2S_FLAG_OVR))!=0)
      return !errorProvider.set(ErrorProvider::ERROR_PROVIDER_I2S,E_I2S_ERROR,status);

    return false;
  }


  /**
   * Check for TXE
   */

  inline bool I2S::readyToSend() const {
    return !!SPI_I2S_GetFlagStatus(_peripheralAddress,SPI_I2S_FLAG_TXE);
  }


  /**
   * Send a block of half words, blocking.
   */

  inline bool I2S::send(const uint16_t *dataToSend,uint32_t numHalfWords) const {

    // wait for ready to send

    while(numHalfWords--) {

      while(!readyToSend())
        if(hasError())
          return false;

      // send the 16-bit halfword

      sendData16(_peripheralAddress,*dataToSend++);
    }

    return true;
  }
}

// END FILE: ../lib/include/i2s/I2S.h
// START FILE: ../lib/include/i2s/I2S2.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct I2S2_Custom : I2SPeripheral<TPinPackage,PERIPHERAL_I2S2>,
                       Features... {

    I2S2_Custom(const typename I2SPeripheral<TPinPackage,PERIPHERAL_I2S2>::Parameters& params)
      : I2SPeripheral<TPinPackage,PERIPHERAL_I2S2>(params),
        Features(static_cast<I2S&>(*this))... {
    }
  };


  /*
   * Default pin package: (WS,CK,SD,MCLK)=(PB12,PB13,PB15,PC6)
   */

  struct I2S2DefaultPinPackage {
    enum {
      Port_WS   = GPIOB_BASE,
      Port_CK   = GPIOB_BASE,
      Port_SD   = GPIOB_BASE,
      Port_MCLK = GPIOC_BASE,

      Pin_WS   = GPIO_Pin_12,
      Pin_CK   = GPIO_Pin_13,
      Pin_SD   = GPIO_Pin_15,
      Pin_MCLK = GPIO_Pin_6
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct I2S2 : I2SPeripheral<I2S2DefaultPinPackage,PERIPHERAL_I2S2>,
                Features... {

    I2S2(const typename I2SPeripheral<I2S2DefaultPinPackage,PERIPHERAL_I2S2>::Parameters& params)
      : I2SPeripheral<I2S2DefaultPinPackage,PERIPHERAL_I2S2>(params),
        Features(static_cast<I2S&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/i2s/I2S2.h
// START FILE: ../lib/include/adc/f4/AdcPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Template base class for ADC peripherals.
   *
   * @tparam TPeripheralName The peripheral name (PERIPHERAL_ADC1, PERIPHERAL_ADC2, PERIPHERAL_ADC3)
   */

  template<PeripheralName TPeripheralName>
  class AdcPeripheral : public Adc {

    protected:
      void initialisePeripheral();

    public:
      AdcPeripheral(Adc *master);
      ~AdcPeripheral();
  };


  /**
   * Constructor
   * @param params The parameters class used to initialise the peripheral
   */

  template<PeripheralName TPeripheralName>
  inline AdcPeripheral<TPeripheralName>::AdcPeripheral(Adc *master)
    : Adc((ADC_TypeDef *)PeripheralTraits<TPeripheralName>::PERIPHERAL_BASE,master) {
  }


  /**
   * Called from the derived class constructor after the features have been constructed
   * and performed any customisation of the init and commoninit values.
   */

  template<PeripheralName TPeripheralName>
  inline void AdcPeripheral<TPeripheralName>::initialisePeripheral() {

    // clocks on first

    ClockControl<TPeripheralName>::On();

    // the features have been constructed and the common init structure customised
    // initialise it and free the memory it was using

    if(_master==nullptr)
      ADC_CommonInit(_commonInit);

    delete _commonInit;

    // and now the other init call

    ADC_Init(_peripheralAddress,&_init);

    // if there are any injected channels then set the count

    if(_injectedChannelCount)
      ADC_InjectedSequencerLengthConfig(_peripheralAddress,_injectedChannelCount);
  }


  /**
   * Destructor, disable peripheral and disable clocks
   */

  template<PeripheralName TPeripheralName>
  inline AdcPeripheral<TPeripheralName>::~AdcPeripheral() {

    // disable the peripheral

    disablePeripheral();

    // clocks off

    ClockControl<TPeripheralName>::Off();
  }
}
// END FILE: ../lib/include/adc/f4/AdcPeripheral.h
// START FILE: ../lib/include/adc/f4/Adc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Non-template base class for the ADC peripheral
   */

  class Adc {

    protected:
     ADC_TypeDef *_peripheralAddress;
     ADC_CommonInitTypeDef *_commonInit;
     ADC_InitTypeDef _init;
     uint8_t _injectedChannelCount;
     Adc *_master;

     static uint8_t _regularChannelRank[3];        // we can have multiple channel feature instances and multiple ADCs
     static uint8_t _injectedChannelRank[3];

    public:
      Adc(ADC_TypeDef *peripheralAddress,Adc *master);

      void enablePeripheral() const;
      void disablePeripheral() const;

      // get and increment the rank for an ADC

      uint8_t getAndIncrementRegularChannelRank(uint8_t adcNumber);
      uint8_t getAndIncrementInjectedChannelRank(uint8_t adcNumber);

      void incrementInjectedChannelCount(uint8_t amountToAdd);

      // regular conversion data access functions

      void startRegularConversion() const;
      bool hasRegularConversionStarted() const;
      bool hasRegularConversionFinished() const;
      uint16_t getRegularConversionValue() const;

      // cast operators

      operator ADC_TypeDef *();
      operator ADC_CommonInitTypeDef *();
      operator ADC_InitTypeDef *();
  };


  /**
   * Constructor
   * @param peripheralAddress The peripheral address
   */

  inline Adc::Adc(ADC_TypeDef *peripheralAddress,Adc *master)
    : _peripheralAddress(peripheralAddress),
      _master(master) {

    // initialise the ranks back to 1 so that the channel features are ready

    _regularChannelRank[0]=_regularChannelRank[1]=_regularChannelRank[2]=1;
    _injectedChannelRank[0]=_injectedChannelRank[1]=_injectedChannelRank[2]=1;
    _injectedChannelCount=0;

    // set up the default init values
    // the features can customise this before the AdcPeripheral class uses

    _init.ADC_Resolution=ADC_Resolution_12b;
    _init.ADC_ScanConvMode=DISABLE;
    _init.ADC_ContinuousConvMode=DISABLE;
    _init.ADC_ExternalTrigConvEdge=ADC_ExternalTrigConvEdge_None;
    _init.ADC_ExternalTrigConv=ADC_ExternalTrigConv_T1_CC1;
    _init.ADC_DataAlign=ADC_DataAlign_Right;
    _init.ADC_NbrOfConversion=0;

    // set up the default common init values
    // the features can customise this before the AdcPeripheral class uses
    // it and frees the memory it used

    _commonInit=new ADC_CommonInitTypeDef;

    _commonInit->ADC_Mode=ADC_Mode_Independent;
    _commonInit->ADC_Prescaler=ADC_Prescaler_Div2;
    _commonInit->ADC_DMAAccessMode=ADC_DMAAccessMode_Disabled;
    _commonInit->ADC_TwoSamplingDelay=ADC_TwoSamplingDelay_5Cycles;
  }


  /**
   * Get the rank (order) number for a regular channel
   * @param adcNumber The ADC number (1..3)
   * @return the current rank number
   */

  inline uint8_t Adc::getAndIncrementRegularChannelRank(uint8_t adcNumber) {
    return _regularChannelRank[adcNumber-1]++;
  }


  /**
   * Get the rank (order) number for an injected channel
   * @param adcNumber The ADC number (1..3)
   * @return the current rank number
   */

  inline uint8_t Adc::getAndIncrementInjectedChannelRank(uint8_t adcNumber) {
    return _injectedChannelRank[adcNumber-1]++;
  }


  /**
   * Return the ADC peripheral address
   */

  inline Adc::operator ADC_TypeDef *() {
    return _peripheralAddress;
  }


  /**
   * Return the ADC common init structure
   */

  inline Adc::operator ADC_CommonInitTypeDef *() {
    return _commonInit;
  }


  /**
   * Return the ADC init structure
   */

  inline Adc::operator ADC_InitTypeDef *() {
    return &_init;
  }


  /**
   * Enable the ADC
   */

  inline void Adc::enablePeripheral() const {
    ADC_Cmd(_peripheralAddress,ENABLE);
  }


  /**
   * Disable the ADC
   */

  inline void Adc::disablePeripheral() const {
    ADC_Cmd(_peripheralAddress,DISABLE);
  }


  /**
   * Start the conversion by software command. This will set SWSTART in CR2.
   */

  inline void Adc::startRegularConversion() const {
    ADC_SoftwareStartConv(_peripheralAddress);
  }


  /**
   * Return true if a software conversion has started. SWSTART in CR2 is cleared
   * by the MCU when the conversion starts
   * @return true if the conversion has started.
   */

  inline bool Adc::hasRegularConversionStarted() const {
    return ADC_GetSoftwareStartConvStatus(_peripheralAddress)==RESET;
  }


  /**
   * Return true if a conversion has finished. Returns the status of the EOC flag
   * @return true if the conversion has finished.
   */

  inline bool Adc::hasRegularConversionFinished() const {
    return ADC_GetFlagStatus(_peripheralAddress,ADC_FLAG_EOC)==SET;
  }


  /**
   * Get the result of a regular conversion
   * @return The conversion result
   */

  inline uint16_t Adc::getRegularConversionValue() const {
    return ADC_GetConversionValue(_peripheralAddress);
  }


  /**
   * Increase the number of injected channels
   */

  inline void Adc::incrementInjectedChannelCount(uint8_t amountToAdd) {
    _injectedChannelCount+=amountToAdd;
  }
}
// END FILE: ../lib/include/adc/f4/Adc.h
// START FILE: ../lib/include/adc/Adc3.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * ADC3 declaration
   *
   * @tparam Features A list of all the features you want to include with this ADC
   */

  template<class... Features>
  struct Adc3 : AdcPeripheral<PERIPHERAL_ADC3>,
                Features... {
    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Adc3(Adc *master=nullptr)
        : AdcPeripheral<PERIPHERAL_ADC3>(master),
          Features(static_cast<Adc&>(*this))... {

      // this is the most-derived class and construction is now complete
      // so we can initialise the peripheral

      initialisePeripheral();

      RecursiveVoidInit<Adc3,Features...>::tinit(this);

      // enable it

      enablePeripheral();
    }
  };
}
// END FILE: ../lib/include/adc/Adc3.h
// START FILE: ../lib/include/adc/features/f4/AdcClockPrescalerFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Feature class to allow changing the prescaler for the ADC analog clock. The ADC clock on the F4 runs off
   * APB2 divided by a prescaler. You specify the prescaler: 2/4/8 as a template parameter and the code
   * selects the correct constant at compile time.
   */

  template<uint8_t TPrescaler>
  struct AdcClockPrescalerFeature : AdcFeatureBase {

    /**
     * Constructor, customise the prescaler
     * @param adc The adc object holding the setup values
     */

    AdcClockPrescalerFeature(Adc& adc)
      : AdcFeatureBase(adc) {

      static_assert(TPrescaler==2 || TPrescaler==4 || TPrescaler==8,"Invalid ADC prescaler: 2,4,8 only");

      // this is a switch on a constant - the optimiser will eliminate everything except
      // the selected assignment

      switch(TPrescaler) {

        case 2:
          ((ADC_CommonInitTypeDef *)adc)->ADC_Prescaler=ADC_Prescaler_Div2;
          break;

        case 4:
          ((ADC_CommonInitTypeDef *)adc)->ADC_Prescaler=ADC_Prescaler_Div4;
          break;

        case 8:
          ((ADC_CommonInitTypeDef *)adc)->ADC_Prescaler=ADC_Prescaler_Div8;
          break;
      }
    }


    /**
     * Post ADC_Init() initialisation
     */

    void initialise() {
    }
  };
}
// END FILE: ../lib/include/adc/features/f4/AdcClockPrescalerFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcInjectedChannelFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Base class for the injected channel feature. Members that don't need to
   * be a part of the template are here.
   */

  class AdcInjectedChannelFeatureBase : public AdcFeatureBase {

    protected:
      uint8_t channelIndexToChannelNumber(uint8_t channelIndex) const;

    public:
      AdcInjectedChannelFeatureBase(Adc& adc);

      void setInjectedChannelOffset(uint8_t channelIndex,uint16_t offset);

      void enableAutoInjectedMode() const;
      void disableAutoInjectedMode() const;

      void enableDiscontinuousInjectedMode() const;
      void disableDiscontinuousInjectedMode() const;

      void startInjectedConversion() const;
      bool hasInjectedConversionStarted() const;
      bool hasInjectedConversionFinished() const;
      uint16_t getInjectedConversionValue(uint8_t channelIndex) const;
  };


  /**
   * Constructor
   */

  inline AdcInjectedChannelFeatureBase::AdcInjectedChannelFeatureBase(Adc& adc)
    : AdcFeatureBase(adc) {
  }


  /**
   * Set the 12-bit offset for the conversion values of an injected channel. This value is subtracted
   * from the converted value for the specified channel. This means that the converted values can
   * be negative.
   * @param channel The channel number (0..3)
   * @param offset The 12-bit offset
   */

  inline void AdcInjectedChannelFeatureBase::setInjectedChannelOffset(uint8_t channel,uint16_t offset) {

    ADC_SetInjectedOffset(_adc,channelIndexToChannelNumber(channel),offset);
  }


  /**
   * The peripheral library confusingly uses channel indexes for setup and then some magic
   * constants for access later. We'll still to indices and map to constants where the
   * API needs them.
   */

  inline uint8_t AdcInjectedChannelFeatureBase::channelIndexToChannelNumber(uint8_t channelIndex) const {

    return channelIndex==0 ? ADC_InjectedChannel_1 :
           channelIndex==1 ? ADC_InjectedChannel_2 :
           channelIndex==2 ? ADC_InjectedChannel_3 :
          ADC_InjectedChannel_4;
  }


  /**
   * Start the conversion by software command. This will set JSWSTART in CR2.
   */

  inline void AdcInjectedChannelFeatureBase::startInjectedConversion() const {
    ADC_SoftwareStartInjectedConv(_adc);
  }


  /**
   * Return true if a software conversion has started. JSWSTART in CR2 is cleared
   * by the MCU when the conversion starts
   * @return true if the conversion has started.
   */

  inline bool AdcInjectedChannelFeatureBase::hasInjectedConversionStarted() const {
    return ADC_GetSoftwareStartInjectedConvCmdStatus(_adc)==RESET;
  }


  /**
   * Return true if a conversion has finished. Returns the status of the JEOC flag
   * @return true if the conversion has finished.
   */

  inline bool AdcInjectedChannelFeatureBase::hasInjectedConversionFinished() const {
    return ADC_GetFlagStatus(_adc,ADC_FLAG_JEOC)==SET;
  }


  /**
   * Get the result of an injected conversion
   * @param channelIndex The 0..3 index of the injected channel
   * @return The conversion result
   */

  inline uint16_t AdcInjectedChannelFeatureBase::getInjectedConversionValue(uint8_t channelIndex) const {
    return ADC_GetInjectedConversionValue(_adc,channelIndexToChannelNumber(channelIndex));
  }


  /**
   * Enable auto-injected mode (injected channels converted after regular)
   */

  inline void AdcInjectedChannelFeatureBase::enableAutoInjectedMode() const {
    ADC_AutoInjectedConvCmd(_adc,ENABLE);
  }


  /**
   * Disable auto-injected mode (injected channels converted after regular)
   */

  inline void AdcInjectedChannelFeatureBase::disableAutoInjectedMode() const {
    ADC_AutoInjectedConvCmd(_adc,DISABLE);
  }


  /**
   * Enable discontinuous injected mode (one-by-one conversion of a group)
   */

  inline void AdcInjectedChannelFeatureBase::enableDiscontinuousInjectedMode() const {
    ADC_InjectedDiscModeCmd(_adc,ENABLE);
  }


  /**
   * Disable discontinuous injected mode (one-by-one conversion of a group)
   */

  inline void AdcInjectedChannelFeatureBase::disableDiscontinuousInjectedMode() const {
    ADC_InjectedDiscModeCmd(_adc,DISABLE);
  }
}
// END FILE: ../lib/include/adc/features/f4/AdcInjectedChannelFeatureBase.h
// START FILE: ../lib/include/adc/features/f4/AdcMultiFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Template class that will be used to initialise the multi-adc mode. You're expected
   * to use one of the template typedefs down below instead of instantiating this
   * directly.
   */

  template<uint32_t TDmaModeType,uint32_t TAdcMultiModeType,uint8_t TTwoSamplingDelay>
  struct AdcMultiFeature : AdcFeatureBase {

    AdcMultiFeature(Adc& adc)
      : AdcFeatureBase(adc) {

      static_assert(TTwoSamplingDelay>=5 && TTwoSamplingDelay<=20,"TTwoSamplingDelay must be between 5 and 20");

      // modes for ADC and DMA

      ((ADC_CommonInitTypeDef *)adc)->ADC_Mode=TAdcMultiModeType;
      ((ADC_CommonInitTypeDef *)adc)->ADC_DMAAccessMode=TDmaModeType;

      // initialise this such that the optimised will eliminate all the conditional tests

      ((ADC_CommonInitTypeDef *)adc)->ADC_TwoSamplingDelay=
          TTwoSamplingDelay==5 ? ADC_TwoSamplingDelay_5Cycles :
          TTwoSamplingDelay==6 ? ADC_TwoSamplingDelay_6Cycles :
          TTwoSamplingDelay==7 ? ADC_TwoSamplingDelay_7Cycles :
          TTwoSamplingDelay==8 ? ADC_TwoSamplingDelay_8Cycles :
          TTwoSamplingDelay==9 ? ADC_TwoSamplingDelay_9Cycles :
          TTwoSamplingDelay==10 ? ADC_TwoSamplingDelay_10Cycles :
          TTwoSamplingDelay==11 ? ADC_TwoSamplingDelay_11Cycles :
          TTwoSamplingDelay==12 ? ADC_TwoSamplingDelay_12Cycles :
          TTwoSamplingDelay==13 ? ADC_TwoSamplingDelay_13Cycles :
          TTwoSamplingDelay==14 ? ADC_TwoSamplingDelay_14Cycles :
          TTwoSamplingDelay==15 ? ADC_TwoSamplingDelay_15Cycles :
          TTwoSamplingDelay==16 ? ADC_TwoSamplingDelay_16Cycles :
          TTwoSamplingDelay==17 ? ADC_TwoSamplingDelay_17Cycles :
          TTwoSamplingDelay==18 ? ADC_TwoSamplingDelay_18Cycles :
          TTwoSamplingDelay==19 ? ADC_TwoSamplingDelay_19Cycles :
          ADC_TwoSamplingDelay_20Cycles;
    }


    /**
     * Get the results of a multi-conversion
     * @return The results of the conversion
     */

    uint32_t getMultiConversionValue() const {
      return ADC_GetMultiModeConversionValue();
    }
  };
}
// END FILE: ../lib/include/adc/features/f4/AdcMultiFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcTemperatureSensorFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Support for the temp sensor ADC channel is a simple extension of the regular channel
   * configuration
   */

  template<uint8_t TSampleCycles,uint16_t TV25=760,uint16_t TAvgSlope=2500>   // from the datasheet (scaled)
  struct AdcTemperatureSensorFeature : AdcRegularChannelFeature<1,TSampleCycles,16> {

    /**
     * Constants used by the conversion function to get good accuracy from
     * the integer calculation
     */

    enum {
      SCALER = 1000
    };


    /**
     * Constructor, initialise upwards then enable the sensor feature
     */

    AdcTemperatureSensorFeature(Adc& adc)
      : AdcRegularChannelFeature<1,TSampleCycles,16>(adc) {
    }


    /**
     * Post ADC_Init() initialisation
     */

    void initialise() {
      AdcRegularChannelFeature<1,TSampleCycles,16>::initialise();
      ADC_TempSensorVrefintCmd(ENABLE);
    }


    /**
     * Convert the value read from the ADC to a temperature in centigrade. We scale up the
     * necessary constants for the calculation to avoid floating point numbers.
     * @param vsense The value read from the ADC
     * @return The temperature in degrees C
     */

    uint8_t getTemperature(uint16_t vsense) const {

      uint32_t value;

      value=(vsense*3300) & 0xfff;

      // scale up the sensed value by 1000

      value=value*SCALER;
      value=((value-TV25)/TAvgSlope)+(25*SCALER);

      return value/SCALER;
    }
  };


  /*
   * Typedefs for the difference cycles on ADC1. There's a minimum conversion time for the
   * temperature so the lower-cycle values are not present.
   */

  typedef AdcTemperatureSensorFeature<ADC_SampleTime_112Cycles> Adc1Cycle112TemperatureSensorFeature;
  typedef AdcTemperatureSensorFeature<ADC_SampleTime_144Cycles> Adc1Cycle144TemperatureSensorFeature;
  typedef AdcTemperatureSensorFeature<ADC_SampleTime_480Cycles> Adc1Cycle480TemperatureSensorFeature;
}
// END FILE: ../lib/include/adc/features/f4/AdcTemperatureSensorFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcInternalReferenceVoltageFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Support for the Vrefint ADC channel is a simple extension of the regular channel
   * configuration
   */

  template<uint8_t TSampleCycles>
  struct AdcInternalReferenceVoltageFeature : AdcRegularChannelFeature<1,TSampleCycles,17> {

    /**
     * Constructor, initialise upwards then enable the vrefint feature
     */

    AdcInternalReferenceVoltageFeature(Adc& adc)
      : AdcRegularChannelFeature<1,TSampleCycles,17>(adc) {
    }


    /**
     * Post ADC_Init() initialisation
     */

    void initialise() {
      AdcRegularChannelFeature<1,TSampleCycles,17>::initialise();
      ADC_TempSensorVrefintCmd(ENABLE);
    }
  };


  /*
   * Typedefs for the difference cycles on ADC1
   */


  typedef AdcInternalReferenceVoltageFeature<ADC_SampleTime_3Cycles> Adc1Cycle3InternalReferenceVoltageFeature;
  typedef AdcInternalReferenceVoltageFeature<ADC_SampleTime_15Cycles> Adc1Cycle15InternalReferenceVoltageFeature;
  typedef AdcInternalReferenceVoltageFeature<ADC_SampleTime_28Cycles> Adc1Cycle28InternalReferenceVoltageFeature;
  typedef AdcInternalReferenceVoltageFeature<ADC_SampleTime_56Cycles> Adc1Cycle56InternalReferenceVoltageFeature;
  typedef AdcInternalReferenceVoltageFeature<ADC_SampleTime_84Cycles> Adc1Cycle84InternalReferenceVoltageFeature;
  typedef AdcInternalReferenceVoltageFeature<ADC_SampleTime_112Cycles> Adc1Cycle112InternalReferenceVoltageFeature;
  typedef AdcInternalReferenceVoltageFeature<ADC_SampleTime_144Cycles> Adc1Cycle144InternalReferenceVoltageFeature;
  typedef AdcInternalReferenceVoltageFeature<ADC_SampleTime_480Cycles> Adc1Cycle480InternalReferenceVoltageFeature;
}
// END FILE: ../lib/include/adc/features/f4/AdcInternalReferenceVoltageFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcAllChannelsAnalogWatchdogFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Support for configuring the analog watchdog feature. The AWD allows you to
   * trigger an interrupt if a voltage crosses pre-defined upper or lower bounds.
   * This feature allows you to configure all enabled channels for monitoring.
   *
   * This feature would normally be combined with AdcInterruptFeature in your
   * ADC declaration.
   */

  template<AdcChannelType TChannelType,uint16_t TLow,uint16_t THigh>
  struct AdcAllChannelsAnalogWatchdogFeature : AdcAnalogWatchdogFeature<TLow,THigh> {

    public:

      /**
       * Constructor
       * @param adc Reference to the main ADC class
       */

      AdcAllChannelsAnalogWatchdogFeature(Adc& adc)
       : AdcAnalogWatchdogFeature<TLow,THigh>(adc) {
      }


      /**
       * Enable the watchdog on all channels of the templated type
       */

      void enableAnalogWatchdog() {

        static_assert(TChannelType==AdcChannelType::Regular ||
                      TChannelType==AdcChannelType::Injected ||
                      TChannelType==AdcChannelType::RegularAndInjected,"Invalid channel type");

        ADC_AnalogWatchdogCmd(
            this->_adc,
            TChannelType==AdcChannelType::Regular ? ADC_AnalogWatchdog_AllRegEnable :
            TChannelType==AdcChannelType::Injected ? ADC_AnalogWatchdog_AllInjecEnable :
            ADC_AnalogWatchdog_AllRegAllInjecEnable);
      }

  };
}
// END FILE: ../lib/include/adc/features/f4/AdcAllChannelsAnalogWatchdogFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcSingleChannelAnalogWatchdogFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Support for configuring the analog watchdog feature. The AWD allows you to
   * trigger an interrupt if a voltage crosses pre-defined upper or lower bounds.
   * This feature allows you to configure a single channel for monitoring.
   *
   * This feature would normally be combined with AdcInterruptFeature in your
   * ADC declaration.
   */

  template<uint8_t TChannelNumber,AdcChannelType TChannelType,uint16_t TLow,uint16_t THigh>
  struct AdcSingleChannelAnalogWatchdogFeature : AdcAnalogWatchdogFeature<TLow,THigh> {

    public:

      /**
       * Constructor
       * @param adc Reference to the main ADC class
       */

      AdcSingleChannelAnalogWatchdogFeature(Adc& adc)
       : AdcAnalogWatchdogFeature<TLow,THigh>(adc) {
      }


      /**
       * Post construction initialisation
       */

      void initialise() {

        // call the base class

        AdcAnalogWatchdogFeature<TLow,THigh>::initialise();

        // set the channel and enable single mode. actual guarding will not start
        // until enableAnalogWatchdog() is called.

        ADC_AnalogWatchdogSingleChannelConfig(this->_adc,TChannelNumber);
      }


      /**
       * Enable the watchdog on the templated channel type
       */

      void enableAnalogWatchdog() {

        static_assert(TChannelType==AdcChannelType::Regular ||
                      TChannelType==AdcChannelType::Injected ||
                      TChannelType==AdcChannelType::RegularAndInjected,"Invalid channel type");

        ADC_AnalogWatchdogCmd(
            this->_adc,
            TChannelType==AdcChannelType::Regular ? ADC_AnalogWatchdog_SingleRegEnable :
            TChannelType==AdcChannelType::Injected ? ADC_AnalogWatchdog_SingleInjecEnable :
            ADC_AnalogWatchdog_SingleRegOrInjecEnable);
      }
  };
}
// END FILE: ../lib/include/adc/features/f4/AdcSingleChannelAnalogWatchdogFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcRegularChannelFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Handle the ADC regular channels (0..18 on the F4). ST's ADC_Channel_XX constants are simple
   * numbers 0..18 so we can use this feature easily, for example...
   *
   * Adc1Cycle3RegularChannelFeature<1,2,6,7>
   *
   * ...will initialise channels 1,2,6 and 7 with 3 cycle sample time on ADC1.
   * @tparam TAdcNumber The ADC number (1..3)
   * @tparam The peripheral library constant for the number of conversion cycles, e.g. ADC_SampleTime_3Cycles
   * @tparam TChannelNumbers List of channel numbers, 0..15.
   */

  template<uint8_t TAdcNumber,uint8_t TSampleCycles,uint8_t... TChannelNumbers>
  class AdcRegularChannelFeature : public AdcFeatureBase {

    protected:

      template<uint8_t TChannelNumber>
      void init();

      template<uint8_t TFirst,uint8_t TNext,uint8_t... TRest>
      void init();

    public:
      AdcRegularChannelFeature(Adc& adc);
      void initialise();
  };


  /*
   * Typedefs for the difference cycles on each ADC
   */

  template<uint8_t... TChannelNumbers> using Adc1Cycle3RegularChannelFeature = AdcRegularChannelFeature<1,ADC_SampleTime_3Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle15RegularChannelFeature = AdcRegularChannelFeature<1,ADC_SampleTime_15Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle28RegularChannelFeature = AdcRegularChannelFeature<1,ADC_SampleTime_28Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle56RegularChannelFeature = AdcRegularChannelFeature<1,ADC_SampleTime_56Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle84RegularChannelFeature = AdcRegularChannelFeature<1,ADC_SampleTime_84Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle112RegularChannelFeature = AdcRegularChannelFeature<1,ADC_SampleTime_112Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle144RegularChannelFeature = AdcRegularChannelFeature<1,ADC_SampleTime_144Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle480RegularChannelFeature = AdcRegularChannelFeature<1,ADC_SampleTime_480Cycles,TChannelNumbers...>;

  template<uint8_t... TChannelNumbers> using Adc2Cycle3RegularChannelFeature = AdcRegularChannelFeature<2,ADC_SampleTime_3Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle15RegularChannelFeature = AdcRegularChannelFeature<2,ADC_SampleTime_15Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle28RegularChannelFeature = AdcRegularChannelFeature<2,ADC_SampleTime_28Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle56RegularChannelFeature = AdcRegularChannelFeature<2,ADC_SampleTime_56Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle84RegularChannelFeature = AdcRegularChannelFeature<2,ADC_SampleTime_84Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle112RegularChannelFeature = AdcRegularChannelFeature<2,ADC_SampleTime_112Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle144RegularChannelFeature = AdcRegularChannelFeature<2,ADC_SampleTime_144Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle480RegularChannelFeature = AdcRegularChannelFeature<2,ADC_SampleTime_480Cycles,TChannelNumbers...>;

  template<uint8_t... TChannelNumbers> using Adc3Cycle3RegularChannelFeature = AdcRegularChannelFeature<3,ADC_SampleTime_3Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle15RegularChannelFeature = AdcRegularChannelFeature<3,ADC_SampleTime_15Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle28RegularChannelFeature = AdcRegularChannelFeature<3,ADC_SampleTime_28Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle56RegularChannelFeature = AdcRegularChannelFeature<3,ADC_SampleTime_56Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle84RegularChannelFeature = AdcRegularChannelFeature<3,ADC_SampleTime_84Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle112RegularChannelFeature = AdcRegularChannelFeature<3,ADC_SampleTime_112Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle144RegularChannelFeature = AdcRegularChannelFeature<3,ADC_SampleTime_144Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle480RegularChannelFeature = AdcRegularChannelFeature<3,ADC_SampleTime_480Cycles,TChannelNumbers...>;


  /**
   * Constructor
   * @param adc Adc class reference
   */

  template<uint8_t TAdcNumber,uint8_t TSampleCycles,uint8_t... TChannelNumbers>
  inline AdcRegularChannelFeature<TAdcNumber,TSampleCycles,TChannelNumbers...>::AdcRegularChannelFeature(Adc& adc)
    : AdcFeatureBase(adc) {

    // increase the number of channels being converted

    ((ADC_InitTypeDef *)adc)->ADC_NbrOfConversion+=sizeof...(TChannelNumbers);
  }


  /**
   * Initialise after ADC_Init
   */

  template<uint8_t TAdcNumber,uint8_t TSampleCycles,uint8_t... TChannelNumbers>
  inline void AdcRegularChannelFeature<TAdcNumber,TSampleCycles,TChannelNumbers...>::initialise() {

    // expand and initialise

    init<TChannelNumbers...>();
  }


  /**
   * Base case initialiser for when parameter pack expansion gets to the last one
   */

  template<uint8_t TAdcNumber,uint8_t TSampleCycles,uint8_t... TChannelNumbers>
  template<uint8_t TChannelNumber>
  inline void AdcRegularChannelFeature<TAdcNumber,TSampleCycles,TChannelNumbers...>::init() {

    if(TChannelNumber<=15)
      AdcChannelGpioInitialiser<TAdcNumber,TChannelNumber>::initialiseGpioPin();

    ADC_RegularChannelConfig(_adc,TChannelNumber,_adc.getAndIncrementRegularChannelRank(TAdcNumber),TSampleCycles);
  }


  /**
   * Recursive initialise for the template parameter pack.
   */

  template<uint8_t TAdcNumber,uint8_t TSampleCycles,uint8_t... TChannelNumbers>
  template<uint8_t TFirst,uint8_t TNext,uint8_t... TRest>
  inline void AdcRegularChannelFeature<TAdcNumber,TSampleCycles,TChannelNumbers...>::init() {

    if(TFirst<=15)
      AdcChannelGpioInitialiser<TAdcNumber,TFirst>::initialiseGpioPin();

    ADC_RegularChannelConfig(_adc,TFirst,_adc.getAndIncrementRegularChannelRank(TAdcNumber),TSampleCycles);
    init<TNext,TRest...>();
  }
}
// END FILE: ../lib/include/adc/features/f4/AdcRegularChannelFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcScanModeFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * This enum determines when the EOC flag is set during scan mode. END_AFTER_EACH_CHANNEL
   * means that EOC gets raised after each channel in the group is converted. So there will
   * be N EOC's for a group containing N channels. END_AFTER_WHOLE_GROUP means that only a
   * single EOC flag will be raised for each group of configured channels. This mode normally
   * implies that you'll be using DMA to move data out to SRAM after each channel is converted.
   */

  enum class AdcScanModeEndType : uint8_t {
    END_AFTER_EACH_CHANNEL,
    END_AFTER_WHOLE_GROUP
  };


  /**
   * Feature class to enable scan-mode. The scan mode end type is a template parameter so
   * that we can generate zero conditional code for the ADC_EOCOnEachRegularChannelCmd parameter.
   * @tparam TEndType The desired condition for raising the EOC flag
   */

  template<AdcScanModeEndType TEndType=AdcScanModeEndType::END_AFTER_WHOLE_GROUP>
  struct AdcScanModeFeature : AdcFeatureBase {

    AdcScanModeFeature(Adc& adc)
      : AdcFeatureBase(adc) {

      static_assert(
          TEndType==AdcScanModeEndType::END_AFTER_EACH_CHANNEL ||
          TEndType==AdcScanModeEndType::END_AFTER_WHOLE_GROUP,
          "TEndType is not a member of the AdcScanModeEndType enumeration");

      ADC_EOCOnEachRegularChannelCmd(adc,TEndType==AdcScanModeEndType::END_AFTER_EACH_CHANNEL ? ENABLE : DISABLE);
      ((ADC_InitTypeDef *)adc)->ADC_ScanConvMode=ENABLE;
    }


    /**
     * Post ADC_Init() initialisation
     */

    void initialise() {
    }
  };
}
// END FILE: ../lib/include/adc/features/f4/AdcScanModeFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcChannelGpioInitialiser.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Utility class for the sole purpose of initialising a GPIO pin for the ADC.
   * @tparam TAdcNumber The ADC number (1..3)
   * @tparam TChannelNumber The channel number (0..15)
   */

  template<uint8_t TAdcNumber,uint8_t TChannelNumber>
  struct AdcChannelGpioInitialiser {

    /**
     * Initialise the GPIO pin. The idea here is that the conditional statements are on constants
     * and so can be evaluated at compile time. The optimiser will eliminate everything except
     * the two assignments for the correct port and pin.
     */

    static void initialiseGpioPin() {

      GPIO_TypeDef *port;
      uint16_t pin;

      static_assert(TAdcNumber>=1 && TAdcNumber<=3,"TAdcNumber out of range");

      if(TAdcNumber==1) {
        switch(TChannelNumber) {
          case 0: port=GPIOA; pin=GPIO_Pin_0; break;
          case 1: port=GPIOA; pin=GPIO_Pin_1; break;
          case 2: port=GPIOA; pin=GPIO_Pin_2; break;
          case 3: port=GPIOA; pin=GPIO_Pin_3; break;
          case 4: port=GPIOA; pin=GPIO_Pin_4; break;
          case 5: port=GPIOA; pin=GPIO_Pin_5; break;
          case 6: port=GPIOA; pin=GPIO_Pin_6; break;
          case 7: port=GPIOA; pin=GPIO_Pin_7; break;
          case 8: port=GPIOB; pin=GPIO_Pin_0; break;
          case 9: port=GPIOB; pin=GPIO_Pin_1; break;
          case 10: port=GPIOC; pin=GPIO_Pin_0; break;
          case 11: port=GPIOC; pin=GPIO_Pin_1; break;
          case 12: port=GPIOC; pin=GPIO_Pin_2; break;
          case 13: port=GPIOC; pin=GPIO_Pin_3; break;
          case 14: port=GPIOC; pin=GPIO_Pin_4; break;
          case 15: port=GPIOC; pin=GPIO_Pin_5; break;
        }
      }
      else if(TAdcNumber==2) {
        switch(TChannelNumber) {
          case 0: port=GPIOA; pin=GPIO_Pin_0; break;
          case 1: port=GPIOA; pin=GPIO_Pin_1; break;
          case 2: port=GPIOA; pin=GPIO_Pin_2; break;
          case 3: port=GPIOA; pin=GPIO_Pin_3; break;
          case 4: port=GPIOA; pin=GPIO_Pin_4; break;
          case 5: port=GPIOA; pin=GPIO_Pin_5; break;
          case 6: port=GPIOA; pin=GPIO_Pin_6; break;
          case 7: port=GPIOA; pin=GPIO_Pin_7; break;
          case 8: port=GPIOB; pin=GPIO_Pin_0; break;
          case 9: port=GPIOB; pin=GPIO_Pin_1; break;
          case 10: port=GPIOC; pin=GPIO_Pin_0; break;
          case 11: port=GPIOC; pin=GPIO_Pin_1; break;
          case 12: port=GPIOC; pin=GPIO_Pin_2; break;
          case 13: port=GPIOC; pin=GPIO_Pin_3; break;
          case 14: port=GPIOC; pin=GPIO_Pin_4; break;
          case 15: port=GPIOC; pin=GPIO_Pin_5; break;
        }
      }
      else if(TAdcNumber==3) {
        switch(TChannelNumber) {
          case 0: port=GPIOA; pin=GPIO_Pin_0; break;
          case 1: port=GPIOA; pin=GPIO_Pin_1; break;
          case 2: port=GPIOA; pin=GPIO_Pin_2; break;
          case 3: port=GPIOA; pin=GPIO_Pin_3; break;
          case 4: port=GPIOF; pin=GPIO_Pin_6; break;
          case 5: port=GPIOF; pin=GPIO_Pin_7; break;
          case 6: port=GPIOF; pin=GPIO_Pin_8; break;
          case 7: port=GPIOF; pin=GPIO_Pin_9; break;
          case 8: port=GPIOF; pin=GPIO_Pin_10; break;
          case 9: port=GPIOF; pin=GPIO_Pin_3; break;
          case 10: port=GPIOC; pin=GPIO_Pin_0; break;
          case 11: port=GPIOC; pin=GPIO_Pin_1; break;
          case 12: port=GPIOC; pin=GPIO_Pin_2; break;
          case 13: port=GPIOC; pin=GPIO_Pin_3; break;
          case 14: port=GPIOF; pin=GPIO_Pin_4; break;
          case 15: port=GPIOF; pin=GPIO_Pin_5; break;
        }
      }

      // initialise the pin

      GpioPinInitialiser::initialise(port,pin);   // this minimal overload is for analog input
    }
  };
}
// END FILE: ../lib/include/adc/features/f4/AdcChannelGpioInitialiser.h
// START FILE: ../lib/include/adc/features/f4/AdcTriggerFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Template base class for the trigger definition classes
   */

  template<uint32_t TEvent,uint32_t TEdge>
  struct AdcTriggerFeature : AdcFeatureBase {

    AdcTriggerFeature(Adc& adc)
      : AdcFeatureBase(adc) {

      // set up the two trigger values

      ((ADC_InitTypeDef *)adc)->ADC_ExternalTrigConv=TEvent;
      ((ADC_InitTypeDef *)adc)->ADC_ExternalTrigConvEdge=TEdge;
    }

    void initialise() {
    }
  };


  /*
   * Typedef for the trigger on EXTI 11
   */

  typedef AdcTriggerFeature<ADC_ExternalTrigConv_Ext_IT11,ADC_ExternalTrigConvEdge_Rising> AdcExti11RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_Ext_IT11,ADC_ExternalTrigConvEdge_Falling> AdcExti11FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_Ext_IT11,ADC_ExternalTrigConvEdge_RisingFalling> AdcExti11RisingFallingTriggerFeature;

  /*
   * Typedefs for the channel trigger features
   */


  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T1_CC1,ADC_ExternalTrigConvEdge_Rising> AdcTimer1Channel1RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T1_CC1,ADC_ExternalTrigConvEdge_Falling> AdcTimer1Channel1FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T1_CC1,ADC_ExternalTrigConvEdge_RisingFalling> AdcTimer1Channel1RisingFallingTriggerFeature;

  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T1_CC2,ADC_ExternalTrigConvEdge_Rising> AdcTimer1Channel2RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T1_CC2,ADC_ExternalTrigConvEdge_Falling> AdcTimer1Channel2FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T1_CC2,ADC_ExternalTrigConvEdge_RisingFalling> AdcTimer1Channel2RisingFallingTriggerFeature;

  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T1_CC3,ADC_ExternalTrigConvEdge_Rising> AdcTimer1Channel3RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T1_CC3,ADC_ExternalTrigConvEdge_Falling> AdcTimer1Channel3FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T1_CC3,ADC_ExternalTrigConvEdge_RisingFalling> AdcTimer1Channel3RisingFallingTriggerFeature;

  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T2_CC2,ADC_ExternalTrigConvEdge_Rising> AdcTimer2Channel2RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T2_CC2,ADC_ExternalTrigConvEdge_Falling> AdcTimer2Channel2FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T2_CC2,ADC_ExternalTrigConvEdge_RisingFalling> AdcTimer2Channel2RisingFallingTriggerFeature;

  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T2_CC3,ADC_ExternalTrigConvEdge_Rising> AdcTimer2Channel3RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T2_CC3,ADC_ExternalTrigConvEdge_Falling> AdcTimer2Channel3FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T2_CC3,ADC_ExternalTrigConvEdge_RisingFalling> AdcTimer2Channel3RisingFallingTriggerFeature;

  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T3_CC1,ADC_ExternalTrigConvEdge_Rising> AdcTimer3Channel1RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T3_CC1,ADC_ExternalTrigConvEdge_Falling> AdcTimer3Channel1FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T3_CC1,ADC_ExternalTrigConvEdge_RisingFalling> AdcTimer3Channel1RisingFallingTriggerFeature;

  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T4_CC4,ADC_ExternalTrigConvEdge_Rising> AdcTimer4Channel4RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T4_CC4,ADC_ExternalTrigConvEdge_Falling> AdcTimer4Channel4FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T4_CC4,ADC_ExternalTrigConvEdge_RisingFalling> AdcTimer4Channel4RisingFallingTriggerFeature;

  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T5_CC1,ADC_ExternalTrigConvEdge_Rising> AdcTimer5Channel1RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T5_CC1,ADC_ExternalTrigConvEdge_Falling> AdcTimer5Channel1FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T5_CC1,ADC_ExternalTrigConvEdge_RisingFalling> AdcTimer5Channel1RisingFallingTriggerFeature;

  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T5_CC2,ADC_ExternalTrigConvEdge_Rising> AdcTimer5Channel2RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T5_CC2,ADC_ExternalTrigConvEdge_Falling> AdcTimer5Channel2FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T5_CC2,ADC_ExternalTrigConvEdge_RisingFalling> AdcTimer5Channel2RisingFallingTriggerFeature;

  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T8_CC1,ADC_ExternalTrigConvEdge_Rising> AdcTimer8Channel1RisingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T8_CC1,ADC_ExternalTrigConvEdge_Falling> AdcTimer8Channel1FallingTriggerFeature;
  typedef AdcTriggerFeature<ADC_ExternalTrigConv_T8_CC1,ADC_ExternalTrigConvEdge_RisingFalling> AdcTimer8Channel1RisingFallingTriggerFeature;


  /**
   * Timer trigger outputs need you to define the trigger source. Here's
   * the template we'll use to do that.
   */

  /**
   * Possible trigger sources
   */

  enum class AdcTriggerSource {
    Reset,              //!< Reset
    Enable,             //!< Enable
    Update,             //!< Update
    CaptureCompare1,    //!< CaptureCompare1
    OutputReference1,   //!< OutputReference1
    OutputReference2,   //!< OutputReference2
    OutputReference3,   //!< OutputReference3
    OutputReference4,   //!< OutputReference4
  };

  template<PeripheralName TTimerPeripheral,AdcTriggerSource TSource,uint32_t TEvent,uint32_t TEdge>
  struct AdcTimerTriggerFeature : AdcTriggerFeature<TEvent,TEdge>  {

    /**
     * Constructor
     * @param adc The adc class reference
     */

    AdcTimerTriggerFeature(Adc& adc)
      : AdcTriggerFeature<TEvent,TEdge>(adc) {

      static_assert(TSource>=AdcTriggerSource::Reset && TSource<=AdcTriggerSource::OutputReference4,"Invalid trigger source");

      TIM_SelectOutputTrigger(
          reinterpret_cast<TIM_TypeDef *>(PeripheralTraits<TTimerPeripheral>::PERIPHERAL_BASE),
          TSource==AdcTriggerSource::Reset ? TIM_TRGOSource_Reset :
          TSource==AdcTriggerSource::Enable ? TIM_TRGOSource_Enable :
          TSource==AdcTriggerSource::Update ? TIM_TRGOSource_Update :
          TSource==AdcTriggerSource::CaptureCompare1 ? TIM_TRGOSource_OC1 :
          TSource==AdcTriggerSource::OutputReference1 ? TIM_TRGOSource_OC1Ref :
          TSource==AdcTriggerSource::OutputReference2 ? TIM_TRGOSource_OC2Ref :
          TSource==AdcTriggerSource::OutputReference3 ? TIM_TRGOSource_OC3Ref :
          TIM_TRGOSource_OC4Ref
      );
    }
  };


  /**
   * Template typedefs for the trigger features - timer 2
   */

  template<AdcTriggerSource TSource>
  using AdcTimer2TriggerRisingFeature=AdcTimerTriggerFeature<PERIPHERAL_TIMER2,TSource,ADC_ExternalTrigConv_T2_TRGO,ADC_ExternalTrigConvEdge_Rising>;

  template<AdcTriggerSource TSource>
  using AdcTimer2TriggerFallingFeature=AdcTimerTriggerFeature<PERIPHERAL_TIMER2,TSource,ADC_ExternalTrigConv_T2_TRGO,ADC_ExternalTrigConvEdge_Falling>;

  template<AdcTriggerSource TSource>
  using AdcTimer2TriggerRisingFallingFeature=AdcTimerTriggerFeature<PERIPHERAL_TIMER2,TSource,ADC_ExternalTrigConv_T2_TRGO,ADC_ExternalTrigConvEdge_RisingFalling>;

  /*
   * Timer 3
   */

  template<AdcTriggerSource TSource>
  using AdcTimer3TriggerRisingFeature=AdcTimerTriggerFeature<PERIPHERAL_TIMER3,TSource,ADC_ExternalTrigConv_T3_TRGO,ADC_ExternalTrigConvEdge_Rising>;

  template<AdcTriggerSource TSource>
  using AdcTimer3TriggerFallingFeature=AdcTimerTriggerFeature<PERIPHERAL_TIMER3,TSource,ADC_ExternalTrigConv_T3_TRGO,ADC_ExternalTrigConvEdge_Falling>;

  template<AdcTriggerSource TSource>
  using AdcTimer3TriggerRisingFallingFeature=AdcTimerTriggerFeature<PERIPHERAL_TIMER3,TSource,ADC_ExternalTrigConv_T3_TRGO,ADC_ExternalTrigConvEdge_RisingFalling>;

  /*
   * Timer 8
   */

  template<AdcTriggerSource TSource>
  using AdcTimer8TriggerRisingFeature=AdcTimerTriggerFeature<PERIPHERAL_TIMER8,TSource,ADC_ExternalTrigConv_T8_TRGO,ADC_ExternalTrigConvEdge_Rising>;

  template<AdcTriggerSource TSource>
  using AdcTimer8TriggerFallingFeature=AdcTimerTriggerFeature<PERIPHERAL_TIMER8,TSource,ADC_ExternalTrigConv_T8_TRGO,ADC_ExternalTrigConvEdge_Falling>;

  template<AdcTriggerSource TSource>
  using AdcTimer8TriggerRisingFallingFeature=AdcTimerTriggerFeature<PERIPHERAL_TIMER8,TSource,ADC_ExternalTrigConv_T8_TRGO,ADC_ExternalTrigConvEdge_RisingFalling>;
}
// END FILE: ../lib/include/adc/features/f4/AdcTriggerFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


/*
 * Forward declare the IRQ handler name. There is a single IRQ handler
 * for ADC 1,2,3 on the F4
 */

extern "C" void ADC_IRQHandler();


namespace stm32plus {


  /**
   * Feature class to allow allow handling of ADC interrupts. Declare this feature
   * with your AdcN<> declaration, register an event handler with the AdvEventSource
   * base class and then use enableInterrupts() to start.
   */

  class AdcInterruptFeature : public AdcEventSource,
                              public AdcFeatureBase {

    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

    protected:
      uint16_t _interruptMask;

    public:
      enum {
        END_OF_CONVERSION           = 0x01,
        INJECTED_END_OF_CONVERSION  = 0x02,
        ADC_OVERFLOW                = 0x04,
        ANALOG_WATCHDOG             = 0x08
      };

      static AdcEventSource *_adcInstance;

    public:
      AdcInterruptFeature(Adc& adc);
      ~AdcInterruptFeature();

      void initialise() {}

      void enableInterrupts(uint16_t interruptMask);
      void disableInterrupts(uint16_t interruptMask);
  };


  /**
   * Typedefs for each ADC. Even though they are all the same on the F4 this is
   * for compatibility with the F1 where there are multiple.
   */

  typedef AdcInterruptFeature Adc1InterruptFeature;
  typedef AdcInterruptFeature Adc2InterruptFeature;
  typedef AdcInterruptFeature Adc3InterruptFeature;


  /**
   * Constructor, initialises the interrupt mask for this class to zero.
   */

  inline AdcInterruptFeature::AdcInterruptFeature(Adc& adc)
    : AdcFeatureBase(adc) {

    _interruptMask=0;
    _adcInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  inline AdcInterruptFeature::~AdcInterruptFeature() {
    if(_interruptMask!=0)
      disableInterrupts(_interruptMask);
  }


  /**
   * Enable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. END_OF_CONVERSION | ADC_OVERFLOW
   */

  inline void AdcInterruptFeature::enableInterrupts(uint16_t interruptMask) {

    _interruptMask|=interruptMask;
    _forceLinkage=&ADC_IRQHandler;

    Nvic::configureIrq(ADC_IRQn);

    if((interruptMask & END_OF_CONVERSION)!=0)
      ADC_ITConfig(_adc,ADC_IT_EOC,ENABLE);
    if((interruptMask & INJECTED_END_OF_CONVERSION)!=0)
      ADC_ITConfig(_adc,ADC_IT_JEOC,ENABLE);
    if((interruptMask & ANALOG_WATCHDOG)!=0)
      ADC_ITConfig(_adc,ADC_IT_AWD,ENABLE);
    if((interruptMask & ADC_OVERFLOW)!=0)
      ADC_ITConfig(_adc,ADC_IT_OVR,ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. END_OF_CONVERSION | ADC_OVERFLOW
   */

  inline void AdcInterruptFeature::disableInterrupts(uint16_t interruptMask) {
    _interruptMask&=~interruptMask;

    if((interruptMask & END_OF_CONVERSION)!=0)
      ADC_ITConfig(_adc,ADC_IT_EOC,DISABLE);
    if((interruptMask & INJECTED_END_OF_CONVERSION)!=0)
      ADC_ITConfig(_adc,ADC_IT_JEOC,DISABLE);
    if((interruptMask & ANALOG_WATCHDOG)!=0)
      ADC_ITConfig(_adc,ADC_IT_AWD,DISABLE);
    if((interruptMask & ADC_OVERFLOW)!=0)
      ADC_ITConfig(_adc,ADC_IT_OVR,DISABLE);
  }
}
// END FILE: ../lib/include/adc/features/f4/AdcInterruptFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcInjectedTriggerFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Template base class for the trigger definition classes
   */

  template<uint32_t TEvent,uint32_t TEdge>
  struct AdcInjectedTriggerFeature : AdcFeatureBase {

    AdcInjectedTriggerFeature(Adc& adc)
      : AdcFeatureBase(adc) {

      // set up the two trigger values

      ADC_ExternalTrigInjectedConvConfig(adc,TEvent);
      ADC_ExternalTrigInjectedConvEdgeConfig(adc,TEdge);
    }

    void initialise() {
    }
  };


  /*
   * Typedef for the trigger on EXTI 15
   */

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_Ext_IT15,ADC_ExternalTrigInjecConvEdge_Rising> AdcExti15RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_Ext_IT15,ADC_ExternalTrigInjecConvEdge_Rising> AdcExti15FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_Ext_IT15,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcExti15RisingFallingTriggerFeature;

  /*
   * Typedefs for the channel trigger features
   */


  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T1_CC4,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer1Channel4RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T1_CC4,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer1Channel4FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T1_CC4,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer1Channel4RisingFallingTriggerFeature;

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T2_CC1,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer2Channel1RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T2_CC1,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer2Channel1FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T2_CC1,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer2Channel1RisingFallingTriggerFeature;

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T3_CC2,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer3Channel2RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T3_CC2,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer3Channel2FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T3_CC2,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer3Channel2RisingFallingTriggerFeature;

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T3_CC4,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer3Channel4RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T3_CC4,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer3Channel4FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T3_CC4,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer3Channel4RisingFallingTriggerFeature;

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T4_CC1,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer4Channel1RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T4_CC1,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer4Channel1FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T4_CC1,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer4Channel1RisingFallingTriggerFeature;

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T4_CC2,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer4Channel2RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T4_CC2,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer4Channel2FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T4_CC2,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer4Channel2RisingFallingTriggerFeature;

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T4_CC3,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer4Channel3RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T4_CC3,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer4Channel3FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T4_CC3,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer4Channel3RisingFallingTriggerFeature;

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T5_CC4,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer5Channel4RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T5_CC4,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer5Channel4FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T5_CC4,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer5Channel4RisingFallingTriggerFeature;

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T8_CC2,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer8Channel2RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T8_CC2,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer8Channel2FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T8_CC2,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer8Channel2RisingFallingTriggerFeature;

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T8_CC3,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer8Channel3RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T8_CC3,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer8Channel3FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T8_CC3,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer8Channel3RisingFallingTriggerFeature;

  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T8_CC4,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer8Channel4RisingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T8_CC4,ADC_ExternalTrigInjecConvEdge_Rising> AdcTimer8Channel4FallingTriggerFeature;
  typedef AdcInjectedTriggerFeature<ADC_ExternalTrigInjecConv_T8_CC4,ADC_ExternalTrigInjecConvEdge_RisingFalling> AdcTimer8Channel4RisingFallingTriggerFeature;


  /**
   * Timer trigger outputs need you to define the trigger source. Here's
   * the template we'll use to do that.
   */

  template<PeripheralName TTimerPeripheral,AdcTriggerSource TSource,uint32_t TEvent,uint32_t TEdge>
  struct AdcTimerInjectedTriggerFeature : AdcInjectedTriggerFeature<TEvent,TEdge>  {

    /**
     * Constructor
     * @param adc The adc class reference
     */

    AdcTimerInjectedTriggerFeature(Adc& adc)
      : AdcInjectedTriggerFeature<TEvent,TEdge>(adc) {

      static_assert(TSource>=AdcTriggerSource::Reset && TSource<=AdcTriggerSource::OutputReference4,"Invalid injected trigger source");

      TIM_SelectOutputTrigger(
          reinterpret_cast<TIM_TypeDef *>(PeripheralTraits<TTimerPeripheral>::PERIPHERAL_BASE),
          TSource==AdcTriggerSource::Reset ? TIM_TRGOSource_Reset :
          TSource==AdcTriggerSource::Enable ? TIM_TRGOSource_Enable :
          TSource==AdcTriggerSource::Update ? TIM_TRGOSource_Update :
          TSource==AdcTriggerSource::CaptureCompare1 ? TIM_TRGOSource_OC1 :
          TSource==AdcTriggerSource::OutputReference1 ? TIM_TRGOSource_OC1Ref :
          TSource==AdcTriggerSource::OutputReference2 ? TIM_TRGOSource_OC2Ref :
          TSource==AdcTriggerSource::OutputReference3 ? TIM_TRGOSource_OC3Ref :
          TIM_TRGOSource_OC4Ref
      );
    }
  };


  /**
   * Template typedefs for the trigger features - timer 1
   */

  template<AdcTriggerSource TSource>
  using AdcTimer1InjectedTriggerRisingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T1_TRGO,ADC_ExternalTrigInjecConvEdge_Rising>;

  template<AdcTriggerSource TSource>
  using AdcTimer1InjectedTriggerFallingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T1_TRGO,ADC_ExternalTrigInjecConvEdge_Falling>;

  template<AdcTriggerSource TSource>
  using AdcTimer1InjectedTriggerRisingFallingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T1_TRGO,ADC_ExternalTrigInjecConvEdge_RisingFalling>;

  /**
   * Template typedefs for the trigger features - timer 2
   */

  template<AdcTriggerSource TSource>
  using AdcTimer2InjectedTriggerRisingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T2_TRGO,ADC_ExternalTrigInjecConvEdge_Rising>;

  template<AdcTriggerSource TSource>
  using AdcTimer2InjectedTriggerFallingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T2_TRGO,ADC_ExternalTrigInjecConvEdge_Falling>;

  template<AdcTriggerSource TSource>
  using AdcTimer2InjectedTriggerRisingFallingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T2_TRGO,ADC_ExternalTrigInjecConvEdge_RisingFalling>;

  /**
   * Template typedefs for the trigger features - timer 4
   */

  template<AdcTriggerSource TSource>
  using AdcTimer4InjectedTriggerRisingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T4_TRGO,ADC_ExternalTrigInjecConvEdge_Rising>;

  template<AdcTriggerSource TSource>
  using AdcTimer4InjectedTriggerFallingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T4_TRGO,ADC_ExternalTrigInjecConvEdge_Falling>;

  template<AdcTriggerSource TSource>
  using AdcTimer4InjectedTriggerRisingFallingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T4_TRGO,ADC_ExternalTrigInjecConvEdge_RisingFalling>;

  /**
   * Template typedefs for the trigger features - timer 5
   */

  template<AdcTriggerSource TSource>
  using AdcTimer5InjectedTriggerRisingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T5_TRGO,ADC_ExternalTrigInjecConvEdge_Rising>;

  template<AdcTriggerSource TSource>
  using AdcTimer5InjectedTriggerFallingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T5_TRGO,ADC_ExternalTrigInjecConvEdge_Falling>;

  template<AdcTriggerSource TSource>
  using AdcTimer5InjectedTriggerRisingFallingFeature=AdcTimerInjectedTriggerFeature<PERIPHERAL_TIMER1,TSource,ADC_ExternalTrigInjecConv_T5_TRGO,ADC_ExternalTrigInjecConvEdge_RisingFalling>;
}
// END FILE: ../lib/include/adc/features/f4/AdcInjectedTriggerFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcInjectedChannelFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Handle the ADC injected channels (0..3 on the F4). ST's ADC_Channel_XX constants are simple
   * numbers 0..18 so we can use this feature easily, for example...
   *
   * Adc1Cycle3InjectedChannelFeature<1,2,6,7>
   *
   * ...will initialise channels 1,2,6 and 7 with 3 cycle sample time on ADC1.
   * @tparam TAdcNumber The ADC number (1..3)
   * @tparam The peripheral library constant for the number of conversion cycles, e.g. ADC_SampleTime_3Cycles
   * @tparam TChannelNumbers List of channel numbers, 0..15.
   */

  template<uint8_t TAdcNumber,uint8_t TSampleCycles,uint8_t... TChannelNumbers>
  class AdcInjectedChannelFeature : public AdcInjectedChannelFeatureBase {

    protected:

      template<uint8_t TChannelNumber>
      void init();

      template<uint8_t TFirst,uint8_t TNext,uint8_t... TRest>
      void init();

    public:
      AdcInjectedChannelFeature(Adc& adc);
      void initialise();
  };


  /*
   * Typedefs for the difference cycles on each ADC
   */

  template<uint8_t... TChannelNumbers> using Adc1Cycle3InjectedChannelFeature = AdcInjectedChannelFeature<1,ADC_SampleTime_3Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle15InjectedChannelFeature = AdcInjectedChannelFeature<1,ADC_SampleTime_15Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle28InjectedChannelFeature = AdcInjectedChannelFeature<1,ADC_SampleTime_28Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle56InjectedChannelFeature = AdcInjectedChannelFeature<1,ADC_SampleTime_56Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle84InjectedChannelFeature = AdcInjectedChannelFeature<1,ADC_SampleTime_84Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle112InjectedChannelFeature = AdcInjectedChannelFeature<1,ADC_SampleTime_112Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle144InjectedChannelFeature = AdcInjectedChannelFeature<1,ADC_SampleTime_144Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc1Cycle480InjectedChannelFeature = AdcInjectedChannelFeature<1,ADC_SampleTime_480Cycles,TChannelNumbers...>;

  template<uint8_t... TChannelNumbers> using Adc2Cycle3InjectedChannelFeature = AdcInjectedChannelFeature<2,ADC_SampleTime_3Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle15InjectedChannelFeature = AdcInjectedChannelFeature<2,ADC_SampleTime_15Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle28InjectedChannelFeature = AdcInjectedChannelFeature<2,ADC_SampleTime_28Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle56InjectedChannelFeature = AdcInjectedChannelFeature<2,ADC_SampleTime_56Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle84InjectedChannelFeature = AdcInjectedChannelFeature<2,ADC_SampleTime_84Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle112InjectedChannelFeature = AdcInjectedChannelFeature<2,ADC_SampleTime_112Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle144InjectedChannelFeature = AdcInjectedChannelFeature<2,ADC_SampleTime_144Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc2Cycle480InjectedChannelFeature = AdcInjectedChannelFeature<2,ADC_SampleTime_480Cycles,TChannelNumbers...>;

  template<uint8_t... TChannelNumbers> using Adc3Cycle3InjectedChannelFeature = AdcInjectedChannelFeature<3,ADC_SampleTime_3Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle15InjectedChannelFeature = AdcInjectedChannelFeature<3,ADC_SampleTime_15Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle28InjectedChannelFeature = AdcInjectedChannelFeature<3,ADC_SampleTime_28Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle56InjectedChannelFeature = AdcInjectedChannelFeature<3,ADC_SampleTime_56Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle84InjectedChannelFeature = AdcInjectedChannelFeature<3,ADC_SampleTime_84Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle112InjectedChannelFeature = AdcInjectedChannelFeature<3,ADC_SampleTime_112Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle144InjectedChannelFeature = AdcInjectedChannelFeature<3,ADC_SampleTime_144Cycles,TChannelNumbers...>;
  template<uint8_t... TChannelNumbers> using Adc3Cycle480InjectedChannelFeature = AdcInjectedChannelFeature<3,ADC_SampleTime_480Cycles,TChannelNumbers...>;


  /**
   * Constructor
   * @param adc Adc class reference
   */

  template<uint8_t TAdcNumber,uint8_t TSampleCycles,uint8_t... TChannelNumbers>
  inline AdcInjectedChannelFeature<TAdcNumber,TSampleCycles,TChannelNumbers...>::AdcInjectedChannelFeature(Adc& adc)
    : AdcInjectedChannelFeatureBase(adc) {

    static_assert(TAdcNumber>=1 && TAdcNumber<=3,"Invalid ADC number, expecting 1/2/3");

    // increase the number of channels being converted

    adc.incrementInjectedChannelCount(sizeof...(TChannelNumbers));
  }


  /**
   * Initialise after ADC_Init
   */

  template<uint8_t TAdcNumber,uint8_t TSampleCycles,uint8_t... TChannelNumbers>
  inline void AdcInjectedChannelFeature<TAdcNumber,TSampleCycles,TChannelNumbers...>::initialise() {

    // expand and initialise

    init<TChannelNumbers...>();
  }


  /**
   * Base case initialiser for when parameter pack expansion gets to the last one
   */

  template<uint8_t TAdcNumber,uint8_t TSampleCycles,uint8_t... TChannelNumbers>
  template<uint8_t TChannelNumber>
  inline void AdcInjectedChannelFeature<TAdcNumber,TSampleCycles,TChannelNumbers...>::init() {

    AdcChannelGpioInitialiser<TAdcNumber,TChannelNumber>::initialiseGpioPin();
    ADC_InjectedChannelConfig(_adc,TChannelNumber,_adc.getAndIncrementInjectedChannelRank(TAdcNumber),TSampleCycles);
  }


  /**
   * Recursive initialise for the template parameter pack.
   */

  template<uint8_t TAdcNumber,uint8_t TSampleCycles,uint8_t... TChannelNumbers>
  template<uint8_t TFirst,uint8_t TNext,uint8_t... TRest>
  inline void AdcInjectedChannelFeature<TAdcNumber,TSampleCycles,TChannelNumbers...>::init() {

    AdcChannelGpioInitialiser<TAdcNumber,TFirst>::initialiseGpioPin();
    ADC_InjectedChannelConfig(_adc,TFirst,_adc.getAndIncrementInjectedChannelRank(TAdcNumber),TSampleCycles);
    init<TNext,TRest...>();
  }
}
// END FILE: ../lib/include/adc/features/f4/AdcInjectedChannelFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcDualFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * The dual ADC feature declares an instance of the second ADC and holds
   * it locally
   */

  template<class TAdc2,uint32_t TDmaModeType,uint32_t TAdcMultiModeType,uint8_t TTwoSamplingDelay>
  class AdcDualFeature : public AdcMultiFeature<TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay> {

    protected:
      scoped_ptr<TAdc2> _adc2;

    public:
      AdcDualFeature(Adc& adc);

      void initialise();

      TAdc2& getAdc2() const;
      uint32_t getDualConversionValue() const;
  };


  /**
   * Constructor
   * @param adc The adc instance
   */

  template<class TAdc2,uint32_t TDmaModeType,uint32_t TAdcMultiModeType,uint8_t TTwoSamplingDelay>
  inline AdcDualFeature<TAdc2,TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay>::AdcDualFeature(Adc& adc)
    : AdcMultiFeature<TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay>(adc) {
  }


  /**
   * Get the results of a dual-conversion
   * @return The results of the conversion
   */

  template<class TAdc2,uint32_t TDmaModeType,uint32_t TAdcMultiModeType,uint8_t TTwoSamplingDelay>
  inline uint32_t AdcDualFeature<TAdc2,TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay>::getDualConversionValue() const {
    return ADC_GetMultiModeConversionValue();
  }


  /**
   * Get a reference to the second ADC
   * @return the second ADC reference
   */

  template<class TAdc2,uint32_t TDmaModeType,uint32_t TAdcMultiModeType,uint8_t TTwoSamplingDelay>
  inline TAdc2& AdcDualFeature<TAdc2,TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay>::getAdc2() const {
    return *_adc2.get();
  }


  /**
   * Post ADC_Init() initialisation
   */

  template<class TAdc2,uint32_t TDmaModeType,uint32_t TAdcMultiModeType,uint8_t TTwoSamplingDelay>
  inline void AdcDualFeature<TAdc2,TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay>::initialise() {
    _adc2.reset(new TAdc2(&this->_adc));
  }


  /*
   * 2 ADC, Independent mode
   */

  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualIndependentNoDmaFeature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_Disabled,ADC_Mode_Independent,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualIndependentDmaMode1Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_1,ADC_Mode_Independent,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualIndependentDmaMode2Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_2,ADC_Mode_Independent,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualIndependentDmaMode3Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_3,ADC_Mode_Independent,TTwoSamplingDelay>;

  /*
   * 2 ADC, Injected simultaneous mode
   */

  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualInjectedSimultaneousNoDmaFeature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_Disabled,ADC_DualMode_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualInjectedSimultaneousDmaMode1Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_1,ADC_DualMode_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualInjectedSimultaneousDmaMode2Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_2,ADC_DualMode_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualInjectedSimultaneousDmaMode3Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_3,ADC_DualMode_InjecSimult,TTwoSamplingDelay>;

  /*
   * 2 ADC, Regular simultaneous mode
   */

  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularSimultaneousNoDmaFeature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_Disabled,ADC_DualMode_RegSimult,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularSimultaneousDmaMode1Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_1,ADC_DualMode_RegSimult,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularSimultaneousDmaMode2Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_2,ADC_DualMode_RegSimult,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularSimultaneousDmaMode3Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_3,ADC_DualMode_RegSimult,TTwoSamplingDelay>;

  /*
   * 2 ADC, Interleaved mode
   */

  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualInterleavedNoDmaFeature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_Disabled,ADC_DualMode_Interl,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualInterleavedDmaMode1Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_1,ADC_DualMode_Interl,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualInterleavedDmaMode2Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_2,ADC_DualMode_Interl,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualInterleavedDmaMode3Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_3,ADC_DualMode_Interl,TTwoSamplingDelay>;

  /*
   * 2 ADC, Alternate trigger mode
   */

  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualAlternateTriggerNoDmaFeature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_Disabled,ADC_DualMode_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualAlternateTriggerDmaMode1Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_1,ADC_DualMode_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualAlternateTriggerDmaMode2Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_2,ADC_DualMode_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualAlternateTriggerDmaMode3Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_3,ADC_DualMode_AlterTrig,TTwoSamplingDelay>;

  /*
   * 2 ADC, Combined regular/injected simultaneous mode
   */

  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularInjectedSimultaneousNoDmaFeature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_Disabled,ADC_DualMode_RegSimult_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularInjectedSimultaneousDmaMode1Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_1,ADC_DualMode_RegSimult_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularInjectedSimultaneousDmaMode2Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_2,ADC_DualMode_RegSimult_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularInjectedSimultaneousDmaMode3Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_3,ADC_DualMode_RegSimult_InjecSimult,TTwoSamplingDelay>;

  /*
   * 2 ADC, Combined regular simultaneous alternate trigger mode
   */

  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularSimultaneousAlternateTriggerNoDmaFeature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_Disabled,ADC_DualMode_RegSimult_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularSimultaneousAlternateTriggerDmaMode1Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_1,ADC_DualMode_RegSimult_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularSimultaneousAlternateTriggerDmaMode2Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_2,ADC_DualMode_RegSimult_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,uint8_t TTwoSamplingDelay> using AdcDualRegularSimultaneousAlternateTriggerDmaMode3Feature=AdcDualFeature<TAdc2,ADC_DMAAccessMode_3,ADC_DualMode_RegSimult_AlterTrig,TTwoSamplingDelay>;
}
// END FILE: ../lib/include/adc/features/f4/AdcDualFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcBatteryVoltageFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Support for the VBAT ADC channel is a simple extension of the regular channel
   * configuration
   */

  template<uint8_t TSampleCycles>
  struct AdcBatteryVoltageFeature : AdcRegularChannelFeature<1,TSampleCycles,18> {

    /**
     * Constructor, initialise upwards then enable the VBAT feature
     */

    AdcBatteryVoltageFeature(Adc& adc)
      : AdcRegularChannelFeature<1,TSampleCycles,18>(adc) {
    }


    /**
     * Post ADC_Init() initialisation
     */

    void initialise() {
      AdcRegularChannelFeature<1,TSampleCycles,18>::initialise();
      ADC_VBATCmd(ENABLE);
    }
  };


  /*
   * Typedefs for the difference cycles on each ADC
   */

  typedef AdcBatteryVoltageFeature<ADC_SampleTime_3Cycles> Adc1Cycle3BatteryVoltageFeature;
  typedef AdcBatteryVoltageFeature<ADC_SampleTime_15Cycles> Adc1Cycle15BatteryVoltageFeature;
  typedef AdcBatteryVoltageFeature<ADC_SampleTime_28Cycles> Adc1Cycle28BatteryVoltageFeature;
  typedef AdcBatteryVoltageFeature<ADC_SampleTime_56Cycles> Adc1Cycle56BatteryVoltageFeature;
  typedef AdcBatteryVoltageFeature<ADC_SampleTime_84Cycles> Adc1Cycle84BatteryVoltageFeature;
  typedef AdcBatteryVoltageFeature<ADC_SampleTime_112Cycles> Adc1Cycle112BatteryVoltageFeature;
  typedef AdcBatteryVoltageFeature<ADC_SampleTime_144Cycles> Adc1Cycle144BatteryVoltageFeature;
  typedef AdcBatteryVoltageFeature<ADC_SampleTime_480Cycles> Adc1Cycle480BatteryVoltageFeature;
}
// END FILE: ../lib/include/adc/features/f4/AdcBatteryVoltageFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcTripleFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Extension of the dual ADC feature to provide a third ADC. Only available on devices where
   * there is a third ADC.
   */

  template<class TAdc2,class TAdc3,uint32_t TDmaModeType,uint32_t TAdcMultiModeType,uint8_t TTwoSamplingDelay>
  class AdcTripleFeature : public AdcDualFeature<TAdc2,TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay> {

    protected:
      scoped_ptr<TAdc3> _adc3;

    public:
      AdcTripleFeature(Adc& adc);

      TAdc3& getAdc3() const;
      void initialise();
  };


  /**
   * Constructor
   * @param adc The adc instance
   */

  template<class TAdc2,class TAdc3,uint32_t TDmaModeType,uint32_t TAdcMultiModeType,uint8_t TTwoSamplingDelay>
  inline AdcTripleFeature<TAdc2,TAdc3,TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay>::AdcTripleFeature(Adc& adc)
    : AdcDualFeature<TAdc2,TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay>(adc) {
  }


  /**
   * Get a reference to the second ADC
   * @return the second ADC reference
   */

  template<class TAdc2,class TAdc3,uint32_t TDmaModeType,uint32_t TAdcMultiModeType,uint8_t TTwoSamplingDelay>
  inline TAdc3& AdcTripleFeature<TAdc2,TAdc3,TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay>::getAdc3() const {
    return *_adc3.get();
  }


  /**
   * Post ADC_Init() initialisation
   */

  template<class TAdc2,class TAdc3,uint32_t TDmaModeType,uint32_t TAdcMultiModeType,uint8_t TTwoSamplingDelay>
  inline void AdcTripleFeature<TAdc2,TAdc3,TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay>::initialise() {

    // call the base class to initialise ADC2 then initialise ADC3 here

    AdcDualFeature<TAdc2,TDmaModeType,TAdcMultiModeType,TTwoSamplingDelay>::initialise();
    _adc3.reset(new TAdc3(&this->_adc));
  }


  /*
   * 3 ADC, Independent mode
   */

  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleIndependentNoDmaFeature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_Disabled,ADC_Mode_Independent,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleIndependentDmaMode1Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_1,ADC_Mode_Independent,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleIndependentDmaMode2Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_2,ADC_Mode_Independent,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleIndependentDmaMode3Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_3,ADC_Mode_Independent,TTwoSamplingDelay>;

  /*
   * 3 ADC, Injected simultaneous mode
   */

  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleInjectedSimultaneousNoDmaFeature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_Disabled,ADC_TripleMode_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleInjectedSimultaneousDmaMode1Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_1,ADC_TripleMode_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleInjectedSimultaneousDmaMode2Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_2,ADC_TripleMode_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleInjectedSimultaneousDmaMode3Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_3,ADC_TripleMode_InjecSimult,TTwoSamplingDelay>;

  /*
   * 3 ADC, Regular simultaneous mode
   */

  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularSimultaneousNoDmaFeature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_Disabled,ADC_TripleMode_RegSimult,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularSimultaneousDmaMode1Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_1,ADC_TripleMode_RegSimult,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularSimultaneousDmaMode2Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_2,ADC_TripleMode_RegSimult,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularSimultaneousDmaMode3Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_3,ADC_TripleMode_RegSimult,TTwoSamplingDelay>;

  /*
   * 3 ADC, Interleaved mode
   */

  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleInterleavedNoDmaFeature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_Disabled,ADC_TripleMode_Interl,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleInterleavedDmaMode1Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_1,ADC_TripleMode_Interl,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleInterleavedDmaMode2Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_2,ADC_TripleMode_Interl,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleInterleavedDmaMode3Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_3,ADC_TripleMode_Interl,TTwoSamplingDelay>;

  /*
   * 3 ADC, Alternate trigger mode
   */

  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleAlternateTriggerNoDmaFeature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_Disabled,ADC_TripleMode_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleAlternateTriggerDmaMode1Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_1,ADC_TripleMode_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleAlternateTriggerDmaMode2Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_2,ADC_TripleMode_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleAlternateTriggerDmaMode3Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_3,ADC_TripleMode_AlterTrig,TTwoSamplingDelay>;

  /*
   * 3 ADC, Combined regular/injected simultaneous mode
   */

  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularInjectedSimultaneousNoDmaFeature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_Disabled,ADC_TripleMode_RegSimult_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularInjectedSimultaneousDmaMode1Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_1,ADC_TripleMode_RegSimult_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularInjectedSimultaneousDmaMode2Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_2,ADC_TripleMode_RegSimult_InjecSimult,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularInjectedSimultaneousDmaMode3Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_3,ADC_TripleMode_RegSimult_InjecSimult,TTwoSamplingDelay>;

  /*
   * 3 ADC, Combined regular simultaneous alternate trigger mode
   */

  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularSimultaneousAlternateTriggerNoDmaFeature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_Disabled,ADC_TripleMode_RegSimult_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularSimultaneousAlternateTriggerDmaMode1Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_1,ADC_TripleMode_RegSimult_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularSimultaneousAlternateTriggerDmaMode2Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_2,ADC_TripleMode_RegSimult_AlterTrig,TTwoSamplingDelay>;
  template<class TAdc2,class TAdc3,uint8_t TTwoSamplingDelay> using AdcTripleRegularSimultaneousAlternateTriggerDmaMode3Feature=AdcTripleFeature<TAdc2,TAdc3,ADC_DMAAccessMode_3,ADC_TripleMode_RegSimult_AlterTrig,TTwoSamplingDelay>;
}
// END FILE: ../lib/include/adc/features/f4/AdcTripleFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcAnalogWatchdogFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Support for configuring the analog watchdog feature. The AWD allows you to
   * trigger an interrupt if a voltage crosses pre-defined upper or lower bounds.
   *
   * This is a base class that supports the threshold setting ability common to
   * all MCUs
   */

  template<uint16_t TLow,uint16_t THigh>
  struct AdcAnalogWatchdogFeature : public AdcFeatureBase {


    /**
     * Constructor
     * @param adc reference to main ADC instance
     */

    AdcAnalogWatchdogFeature(Adc& adc)
      : AdcFeatureBase(adc) {

      static_assert(TLow<=THigh && THigh<=4095,"analog watchdog threshold out of range");
    }


    /**
     * Set the thresholds, post initialisation
     */

    void initialise() {
      setWatchdogThresholds(TLow,THigh);
    }


    /**
     * Set the thresholds for the watchdog. Allows adjustment post-construction if required.
     * @param low lower threshold
     * @param high higher threshold
     */

    void setWatchdogThresholds(uint16_t low,uint16_t high) {
      ADC_AnalogWatchdogThresholdsConfig(_adc,high,low);
    }


    /**
     * Disable the analog watchdog
     */

    void disableAnalogWatchdog() const {
      ADC_AnalogWatchdogCmd(_adc,ADC_AnalogWatchdog_None);
    }
  };
}
// END FILE: ../lib/include/adc/features/f4/AdcAnalogWatchdogFeature.h
// START FILE: ../lib/include/adc/features/f4/AdcResolutionFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Feature class to allow changing the resolution. You specify the resolution: 12/10/8/6 as a template parameter
   * and the code selects the correct constant at compile time.
   */

  template<uint8_t TResolution>
  struct AdcResolutionFeature : AdcFeatureBase {

    /**
     * Constructor, customise the resolution
     * @param adc The adc object holding the setup values
     */

    AdcResolutionFeature(Adc& adc)
      : AdcFeatureBase(adc) {

      // this is a switch on a constant - the optimiser will eliminate everything except
      // the selected assignment

      switch(TResolution) {

        case 12:
          ((ADC_InitTypeDef *)adc)->ADC_Resolution=ADC_Resolution_12b;
          break;

        case 10:
          ((ADC_InitTypeDef *)adc)->ADC_Resolution=ADC_Resolution_10b;
          break;

        case 8:
          ((ADC_InitTypeDef *)adc)->ADC_Resolution=ADC_Resolution_8b;
          break;

        case 6:
          ((ADC_InitTypeDef *)adc)->ADC_Resolution=ADC_Resolution_6b;
          break;
      }
    }


    /**
     * Post ADC_Init() initialisation
     */

    void initialise() {
    }
  };
}
// END FILE: ../lib/include/adc/features/f4/AdcResolutionFeature.h
// START FILE: ../lib/include/adc/features/AdcContinuousModeFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Trivial feature class to enable continuous-mode
   */

  struct AdcContinuousModeFeature : AdcFeatureBase {

    /**
     * Constructor
     * @param adc
     */

    AdcContinuousModeFeature(Adc& adc)
      : AdcFeatureBase(adc) {
      ((ADC_InitTypeDef *)adc)->ADC_ContinuousConvMode=ENABLE;
    }


    /**
     * Post ADC_Init() initialisation
     */

    void initialise() {
    }
  };
}
// END FILE: ../lib/include/adc/features/AdcContinuousModeFeature.h
// START FILE: ../lib/include/adc/features/AdcFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for ADC features
   */

  class AdcFeatureBase {
    protected:
      Adc& _adc;

    public:
      AdcFeatureBase(Adc& adc);
      operator Adc&();
  };


  /**
   * Constructor
   * @param adc
   */

  inline AdcFeatureBase::AdcFeatureBase(Adc& adc)
    : _adc(adc) {
  }


  /**
   * Cast to Adc reference
   */

  inline AdcFeatureBase::operator Adc&() {
    return _adc;
  }
}
// END FILE: ../lib/include/adc/features/AdcFeatureBase.h
// START FILE: ../lib/include/adc/features/AdcChannelType.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Encapsulation of the ADC channel types for the more advanced MCUs. Used
   * by the analog watchdog functionality.
   */

  enum class AdcChannelType {
    Regular,
    Injected,
    RegularAndInjected
  };
}
// END FILE: ../lib/include/adc/features/AdcChannelType.h
// START FILE: ../lib/include/adc/Adc1.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * ADC1 declaration
   *
   * @tparam Features A list of all the features you want to include with this ADC
   */

  template<class... Features>
  struct Adc1 : AdcPeripheral<PERIPHERAL_ADC1>,
                Features... {
    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Adc1(Adc *master=nullptr)
        : AdcPeripheral<PERIPHERAL_ADC1>(master),
          Features(static_cast<Adc&>(*this))... {

      // this is the most-derived class and construction is now complete
      // so we can initialise the peripheral

      initialisePeripheral();

      RecursiveVoidInit<Adc1,Features...>::tinit(this);

      // enable it

      enablePeripheral();
    }
  };
}
// END FILE: ../lib/include/adc/Adc1.h
// START FILE: ../lib/include/adc/AdcEventSource.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * ADC event types
   */

  enum class AdcEventType : uint8_t {
    EVENT_REGULAR_END_OF_CONVERSION,
    EVENT_INJECTED_END_OF_CONVERSION,
    EVENT_ANALOG_WATCHDOG,
    EVENT_OVERFLOW,
    EVENT_END_OF_SEQUENCE,
    EVENT_END_OF_SAMPLING,
    EVENT_ADC_READY
  };


  /**
   * The signature for ADC events: void myHandler(UsartEventType uet,uint8_t adcNumber);
   */

  DECLARE_EVENT_SIGNATURE(AdcInterrupt,void(AdcEventType,uint8_t adcNumber));


  /**
   * Base structure that holds just the event subscriber/publisher for the ADC
   */

  struct AdcEventSource {
    DECLARE_EVENT_SOURCE(AdcInterrupt);
  };
}
// END FILE: ../lib/include/adc/AdcEventSource.h
// START FILE: ../lib/include/adc/Adc2.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * ADC2 declaration
   *
   * @tparam Features A list of all the features you want to include with this ADC
   */

  template<class... Features>
  struct Adc2 : AdcPeripheral<PERIPHERAL_ADC2>,
                Features... {
    /**
     * Constructor
     * @param params Initialisation parameters
     */

    Adc2(Adc *master=nullptr)
        : AdcPeripheral<PERIPHERAL_ADC2>(master),
          Features(static_cast<Adc&>(*this))... {

      // this is the most-derived class and construction is now complete
      // so we can initialise the peripheral

      initialisePeripheral();

      RecursiveVoidInit<Adc2,Features...>::tinit(this);

      // enable it

      enablePeripheral();
    }
  };
}
// END FILE: ../lib/include/adc/Adc2.h
// START FILE: ../lib/include/config/can.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


// dependencies

#include "config/nvic.h"
#include "config/rcc.h"
#include "config/gpio.h"
#include "config/event.h"
#include "util/Meta.h"

// device-specific pin initialiser

#if defined(STM32PLUS_F1)
  #include "can/f1/CanPinInitialiser.h"
#elif defined(STM32PLUS_F4)
  #include "can/f4/CanAlternateFunctionMapper.h"
  #include "can/f4/CanPinInitialiser.h"
#endif

// generic peripheral includes

#include "can/CanEventSource.h"
#include "can/Can.h"
#include "can/CanPeripheral.h"
#include "can/CanFeatureBase.h"

// device-specific peripheral includes

#if defined(STM32PLUS_F1)
  #include "can/f1/Can1.h"
#elif defined(STM32PLUS_F4)
  #include "can/f4/Can1.h"
  #include "can/f4/Can2.h"
#endif

#define USE_CAN1_INTERRUPT
#define USE_CAN2_INTERRUPT

// generic features

#include "can/features/Can1FilterBypassFeature.h"
#include "can/features/Can2FilterBypassFeature.h"
#include "can/features/CanSilentModeFeature.h"
#include "can/features/CanLoopbackModeFeature.h"

// device-specific features

#if defined(STM32PLUS_F1)
  #include "can/features/f1/hd,md/Can1InterruptFeature.h"
#elif defined(STM32PLUS_F4)
  #include "can/features/f4/Can1InterruptFeature.h"
  #include "can/features/f4/Can2InterruptFeature.h"
#endif
// END FILE: ../lib/include/config/can.h
// START FILE: ../lib/include/config/custom/custom_traits.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/*
 default do-nothing customisation file intended as a placeholder when you do not
 create custom/custom_traits.h of your own

 custom/custom_traits.h should contain full specialisations of PeripheralTraits
 to match your app's requirements for each peripheral. e.g:

template<>
struct PeripheralTraits<PERIPHERAL_USART1> {
  enum { GPIO_SPEED = GPIO_Speed_10Mhz };
};

 The compilation option "-iquot ." ensures that your "custom/custom_traits.h" is
 picked up before this empty file provided as a fallback by the library.
*/
// END FILE: ../lib/include/config/custom/custom_traits.h
// START FILE: ../lib/include/config/stdperiph.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


// include the file that sets up all the MCU #defines

#include "config/mcu_defines.h"


/**
 * @file
 * This internal include file is included for you by the top-level stm32plus.h config file. Its purpose is to
 * include everything that's required from the ST Microelectronics Standard Peripheral Library.
 */

#if defined(STM32PLUS_F1)

#include "fwlib/f1/stdperiph/inc/misc.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_dac.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_gpio.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_spi.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_rcc.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_dma.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_sdio.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_tim.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_flash.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_fsmc.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_rtc.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_pwr.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_bkp.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_usart.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_exti.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_i2c.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_flash.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_crc.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_adc.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_can.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_flash.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_cec.h"
#include "fwlib/f1/stdperiph/inc/stm32f10x_wwdg.h"

#elif defined(STM32PLUS_F4)

#include "fwlib/f4/stdperiph/inc/misc.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_adc.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_can.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_crc.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_dac.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_gpio.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_spi.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_rcc.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_dma.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_hash.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_sdio.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_tim.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_flash.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_fsmc.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_rng.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_rtc.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_pwr.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_usart.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_exti.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_i2c.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_flash.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_wwdg.h"
#include "fwlib/f4/stdperiph/inc/stm32f4xx_syscfg.h"

#elif defined(STM32PLUS_F0_51)

#include "fwlib/f0/stdperiph/inc/stm32f0xx_misc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_adc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_crc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_dac.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_dma.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_exti.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_flash.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_gpio.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_i2c.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_rcc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_rtc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_spi.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_pwr.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_spi.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_syscfg.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_tim.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_wwdg.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_usart.h"

#elif defined(STM32PLUS_F0_30)

#include "fwlib/f0/stdperiph/inc/stm32f0xx_misc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_adc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_crc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_dma.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_exti.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_flash.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_gpio.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_i2c.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_rcc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_rtc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_spi.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_pwr.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_spi.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_syscfg.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_tim.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_wwdg.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_usart.h"

#elif defined(STM32PLUS_F0_42)

#include "fwlib/f0/stdperiph/inc/stm32f0xx_misc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_adc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_crc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_dma.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_exti.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_flash.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_gpio.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_i2c.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_rcc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_rtc.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_spi.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_pwr.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_spi.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_syscfg.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_tim.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_wwdg.h"
#include "fwlib/f0/stdperiph/inc/stm32f0xx_usart.h"

#else

#error STM32PLUS_Fn macro has not been defined: check config/stm32plus.h

#endif

// END FILE: ../lib/include/config/stdperiph.h
// START FILE: ../lib/include/config/iterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This is an internal config file that is included as a dependency by the other config files that need it, for
 * example the filesystem drivers.
 */

// includes for the feature

#include "iterator/Iterator.h"
#include "iterator/ResetableIterator.h"
// END FILE: ../lib/include/config/iterator.h
// START FILE: ../lib/include/config/stream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Include this file to get access to the general purpose stream I/O classes. There are implementations
 * of streams for byte arrays, circular buffers, LZG decompression and linear buffers. Some plumbing
 * classes implement connected and buffered streams.
 */

// stream depends on timing, memblock, double precision, STL string, MinMax

#include "config/timing.h"
#include "util/DoublePrecision.h"
#include "memory/Memblock.h"
#include "string"

// includes for the feature

#include "stream/StreamBase.h"
#include "stream/InputStream.h"
#include "stream/OutputStream.h"
#include "stream/Reader.h"
#include "stream/BufferedInputOutputStream.h"
#include "stream/ByteArrayOutputStream.h"
#include "stream/ByteArrayInputStream.h"
#include "stream/CircularBufferInputOutputStream.h"
#include "stream/LzgDecompressionInputStream.h"
#include "stream/ConnectedInputOutputStream.h"
#include "stream/LinearBufferInputOutputStream.h"
#include "stream/TextOutputStream.h"
#include "stream/StlStringInputStream.h"
#include "stream/ReadAheadInputStream.h"


// END FILE: ../lib/include/config/stream.h
// START FILE: ../lib/include/config/eeprom.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This file gets you access to the EEPROM functionality.
 */

// eeprom depends on i2c, input stream, output stream, minmax

#include "config/i2c.h"
#include "config/stream.h"

// general includes

#include "eeprom/SerialEeprom.h"

// device includes

#include "eeprom/AT24Cxx.h"
#include "eeprom/BR24G32.h"
// END FILE: ../lib/include/config/eeprom.h
// START FILE: ../lib/include/config/smartptr.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/**
 * @file
 * Include this file to get access to the smart pointers included
 * with the package.
 */


#include "memory/scoped_array.h"
#include "memory/scoped_ptr.h"
// END FILE: ../lib/include/config/smartptr.h
// START FILE: ../lib/include/config/rtc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Include this file to get access to the real time clock functionality. These peripherals are significantly different
 * on the F1 and F4. Support is also provided for the I2C-based DS1307 device.
 */

// rtc depends on rcc, nvic, event, exti, timer

#include "config/rcc.h"
#include "config/nvic.h"
#include "config/event.h"
#include "config/exti.h"
#include "config/timer.h"

// device-specifc includes

#if defined(STM32PLUS_F1)
  #include "rtc/f1/RtcBase.h"
#elif defined(STM32PLUS_F4)
  #include "rtc/f4/RtcBase.h"
#elif defined(STM32PLUS_F0)
  #include "rtc/f0/RtcBase.h"
#else
  #error Unsupported MCU
#endif

// generic feature includes

#include "rtc/Rtc.h"
#include "rtc/features/RtcFeatureBase.h"
#include "rtc/features/RtcConstantLsiFrequencyProvider.h"

// device specific feature includes

#if defined(STM32PLUS_F1)

  #define USE_RTC_INTERRUPT

  #include "rtc/features/f1/RtcAlarmInterruptFeature.h"
  #include "rtc/features/f1/RtcLseClockFeature.h"
  #include "rtc/features/f1/RtcOverflowInterruptFeature.h"
  #include "rtc/features/f1/RtcSecondInterruptFeature.h"
  #include "rtc/features/f1/RtcTamperOutputFeature.h"
  #include "rtc/features/f1/RtcLsiClockFeature.h"

#elif defined(STM32PLUS_F4)

  #include "rtc/features/f4/RtcAlarmInterruptFeature.h"
  #include "rtc/features/f4/RtcLseClockFeature.h"
  #include "rtc/features/f4/RtcLsiClockFeature.h"
  #include "rtc/features/f4/RtcSecondInterruptFeature.h"
  #include "rtc/features/f4/RtcMeasuredLsiFrequencyProvider.h"

#elif defined(STM32PLUS_F0)

  #include "rtc/features/f0/RtcAlarmInterruptFeature.h"
  #include "rtc/features/f0/RtcLseClockFeature.h"
  #include "rtc/features/f0/RtcLsiClockFeature.h"
  #include "rtc/features/f0/RtcHseDiv32ClockFeature.h"
  #include "rtc/features/f0/RtcMeasuredLsiFrequencyProvider.h"

#endif

// external device support

#include "rtc/DS1307/DS1307.h"
// END FILE: ../lib/include/config/rtc.h
// START FILE: ../lib/include/config/gpio.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Include this config file to use the raw GPIO port and pin functionality. Just about every peripheral with an
 * external interface includes this as a dependency so there's little chance that you'll need to include it directly.
 */

// dependencies

#include "util/BitHacks.h"

// generic peripheral includes

#include "gpio/GpioPortBase.h"
#include "gpio/GpioAlternateFunctionMapper.h"

// device-specific feature includes

#if defined(STM32PLUS_F1)

  #include "gpio/f1/GpioPinMap.h"
  #include "gpio/f1/Gpio.h"
  #include "gpio/GpioPinRef.h"
  #include "gpio/GpioIterator.h"
  #include "gpio/f1/GpioPort.h"
  #include "gpio/f1/features/DigitalOutputFeature.h"
  #include "gpio/f1/features/DigitalInputFeature.h"
  #include "gpio/f1/features/AlternateFunctionFeature.h"
  #include "gpio/f1/features/AnalogInputFeature.h"
  #include "gpio/f1/GpioAlternateFunctionMapper.h"
  #include "gpio/f1/GpioPorts.h"

#elif defined(STM32PLUS_F4)

  #include "gpio/f4/GpioPinMap.h"
  #include "gpio/f4/Gpio.h"
  #include "gpio/GpioPinRef.h"
  #include "gpio/GpioIterator.h"
  #include "gpio/f4/GpioPort.h"
  #include "gpio/f4/features/DigitalOutputFeature.h"
  #include "gpio/f4/features/DigitalInputFeature.h"
  #include "gpio/f4/features/AlternateFunctionFeature.h"
  #include "gpio/f4/features/AnalogInputFeature.h"
  #include "gpio/f4/GpioPorts.h"


#elif defined(STM32PLUS_F0)

  #include "gpio/f0/GpioPinMap.h"
  #include "gpio/f0/Gpio.h"
  #include "gpio/GpioPinRef.h"
  #include "gpio/GpioIterator.h"
  #include "gpio/f0/GpioPort.h"
  #include "gpio/f0/features/DigitalOutputFeature.h"
  #include "gpio/f0/features/DigitalInputFeature.h"
  #include "gpio/f0/features/AlternateFunctionFeature.h"
  #include "gpio/f0/features/AnalogInputFeature.h"
  #include "gpio/f0/GpioPorts.h"

#endif

// generic utility includes

#include "gpio/GpioPinInitialiser.h"
// END FILE: ../lib/include/config/gpio.h
// START FILE: ../lib/include/config/string.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

/**
 * @file
 * Include this config file to get access to the string utilities. Numeric-to-ASCII and string tokenisation
 * utilities are the sort of thing you will find here.
 */

// string depends on scoped array, STL string, vector

#include "memory/scoped_array.h"
#include <iterator>
#include <vector>
#include <string>

// includes for the features

#include "string/StringUtil.h"
#include "string/TokenisedString.h"
#include "string/StdStringUtil.h"
#include "string/Ascii.h"
// END FILE: ../lib/include/config/string.h
// START FILE: ../lib/include/config/rcc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This is an internal config file that is included by any peripheral that has a clock, i.e. all of them. Methods
 * are provided to allow clocks to be stopped and started and to interrogate the bus speeds and multipliers.
 */

// generic includes

#include "rcc/ClockControl.h"
#include "rcc/RccBusInformation.h"
#include "rcc/PeripheralBusSpeed.h"

// device-specific includes

#if defined(STM32PLUS_F1)

  #include "rcc/f1/ClockControl.h"
  #include "rcc/f1/PeripheralBusSpeed.h"

#elif defined(STM32PLUS_F4)

  #include "rcc/f4/ClockControl.h"
  #include "rcc/f4/PeripheralBusSpeed.h"

#elif defined(STM32PLUS_F0)

  #include "rcc/f0/ClockControl.h"

#endif

// END FILE: ../lib/include/config/rcc.h
// START FILE: ../lib/include/config/hash.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This config file enables access to the HASH peripheral in the F4 for performing cryptographic
 * hash functions. The functionality is emulated in software for devices that don't have the
 * peripheral.
 */

// hash depends on timing

#include "config/timing.h"

// device-specific peripheral includes

#if defined(STM32PLUS_F4) && defined(STM32PLUS_F4_HARDWARE_CRYPTO)
  #include "hash/f4/SHA1.h"
#else
  #include "hash/software/SHA1.h"
#endif

// generic peripheral includes

#include "hash/HashPeripheral.h"

// END FILE: ../lib/include/config/hash.h
// START FILE: ../lib/include/config/debug.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This file provides access to generic utilities that can be used to
 * assist debugging
 */

// debug depends on usart,stream,malloc.h

#include "config/stm32plus.h"

#include <malloc.h>
#include "config/usart.h"
#include "config/stream.h"

// include the features

// If the MCU is supported (on the F4 and F1)

#if defined(STM32PLUS_F4) || defined(STM32PLUS_F1)
  #include "debug/heapMonitor.h"
  #include "debug/usartHeapMonitor.h"
#endif


// SemiHosting is always possible

#include "debug/SemiHosting.h"


namespace stm32plus {
  extern SemiHosting shost;
}
// END FILE: ../lib/include/config/debug.h
// START FILE: ../lib/include/config/i2c.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

/**
 * @file
 * This file provides access to the I2C peripheral. All the peripherals are exposed with multiple pin configurations
 * available. DMA and interrupt-driven access are both supported.
 */

// i2c depends on rcc, gpio, event, interrupts, dma, timing

#include "config/rcc.h"
#include "config/gpio.h"
#include "config/event.h"
#include "config/dma.h"
#include "config/timing.h"

// generic peripheral includes

#include "i2c/I2CPinInitialiser.h"
#include "i2c/I2CEventSource.h"

#if defined(STM32PLUS_F0)
  #include "i2c/f0/I2C.h"
  #include "i2c/f0/I2CPeripheral.h"
#elif defined(STM32PLUS_F1) || defined(STM32PLUS_F4)
  #include "i2c/f1,f4/I2C.h"
  #include "i2c/f1,f4/I2CPeripheral.h"
#endif

// generic feature includes

#include "i2c/features/I2CFeatureBase.h"
#include "i2c/features/I2CIoFeature.h"
#include "i2c/features/I2CMasterPollingFeature.h"
#include "i2c/features/I2CSingleByteMasterPollingFeature.h"
#include "i2c/features/I2CTwoByteMasterPollingFeature.h"
#include "i2c/features/I2CInterruptFeature.h"

#if defined(STM32PLUS_F1) || defined(STM32PLUS_F4)
#include "i2c/features/f1,f4/I2CSlaveFeature.h"
#endif

// includes for the alternate function mappings

#if defined(STM32PLUS_F4)
  #include "i2c/f4/I2CAlternateFunctionMapper.h"
#elif defined(STM32PLUS_F0)
  #include "i2c/f0/I2CAlternateFunctionMapper.h"
#endif

// generic peripheral includes

#include "i2c/I2C2.h"

#if defined(STM32PLUS_F0)
  #include "i2c/f0/I2C1.h"
#elif defined(STM32PLUS_F1)
  #include "i2c/f1/I2C1.h"
#elif defined(STM32PLUS_F4)
  #include "i2c/f4/I2C1.h"
#endif

// enable all interrupts

#define USE_I2C1_INTERRUPT
#define USE_I2C2_INTERRUPT

// device specific includes

#if defined(STM32PLUS_F0)

  #include "i2c/features/f0/I2CSecondSlaveFeature.h"
  #include "i2c/f0/I2C2Remap.h"

#elif defined(STM32PLUS_F1)

  #include "i2c/features/f1/I2CSecondSlaveFeature.h"

#elif defined(STM32PLUS_F4)

  #define USE_I2C3_INTERRUPT

  #include "i2c/features/f4/I2CInterruptFeature.h"
  #include "i2c/features/f4/I2CSecondSlaveFeature.h"

  #include "i2c/f4/I2C2Remap.h"
  #include "i2c/f4/I2C3.h"

#endif
// END FILE: ../lib/include/config/i2c.h
// START FILE: ../lib/include/config/net.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This config file gets you access to the networking support. Support is provided for the
 * builtin MAC on the F4.
 */

#if defined(STM32PLUS_F4) || defined(STM32PLUS_F1_CL_E)


// net depends on GPIO, RCC, traits, timing, event, smart pointers, meta, stl slist, concurrent, rtc, string, rng, stream

#include "config/gpio.h"
#include "config/rcc.h"
#include "config/traits.h"
#include "config/timing.h"
#include "config/event.h"
#include "config/rtc.h"
#include "config/string.h"
#include "config/concurrent.h"
#include "config/rng.h"
#include "config/stream.h"
#include "memory/scoped_array.h"
#include "memory/circular_buffer.h"
#include "memory/scoped_ptr.h"
#include "memory/linked_ptr.h"
#include "util/Meta.h"
#include "iterator"
#include "slist"
#include "vector"
#include "list"
#include "algorithm"
#include "string"

// generic includes

#include "net/EtherType.h"
#include "net/NetUtil.h"
#include "net/datalink/DatalinkChecksum.h"
#include "net/NetBuffer.h"
#include "net/NetEventDescriptor.h"
#include "net/NetworkErrorEvent.h"
#include "net/NetworkEvents.h"
#include "net/NetworkDebugEvent.h"
#include "net/NetworkIntervalTicker.h"
#include "net/NetworkUtilityObjects.h"
#include "net/NetMeta.h"

#include "net/transport/icmp/IcmpType.h"
#include "net/transport/icmp/IcmpCode.h"

// physical layer

#include "net/physical/PhysicalLayer.h"
#include "net/physical/PhyReadRequestEvent.h"
#include "net/physical/PhyWriteRequestEvent.h"
#include "net/physical/PhyBase.h"
#include "net/physical/ksz8051mll/KSZ8051MLL.h"
#include "net/physical/ksz8091rna/KSZ8091RNA.h"
#include "net/physical/dp83848c/DP83848C.h"
#include "net/physical/lan8710a/LAN8710A.h"
#include "net/physical/PhyHardReset.h"

// data link layer

#include "net/datalink/DatalinkFrame.h"
#include "net/datalink/DatalinkFrameEvent.h"
#include "net/datalink/DatalinkFrameSentEvent.h"

#include "net/datalink/DatalinkLayer.h"

#include "net/datalink/mac/fwlib/ethernet.h"

#include "net/datalink/MacAddress.h"
#include "net/datalink/EthernetTransmitRequestEvent.h"
#include "net/datalink/EthernetFrameData.h"
#include "net/datalink/EthernetTaggedFrameData.h"
#include "net/datalink/EthernetSnapFrameData.h"
#include "net/datalink/EthernetTaggedSnapFrameData.h"
#include "net/datalink/EthernetFrame.h"
#include "net/datalink/mac/MacAddressFilter.h"
#include "net/datalink/mac/MacDefaultPinPackage.h"
#include "net/datalink/mac/MacBase.h"
#include "net/datalink/mac/Mac.h"

#if defined(STM32PLUS_F4)

  #include "net/datalink/mac/f4/MacRemapPinPackage.h"
  #include "net/datalink/mac/f4/MiiInterface.h"
  #include "net/datalink/mac/f4/RmiiInterface.h"

#elif defined(STM32PLUS_F1_CL_E)

  #include "net/datalink/mac/f1/MacRemapPinPackage.h"
  #include "net/datalink/mac/f1/MiiInterface.h"
  #include "net/datalink/mac/f1/RmiiInterface.h"

#else
  #error "Unsupported MCU"
#endif

// network layer

#include "net/network/ip/IpAddress.h"
#include "net/network/ip/IpSubnetMask.h"

#include "net/application/DomainNameAnnouncementEvent.h"
#include "net/application/IpAddressAnnouncementEvent.h"
#include "net/application/IpDefaultGatewayAnnouncementEvent.h"
#include "net/application/IpDnsServersAnnouncementEvent.h"
#include "net/application/IpSubnetMaskAnnouncementEvent.h"
#include "net/datalink/MacAddressAnnoucementEvent.h"

#include "net/network/IpProtocol.h"
#include "net/network/ip/InternetChecksum.h"
#include "net/network/ip/IpTransmitRequestEvent.h"
#include "net/network/arp/ArpMappingRequestEvent.h"

#include "net/network/ip/IpAddressMappingEvent.h"

#include "net/network/arp/ArpOperation.h"
#include "net/network/arp/ArpFrameData.h"
#include "net/network/arp/ArpCache.h"
#include "net/network/arp/ArpReceiveEvent.h"
#include "net/network/arp/Arp.h"

#include "net/network/ip/IpPorts.h"
#include "net/network/ip/IpPacketHeader.h"
#include "net/network/ip/IpPacket.h"
#include "net/network/ip/IpPacketEvent.h"
#include "net/network/ip/features/IpFragmentedPacket.h"
#include "net/network/ip/features/IpPacketReassemblerFeature.h"
#include "net/network/ip/features/IpPacketFragmentFeature.h"
#include "net/network/ip/features/IpDisablePacketFragmentFeature.h"
#include "net/network/ip/features/IpDisablePacketReassemblerFeature.h"
#include "net/network/ip/Ip.h"

#include "net/network/NetworkLayer.h"

// transport layer

#include "net/transport/icmp/IcmpPacket.h"
#include "net/transport/icmp/IcmpPacketEvent.h"
#include "net/transport/icmp/IcmpTransmitRequestEvent.h"
#include "net/transport/icmp/IcmpErrorPacket.h"
#include "net/transport/icmp/Icmp.h"

#include "net/transport/udp/UdpDatagram.h"
#include "net/transport/udp/UdpDatagramEvent.h"
#include "net/transport/udp/Udp.h"

#include "net/transport/tcp/TcpOptions.h"
#include "net/transport/tcp/TcpHeaderFlags.h"
#include "net/transport/tcp/TcpState.h"
#include "net/transport/tcp/TcpHeader.h"
#include "net/transport/tcp/TcpSegmentEvent.h"
#include "net/transport/tcp/TcpTransmitWindow.h"
#include "net/transport/tcp/TcpReceiveWindow.h"
#include "net/transport/tcp/TcpConnectionStateChangedEvent.h"
#include "net/transport/tcp/TcpConnectionState.h"
#include "net/transport/tcp/TcpClosingConnectionState.h"
#include "net/transport/tcp/TcpEvents.h"
#include "net/transport/tcp/TcpFindConnectionNotificationEvent.h"
#include "net/transport/tcp/TcpConnectionReleasedEvent.h"
#include "net/transport/tcp/TcpConnectionClosedEvent.h"
#include "net/transport/tcp/TcpConnectionDataReadyEvent.h"
#include "net/transport/tcp/TcpReceiveBuffer.h"
#include "net/transport/tcp/TcpConnection.h"
#include "net/transport/tcp/TcpClientConnection.h"
#include "net/transport/tcp/TcpResendDelayCalculator.h"
#include "net/transport/tcp/TcpAcceptEvent.h"
#include "net/transport/tcp/TcpServerReleasedEvent.h"
#include "net/transport/tcp/TcpServerBase.h"
#include "net/transport/tcp/TcpServer.h"
#include "net/transport/tcp/Tcp.h"
#include "net/transport/tcp/TcpWaitState.h"
#include "net/transport/tcp/TcpConnectionArray.h"
#include "net/transport/tcp/TcpTextLineReceiver.h"
#include "net/transport/tcp/TcpOutputStreamOfStreams.h"
#include "net/transport/tcp/TcpInputStream.h"
#include "net/transport/tcp/TcpOutputStream.h"
#include "net/transport/TransportLayer.h"

// application layer

#include "net/application/dns/DnsPacketHeader.h"
#include "net/application/dns/DnsQueryPacket.h"
#include "net/application/dns/DnsReplyPacket.h"
#include "net/application/dns/DnsCache.h"
#include "net/application/dns/Dns.h"

#include "net/application/dhcp/DhcpRenewalDueEvent.h"
#include "net/application/dhcp/DhcpPacket.h"
#include "net/application/dhcp/DhcpClient.h"
#include "net/application/staticIpClient/StaticIpClient.h"
#include "net/application/ping/Ping.h"

#include "net/application/llip/LinkLocalIp.h"

#include "net/application/ApplicationLayer.h"

// network stack

#include "net/NetworkStack.h"

#endif
// END FILE: ../lib/include/config/net.h
// START FILE: ../lib/include/config/event.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Include this config file to get access to the C++ event system. The event system allows you to raise
 * type-safe events that listeners can subscribe to. This system avoids the use of the void* pointers
 * that the Observer/Observable system uses and allows event arguments to be tightly coupled to the
 * class that raises them.
 */

// event depends on stl slist
// some implementation contain slist in ext/slist
#include "iterator"
#ifdef EXT_SLIST
    #include "ext/slist"
#else
    #include "slist"
#endif

// include the event/slot signal classes

#include "event/slot.h"
#include "event/signal.h"

// macros for declaring the event signature and source class

#define DECLARE_EVENT_SIGNATURE(name,sig) typedef wink::slot<sig> name##EventSourceSlot; typedef wink::signal<name##EventSourceSlot> name##EventSourceType
#define DECLARE_EVENT_SOURCE(name) name##EventSourceType name##EventSender
// END FILE: ../lib/include/config/event.h
// START FILE: ../lib/include/config/timer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This file provides access to the STM32 timer peripherals. The timers are incredibly configurable and
 * very powerful peripherals that can be used on their own or linked in various ways to other peripherals
 * on the STM32 where timing might be useful.
 *
 * Access to all the timer peripherals is provided and feature classes are there for you to pick and choose
 * what you need from your timer. There's an awful lot in here, see the examples for a good run-down of
 * what you can do.
 */

// timer depends on gpio, event, interrupts, nvic, rtc, exti, scoped_ptr

#include "config/gpio.h"
#include "config/nvic.h"
#include "config/rtc.h"
#include "config/event.h"
#include "config/exti.h"
#include "memory/scoped_ptr.h"

// generic peripheral and feature includes

#include "timer/TimerEventSource.h"
#include "timer/Timer.h"
#include "timer/TimerPeripheral.h"

#include "timer/features/TimerFeatureBase.h"
#include "timer/features/TimerInterruptFeatureEnabler.h"
#include "timer/features/TimerChannelFeatureBase.h"

// generic timer channel feature includes

#include "timer/features/channel/TimerChannelOCPolarityFeature.h"
#include "timer/features/channel/TimerChannelOCNPolarityFeature.h"
#include "timer/features/channel/TimerChannelOCModeFeature.h"
#include "timer/features/channel/TimerChannelOCPulseFeature.h"
#include "timer/features/channel/TimerChannelOCIdleStateFeature.h"
#include "timer/features/channel/TimerChannelOCNIdleStateFeature.h"

#include "timer/features/channel/TimerChannelICPolarityFeature.h"
#include "timer/features/channel/TimerChannelICSelectionFeature.h"
#include "timer/features/channel/TimerChannelICPrescalerFeature.h"
#include "timer/features/channel/TimerChannelICFilterFeature.h"

// generic feature includes

#include "timer/features/TimerChannelFeature.h"
#include "timer/features/TimerChannel1Feature.h"
#include "timer/features/TimerChannel2Feature.h"
#include "timer/features/TimerChannel3Feature.h"
#include "timer/features/TimerChannel4Feature.h"
#include "timer/features/TimerExternalMode1ClockFeature.h"
#include "timer/features/TimerInternalTriggerClockFeature.h"
#include "timer/features/TimerMasterFeature.h"
#include "timer/features/TimerSlaveFeature.h"
#include "timer/features/TimerEncoderFeature.h"
#include "timer/features/TimerBreakFeature.h"

// generic peripheral includes

#include "timer/TimerPeripheral.h"
#include "timer/AdvancedControlTimer.h"
#include "timer/GeneralPurposeTimer.h"
#include "timer/BasicTimer.h"

#include "timer/Timer1.h"
#include "timer/Timer2.h"
#include "timer/Timer3.h"

#if defined(STM32PLUS_F1) || defined(STM32PLUS_F0) || defined(STM32PLUS_F4_HAS_TIM6_7_8_12_13_14)

  #include "timer/Timer6.h"
  #include "timer/Timer14.h"

#endif

// MCU-specific timer includes

#if defined(STM32PLUS_F1)

  #include "timer/f1/Timer4.h"
  #include "timer/f1/Timer5.h"
  #include "timer/f1/Timer7.h"
  #include "timer/f1/Timer8.h"
  #include "timer/f1/Timer9.h"
  #include "timer/f1/Timer10.h"
  #include "timer/f1/Timer11.h"
  #include "timer/f1/Timer12.h"
  #include "timer/f1/Timer13.h"

#elif defined(STM32PLUS_F4)

  #include "timer/f4/Timer4.h"
  #include "timer/f4/Timer5.h"
  #include "timer/f4/Timer9.h"
  #include "timer/f4/Timer10.h"
  #include "timer/f4/Timer11.h"

#if defined(STM32PLUS_F4_HAS_TIM6_7_8_12_13_14)

  #include "timer/f4/Timer7.h"
  #include "timer/f4/Timer8.h"
  #include "timer/f4/Timer12.h"
  #include "timer/f4/Timer13.h"

#endif

#elif defined(STM32PLUS_F0)

  #include "timer/f0/Timer15.h"
  #include "timer/f0/Timer16.h"
  #include "timer/f0/Timer17.h"

#endif

// enable all interrupts

#define USE_TIM1_BRK_INTERRUPT
#define USE_TIM1_UP_INTERRUPT
#define USE_TIM1_TRG_COM_INTERRUPT
#define USE_TIM1_CC_INTERRUPT
#define USE_TIM1_UP_TIM16_INTERRUPT
#define USE_TIM1_BRK_TIM15_INTERRUPT
#define USE_TIM1_TRG_COM_TIM17_INTERRUPT
#define USE_TIM1_BRK_UP_TRG_COM_INTERRUPT

#define USE_TIM8_BRK_INTERRUPT
#define USE_TIM8_UP_INTERRUPT
#define USE_TIM8_TRG_COM_INTERRUPT
#define USE_TIM8_CC_INTERRUPT

#define USE_TIM2_INTERRUPT
#define USE_TIM3_INTERRUPT
#define USE_TIM4_INTERRUPT
#define USE_TIM5_INTERRUPT
#define USE_TIM6_INTERRUPT
#define USE_TIM7_INTERRUPT
#define USE_TIM9_INTERRUPT
#define USE_TIM10_INTERRUPT
#define USE_TIM11_INTERRUPT
#define USE_TIM12_INTERRUPT
#define USE_TIM13_INTERRUPT
#define USE_TIM14_INTERRUPT
#define USE_TIM15_INTERRUPT
#define USE_TIM16_INTERRUPT
#define USE_TIM17_INTERRUPT

// device-specific feature includes

#if defined(STM32PLUS_F1_HD)
  #include "timer/features/f1/hd/TimerInterruptFeature.h"
#elif defined(STM32PLUS_F1_CL)
  #include "timer/features/f1/cl/TimerInterruptFeature.h"
#elif defined(STM32PLUS_F1_MD)
  #include "timer/features/f1/md/TimerInterruptFeature.h"
#elif defined(STM32PLUS_F1_MD_VL)
  #include "timer/features/f1/mdvl/TimerInterruptFeature.h"
#elif defined(STM32PLUS_F1_XL)
  #include "timer/features/f1/xl/TimerInterruptFeature.h"
#endif

#if defined(STM32PLUS_F1)

  #include "timer/features/f1/TimerInternalClockFeature.h"
  #include "timer/features/f1/Timer1GpioFeature.h"
  #include "timer/features/f1/Timer2GpioFeature.h"
  #include "timer/features/f1/Timer3GpioFeature.h"
  #include "timer/features/f1/Timer4GpioFeature.h"
  #include "timer/features/f1/Timer5GpioFeature.h"
  #include "timer/features/f1/Timer8GpioFeature.h"
  #include "timer/features/f1/Timer9GpioFeature.h"
  #include "timer/features/f1/Timer10GpioFeature.h"
  #include "timer/features/f1/Timer11GpioFeature.h"
  #include "timer/features/f1/Timer13GpioFeature.h"
  #include "timer/features/f1/Timer14GpioFeature.h"

#elif defined(STM32PLUS_F4)

  #include "timer/f4/TimerAlternateFunctionMapper.h"
  #include "timer/features/f4/TimerInterruptFeature.h"
  #include "timer/features/f4/Timer1GpioFeature.h"
  #include "timer/features/f4/Timer2GpioFeature.h"
  #include "timer/features/f4/Timer3GpioFeature.h"
  #include "timer/features/f4/Timer4GpioFeature.h"
  #include "timer/features/f4/Timer5GpioFeature.h"
  #include "timer/features/f4/Timer9GpioFeature.h"
  #include "timer/features/f4/Timer10GpioFeature.h"
  #include "timer/features/f4/Timer11GpioFeature.h"

#if defined(STM32PLUS_F4_HAS_TIM6_7_8_12_13_14)

  #include "timer/features/f4/Timer8GpioFeature.h"
  #include "timer/features/f4/Timer13GpioFeature.h"
  #include "timer/features/f4/Timer14GpioFeature.h"

#endif

  #include "timer/features/f4/Timer2RemapEthernetPtpFeature.h"
  #include "timer/features/f4/Timer2RemapUsbFullSpeedSofFeature.h"
  #include "timer/features/f4/Timer2RemapUsbHighSpeedSofFeature.h"
  #include "timer/features/f4/Timer5RemapLsiFeature.h"
  #include "timer/features/f4/Timer5RemapLseFeature.h"
  #include "timer/features/f4/Timer5RemapRtcFeature.h"
  #include "timer/features/f4/Timer11RemapHseFeature.h"
  #include "timer/features/f4/TimerInternalClockFeature.h"

#elif defined(STM32PLUS_F0)

  #include "timer/f0/TimerAlternateFunctionMapper.h"
  #include "timer/features/f0/TimerInterruptFeature.h"
  #include "timer/features/f0/Timer1GpioFeature.h"
  #include "timer/features/f0/Timer2GpioFeature.h"
  #include "timer/features/f0/Timer3GpioFeature.h"
  #include "timer/features/f0/Timer14GpioFeature.h"
  #include "timer/features/f0/Timer15GpioFeature.h"
  #include "timer/features/f0/Timer16GpioFeature.h"
  #include "timer/features/f0/Timer17GpioFeature.h"
  #include "timer/features/f0/Timer14RemapGpioFeature.h"
  #include "timer/features/f0/Timer14RemapHseDiv32Feature.h"
  #include "timer/features/f0/Timer14RemapMcoFeature.h"
  #include "timer/features/f0/Timer14RemapRtcClkFeature.h"
  #include "timer/features/f0/TimerInternalClockFeature.h"

#endif
// END FILE: ../lib/include/config/timer.h
// START FILE: ../lib/include/config/display/tft.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This configuration file should be included if you want to use any of the TFT drivers and the
 * associated graphics library.
 */

// tft depends on gpio, fsmc, timing, dma, stream, memblock, string, font

#include "config/gpio.h"

#if defined(STM32PLUS_F1_HD) || defined(STM32F40_41xxx)
  #include "config/fsmc.h"
#endif

#include "config/timing.h"
#include "config/dma.h"
#include "config/stream.h"
#include "config/string.h"
#include "config/display/font.h"
#include "util/DoublePrecision.h"
#include "memory/Memblock.h"

// includes for the features

#include "display/Point.h"
#include "display/Size.h"
#include "display/Rectangle.h"

// include the sample fonts

#include "display/graphic/fonts/Font_apple_8.h"
#include "display/graphic/fonts/Font_volter_goldfish_9.h"
#include "display/graphic/fonts/Font_kyrou9_bold_8.h"
#include "display/graphic/fonts/Font_kyrou9_regular_8.h"
#include "display/graphic/fonts/Font_atari_st_16.h"
#include "display/graphic/fonts/Font_dos_16.h"
#include "display/graphic/fonts/Font_nintendo_ds_16.h"
#include "display/graphic/fonts/Font_pixelade_13.h"
#include "display/graphic/fonts/Font_proggy_clean_16.h"

#include "display/graphic/gamma/DisplayDeviceGamma.h"
#include "display/graphic/gamma/NullDisplayDeviceGamma.h"

#if defined(STM32PLUS_F1_HD) || defined(STM32F40_41xxx)
  #include "display/graphic/access/Fsmc16BitAccessMode.h"
  #include "display/graphic/access/Fsmc8BitAccessMode.h"
#endif

// graphics library includes

#include "display/graphic/ColourNames.h"
#include "display/graphic/Backlight.h"
#include "display/graphic/GraphicTerminal.h"
#include "display/graphic/PanelConfiguration.h"
#include "display/graphic/PicoJpeg.h"
#include "display/graphic/JpegDecoder.h"
#include "display/graphic/GraphicsLibrary.h"

// include the optimised GPIO drivers in specialisation order

#include "display/graphic/access/Gpio16BitAccessMode.h"

// these two are for devices capable of 72MHz and above

#if defined(STM32PLUS_F1) || defined(STM32PLUS_F4)
  #include "display/graphic/access/Gpio16BitAccessMode_64K_72_50_50.h"      // optimised for 64K colours
  #include "display/graphic/access/Gpio16BitAccessMode_72_50_50.h"          // generic for >64K colours
#endif

// minimum of 24MHz clock required for these

#include "display/graphic/access/Gpio16BitAccessMode_64K_24_80_80.h"      // optimised for 64K colours
#include "display/graphic/access/Gpio16BitAccessMode_24_80_80.h"          // generic for >64K colours

#include "display/graphic/access/Gpio16BitAccessMode_64K_48_42_42.h"      // optimised for 64K colours
#include "display/graphic/access/Gpio16BitAccessMode_48_42_42.h"          // generic for >64K colours

// include the device drivers

#include "display/graphic/tft/ili9325/ILI9325.h"
#include "display/graphic/tft/ili9481/ILI9481.h"
#include "display/graphic/tft/ili9327/ILI9327.h"
#include "display/graphic/tft/ili9327/ILI9327400x240PanelTraits.h"
#include "display/graphic/tft/hx8347a/HX8347A.h"
#include "display/graphic/tft/mc2pa8201/MC2PA8201.h"
#include "display/graphic/tft/lds285/LDS285.h"
#include "display/graphic/tft/ssd1289/SSD1289.h"
#include "display/graphic/tft/st7783/ST7783.h"
#include "display/graphic/tft/lgdp453x/LGDP453x.h"
#include "display/graphic/tft/hx8352a/HX8352A.h"
#include "display/graphic/tft/r61523/R61523.h"
#include "display/graphic/tft/hx8352a/panelTraits/LG_KF700.h"
#include "display/graphic/tft/hx8352a/panelTraits/TM032LDH05.h"

#if !defined(STM32PLUS_F0)        // there's an FSMC dependency in here
  #include "display/graphic/tft/ssd1963/SSD1963.h"
  #include "display/graphic/tft/ssd1963/panelTraits/SSD1963_480x272PanelTraits.h"
#endif

#include "display/graphic/tft/TftInterfaces.h"

// include the interactive gamma class

#include "display/graphic/gamma/InteractiveGamma.h"
// END FILE: ../lib/include/config/display/tft.h
// START FILE: ../lib/include/config/display/font.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// include the feature

#include "display/graphic/FontChar.h"
#include "display/graphic/Font.h"
// END FILE: ../lib/include/config/display/font.h
// START FILE: ../lib/include/config/display/character.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Include this config file if you want to use any of the character based LCD functionality. Currently
 * this gets you access to the HD44780 driver and character terminal.
 */

// character display depends on gpio, timing, string, double precision

#include "config/gpio.h"
#include "config/timing.h"
#include "config/string.h"
#include "util/DoublePrecision.h"

// includes for the devices

#include "display/character/CharacterLcd.h"
#include "display/character/HD44780.h"

// includes for the features

#include "display/Point.h"
#include "display/Size.h"

#include "display/character/CharacterLcdTerminal.h"
// END FILE: ../lib/include/config/display/character.h
// START FILE: ../lib/include/config/display/touch.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


// touch depends on event, stream, exti, millisecond timer, spi

#include "config/event.h"
#include "config/stream.h"
#include "config/exti.h"
#include "config/spi.h"
#include "timing/MillisecondTimer.h"

// includes for the features

#include "display/Point.h"
#include "display/Size.h"

#include "display/touch/TouchScreenCalibration.h"
#include "display/touch/TouchScreenPostProcessor.h"
#include "display/touch/TouchScreen.h"
#include "display/touch/AveragingTouchScreenPostProcessor.h"
#include "display/touch/PassThroughTouchScreenCalibration.h"
#include "display/touch/PassThroughTouchScreenPostProcessor.h"
#include "display/touch/ThreePointTouchScreenCalibration.h"
#include "display/touch/TouchScreenCalibrator.h"
#include "display/touch/ThreePointTouchScreenCalibrator.h"

#include "display/touch/ADS7843AsyncTouchScreen.h"
// END FILE: ../lib/include/config/display/touch.h
// START FILE: ../lib/include/config/button.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This config file gets you access to the built-in support for push-button logic. There is a plain
 * pushbutton class and one that supports auto-repeat.
 */

// buttons depend on gpio, event, MillisecondTimer

#include "config/gpio.h"
#include "config/event.h"
#include "timing/MillisecondTimer.h"

// include the buttons

#include "button/PushButton.h"
#include "button/AutoRepeatPushButton.h"
// END FILE: ../lib/include/config/button.h
// START FILE: ../lib/include/config/net_ftp.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This config file gets you access to the FTP application layer feature.
 */

#if defined(STM32PLUS_F4) || defined(STM32PLUS_F1_CL_E)


// net_ftp depends on net, stream

#include "config/stream.h"
#include "config/net.h"

// includes for the protocol


#include "net/application/ftp/FtpServerAuthenticationState.h"
#include "net/application/ftp/FtpServerDataConnection.h"
#include "net/application/ftp/FtpServerConnectionBase.h"
#include "net/application/ftp/FtpServerConnection.h"


#endif
// END FILE: ../lib/include/config/net_ftp.h
// START FILE: ../lib/include/config/stm32plus.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This is the primary include file for stm32plus. You should always include it before you include any
 * other config files.
 *
 * Configuration for the library is here. Make sure you have defined one of the MCU selection defines:
 *
 *  STM32PLUS_F1_HD
 *  STM32PLUS_F1_CL
 *  STM32PLUS_F1_MDVL
 *  STM32PLUS_F0_51
 *  STM32PLUS_F401
 *  ... and all the others (see SConstruct for all)
 *
 *  Also ensure that HSE_VALUE has been set to the speed of your external oscillator in hertz. The scons
 *  build procedure takes care of all these definitions.
 */


// include the standard peripheral library

#include "config/stdperiph.h"


/*
 * Verify that HSE_VALUE is defined
 */

#if !defined(HSE_VALUE) && !defined(HSI_VALUE)
#error "Please define HSE_VALUE or HSI_VALUE to the frequency of your external/internal oscillator in hertz"
#endif


/*
 * Flag that we are an STM32PLUS project with the current release version
 */

#undef STM32PLUS_BUILD
#define STM32PLUS_BUILD 0x040100


/**
 * @namespace stm32plus 'stm32plus' is the primary namespace for everything inside the library. There are
 * also some sub-namespaces such as 'display' for the graphics code.
 */

namespace stm32plus {


  /**
   * MCU Series names
   */

  enum McuSeries {
    SERIES_F0,  //!< STM32 F0
    SERIES_F1,  //!< STM32 F1
    SERIES_F4   //!< STM32 F4
  };


  /**
   * Peripheral names
   */

  enum PeripheralName {
    PERIPHERAL_ADC1,                //!< PERIPHERAL_ADC1
    PERIPHERAL_ADC2,                //!< PERIPHERAL_ADC1
    PERIPHERAL_ADC3,                //!< PERIPHERAL_ADC1
    PERIPHERAL_BACKUP,              //!< PERIPHERAL_BACKUP
    PERIPHERAL_CRC,                 //!< PERIPHERAL_CRC
    PERIPHERAL_DAC1,                //!< PERIPHERAL_DAC1
    PERIPHERAL_DAC2,                //!< PERIPHERAL_DAC2
    PERIPHERAL_DMA1,                //!< PERIPHERAL_DMA1
    PERIPHERAL_DMA2,                //!< PERIPHERAL_DMA2
    PERIPHERAL_GPIO,                //!< PERIPHERAL_GPIO
    PERIPHERAL_FSMC,                //!< PERIPHERAL_FSMC
    PERIPHERAL_FMC,                 //!< PERIPHERAL_FMC
    PERIPHERAL_HASH,                //!< PERIPHERAL_HASH
    PERIPHERAL_I2C1,                //!< PERIPHERAL_I2C1
    PERIPHERAL_I2C2,                //!< PERIPHERAL_I2C2
    PERIPHERAL_I2C3,                //!< PERIPHERAL_I2C3
    PERIPHERAL_I2S2,                //!< PERIPHERAL_I2S2
    PERIPHERAL_I2S3,                //!< PERIPHERAL_I2S3
    PERIPHERAL_MAC,                 //!< PERIPHERAL_MAC
    PERIPHERAL_MAC_REMAP,           //!< PERIPHERAL_MAC_REMAP
    PERIPHERAL_OTG_FS,              //!< internal OTG FS PHY
    PERIPHERAL_OTG_HS,              //!< internal OTG HS PHY
    PERIPHERAL_POWER,               //!< PERIPHERAL_POWER
    PERIPHERAL_RNG,                 //!< PERIPHERAL_RNG
    PERIPHERAL_SDIO,                //!< PERIPHERAL_SDIO
    PERIPHERAL_SPI1,                //!< PERIPHERAL_SPI1
    PERIPHERAL_SPI1_REMAP,          //!< PERIPHERAL_SPI1_REMAP
    PERIPHERAL_SPI2,                //!< PERIPHERAL_SPI2
    PERIPHERAL_SPI3,                //!< PERIPHERAL_SPI3
    PERIPHERAL_SPI3_REMAP,          //!< PERIPHERAL_SPI3_REMAP
    PERIPHERAL_SYSCFG,              //!< PERIPHERAL_SYSCFG
    PERIPHERAL_TIMER1,              //!< PERIPHERAL_TIMER1
    PERIPHERAL_TIMER2,              //!< PERIPHERAL_TIMER2
    PERIPHERAL_TIMER3,              //!< PERIPHERAL_TIMER3
    PERIPHERAL_TIMER4,              //!< PERIPHERAL_TIMER4
    PERIPHERAL_TIMER5,              //!< PERIPHERAL_TIMER5
    PERIPHERAL_TIMER6,              //!< PERIPHERAL_TIMER6
    PERIPHERAL_TIMER7,              //!< PERIPHERAL_TIMER7
    PERIPHERAL_TIMER8,              //!< PERIPHERAL_TIMER8
    PERIPHERAL_TIMER9,              //!< PERIPHERAL_TIMER9
    PERIPHERAL_TIMER10,             //!< PERIPHERAL_TIMER10
    PERIPHERAL_TIMER11,             //!< PERIPHERAL_TIMER11
    PERIPHERAL_TIMER12,             //!< PERIPHERAL_TIMER12
    PERIPHERAL_TIMER13,             //!< PERIPHERAL_TIMER13
    PERIPHERAL_TIMER14,             //!< PERIPHERAL_TIMER14
    PERIPHERAL_TIMER15,             //!< PERIPHERAL_TIMER15
    PERIPHERAL_TIMER16,             //!< PERIPHERAL_TIMER16
    PERIPHERAL_TIMER17,             //!< PERIPHERAL_TIMER17
    PERIPHERAL_USART1,              //!< PERIPHERAL_USART1
    PERIPHERAL_USART1_REMAP,        //!< PERIPHERAL_USART1_REMAP
    PERIPHERAL_USART2,              //!< PERIPHERAL_USART2
    PERIPHERAL_USART2_REMAP,        //!< PERIPHERAL_USART2_REMAP
    PERIPHERAL_USART3,              //!< PERIPHERAL_USART3
    PERIPHERAL_USART3_PARTIAL_REMAP,  //!< PERIPHERAL_USART3_PARTIAL_REMAP
    PERIPHERAL_USART3_FULL_REMAP,   //!< PERIPHERAL_USART3_FULL_REMAP
    PERIPHERAL_UART4,               //!< PERIPHERAL_UART4
    PERIPHERAL_UART5,               //!< PERIPHERAL_UART5
    PERIPHERAL_USART6,              //!< PERIPHERAL_USART6
    PERIPHERAL_CAN1,				        //!< PERIPHERAL_CAN1
    PERIPHERAL_CAN2					        //!< PERIPHERAL_CAN2
  };


  /**
   * Endian-ness values for when we need it. Careful: BIG_ENDIAN and LITTLE_ENDIAN
   * are defined as macros.
   */

  enum class Endian {
    LITTLE_ENDIAN_MCU,  //!< little endian
    BIG_ENDIAN_MCU      //!< big endian
  };
}


// include standard libraries

#include <cstdlib>
#include <cstring>
#include <ctime>
#include <cctype>

// error provider is common to everyone

#include "error/ErrorProvider.h"


// include the customisable peripheral traits

#include "config/traits.h"


/**
@mainpage stm32plus documentation
<H1>README and INSTALL are on Github</H1>

  Please browse to https://github.com/andysworkshop/stm32plus
 */
// END FILE: ../lib/include/config/stm32plus.h
// START FILE: ../lib/include/config/i2s.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

/**
 * @file
 * This config file provides access to the I2S peripheral functionality. DMA and interrupt based access to the
 * peripheral are supported. All the I2S peripherals are supported with all the pin configurations.
 */

// i2s depends on rcc, gpio, event, interrupts, dma, spi

#include "config/rcc.h"
#include "config/gpio.h"
#include "config/event.h"
#include "config/dma.h"
#include "config/spi.h"

// device-specific pin initialiser

#if defined(STM32PLUS_F1)
  #include "i2s/f1/I2SPinInitialiser.h"
#elif defined(STM32PLUS_F4)
  #include "i2s/f4/I2SAlternateFunctionMapper.h"
  #include "i2s/f4/I2SPinInitialiser.h"
#elif defined(STM32PLUS_F0)
  #include "i2s/f0/I2SAlternateFunctionMapper.h"
  #include "i2s/f0/I2SPinInitialiser.h"
#endif

// generic peripheral includes

#include "i2s/I2S.h"
#include "i2s/I2SPeripheral.h"

// generic feature includes

#include "i2s/features/I2SFeatureBase.h"
#include "i2s/features/I2SInterruptFeature.h"

// generic peripheral includes

#include "i2s/I2S.h"
#include "i2s/I2SPeripheral.h"
#include "i2s/I2S2.h"
#include "i2s/I2S3.h"

// enable all interrupts

#define USE_I2S2_INTERRUPT
#define USE_I2S3_INTERRUPT
// END FILE: ../lib/include/config/i2s.h
// START FILE: ../lib/include/config/timing.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Timing, as opposed to timer, gets you access to the milli and microsecond timing and delay functionality
 * as well as the time provider implementations that use the RTC. Time providers are used by the file system
 * drivers to provide a timestamp when you create or modify a file or directory.
 */

// timing depends on timer, rtc

#include "config/timer.h"
#include "config/rtc.h"


// includes for the features that build on the timer

#include "timing/TimeProvider.h"
#include "timing/RtcTimeProvider.h"
#include "timing/NullTimeProvider.h"
#include "timing/MicrosecondDelay.h"
#include "timing/MillisecondTimer.h"
// END FILE: ../lib/include/config/timing.h
// START FILE: ../lib/include/config/spi.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Include this config file to get access to the SPI peripherals. All peripherals are supported and access is provided
 * via DMA and/or interrupts.
 */

// spi depends on rcc, gpio, dma, stream, event

#include "config/rcc.h"
#include "config/gpio.h"
#include "config/dma.h"
#include "config/stream.h"
#include "config/event.h"

// device-specific pin initialiser

#if defined(STM32PLUS_F1)

  #include "spi/f1/SpiPinInitialiser.h"
  #include "spi/f1/SpiDeviceIo.h"

#elif defined(STM32PLUS_F4)

  #include "spi/f4/SpiAlternateFunctionMapper.h"
  #include "spi/f4/SpiPinInitialiser.h"
  #include "spi/f4/SpiDeviceIo.h"

#elif defined(STM32PLUS_F0)

  #include "spi/f0/SpiAlternateFunctionMapper.h"
  #include "spi/f0/SpiPinInitialiser.h"
  #include "spi/f0/SpiDeviceIo.h"

  // got renamed in the F0 SDK

  #define SPI_I2S_ClearITPendingBit(a,b)  SPI_I2S_ClearFlag((a),(b))

#endif

// general includes for the peripheral

#include "spi/SpiEventSource.h"
#include "spi/Spi.h"

// device-specific includes for the peripheral

#if defined(STM32PLUS_F0)
  #include "spi/f0/SpiPeripheral.h"
#elif defined(STM32PLUS_F1)
  #include "spi/f1/SpiPeripheral.h"
#elif defined(STM32PLUS_F4)
  #include "spi/f4/SpiPeripheral.h"
#endif

// generic feature includes

#include "spi/features/SpiFeatureBase.h"
#include "spi/features/SpiInterruptFeature.h"

// device specific includes

#if defined(STM32PLUS_F0)

  #include "spi/features/f0/SpiFifoNotifyFeature.h"

  #include "spi/f0/Spi1.h"
  #include "spi/f0/Spi3.h"

#elif defined(STM32PLUS_F1)

  #include "spi/f1/Spi1.h"
  #include "spi/f1/Spi3.h"

#elif defined(STM32PLUS_F4)

  #include "spi/f4/Spi1.h"
  #include "spi/f4/Spi3.h"

#endif

#include "spi/Spi2.h"

#define USE_SPI1_INTERRUPT
#define USE_SPI2_INTERRUPT
#define USE_SPI3_INTERRUPT

// utility classes

#include "spi/SpiPollingInputStream.h"
#include "spi/SpiPollingOutputStream.h"
// END FILE: ../lib/include/config/spi.h
// START FILE: ../lib/include/config/dac.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This file gets you access to the STM32 DAC peripheral. Functionality is provided to access both DAC channels
 * either synchronously or via DMA.
 *
 * A driver is also provided for the CS43L22 peripheral that can be found onboard the STM32F4DISCOVERY board
 * sold by ST Microelectronics.
 */

// dac depends on I2C, I2S, rcc, dma

#include "config/i2c.h"
#include "config/i2s.h"
#include "config/rcc.h"
#include "config/dma.h"

// peripheral includes

#include "dac/Dac.h"
#include "dac/DacPinInitialiser.h"
#include "dac/DacPeripheral.h"

// feature includes

#include "dac/features/DacFeatureBase.h"
#include "dac/features/DacDataAlignmentFeature.h"

#if defined(STM32PLUS_F1) || defined(STM32PLUS_F4)
  #include "dac/features/f1,f4/DacDualChannelFeature.h"
#endif

// dac channels

#include "dac/Dac1.h"
#include "dac/Dac2.h"

// specific device includes

#include "dac/CS43L22/CS43L22ControlI2C.h"
#include "dac/CS43L22/NullCS43L22DataPeripheral.h"
#include "dac/CS43L22/CS43L22.h"
// END FILE: ../lib/include/config/dac.h
// START FILE: ../lib/include/config/usb/device/cdc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#if defined(STM32PLUS_F4)

  // device base include

  #include "config/usb/device/device.h"

  // CDC device includes

  #include "usb/f4/device/cdc/CdcControlCommand.h"
  #include "usb/f4/device/cdc/CdcLineCoding.h"

  #include "usb/f4/device/cdc/events/CdcDataReceivedEvent.h"
  #include "usb/f4/device/cdc/events/CdcControlEvent.h"

  #include "usb/f4/device/cdc/CdcProtocol.h"
  #include "usb/f4/device/cdc/CdcSubClass.h"
  #include "usb/f4/device/cdc/CdcFunctionalDescriptor.h"
  #include "usb/f4/device/cdc/CdcHeaderFunctionalDescriptor.h"
  #include "usb/f4/device/cdc/CdcOneSlaveUnionFunctionalDescriptor.h"
  #include "usb/f4/device/cdc/CdcCallManagementFunctionalDescriptor.h"
  #include "usb/f4/device/cdc/CdcAbstractControlManagementFunctionalDescriptor.h"

  #include "usb/f4/device/cdc/CdcDevice.h"
  #include "usb/f4/device/cdc/ComPortCdcDevice.h"

#endif

// END FILE: ../lib/include/config/usb/device/cdc.h
// START FILE: ../lib/include/config/usb/device/hid.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#if defined(STM32PLUS_F4)

  // device base include

  #include "config/usb/device/device.h"

  // HID device includes

  #include "usb/f4/device/hid/HidClassRequestType.h"
  #include "usb/f4/device/hid/HidClassDescriptor.h"
  #include "usb/f4/device/hid/HidSubClass.h"
  #include "usb/f4/device/hid/HidProtocol.h"

  #include "usb/f4/device/hid/events/HidKeyboardLedStateEvent.h"

  #include "usb/f4/device/hid/HidDevice.h"
  #include "usb/f4/device/hid/MouseReportDescriptor.h"
  #include "usb/f4/device/hid/KeyboardReportDescriptor.h"
  #include "usb/f4/device/hid/MouseHidDevice.h"
  #include "usb/f4/device/hid/KeyboardHidDevice.h"

#endif

// END FILE: ../lib/include/config/usb/device/hid.h
// START FILE: ../lib/include/config/usb/device/msc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#if defined(STM32PLUS_F4)

  // device base include

  #include "config/usb/device/device.h"

  // MSC descriptors

  #include "usb/f4/device/msc/MscProtocol.h"
  #include "usb/f4/device/msc/MscSubClass.h"

  // MSC types

  #include "usb/f4/device/msc/MscBotState.h"
  #include "usb/f4/device/msc/MscBotStatus.h"
  #include "usb/f4/device/msc/MscBotClassRequest.h"

  #include "usb/f4/device/msc/MscScsiSense.h"
  #include "usb/f4/device/msc/MscScsiCommand.h"
  #include "usb/f4/device/msc/MscBotCswStatus.h"
  #include "usb/f4/device/msc/MscBotCommandBlockWrapper.h"
  #include "usb/f4/device/msc/MscBotCommandStatusWrapper.h"

  // MSC events

  #include "usb/f4/device/msc/events/MscBotGetMaxLunEvent.h"
  #include "usb/f4/device/msc/events/MscBotResetEvent.h"
  #include "usb/f4/device/msc/events/MscBotIsReadyEvent.h"
  #include "usb/f4/device/msc/events/MscBotIsWriteProtectedEvent.h"
  #include "usb/f4/device/msc/events/MscBotGetInquiryPageEvent.h"
  #include "usb/f4/device/msc/events/MscBotGetCapacityEvent.h"
  #include "usb/f4/device/msc/events/MscBotReadEvent.h"
  #include "usb/f4/device/msc/events/MscBotWriteEvent.h"

  // MSC device includes

  #include "usb/f4/device/msc/MscScsi.h"
  #include "usb/f4/device/msc/MscDevice.h"
  #include "usb/f4/device/msc/BotMscDevice.h"

#endif

// END FILE: ../lib/include/config/usb/device/msc.h
// START FILE: ../lib/include/config/usb/device/device.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#if defined(STM32PLUS_F0_42)

  #define USE_USB_INTERRUPT

  // USB depends on gpio, event, nvic, bit hacks

  #include "config/gpio.h"
  #include "config/event.h"
  #include "config/nvic.h"
  #include "util/BitHacks.h"
  #include "util/StdExt.h"

  // core includes

  #include "usb/f0/UsbInterruptHandler.h"
  #include "usb/f0/UsbSelfPoweredFeature.h"
  #include "usb/f0/UsbDefs.h"
  #include "usb/f0/UsbStatusType.h"
  #include "usb/f0/UsbBufferDescriptionTableEntry.h"
  #include "usb/f0/UsbSetupHeader.h"
  #include "usb/f0/UsbInEndpointData.h"
  #include "usb/f0/UsbConfigurationFlags.h"

  // device type includes

  #include "usb/f0/hid/UsbCustomHid.h"

#elif defined(STM32PLUS_F4)

  /*
   * Don't include this file directly in application code, instead you should include the correct
   * device class (config/usb/f4/device/cdc.h, config/usb/f4/device/hid.h etc...)
   */

  #define USE_OTG_FS_INTERRUPT

  // ST driver includes

  #include "usblib/hal/inc/stm32f4xx_ll_usb.h"
  #include "usblib/hal/inc/stm32f4xx_hal_pcd.h"
  #include "usblib/hal/inc/stm32f4xx_hal_pcd_ex.h"

  #include "config/event.h"

  #include "usb/f4/UsbEventDescriptor.h"
  #include "usb/f4/UsbErrorEvent.h"
  #include "usb/f4/UsbEventSource.h"

  #include "usblib/device/core/inc/usbd_def.h"
  #include "usblib/device/core/inc/usbd_core.h"

  // usb depends on ...

  #include "config/timing.h"
  #include "config/smartptr.h"
  #include "config/rcc.h"
  #include "config/exti.h"
  #include "util/Meta.h"
  #include "util/StdExt.h"

  #include "usb/f4/device/HalUsbdStatus.h"

  #include "usb/f4/phy/features/PhyFeatureBase.h"
  #include "usb/f4/phy/events/OtgFsInterruptEvent.h"
  #include "usb/f4/phy/features/FsLowPowerFeature.h"
  #include "usb/f4/phy/features/InternalFsPhyInterruptFeature.h"
  #include "usb/f4/phy/InternalFsPhy.h"
  #include "usb/f4/core/Core.h"

  // device-level includes

  #include "usb/f4/device/DescriptorHeader.h"
  #include "usb/f4/device/ConfigurationDescriptor.h"
  #include "usb/f4/device/InterfaceDescriptor.h"
  #include "usb/f4/device/InterfaceAssociationDescriptor.h"
  #include "usb/f4/device/EndpointDescriptor.h"
  #include "usb/f4/device/DeviceDescriptor.h"
  #include "usb/f4/device/DeviceQualifierDescriptor.h"
  #include "usb/f4/device/LanguageDescriptor.h"
  #include "usb/f4/device/EndpointType.h"

  // device event includes

  #include "usb/f4/device/events/DeviceSdkNotifyEvent.h"
  #include "usb/f4/device/events/DeviceSdkEndpointEvent.h"
  #include "usb/f4/device/events/DeviceSdkOpenEndpointEvent.h"
  #include "usb/f4/device/events/DeviceSdkIsStalledEndpointEvent.h"
  #include "usb/f4/device/events/DeviceSdkDataEndpointEvent.h"
  #include "usb/f4/device/events/DeviceSdkGetLastTransferredSizeEndpointEvent.h"
  #include "usb/f4/device/events/DeviceGetDeviceDescriptorEvent.h"
  #include "usb/f4/device/events/DeviceGetLanguageDescriptorEvent.h"
  #include "usb/f4/device/events/DeviceGetDisplayStringDescriptorEvent.h"
  #include "usb/f4/device/events/DeviceSdkResetInterruptEvent.h"
  #include "usb/f4/device/events/DeviceSdkSuspendInterruptEvent.h"
  #include "usb/f4/device/events/DeviceSdkResumeInterruptEvent.h"
  #include "usb/f4/device/events/DeviceSdkSetupStageInterruptEvent.h"
  #include "usb/f4/device/events/DeviceSdkConnectInterruptEvent.h"
  #include "usb/f4/device/events/DeviceSdkDisconnectInterruptEvent.h"
  #include "usb/f4/device/events/DeviceSdkDataOutStageInterruptEvent.h"
  #include "usb/f4/device/events/DeviceSdkDataInStageInterruptEvent.h"

  #include "usb/f4/device/events/class/DeviceClassSdkInitEvent.h"
  #include "usb/f4/device/events/class/DeviceClassSdkDeInitEvent.h"
  #include "usb/f4/device/events/class/DeviceClassSdkDataInEvent.h"
  #include "usb/f4/device/events/class/DeviceClassSdkDataOutEvent.h"
  #include "usb/f4/device/events/class/DeviceClassSdkEp0ReadyEvent.h"
  #include "usb/f4/device/events/class/DeviceClassSdkEp0TxSentEvent.h"
  #include "usb/f4/device/events/class/DeviceClassSdkGetConfigurationDescriptorEvent.h"
  #include "usb/f4/device/events/class/DeviceClassSdkGetDeviceQualifierDescriptorEvent.h"
  #include "usb/f4/device/events/class/DeviceClassSdkSetupEvent.h"
  #include "usb/f4/device/events/class/DeviceClassSdkSofEvent.h"

  // device features

  #include "usb/f4/device/Device.h"
  #include "usb/f4/device/DeviceClass.h"

  #include "usb/f4/device/features/DeviceFeatureBase.h"
  #include "usb/f4/device/features/endpoints/ControlEndpointFeature.h"
  #include "usb/f4/device/features/endpoints/InEndpointFeatureBase.h"
  #include "usb/f4/device/features/endpoints/OutEndpointFeatureBase.h"
  #include "usb/f4/device/features/endpoints/InterruptInEndpointFeature.h"
  #include "usb/f4/device/features/endpoints/InterruptOutEndpointFeature.h"
  #include "usb/f4/device/features/endpoints/BulkInEndpointFeature.h"
  #include "usb/f4/device/features/endpoints/BulkOutEndpointFeature.h"
  #include "usb/f4/device/features/StringFeatureBase.h"
  #include "usb/f4/device/features/ManufacturerTextFeature.h"
  #include "usb/f4/device/features/ProductTextFeature.h"
  #include "usb/f4/device/features/SerialNumberTextFeature.h"
  #include "usb/f4/device/features/ConfigurationTextFeature.h"
  #include "usb/f4/device/features/InterfaceTextFeature.h"

#endif

// END FILE: ../lib/include/config/usb/device/device.h
// START FILE: ../lib/include/config/net_http.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This config file gets you access to the HTTP application layer feature.
 */

#if defined(STM32PLUS_F4) || defined(STM32PLUS_F1_CL_E)


// net_http depends on net, stream

#include "config/stream.h"
#include "config/net.h"

// includes for the protocol

#include "net/application/http/HttpVersion.h"
#include "net/application/http/HttpMethod.h"
#include "net/application/http/HttpServerConnection.h"
#include "net/application/http/HttpClient.h"


#endif
// END FILE: ../lib/include/config/net_http.h
// START FILE: ../lib/include/config/sram.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Include this file to get access to the SRAM functionality provided by the FSMC peripheral. A driver is
 * provided for the ISSI IS61LV25616 device.
 */

// sram depends on fsmc, memory copy, device

#include "config/fsmc.h"
#include "config/device.h"
#include "memory/MEM_DataCopy.h"

// includes for the memory devices

#include "sram/GenericSram.h"
#include "sram/IS61LV25616.h"
// END FILE: ../lib/include/config/sram.h
// START FILE: ../lib/include/config/rng.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

/**
 * @file
 * This file provides access to a random number generator. On the F4 the hardware RNG is used. On
 * the F1 we fall back to an implementation of WELL512a which has good randomness properties but
 * not good enough for secure crypto.
 */

// RNG depends on rcc, nvic, event

#include "config/rcc.h"
#include "config/nvic.h"
#include "config/event.h"

// device specific includes

#if defined(STM32PLUS_F4)

#define USE_RNG_INTERRUPT

#include "rng/f4/Rng.h"
#include "rng/f4/RngEventSource.h"
#include "rng/f4/features/RngInterruptFeature.h"

#elif defined(STM32PLUS_F1)

#include "rng/f1/Well512.h"

#else
#error "Unsupported MCU"
#endif
// END FILE: ../lib/include/config/rng.h
// START FILE: ../lib/include/config/traits.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This file is used to specify default 'traits' that are pervasive throughout a peripheral. A good example
 * is the GPIO speed (actually the rise and fall slope) which is set at a default of 50MHz.
 */


// generic implementation


#if defined(STM32PLUS_F1_HD)
  #include "traits/f1/hd/traits.h"
#elif defined(STM32PLUS_F1_CL_E)
  #include "traits/f1/cl/traits.h"
#elif defined(STM32PLUS_F1_MD)
  #include "traits/f1/md/traits.h"
#elif defined(STM32PLUS_F1_MD_VL)
  #include "traits/f1/mdvl/traits.h"
#elif defined(STM32PLUS_F4)
  #include "traits/f4/traits.h"
#elif defined(STM32PLUS_F0_51) || defined(STM32PLUS_F0_30)  || defined(STM32PLUS_F0_42)
  #include "traits/f0/traits.h"
#endif

/*
 * very important: the default custom_traits file does nothing. supply your
 * own config/custom/custom/traits.h file to override this and use the compiler
 * option -iquot <path> to ensure it gets picked up first. Use the content of this file to
 * provide your own specialisation of the PeripheralTraits structure for the peripheral
 * that you're interested in.
 */

#include "config/custom/custom_traits.h"
// END FILE: ../lib/include/config/traits.h
// START FILE: ../lib/include/config/fsmc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This config file enables access to the FSMC peripheral. Normally you don't need to include this file because
 * it will be included as a dependency of something else that uses the FSMC, for example the display drivers.
 * The FSMC is not available on the F105 and F107 devices.
 */

#if defined(STM32PLUS_F1_CL) ||   \
defined(STM32PLUS_F1_MD_VL) ||    \
    defined(STM32PLUS_F0) ||      \
    defined(STM32F427_437xx) || defined(STM32F429_439xx)

#error The FSMC is not available on the F0/F100/F105/F107/F42X/F43X
#endif


// fsmc depends on rcc, gpio

#include "config/rcc.h"
#include "config/gpio.h"

// generic peripheral includes

#include "fsmc/FsmcPeripheral.h"

// device-specific peripheral includes

#if defined(STM32PLUS_F1)
  #include "fsmc/f1/FsmcPeripheral.h"
#elif defined(STM32PLUS_F4)
  #include "fsmc/f4/FsmcAlternateFunctionMapper.h"
  #include "fsmc/f4/FsmcPeripheral.h"
#endif

// includes for the timings

#include "fsmc/FsmcAddressDataSetupTiming.h"
#include "fsmc/Fsmc8080LcdTiming.h"
#include "fsmc/FsmcNandTiming.h"
#include "fsmc/FsmcSramTiming.h"

// includes for memories

#include "fsmc/FsmcSram.h"
#include "fsmc/FsmcNand.h"
// END FILE: ../lib/include/config/fsmc.h
// START FILE: ../lib/include/config/sdcard.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Include this file to get access to the raw SDIO sdcard functionality. Support is provided for access
 * by interrupts and/or DMA. SdioDmaSdCard is provided as a utility class that pulls everything together
 * to give access to the peripheral. SDIO support is not available on the F105 and F107 devices.
 */

#if defined(STM32PLUS_F1_CL) || defined(STM32PLUS_F1_MD_VL)      // the 100/105/107 do not have SDIO
#error SDIO is not available on the F105/F107
#endif

// sdcard depends on rcc, device, gpio, nvic, dma, timing

#include "config/rcc.h"
#include "config/gpio.h"
#include "config/device.h"
#include "config/nvic.h"
#include "config/dma.h"
#include "config/timing.h"

// use interrupts

#define USE_SDIO_INTERRUPT

#if defined(STM32PLUS_F4)
  #include "sdcard/f4/SdioAlternateFunctionMapper.h"
#endif

// includes for the peripheral

#include "sdcard/SdioEventSource.h"
#include "sdcard/SdCardBase.h"

// feature includes

#include "sdcard/features/SdCardFeatureBase.h"
#include "sdcard/features/SdCardIoFeature.h"
#include "sdcard/features/SdCardSdioFeature.h"
#include "sdcard/features/SdioInterruptFeature.h"

// the template class

#include "sdcard/SdCard.h"

// utility classes

#include "sdcard/SdCardDetector.h"
#include "sdcard/SdioDmaSdCard.h"
// END FILE: ../lib/include/config/sdcard.h
// START FILE: ../lib/include/config/adc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This file gets you access to the STM32 ADC peripheral.
 */

// adc depends on rcc, dma, meta-programming utils, smart ptr

#include "config/rcc.h"
#include "config/dma.h"
#include "config/smartptr.h"
#include "util/Meta.h"

// peripheral includes

#include "adc/AdcEventSource.h"

#if defined(STM32PLUS_F0)

  #include "adc/f0/Adc.h"
  #include "adc/f0/AdcPeripheral.h"
  #include "adc/Adc1.h"

#elif defined(STM32PLUS_F1)

  // all F1 includes

  #include "adc/f1/Adc.h"
  #include "adc/f1/AdcPeripheral.h"
  #include "adc/Adc1.h"

  // additional includes for the HD range

  #if defined(STM32PLUS_F1_HD) || defined(STM32PLUS_F1_CL_E) || defined(STM32PLUS_F1_MD)
    #include "adc/Adc2.h"
  #endif

  #if defined(STM32PLUS_F1_HD)
    #include "adc/Adc3.h"
  #endif

#elif defined(STM32PLUS_F4)

  #include "adc/f4/Adc.h"
  #include "adc/f4/AdcPeripheral.h"
  #include "adc/Adc1.h"
  #include "adc/Adc2.h"
  #include "adc/Adc3.h"

#endif

// enable our handling of the ADC interrupt

#define USE_ADC_INTERRUPT

// feature includes

#include "adc/features/AdcFeatureBase.h"
#include "adc/features/AdcContinuousModeFeature.h"
#include "adc/features/AdcChannelType.h"

// device specific feature includes

#if defined(STM32PLUS_F0)

  #include "adc/features/f0/AdcChannelGpioInitialiser.h"

  #include "adc/features/f0/AdcResolutionFeature.h"
  #include "adc/features/f0/AdcTriggerFeature.h"
  #include "adc/features/f0/AdcClockModeFeature.h"
  #include "adc/features/f0/AdcRegularChannelFeature.h"
  #include "adc/features/f0/AdcDownwardChannelOrderFeature.h"
  #include "adc/features/f0/AdcBatteryVoltageFeature.h"
  #include "adc/features/f0/AdcInternalReferenceVoltageFeature.h"
  #include "adc/features/f0/AdcTemperatureSensorFeature.h"
  #include "adc/features/f0/AdcInterruptFeature.h"
  #include "adc/features/f0/AdcAnalogWatchdogFeature.h"
  #include "adc/features/f0/AdcSingleChannelAnalogWatchdogFeature.h"
  #include "adc/features/f0/AdcAllChannelsAnalogWatchdogFeature.h"
  #include "adc/features/f0/AdcAutoPowerOffFeature.h"
  #include "adc/features/f0/AdcAutoDelayFeature.h"

#elif defined(STM32PLUS_F1)

  #include "adc/features/f1/AdcChannelGpioInitialiser.h"

  #include "adc/features/f1/AdcClockPrescalerFeature.h"
  #include "adc/features/f1/AdcTriggerFeature.h"
  #include "adc/features/f1/AdcDualFeature.h"
  #include "adc/features/f1/AdcRegularChannelFeature.h"
  #include "adc/features/f1/AdcScanModeFeature.h"
  #include "adc/features/f1/AdcInterruptFeature.h"
  #include "adc/features/f1/AdcTemperatureSensorFeature.h"
  #include "adc/features/f1/AdcInternalReferenceVoltageFeature.h"
  #include "adc/features/f1/AdcInjectedChannelFeatureBase.h"
  #include "adc/features/f1/AdcInjectedChannelFeature.h"
  #include "adc/features/f1/AdcInjectedTriggerFeature.h"
  #include "adc/features/f1/AdcAnalogWatchdogFeature.h"
  #include "adc/features/f1/AdcSingleChannelAnalogWatchdogFeature.h"
  #include "adc/features/f1/AdcAllChannelsAnalogWatchdogFeature.h"

#elif defined(STM32PLUS_F4)

  #include "adc/features/f4/AdcChannelGpioInitialiser.h"

  #include "adc/features/f4/AdcResolutionFeature.h"
  #include "adc/features/f4/AdcTriggerFeature.h"
  #include "adc/features/f4/AdcClockPrescalerFeature.h"
  #include "adc/features/f4/AdcMultiFeature.h"
  #include "adc/features/f4/AdcDualFeature.h"
  #include "adc/features/f4/AdcTripleFeature.h"

  #include "adc/features/f4/AdcRegularChannelFeature.h"
  #include "adc/features/f4/AdcScanModeFeature.h"
  #include "adc/features/f4/AdcInterruptFeature.h"
  #include "adc/features/f4/AdcInjectedChannelFeatureBase.h"
  #include "adc/features/f4/AdcInjectedChannelFeature.h"
  #include "adc/features/f4/AdcInjectedTriggerFeature.h"
  #include "adc/features/f4/AdcBatteryVoltageFeature.h"
  #include "adc/features/f4/AdcInternalReferenceVoltageFeature.h"
  #include "adc/features/f4/AdcTemperatureSensorFeature.h"
  #include "adc/features/f4/AdcAnalogWatchdogFeature.h"
  #include "adc/features/f4/AdcSingleChannelAnalogWatchdogFeature.h"
  #include "adc/features/f4/AdcAllChannelsAnalogWatchdogFeature.h"

#endif

// END FILE: ../lib/include/config/adc.h
// START FILE: ../lib/include/config/exti.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This config file provides access to the EXTI (external interrupt) peripheral functionality. EXTI is
 * typically the best choice for interfacing any peripheral that provides an "I've been activated" line
 * that changes state when it has something to tell you. Push-buttons are another good example.
 */

// exti depends on gpio, event, nvic

#include "config/gpio.h"
#include "config/event.h"
#include "config/nvic.h"

// enable all interrupts

#define USE_EXTI0_INTERRUPT
#define USE_EXTI0_1_INTERRUPT
#define USE_EXTI1_INTERRUPT
#define USE_EXTI2_INTERRUPT
#define USE_EXTI2_3_INTERRUPT
#define USE_EXTI3_INTERRUPT
#define USE_EXTI4_INTERRUPT
#define USE_EXTI4_15_INTERRUPT
#define USE_EXTI9_5_INTERRUPT
#define USE_EXTI15_10_INTERRUPT
#define USE_EXTI_PVD_INTERRUPT
#define USE_EXTI_RTC_ALARM_INTERRUPT
#define USE_EXTI_RTC_INTERRUPT
#define USE_EXTI_USB_FS_WAKEUP_INTERRUPT
#define USE_EXTI_OTG_FS_WAKEUP_INTERRUPT      // CL only
#define USE_EXTI_ETH_WAKEUP_INTERRUPT
#define USE_EXTI_USB_HS_WAKEUP_INTERRUPT
#define USE_EXTI_TAMP_STAMP_INTERRUPT
#define USE_EXTI_RTC_WAKEUP_INTERRUPT

// common peripheral includes

#include "exti/ExtiPeripheralBase.h"

// device-specific includes

#if defined(STM32PLUS_F1)
  #include "exti/f1/ExtiInterruptEnabler.h"
  #include "exti/f1/ExtiPeripheral.h"
#elif defined(STM32PLUS_F4)
  #include "exti/f4/ExtiInterruptEnabler.h"
  #include "exti/f4/ExtiPeripheral.h"
#elif defined(STM32PLUS_F0)
  #include "exti/f0/ExtiInterruptEnabler.h"
  #include "exti/f0/ExtiPeripheral.h"
#endif

// END FILE: ../lib/include/config/exti.h
// START FILE: ../lib/include/config/dma.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This file provides access to all DMA functionality. Normally you don't have to include this file because it's included
 * as a dependency of any peripheral that has DMA access. An exception is if you're planning to use memory-to-memory
 * fill or copy. In those cases you do need to include this file.
 */

// dma depends on rcc, nvic, event, smart pointers, Timer

#include "config/rcc.h"
#include "config/nvic.h"
#include "config/event.h"
#include "config/timer.h"

#include "memory/scoped_array.h"

// generic includes

#include "dma/DmaEventSource.h"
#include "dma/features/DmaLcdWriter.h"

// device-specific peripheral includes

#if defined(STM32PLUS_F1)

  #define USE_DMA1_1_INTERRUPT
  #define USE_DMA1_2_INTERRUPT
  #define USE_DMA1_3_INTERRUPT
  #define USE_DMA1_4_INTERRUPT
  #define USE_DMA1_5_INTERRUPT
  #define USE_DMA1_6_INTERRUPT
  #define USE_DMA1_7_INTERRUPT
  #define USE_DMA2_1_INTERRUPT
  #define USE_DMA2_2_INTERRUPT
  #define USE_DMA2_3_INTERRUPT
  #define USE_DMA2_4_INTERRUPT        // CL only
  #define USE_DMA2_5_INTERRUPT        // CL only
  #define USE_DMA2_4_5_INTERRUPT      // non-CL only

  #include "dma/f1/Dma.h"
  #include "dma/features/DmaFeatureBase.h"

  #include "dma/f1/Dma1Channel1.h"
  #include "dma/f1/Dma1Channel2.h"
  #include "dma/f1/Dma1Channel3.h"
  #include "dma/f1/Dma1Channel4.h"
  #include "dma/f1/Dma1Channel5.h"
  #include "dma/f1/Dma1Channel6.h"
  #include "dma/f1/Dma1Channel7.h"
  #include "dma/f1/Dma2Channel1.h"
  #include "dma/f1/Dma2Channel2.h"
  #include "dma/f1/Dma2Channel3.h"
  #include "dma/f1/Dma2Channel4.h"
  #include "dma/f1/Dma2Channel5.h"

  #if defined(STM32PLUS_F1_HD) || defined(STM32PLUS_FL_XL)
    #include "dma/features/f1/xl_hd/DmaInterruptFeature.h"
  #elif defined(STM32PLUS_F1_CL)
    #include "dma/features/f1/cl/DmaInterruptFeature.h"
#elif defined(STM32PLUS_F1_MD)
#include "dma/features/f1/md/DmaInterruptFeature.h"
  #elif defined(STM32PLUS_F1_MD_VL)
    #include "dma/features/f1/mdvl/DmaInterruptFeature.h"
  #endif

  #include "dma/features/f1/Dma1Channel1InterruptFeature.h"
  #include "dma/features/f1/Dma1Channel2InterruptFeature.h"
  #include "dma/features/f1/Dma1Channel3InterruptFeature.h"
  #include "dma/features/f1/Dma1Channel4InterruptFeature.h"
  #include "dma/features/f1/Dma1Channel5InterruptFeature.h"
  #include "dma/features/f1/Dma1Channel6InterruptFeature.h"
  #include "dma/features/f1/Dma1Channel7InterruptFeature.h"
  #include "dma/features/f1/Dma2Channel1InterruptFeature.h"
  #include "dma/features/f1/Dma2Channel2InterruptFeature.h"
  #include "dma/features/f1/Dma2Channel3InterruptFeature.h"
  #include "dma/features/f1/Dma2Channel4InterruptFeature.h"
  #include "dma/features/f1/Dma2Channel5InterruptFeature.h"

  #include "dma/features/f1/DmaMemoryCopyBaseFeature.h"
  #include "dma/features/f1/TimerDmaFeature.h"
  #include "dma/features/f1/UsartDmaReaderFeature.h"
  #include "dma/features/f1/UsartDmaWriterFeature.h"
  #include "dma/features/f1/SpiDmaReaderFeature.h"
  #include "dma/features/f1/SpiDmaWriterFeature.h"
  #include "dma/features/f1/I2CDmaReaderFeature.h"
  #include "dma/features/f1/I2CDmaWriterFeature.h"
  #include "dma/features/f1/I2SDmaReaderFeature.h"
  #include "dma/features/f1/I2SDmaWriterFeature.h"
  #include "dma/features/f1/SdioDmaReaderFeature.h"
  #include "dma/features/f1/SdioDmaWriterFeature.h"
  #include "dma/features/f1/DmaFsmcLcdMemoryCopyFeature.h"
  #include "dma/features/f1/AdcDmaFeature.h"
  #include "dma/features/f1/AdcMultiDmaFeature.h"
  #include "dma/features/f1/DacDmaWriterFeature.h"

  #include "dma/features/f1/DmaPeripheralInfo.h"

#elif defined(STM32PLUS_F4)

  #define USE_DMA1_0_INTERRUPT
  #define USE_DMA1_1_INTERRUPT
  #define USE_DMA1_2_INTERRUPT
  #define USE_DMA1_3_INTERRUPT
  #define USE_DMA1_4_INTERRUPT
  #define USE_DMA1_5_INTERRUPT
  #define USE_DMA1_6_INTERRUPT
  #define USE_DMA1_7_INTERRUPT
  #define USE_DMA2_0_INTERRUPT
  #define USE_DMA2_1_INTERRUPT
  #define USE_DMA2_2_INTERRUPT
  #define USE_DMA2_3_INTERRUPT
  #define USE_DMA2_4_INTERRUPT
  #define USE_DMA2_5_INTERRUPT
  #define USE_DMA2_6_INTERRUPT
  #define USE_DMA2_7_INTERRUPT

  #include "dma/f4/Dma.h"
  #include "dma/features/DmaFeatureBase.h"

  #include "dma/f4/DmaIncludes.h"

  #include "dma/features/f4/DmaInterruptFeature.h"
  #include "dma/features/f4/Dma1Stream0InterruptFeature.h"
  #include "dma/features/f4/Dma1Stream1InterruptFeature.h"
  #include "dma/features/f4/Dma1Stream2InterruptFeature.h"
  #include "dma/features/f4/Dma1Stream3InterruptFeature.h"
  #include "dma/features/f4/Dma1Stream4InterruptFeature.h"
  #include "dma/features/f4/Dma1Stream5InterruptFeature.h"
  #include "dma/features/f4/Dma1Stream6InterruptFeature.h"
  #include "dma/features/f4/Dma1Stream7InterruptFeature.h"
  #include "dma/features/f4/Dma2Stream0InterruptFeature.h"
  #include "dma/features/f4/Dma2Stream1InterruptFeature.h"
  #include "dma/features/f4/Dma2Stream2InterruptFeature.h"
  #include "dma/features/f4/Dma2Stream3InterruptFeature.h"
  #include "dma/features/f4/Dma2Stream4InterruptFeature.h"
  #include "dma/features/f4/Dma2Stream5InterruptFeature.h"
  #include "dma/features/f4/Dma2Stream6InterruptFeature.h"
  #include "dma/features/f4/Dma2Stream7InterruptFeature.h"

  #include "dma/features/f4/DmaMemoryCopyBaseFeature.h"
  #include "dma/features/f4/TimerDmaFeature.h"
  #include "dma/features/f4/UsartDmaReaderFeature.h"
  #include "dma/features/f4/UsartDmaWriterFeature.h"
  #include "dma/features/f4/SpiDmaReaderFeature.h"
  #include "dma/features/f4/SpiDmaWriterFeature.h"
  #include "dma/features/f4/I2CDmaReaderFeature.h"
  #include "dma/features/f4/I2CDmaWriterFeature.h"
  #include "dma/features/f4/I2SDmaReaderFeature.h"
  #include "dma/features/f4/I2SDmaWriterFeature.h"
  #include "dma/features/f4/SdioDmaReaderFeature.h"
  #include "dma/features/f4/SdioDmaWriterFeature.h"
  #include "dma/features/f4/DmaFsmcLcdMemoryCopyFeature.h"
  #include "dma/features/f4/AdcDmaFeature.h"
  #include "dma/features/f4/AdcMultiDmaFeature.h"

#if defined(STM32PLUS_F4_HAS_DAC)
  #include "dma/features/f4/DacDmaWriterFeature.h"
#endif

  #include "dma/features/f4/DmaPeripheralInfo.h"

#elif defined(STM32PLUS_F0)

  #define USE_DMA1_1_INTERRUPT
  #define USE_DMA1_2_3_INTERRUPT
  #define USE_DMA1_4_5_INTERRUPT

  #include "dma/f0/Dma.h"
  #include "dma/features/DmaFeatureBase.h"

  #include "dma/f0/Dma1Channel1.h"
  #include "dma/f0/Dma1Channel2.h"
  #include "dma/f0/Dma1Channel3.h"
  #include "dma/f0/Dma1Channel4.h"
  #include "dma/f0/Dma1Channel5.h"

   #include "dma/features/f0/DmaInterruptFeature.h"

  #include "dma/features/f0/Dma1Channel1InterruptFeature.h"
  #include "dma/features/f0/Dma1Channel2InterruptFeature.h"
  #include "dma/features/f0/Dma1Channel3InterruptFeature.h"
  #include "dma/features/f0/Dma1Channel4InterruptFeature.h"
  #include "dma/features/f0/Dma1Channel5InterruptFeature.h"

  #include "dma/features/f0/DmaMemoryCopyBaseFeature.h"
  #include "dma/features/f0/TimerDmaFeature.h"
  #include "dma/features/f0/UsartDmaReaderFeature.h"
  #include "dma/features/f0/UsartDmaWriterFeature.h"
  #include "dma/features/f0/SpiDmaReaderFeature.h"
  #include "dma/features/f0/SpiDmaWriterFeature.h"
  #include "dma/features/f0/I2CDmaReaderFeature.h"
  #include "dma/features/f0/I2CDmaWriterFeature.h"
  #include "dma/features/f0/AdcDmaFeature.h"

#if !(defined(STM32PLUS_F0_30) || defined(STM32PLUS_F0_42))
  #include "dma/features/f0/DacDmaWriterFeature.h"
#endif

  #include "dma/features/f0/DmaPeripheralInfo.h"

#endif

// includes for the features

#include "dma/features/DmaMemoryCopyFeature.h"
#include "dma/features/DmaMemoryFillFeature.h"
#include "dma/features/PwmFadeTimerDmaFeature.h"
// END FILE: ../lib/include/config/dma.h
// START FILE: ../lib/include/config/power.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Include this config file to get access to the power management functionality of the STM32. Low power modes
 * allow you to put the STM32 into its sleep or stop mode.
 */

// power depends on rcc

#include "config/rcc.h"

// generic includes for the peripheral

#if defined(STM32PLUS_F0)
  #include "pwr/f0/LowPowerModes.h"
#elif defined(STM32PLUS_F1) || defined(STM32PLUS_F4)
  #include "pwr/f1,f4/LowPowerModes.h"
#endif
// END FILE: ../lib/include/config/power.h
// START FILE: ../lib/include/config/device.h
#/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This file gives access to the low-level block device drivers and streams. You normally don't have to include
 * this config file as it's included for you as a dependency of something else such as the filesystem drivers.
 */

// device depends on filesystem MBR, memory copy, memblock, stream

#include "filesystem/MbrPartition.h"
#include "filesystem/Mbr.h"
#include "memory/MEM_DataCopy.h"
#include "memory/Memblock.h"
#include "config/stream.h"

// includes for the feature

#include "device/BlockDevice.h"
#include "device/CachedBlockDevice.h"

// includes for the extra classes

#include "device/BlockDeviceOutputStream.h"
#include "device/BlockDeviceInputStream.h"
// END FILE: ../lib/include/config/device.h
// START FILE: ../lib/include/config/concurrent.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


/**
 * @file
 * This config file gives access to the concurrency-related utility classes such as Mutex, Critical Section
 * and other classes. These are useful when sharing data between IRQ and normal code paths.
 */

#include "config/timing.h"

#include "concurrent/CriticalSection.h"
#include "concurrent/atomic.h"
#include "concurrent/IrqSuspend.h"

// mutex only on cortex M3 and above due to the need for strex/ldrex* instructions

#if !defined(STM32PLUS_F0)
  #include "concurrent/Mutex.h"
#endif
// END FILE: ../lib/include/config/concurrent.h
// START FILE: ../lib/include/config/crc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This file gets you access to the CRC peripheral functionality. Big-endian and little-endian
 * calculation is supported.
 */

// CRC depends on output stream

#include "config/stream.h"

// generic peripheral includes

#include "crc/CrcBase.h"
#include "crc/CrcPeripheral.h"
#include "crc/BigEndianCrc.h"
#include "crc/LittleEndianCrc.h"

// utility classes

#include "crc/CrcOutputStream.h"
// END FILE: ../lib/include/config/crc.h
// START FILE: ../lib/include/config/filesystem.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * Include this config file to get access to all the filesytem functionality. At present this grants you access
 * to the FAT16 and FAT32 functionality.
 */

// filesystem depends on iterator, stream, device, timing, string

#include "config/iterator.h"
#include "config/stream.h"
#include "config/device.h"
#include "config/timing.h"
#include "config/string.h"

// includes for the feature

#include "filesystem/File.h"
#include "filesystem/FileInformation.h"
#include "filesystem/DirectoryIterator.h"
#include "filesystem/FileInputStream.h"
#include "filesystem/FileOutputStream.h"
#include "filesystem/FileReader.h"
#include "filesystem/OwnedFileInputStream.h"
#include "filesystem/OwnedFileOutputStream.h"
#include "filesystem/MbrPartition.h"
#include "filesystem/Mbr.h"
#include "filesystem/TokenisedPathname.h"
#include "filesystem/FileSystem.h"

#include "filesystem/fat/BootSector16.h"
#include "filesystem/fat/BootSector32.h"
#include "filesystem/fat/BootSector.h"


#include "filesystem/fat/LongDirectoryEntry.h"
#include "filesystem/fat/ShortDirectoryEntry.h"
#include "filesystem/fat/DirectoryEntry.h"
#include "filesystem/fat/DirectoryEntryWithLocation.h"
#include "filesystem/fat/FilenameHandler.h"
#include "filesystem/fat/DirectoryEntryIterator.h"

#include "filesystem/fat/ClusterChainIterator.h"
#include "filesystem/fat/FatFileInformation.h"
#include "filesystem/fat/FatIterator.h"
#include "filesystem/fat/FileSectorIterator.h"
#include "filesystem/fat/LongNameDirentGenerator.h"
#include "filesystem/fat/NormalDirectoryEntryIterator.h"

#include "filesystem/fat/FreeClusterFinder.h"
#include "filesystem/fat/IteratingFreeClusterFinder.h"
#include "filesystem/fat/LinearFreeClusterFinder.h"
#include "filesystem/fat/WearResistFreeClusterFinder.h"

#include "filesystem/fat/FatFile.h"
#include "filesystem/fat/FatFileSystem.h"
#include "filesystem/fat/FatFileSystemFormatter.h"

#include "filesystem/fat/Fat32FsInfo.h"
#include "filesystem/fat/Fat32FileSystem.h"
#include "filesystem/fat/Fat32FileSystemFormatter.h"

#include "filesystem/fat/Fat16FileSystem.h"
#include "filesystem/fat/Fat16FileSystemFormatter.h"
#include "filesystem/fat/Fat16RootDirectoryEntryIterator.h"
#include "filesystem/fat/FatDirectoryIterator.h"
// END FILE: ../lib/include/config/filesystem.h
// START FILE: ../lib/include/config/nvic.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This config file gets you access to the NVIC peripheral functionality. The initialise function is used
 * to start up the Nvic with the priority grouping of your choice. The default is to start up in
 * NVIC_PriorityGroup_4 which provides 4 bits for interrupt priority and none for sub-priority. You can
 * change this to whatever you need.
 */

// generic includes for the peripheral

#if defined(STM32PLUS_F1)
  #include "nvic/f1/NvicPeripheral.h"
#elif defined(STM32PLUS_F4)
  #include "nvic/f4/NvicPeripheral.h"
#elif defined(STM32PLUS_F0)
  #include "nvic/f0/NvicPeripheral.h"
#else
  #error Unsupported MCU
#endif
// END FILE: ../lib/include/config/nvic.h
// START FILE: ../lib/include/config/fx.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

/**
 * @file
 * This config file gets you access to the 'easing functions' that can be used to provide smooth animation
 * acceleration and deceleration algorithms that you see all over the place these days in everything from
 * PC GUIs to smartphones. The 'pframe' example uses easing functions to scroll in the next image.
 */

// fx depends on timing, math

#include "config/timing.h"
#include <math.h>

// sometimes absent from C++0x depending on source compatibility level

#if !defined(M_PI)
#define M_PI    3.14159265358979323846
#endif

#if !defined(M_PI_2)
#define M_PI_2    1.57079632679489661923
#endif

// includes for the feature

#include "fx/easing/EasingBase.h"
#include "fx/easing/BackEase.h"
#include "fx/easing/BounceEase.h"
#include "fx/easing/CircularEase.h"
#include "fx/easing/CubicEase.h"
#include "fx/easing/ElasticEase.h"
#include "fx/easing/ExponentialEase.h"
#include "fx/easing/LinearEase.h"
#include "fx/easing/QuadraticEase.h"
#include "fx/easing/QuarticEase.h"
#include "fx/easing/QuinticEase.h"
#include "fx/easing/SineEase.h"
// END FILE: ../lib/include/config/fx.h
// START FILE: ../lib/include/config/mcu_defines.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


/**
 * Use the selected MCU family to set up other definitions used to include and exclude
 * features. Some are used by stm32plus and some are used by the ST peripheral and CMSIS
 * libraries.
 *
 * The _HAS_ macros are considered private to stm32plus and may change without warning
 * with new library releases.
 */


#if defined(STM32PLUS_F1_HD)
  #define STM32PLUS_F1                // enable features common to all F1
  #define STM32F10X_HD                // for the std peripheral library

#elif defined(STM32PLUS_F1_CL_E)
  #define STM32PLUS_F1                // enable features common to all F1
  #define STM32PLUS_F1_CL             // enable features common to F105 and F107
  #define STM32F10X_CL                // for the std peripheral library

#elif defined(STM32PLUS_F1_MD_VL)
  #define STM32PLUS_F1                // enable features common to all F1
  #define STM32PLUS_F1_VL             // enable features common to all VL devices
  #define STM32F10X_MD_VL             // for the std peripheral library

#elif defined(STM32PLUS_F1_MD)
  #define STM32PLUS_F1                // enable features common to all F1
  #define STM32F10X_MD                // for the std peripheral library

#elif defined(STM32PLUS_F0_51) || defined(STM32PLUS_F0_30)
  #define STM32PLUS_F0                // enable features common to all F0
  #define STM32F0XX_MD                // these are medium density devices
#elif defined(STM32PLUS_F0_42)
  #define STM32PLUS_F0
  #define STM32F0XX
#elif defined(STM32PLUS_F405)
  #define STM32PLUS_F4
  #define STM32F405xx
  #define STM32F40_41xxx
  #define STM32PLUS_F4_HAS_CAN
  #define STM32PLUS_F4_HAS_ADC2_3
  #define STM32PLUS_F4_HAS_USART3_4_5
  #define STM32PLUS_F4_HAS_GPIOF_G_I
  #define STM32PLUS_F4_HAS_TIM6_7_8_12_13_14
  #define STM32PLUS_F4_HAS_OTG_HS
  #define STM32PLUS_F4_HAS_DAC
  #define STM32PLUS_F4_HAS_FSMC

#elif defined(STM32PLUS_F407)
  #define STM32PLUS_F4
  #define STM32F407xx
  #define STM32F40_41xxx
  #define STM32PLUS_F4_HAS_MAC
  #define STM32PLUS_F4_HAS_DCMI
  #define STM32PLUS_F4_HAS_CAN
  #define STM32PLUS_F4_HAS_ADC2_3
  #define STM32PLUS_F4_HAS_USART3_4_5
  #define STM32PLUS_F4_HAS_GPIOF_G_I
  #define STM32PLUS_F4_HAS_TIM6_7_8_12_13_14
  #define STM32PLUS_F4_HAS_OTG_HS
  #define STM32PLUS_F4_HAS_DAC
  #define STM32PLUS_F4_HAS_FSMC

#elif defined(STM32PLUS_F415)
  #define STM32PLUS_F4
  #define STM32F415xx
  #define STM32F40_41xxx
  #define STM32PLUS_F4_HAS_CRYPTO
  #define STM32PLUS_F4_HAS_CAN
  #define STM32PLUS_F4_HAS_ADC2_3
  #define STM32PLUS_F4_HAS_USART3_4_5
  #define STM32PLUS_F4_HAS_GPIOF_G_I
  #define STM32PLUS_F4_HAS_TIM6_7_8_12_13_14
  #define STM32PLUS_F4_HAS_OTG_HS
  #define STM32PLUS_F4_HAS_DAC
  #define STM32PLUS_F4_HAS_FSMC

#elif defined(STM32PLUS_F417)
  #define STM32PLUS_F4
  #define STM32F417xx
  #define STM32F40_41xxx
  #define STM32PLUS_F4_HAS_MAC
  #define STM32PLUS_F4_HAS_DCMI
  #define STM32PLUS_F4_HAS_CRYPTO
  #define STM32PLUS_F4_HAS_CAN
  #define STM32PLUS_F4_HAS_ADC2_3
  #define STM32PLUS_F4_HAS_USART3_4_5
  #define STM32PLUS_F4_HAS_GPIOF_G_I
  #define STM32PLUS_F4_HAS_TIM6_7_8_12_13_14
  #define STM32PLUS_F4_HAS_OTG_HS
  #define STM32PLUS_F4_HAS_DAC
  #define STM32PLUS_F4_HAS_FSMC

#elif defined(STM32PLUS_F427)
  #define STM32PLUS_F4
  #define STM32F427xx
  #define STM32F427_437xx
  #define STM32PLUS_F4_HAS_MAC
  #define STM32PLUS_F4_HAS_DCMI
  #define STM32PLUS_F4_HAS_SAI
  #define STM32PLUS_F4_HAS_DMA2D
  #define STM32PLUS_F4_HAS_CAN
  #define STM32PLUS_F4_HAS_ADC2_3
  #define STM32PLUS_F4_HAS_USART3_4_5
  #define STM32PLUS_F4_HAS_GPIOF_G_I
  #define STM32PLUS_F4_HAS_GPIOJ_K
  #define STM32PLUS_F4_HAS_TIM6_7_8_12_13_14
  #define STM32PLUS_F4_HAS_OTG_HS
  #define STM32PLUS_F4_HAS_DAC
  #define STM32PLUS_F4_HAS_FMC

#elif defined(STM32PLUS_F429)
  #define STM32PLUS_F4
  #define STM32F429xx
  #define STM32F429_439xx
  #define STM32PLUS_F4_HAS_MAC
  #define STM32PLUS_F4_HAS_DCMI
  #define STM32PLUS_F4_HAS_SAI
  #define STM32PLUS_F4_HAS_LTDC
  #define STM32PLUS_F4_HAS_DMA2D
  #define STM32PLUS_F4_HAS_CAN
  #define STM32PLUS_F4_HAS_ADC2_3
  #define STM32PLUS_F4_HAS_USART3_4_5
  #define STM32PLUS_F4_HAS_GPIOF_G_I
  #define STM32PLUS_F4_HAS_GPIOJ_K
  #define STM32PLUS_F4_HAS_TIM6_7_8_12_13_14
  #define STM32PLUS_F4_HAS_OTG_HS
  #define STM32PLUS_F4_HAS_DAC
  #define STM32PLUS_F4_HAS_FMC

#elif defined(STM32PLUS_F437)
  #define STM32PLUS_F4
  #define STM32F437xx
  #define STM32F427_437xx
  #define STM32PLUS_F4_HAS_MAC
  #define STM32PLUS_F4_HAS_DCMI
  #define STM32PLUS_F4_HAS_SAI
  #define STM32PLUS_F4_HAS_CRYPTO
  #define STM32PLUS_F4_HAS_DMA2D
  #define STM32PLUS_F4_HAS_CAN
  #define STM32PLUS_F4_HAS_ADC2_3
  #define STM32PLUS_F4_HAS_USART3_4_5
  #define STM32PLUS_F4_HAS_GPIOF_G_I
  #define STM32PLUS_F4_HAS_GPIOJ_K
  #define STM32PLUS_F4_HAS_TIM6_7_8_12_13_14
  #define STM32PLUS_F4_HAS_OTG_HS
  #define STM32PLUS_F4_HAS_DAC
  #define STM32PLUS_F4_HAS_FMC

#elif defined(STM32PLUS_F439)
  #define STM32PLUS_F4
  #define STM32F439xx
  #define STM32F429_439xx
  #define STM32PLUS_F4_HAS_MAC
  #define STM32PLUS_F4_HAS_DCMI
  #define STM32PLUS_F4_HAS_SAI
  #define STM32PLUS_F4_HAS_CRYPTO
  #define STM32PLUS_F4_HAS_LTDC
  #define STM32PLUS_F4_HAS_DMA2D
  #define STM32PLUS_F4_HAS_CAN
  #define STM32PLUS_F4_HAS_ADC2_3
  #define STM32PLUS_F4_HAS_USART3_4_5
  #define STM32PLUS_F4_HAS_GPIOF_G_I
  #define STM32PLUS_F4_HAS_GPIOJ_K
  #define STM32PLUS_F4_HAS_TIM6_7_8_12_13_14
  #define STM32PLUS_F4_HAS_OTG_HS
  #define STM32PLUS_F4_HAS_DAC
  #define STM32PLUS_F4_HAS_FMC

#else
  #error "You must define an MCU type. See config/stm32plus.h"
#endif
// END FILE: ../lib/include/config/mcu_defines.h
// START FILE: ../lib/include/config/flash/internal.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This config file gets you access to the internal flash memory device. Please note that the internal flash
 * on all STM32 models is rated for 10000 erase/program operations on each page.
 */

// internal flash depends on CRC

#include "config/crc.h"

// device specific includes

#if defined(STM32PLUS_F0)

  #include "flash/internal/f0/InternalFlashPeripheral.h"
  #include "flash/internal/f0/InternalFlashDevice.h"

#elif defined(STM32PLUS_F1)

  #include "flash/internal/f1/InternalFlashPeripheral.h"
  #include "flash/internal/f1/InternalFlashDevice.h"

#elif defined(STM32PLUS_F4)

  #include "flash/internal/f4/InternalFlashVoltageRange.h"
  #include "flash/internal/f4/InternalFlashSectorMap.h"
  #include "flash/internal/f4/InternalFlashPeripheral.h"
  #include "flash/internal/f4/InternalFlashDevice.h"

#endif

// generic feature includes

#include "flash/internal/features/InternalFlashFeatureBase.h"
#include "flash/internal/features/InternalFlashLockFeature.h"

// device specific features

#if defined(STM32PLUS_F0)

  #include "flash/internal/f0/features/InternalFlashWriteFeature.h"

#elif defined(STM32PLUS_F1)

  #include "flash/internal/f1/features/InternalFlashWriteFeature.h"

#elif defined(STM32PLUS_F4)

  #include "flash/internal/f4/features/InternalFlashWriteFeature.h"

#endif

// general utilities

#include "flash/internal/InternalFlashWordWriter.h"
#include "flash/internal/InternalFlashSettingsStorage.h"
// END FILE: ../lib/include/config/flash/internal.h
// START FILE: ../lib/include/config/flash/spi.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

/**
 * @file
 * This config file gets you access to the flash memory interfaces. Support is provided for the Atmel AT45DB161D
 * serial flash device and the Samsung K9F1G08Q0C NAND flash device.
 */

// spi flash depends on spi, timing, stream

#include "config/spi.h"
#include "config/timing.h"
#include "config/stream.h"

// include the main classes

#include "flash/spi/Base.h"
#include "flash/spi/Command.h"
#include "flash/spi/SpiFlashDevice.h"

// include the 'standard' commands

#include "flash/spi/commands/Commands.h"
#include "flash/spi/commands/WriteStatusRegister.h"
#include "flash/spi/commands/WriteEnable.h"
#include "flash/spi/commands/WriteDisable.h"
#include "flash/spi/commands/PageProgram.h"
#include "flash/spi/commands/ReadStatusRegister.h"
#include "flash/spi/commands/Read.h"
#include "flash/spi/commands/FastRead.h"
#include "flash/spi/commands/SectorErase.h"
#include "flash/spi/commands/BlockErase.h"
#include "flash/spi/commands/ChipErase.h"
#include "flash/spi/commands/ReadJedecId.h"
#include "flash/spi/commands/DeepPowerDown.h"
#include "flash/spi/commands/ReleaseDeepPowerDown.h"

// include the manufacturer devices

#include "flash/spi/devices/StandardSpiFlashDevice.h"

#include "flash/spi/devices/w25q16dw/Commands.h"
#include "flash/spi/devices/w25q16dw/EraseSuspend.h"
#include "flash/spi/devices/w25q16dw/EraseResume.h"
#include "flash/spi/devices/w25q16dw/W25Q16DW.h"

#include "flash/spi/devices/s25fl208k/Commands.h"
#include "flash/spi/devices/s25fl208k/S25FL208K.h"

// include the stream class

#include "flash/spi/SpiFlashInputStream.h"
// END FILE: ../lib/include/config/flash/spi.h
// START FILE: ../lib/include/config/usart.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

/**
 * @file
 * Include this file to get access to the USART peripherals. All peripherals are exposed with all the
 * alternate-function pin mappings. Access via interrupts and DMA are both supported and there's an
 * input and an output stream to help access in polling mode.
 */

// usart depends on rcc, gpio, stream, interrupts, dma

#include "config/rcc.h"
#include "config/gpio.h"
#include "config/stream.h"
#include "config/dma.h"

// device-specific pin initialiser

#if defined(STM32PLUS_F1)

  #include "usart/f1/UsartPinInitialiser.h"

#elif defined(STM32PLUS_F4)

  #include "usart/f4/UsartAlternateFunctionMapper.h"
  #include "usart/f4/UsartPinInitialiser.h"

#elif defined(STM32PLUS_F0)

  #include "usart/f0/UsartAlternateFunctionMapper.h"
  #include "usart/f0/UsartPinInitialiser.h"

#endif

// generic peripheral includes

#include "usart/UsartEventSource.h"
#include "usart/Usart.h"
#include "usart/UsartPeripheral.h"

// generic feature includes

#include "usart/features/UsartFeatureBase.h"

// generic peripheral includes

#if defined(STM32PLUS_F0)
  #include "usart/f0/Usart1.h"
  #include "usart/f0/Usart2.h"
  #include "usart/f0/Usart3.h"
  #include "usart/f0/Usart2Remap2PinPackage.h"
#else
  #include "usart/Uart4.h"
  #include "usart/Uart5.h"
#endif

#if defined(STM32PLUS_F1)
  #include "usart/f1/Usart1.h"
  #include "usart/f1/Usart2.h"
  #include "usart/f1/Usart3.h"
#endif

// enable all interrupt handlers

#define USE_USART1_INTERRUPT
#define USE_USART2_INTERRUPT
#define USE_USART3_INTERRUPT
#define USE_UART4_INTERRUPT
#define USE_UART5_INTERRUPT

// device specific includes

#if defined(STM32PLUS_F1_XL) || defined(STM32PLUS_F1_HD) || defined(STM32PLUS_F1_CL)

  #include "usart/features/f1/xl_hd_cl/UsartInterruptFeature.h"

#elif defined(STM32PLUS_F1_MD) || defined(STM32PLUS_F1_MD_VL)

  #include "usart/features/f1/mdvl/UsartInterruptFeature.h"

#elif defined(STM32PLUS_F4)

  #define USE_USART6_INTERRUPT

  #include "usart/f4/Usart1.h"
  #include "usart/f4/Usart2.h"
  #include "usart/f4/Usart3.h"
  #include "usart/f4/Usart6.h"

  #include "usart/features/f4/UsartInterruptFeature.h"

#elif defined(STM32PLUS_F0)

  #include "usart/features/f0/UsartInterruptFeature.h"

#endif

// utility classes

#include "usart/UsartPollingInputStream.h"
#include "usart/UsartPollingOutputStream.h"
// END FILE: ../lib/include/config/usart.h
// START FILE: ../lib/include/sram/IS61LV25616.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Implementation of the ISSI IS61LV25616 256K x 16 (4Mbit) SRAM
   */

  template<class TFsmc>
  class IS61LV25616 : public GenericSram<TFsmc> {

    public:

      /**
       * Access time of this device. Used for setting up the FSMC timing
       */

      enum AccessTime {
        /// 10ns
        TEN_NS,
        /// 12ns
        TWELVE_NS
      };

      /**
       * Size of the device, in bytes
       */

      enum {
        SIZE_IN_BYTES = 524288        // 4Mbit
      };

    protected:
      FsmcSramTiming createTiming(AccessTime accessTime);

    public:
      IS61LV25616(AccessTime accessTime);
      virtual ~IS61LV25616() {}

      // overrides from BlockDevice

      virtual uint32_t getTotalBlocksOnDevice() override;
  };


  /**
   * Constructor
   * @param bank Which bank it's attached to, e.g.  FSMC_Bank1_NORSRAM1
   * @param accessTime The access timing for this device, e.g. 10ns
   */

  template<class TFsmc>
  inline IS61LV25616<TFsmc>::IS61LV25616(AccessTime accessTime)
    : GenericSram<TFsmc>(createTiming(accessTime),17) {     // A17 is the last address line
  }


  /**
   * Create the timing structure
   * @return The timing structure
   */

  template<class TFsmc>
  inline FsmcSramTiming IS61LV25616<TFsmc>::createTiming(AccessTime accessTime) {

    FsmcSramTiming timing;

    timing.FSMC_AccessMode=FSMC_AccessMode_A;
    timing.FSMC_AddressHoldTime=0;
    timing.FSMC_BusTurnAroundDuration=0;
    timing.FSMC_CLKDivision=0;
    timing.FSMC_DataLatency=0;

    if(accessTime==TEN_NS) {
      timing.FSMC_AddressSetupTime=0;
      timing.FSMC_DataSetupTime=1;
    }
    else if(accessTime==TWELVE_NS) {
      timing.FSMC_AddressSetupTime=0;
      timing.FSMC_DataSetupTime=1;
    }

    return timing;
  }


  /**
   * Get the total number of blocks on this device = 524288/512 = 1024 blocks
   * @return 524288/512 = 1024 blocks
   */

  template<class TFsmc>
  inline uint32_t IS61LV25616<TFsmc>::getTotalBlocksOnDevice() {
    return 1024;
  }
}
// END FILE: ../lib/include/sram/IS61LV25616.h
// START FILE: ../lib/include/sram/GenericSram.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Generic implementation of the SRAM interface
   */

  template<class TFsmc>
  class GenericSram : public FsmcSram<TFsmc>,
                      public BlockDevice {

    protected:
      static const uint32_t BLOCK_SIZE = 512;

      uint8_t *_sramStartAddress;

      /**
       * Error codes
       */

      enum {
        /// SRAM block device has no MBR
        E_NO_MBR = 1
      };

    public:
      GenericSram(const FsmcSramTiming& timing,const uint32_t lastAddressLineIndex);
      virtual ~GenericSram() {}

      // overrides from BlockDevice

      virtual uint32_t getBlockSizeInBytes() override;
      virtual bool readBlock(void *dest,uint32_t blockIndex) override;
      virtual bool readBlocks(void *dest,uint32_t blockIndex,uint32_t numBlocks) override;
      virtual bool writeBlock(const void *src,uint32_t blockIndex) override;
      virtual bool writeBlocks(const void *src,uint32_t blockIndex,uint32_t numBlocks) override;
      virtual formatType getFormatType() override;
      virtual bool getMbr(Mbr *mbr) override;

      /**
       * Cast to a void * for user access
       */

      operator void *() {
        return _sramStartAddress;
      }
  };


  /**
   * Constructor. Initialise the device
   */

  template<class TFsmc>
  inline GenericSram<TFsmc>::GenericSram(const FsmcSramTiming& timing,const uint32_t lastAddressLineIndex)
    : FsmcSram<TFsmc>(timing,lastAddressLineIndex) {

    // the bank of SRAM is not volatile (does not contain peripheral registers)

    _sramStartAddress=TFsmc::template getBaseAddress<uint8_t>();
  }


  /*
   * Get the block size.
   * @return always 512
   */

  template<class TFsmc>
  inline uint32_t GenericSram<TFsmc>::getBlockSizeInBytes() {
    return BLOCK_SIZE;
  }


  /*
   * Read a single block
   */

  template<class TFsmc>
  inline bool GenericSram<TFsmc>::readBlock(void *dest,uint32_t blockIndex)  {
    memcpy(dest,_sramStartAddress+(blockIndex * BLOCK_SIZE),BLOCK_SIZE);
    return true;
  }


  /*
   * Read many blocks
   */

  template<class TFsmc>
  inline bool GenericSram<TFsmc>::readBlocks(void *dest,uint32_t blockIndex,uint32_t numBlocks) {
    memcpy(dest,_sramStartAddress+(blockIndex * BLOCK_SIZE),numBlocks * BLOCK_SIZE);
    return true;
  }


  /*
   * Write a block
   */

  template<class TFsmc>
  inline bool GenericSram<TFsmc>::writeBlock(const void *src,uint32_t blockIndex) {
    memcpy(_sramStartAddress+(blockIndex * BLOCK_SIZE),src,BLOCK_SIZE);
    return true;
  }


  /*
   * Write many blocks
   */

  template<class TFsmc>
  inline bool GenericSram<TFsmc>::writeBlocks(const void *src,uint32_t blockIndex,uint32_t numBlocks) {
    memcpy(_sramStartAddress+(blockIndex * BLOCK_SIZE),src,numBlocks * BLOCK_SIZE);
    return true;
  }


  /*
   * Get the format type - no MBR
   */

  template<class TFsmc>
  inline BlockDevice::formatType GenericSram<TFsmc>::getFormatType() {
    return BlockDevice::formatNoMbr;
  }


  /*
   * Cannot get the MBR
   */

  template<class TFsmc>
  inline bool GenericSram<TFsmc>::getMbr(Mbr *mbr __attribute((unused))) {
    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_SRAM,E_NO_MBR);
  }
}
// END FILE: ../lib/include/sram/GenericSram.h
// START FILE: ../lib/include/filesystem/FileInformation.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief File information base class
   *
   * Defines the valid file attributes and the methods that a derived class must
   * supply.
   */

  class FileInformation {

    public:

      virtual ~FileInformation() {}

      /**
       * Abstract file attributes. Full set may not be supported by all file systems.
       * These attributes are intended to match FAT attributes 1:1 and will always do so.
       */

      enum FileAttributes {
        /// File is read only
        ATTR_READ_ONLY=0x1,

        /// File is hidden
        ATTR_HIDDEN=0x2,

        /// File is a system file
        ATTR_SYSTEM=0x4,

        /// File is actually the volume label
        ATTR_VOLUME_ID=0x8,

        /// File is a directory
        ATTR_DIRECTORY=0x10,

        /// File has been archived
        ATTR_ARCHIVE=0x20
      };


      /**
       * Get the file attributes as a bitmask of FileAttributes enumeration.
       * @return The file attributes.
       */

      virtual uint32_t getAttributes() const=0;

      /**
       * Get an internal pointer to the file or directory name.
       * @return The filename.
       */

      virtual const char *getFilename() const=0;


      /**
       * Get the the creation date time as a Unix time_t
       * @return The creation date and time.
       */

      virtual time_t getCreationDateTime() const=0;


      /**
       * Get the last write date and time as a Unix time_t.
       * @return The last write date and time.
       */

      virtual time_t getLastWriteDateTime() const=0;


      /**
       * Get the last access date and time as a Unix time_t.
       * @return The last access date and time.
       */

      virtual time_t getLastAccessDateTime() const=0;


      /**
       * Get the file length up to a maximum of 4Gb.
       * @return THe file length.
       */

      virtual uint32_t getLength() const=0;
  };
}

// END FILE: ../lib/include/filesystem/FileInformation.h
// START FILE: ../lib/include/filesystem/FileReader.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Extension of FileInputStream to provide the facility to read lines
   * from a file. This is unbuffered, hence can be slow.
   */

  class FileReader : public Reader {

    protected:
      FileInputStream _fis;

    public:
      FileReader(File& file);
      virtual ~FileReader() {}

      // overrides from Reader

      virtual bool readLine(char *buffer,uint32_t maxLength) override;

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool close() override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;
      virtual bool reset() override;
  };


  /**
   * Constructor
   * @param file The file to read from
   */

  inline FileReader::FileReader(File& file)
    : _fis(file) {
  }


  /**
   * Read a line from the file
   * @param buffer Where to store the characters
   * @param maxLength The most to read, including a null
   * @return true if it worked, false for failure
   */

  inline bool FileReader::readLine(char *buffer,uint32_t maxLength) {

    char *ptr;
    int16_t c;

    // set up pointer and decrease maxlength for the \0 terminator

    ptr=buffer;
    maxLength--;

    for(;;) {

      // get and check for error

      if((c=_fis.read())==E_STREAM_ERROR)
        return false;

      // check for EOF or EOL

      if(c==E_END_OF_STREAM || c=='\n')
        break;

      // store character if not a CR and there is space

      if(c!='\r' && maxLength) {

        *ptr++=c;
        maxLength--;
      }
    }

    // terminate the line

    *ptr='\0';
    return true;
  }


  /*
   * InputStream overrides deferred to the contained class
   */

  inline int16_t FileReader::read() {
    return _fis.read();
  }

  inline bool FileReader::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {
    return _fis.read(buffer,size,actuallyRead);
  }

  inline bool FileReader::close() {
    return _fis.close();
  }

  inline bool FileReader::skip(uint32_t howMuch) {
    return _fis.skip(howMuch);
  }

  inline bool FileReader::available() {
    return _fis.available();
  }

  inline bool FileReader::reset() {
    return _fis.reset();
  }
}

// END FILE: ../lib/include/filesystem/FileReader.h
// START FILE: ../lib/include/filesystem/Mbr.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#ifdef WIN32
#pragma pack(push,1)
#endif

namespace stm32plus {

  /**
   * MBR definition
   */

  struct Mbr {

      /// Code area for boot loader.
      uint8_t code[440];

      /// Disk signature (optional).
      uint32_t diskSignature;

      /// reserved word
      uint16_t reserved1;

      /// table of primary partitions
      MbrPartition partitions[4];

      /// 0x55AA alternating bit pattern signature
      uint16_t signature;
#ifdef WIN32
    };
#else
  }__attribute__ ((packed));
#endif

  // MBR signature value

  static const uint16_t MBR_SIGNATURE=0xAA55;
}

#ifdef WIN32
#pragma pack(pop)
#endif
// END FILE: ../lib/include/filesystem/Mbr.h
// START FILE: ../lib/include/filesystem/OwnedFileOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Subclass of a file output stream that owns the file pointer
   * and will delete it when the stream is deleted
   */

  struct OwnedFileOutputStream : FileOutputStream {

    /**
     * Constructor
     * @param file The file pointer
     */

    OwnedFileOutputStream(File *file) :
      FileOutputStream(*file) {
    }


    /**
     * Destructor, delete the file pointer
     */

    virtual ~OwnedFileOutputStream() {
      delete &_file;
    }
  };
}
// END FILE: ../lib/include/filesystem/OwnedFileOutputStream.h
// START FILE: ../lib/include/filesystem/FileSystem.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief File system base class.
   *
   * All file systems that derive from this use the same Unix style pathnames for addressing files. That is,
   * forward slashes as separators with / as the root. e.g. "/FileInRootDirectory.txt" or "/subdir/My Documents".
   * None of the filesystems support multibyte characters as filenames.
   */

  class FileSystem {

    protected:
      uint32_t _firstSectorIndex;
      uint32_t _sectorsPerBlock;
      BlockDevice& _blockDevice;
      const TimeProvider& _timeProvider;

    protected:
      FileSystem(BlockDevice& blockDevice,const TimeProvider& timeProvider,uint32_t firstSectorIndex);

      uint32_t sectorIndexToBlockIndex(uint32_t sectorIndex) const; // Convert a sector index to a block index
      uint32_t sectorOffsetIntoBlock(uint32_t sectorIndex) const; // Get the byte offset into a block of the sector

    public:

      /**
       * Error codes
       */
      enum {
        /// Filesystem type is not known
        E_UNKNOWN_FILESYSTEM=1,

        /// Pathname is invalid
        E_INVALID_PATHNAME,

        /// Device block size and filesystem sector size are not the same
        E_UNEQUAL_BLOCK_SECTOR_SIZES,

        /// File already exists
        E_FILE_EXISTS,

        /// invalid block size
        E_INVALID_BLOCK_SIZE
      };


      /**
       * Possible file system types
       */

      enum FileSystemType {
        /// FAT16 filesystem
        Fat16,

        /// FAT32 filesystem
        Fat32
      };

    public:
      static bool getInstance(BlockDevice& blockDevice,const TimeProvider& timeProvider,FileSystem*& newFileSystem);

      virtual ~FileSystem();

      const TimeProvider& getTimeProvider() const;

      virtual bool readSector(uint32_t sectorIndex,void *buffer);
      virtual bool writeSector(uint32_t sectorIndex,void *buffer);

      /**
       * Get the first sector index
       * @return the index of the first sector on the device
       */

      uint32_t getFirstSector() const {
        return _firstSectorIndex;
      }

      /**
       * Get the type of the file system from the enumeration.
       * @return The file system type.
       */

      virtual FileSystemType getFileSystemType() const=0;


      /**
       * Get file information for the given pathname.
       *
       * @param[in] filename The full pathname of the file to get information for.
       * @param[out] finfo The information for this file. Caller must delete when finished.
       * @return false if it fails.
       */

      virtual bool getFileInformation(const char *filename,FileInformation*& finfo)=0;


      /**
       * Create a file at the given pathname. The file must not already exist. The newly created
       * file is available for opening afterwards and will have zero length.
       *
       * @param[in] filename The filename to create.
       * @return false if it fails.
       */

      virtual bool createFile(const char *filename)=0;


      /**
       * Create a new directory at the given pathname.
       * @param[in] dirname The new directory name.
       * @return false if it fails.
       */

      virtual bool createDirectory(const char *dirname)=0;


      /**
       * Open the file at the given pathname.
       * @param[in] filename The full pathname to an existing file.
       * @param[out] newFile The new File object that the caller can use. Caller must delete when finished.
       * @return false if it fails.
       */

      virtual bool openFile(const char *filename,File*& newFile)=0;


      /**
       * Delete the file at the given pathname.
       * @param[in] filename The filename to delete.
       * @return false if it fails.
       */

      virtual bool deleteFile(const char *filename)=0;


      /**
       * Delete the directory with the given name. The directory must be empty.
       * @param[in] dirname The directory to delete.
       * @return false if it fails.
       */

      virtual bool deleteDirectory(const char *dirname)=0;

      /**
       * Get the size of a sector on this file system. Usually 512.
       * @return The sector size.
       */

      virtual uint32_t getSectorSizeInBytes() const=0;

      /**
       * Get a directory iterator on to the given directory.
       * @param[in] pathname The pathname to the directory to open.
       * @param[out] newIterator A new iterator for the caller to use. Caller must delete when finished.
       * @return false if it fails.
       */

      virtual bool getDirectoryIterator(const char *pathname,DirectoryIterator*& newIterator)=0;


      /**
       * Get the free space on the device as a two part result. The free space in bytes
       * Can be found by multiplying the two results together.
       * @param[out] freeUnits The number of free units.
       * @param[out] unitsMultiplier What to multiply freeUnits by to get a byte size.
       * @return false if it fails.
       */

      virtual bool getFreeSpace(uint32_t& freeUnits,uint32_t& unitsMultiplier)=0;
  };
}
// END FILE: ../lib/include/filesystem/FileSystem.h
// START FILE: ../lib/include/filesystem/TokenisedPathname.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Tokenised pathname string: supports back and forward slash as separator
   */

  class TokenisedPathname : public TokenisedString {
    public:
      TokenisedPathname(const char *pathname_);
      virtual ~TokenisedPathname() {}
  };
}
// END FILE: ../lib/include/filesystem/TokenisedPathname.h
// START FILE: ../lib/include/filesystem/File.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Base class for file objects
   */

  class File {

    protected:
      uint32_t _offset;

    public:

      /**
       * The valid seek start positions.
       */

      enum SeekFrom {
        /// Start from the beginning of the file.
        SeekStart,

        /// Start from the end of the file.
        SeekEnd,

        /// Start from the current file position
        SeekCurrent
      };

      /**
       * Error codes
       */

      enum {
        /// A requested seek position is not valid
        E_INVALID_FILE_POSITION=1,

        /// The end of the file has been reached
        E_END_OF_FILE,

        /// The file is unusable because it contains a bad cluster
        E_BAD_CLUSTER
      };

    public:
      File();

    /**
     * Virtual destructor, does nothing
     */
      virtual ~File() {
      }


      virtual uint32_t getOffset() const;

    /**
     * Read from the file. If the end of file is hit then actuallyRead_ will be shorter
     * than the amount requested.
     *
     * @param[in,out] ptr_ Caller supplied buffer to write to.
     * @param[in] size_ The number of bytes to attempt to read.
     * @param[out] actuallyRead_ The number of bytes actually read.
     * @return false if it fails, or end of file is hit. Check error provider for E_END_OF_FILE for this case.
     */

      virtual bool read(void *ptr_,uint32_t size_,uint32_t& actuallyRead_)=0;

    /**
     * Write to the file.
     *
     * @param[in] ptr_ The buffer to write.
     * @param[in] size_ The number of bytes to write.
     * @return false if it fails.
     */

      virtual bool write(const void *ptr_,uint32_t size_)=0;

    /**
     * Seek to a given offset within the file. Valid locations to seek to are from zero to the file
     * length. Seeking to the file length moves the pointer to one past the end of the file data so
     * that subsequent file writes append to the existing file.

     * @param[in] offset_ The distance to move from the origin_ parameter.
     * @param[in] origin_ One of the SeekFrom enumeration.
     */

      virtual bool seek(int32_t offset_,SeekFrom origin_)=0;

    /**
     * Get the file length.
     * @return The file length up to the maximum supported 4Gb.
     */

      virtual uint32_t getLength()=0;
  };
}
// END FILE: ../lib/include/filesystem/File.h
// START FILE: ../lib/include/filesystem/DirectoryIterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Class for iterating over the contents of a directory.
   *
   * Inherits from Iterator<const FileInformation&> and adds members for manipulating the directory
   */

  class DirectoryIterator : public Iterator<const FileInformation&> {

    public:

    /**
     * Error codes
     */
      enum {

        /// Entry is not a directory.
        E_NOT_A_DIRECTORY=1,

        /// Directory not found.
        E_DIRECTORY_NOT_FOUND,

        /// Directory entry not found
        E_ENTRY_NOT_FOUND
      };

      /**
       * Virtual destructor, does nothing.
       */

      virtual ~DirectoryIterator() {
      }

      /**
       * Get a new iterator on to the subdirectory pointed to by this iterator.
       * @param[out] newIterator The new iterator created by this call. Caller must delete when finished.
       */

      virtual bool getSubdirectoryIterator(DirectoryIterator *& newIterator)=0;


      /**
       * Check if we are pointing at the special "." entry that represents the current directory.
       *
       * @return true if this is the current directory.
       */

      virtual bool isCurrentDirectory()=0;

      /**
       * Check if we are pointing at the special ".." entry that represents the parent directory.
       *
       * @return true if this is the parent directory.
       */

      virtual bool isParentDirectory()=0;


      /**
       * Advance the iterator to the given filename (directory search)
       *
       * @param filename The filename to search for.
       * @return false if it fails.
       */

      virtual bool moveTo(const char *filename)=0;

      /**
       * Open the file pointed to by this iterator and return a high level File object for manipulating it.
       *
       * @param[out] newFile The new File object. Caller must deleted when finished.
       * @return false if it fails.
       */

      virtual bool openFile(File*& newFile)=0;
  };
}
// END FILE: ../lib/include/filesystem/DirectoryIterator.h
// START FILE: ../lib/include/filesystem/OwnedFileInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Subclass of a file input stream that owns the file pointer
   * and will delete it when the stream is deleted
   */

  struct OwnedFileInputStream : FileInputStream {

    /**
     * Constructor
     * @param file The file pointer
     */

    OwnedFileInputStream(File *file) :
      FileInputStream(*file) {
    }


    /**
     * Destructor, delete the file pointer
     */

    virtual ~OwnedFileInputStream() {
      delete &_file;
    }
  };
}
// END FILE: ../lib/include/filesystem/OwnedFileInputStream.h
// START FILE: ../lib/include/filesystem/MbrPartition.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#ifdef WIN32
#pragma pack(push,1)
#endif

namespace stm32plus {

  /**
   * MBR partition definition
   */

  struct MbrPartition {

      /// status (0x80 = bootable (active), 0x00 = non-bootable, other = invalid )
      uint8_t status;

      /// CHS address of first absolute sector in partition. The format is described by 3 bytes
      uint8_t chsFirstSector[3];

      /// Partition type (see documentation on web)
      uint8_t partitionType;

      /// CHS address of last sector in partition.
      uint8_t chsLastSector[3];

      /// LBA of first absolute sector in the partition.
      uint32_t lbaFirstSector;

      /// Number of sectors in partition, in little-endian format
      uint32_t numSectors;
#ifdef WIN32
    };
#else
  }__attribute__ ((packed));
#endif
}

#ifdef WIN32
#pragma pack(pop)
#endif
// END FILE: ../lib/include/filesystem/MbrPartition.h
// START FILE: ../lib/include/filesystem/FileInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Implementation of an input stream for files
   */

  class FileInputStream : public InputStream {

    protected:
      File& _file;

    public:
      FileInputStream(File& file);
      virtual ~FileInputStream() {}

    public:

      // overrides from InputStream

      virtual int16_t read() override;
      virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
      virtual bool close() override;
      virtual bool skip(uint32_t howMuch) override;
      virtual bool available() override;
      virtual bool reset() override;
  };


  /**
   * Constructor with file
   * @param[in] file The file to read the data from. Caller supplied, must not go out of scope.
   */

  inline FileInputStream::FileInputStream(File& file) :
    _file(file) {
  }


  /**
   * Read data from the file
   * @param buffer where to read out to
   * @param size how much to try to read
   * @param[out] actuallyRead how much was read (may be zero for EOF)
   * @return false on error.
   */

  inline bool FileInputStream::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {
    return _file.read(buffer,size,actuallyRead);
  }


  /**
   * no-op close
   * @return always true
   */

  inline bool FileInputStream::close() {
    return true;
  }


  /*
   * Skip some distance. Seeking past the end is an error.
   * @param howMuch How far to seek forward.
   * @return true if it worked
   */

  inline bool FileInputStream::skip(uint32_t howMuch) {
    return _file.seek(howMuch,File::SeekCurrent);
  }


  /**
   * Check if anything available
   * @return true if there is at least a byte available
   */

  inline bool FileInputStream::available() {
    return _file.getOffset() < _file.getLength();
  }


  /**
   * Read the next byte from the stream (0..255, or E_END_OF_STREAM for EOF, or E_STREAM_ERROR for error)
   * @return The next byte, or an error code
   */

  inline int16_t FileInputStream::read() {

    uint8_t value;
    uint32_t actuallyRead;

    if(!_file.read(&value,1,actuallyRead))
      return E_STREAM_ERROR;

    return actuallyRead == 0 ? static_cast<int16_t>(E_END_OF_STREAM) : value;
  }


  /**
   * Reset to start of stream
   * @return true if it worked
   */

  inline bool FileInputStream::reset() {
    return _file.seek(0,File::SeekStart);
  }
}
// END FILE: ../lib/include/filesystem/FileInputStream.h
// START FILE: ../lib/include/filesystem/FileOutputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Implementation of an output stream for files
   */

  class FileOutputStream : public OutputStream {
    protected:
      File& _file;

    public:
      FileOutputStream(File& f);

    public:

      // overrides from OutputStream

      virtual bool write(uint8_t c) override;
      virtual bool write(const void *buffer,uint32_t size) override;
      virtual bool close() override;

      virtual bool flush() override;
  };


  /**
   * Constructor with file.
   * @param[in] file The file to write to. Caller supplied parameter, must not go out of scope.
   */

  inline FileOutputStream::FileOutputStream(File& file)
    : _file(file) {
  }


  /**
   * Write data to the file
   * @param buffer source of your data
   * @param size How much to write
   */

  inline bool FileOutputStream::write(const void *buffer,uint32_t size) {
    return _file.write(buffer,size);
  }


  /**
   * no-op close
   * @return true
   */

  inline bool FileOutputStream::close() {
    return true;
  }


  /**
   * Write byte to file
   * @param c The byte to write
   * @return true if it worked
   */

  inline bool FileOutputStream::write(uint8_t c) {
    return _file.write(&c,sizeof(c));
  }


  /**
   * No-op flush
   * @return true always
   */

  inline bool FileOutputStream::flush() {
    return true;
  }
}
// END FILE: ../lib/include/filesystem/FileOutputStream.h
// START FILE: ../lib/include/filesystem/fat/FatFileInformation.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Extended file information to include the FAT-specific DirectoryEntry
     */

    class FatFileInformation : public FileInformation {

      protected:
        uint32_t _attributes;
        const char *_filename;
        time_t _creationDate;
        time_t _lastWriteDateTime;
        time_t _lastAccessDateTime;
        uint32_t _length;

      public:
        /**
         * Default constructor. Do nothing.
         */

        FatFileInformation() {
        }

        FatFileInformation(const char *filename,const DirectoryEntryWithLocation& dirent);

        /**
         * Virtual destructor. Do nothing.
         */

        virtual ~FatFileInformation() {
        }

        // overrides from FileInformation

        virtual uint32_t getAttributes() const override;
        virtual const char *getFilename() const override;
        virtual time_t getCreationDateTime() const override;
        virtual time_t getLastWriteDateTime() const override;
        virtual time_t getLastAccessDateTime() const override;
        virtual uint32_t getLength() const override;
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/FatFileInformation.h
// START FILE: ../lib/include/filesystem/fat/IteratingFreeClusterFinder.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Free cluster finder that uses a FAT iterator to find free clusters.
     *
     * This is a base class
     */

    class IteratingFreeClusterFinder : public FreeClusterFinder {

      protected:
        FatIterator _iterator;

      protected:
        IteratingFreeClusterFinder(FatFileSystem& fs,uint32_t firstFatEntry);

      public:

      /**
       * Virtual destructor, does nothing
       */

        virtual ~IteratingFreeClusterFinder() {
        }

        // overrides from FreeClusterFinder

        virtual bool find(uint32_t& freeCluster) override;
    };

  }
}
// END FILE: ../lib/include/filesystem/fat/IteratingFreeClusterFinder.h
// START FILE: ../lib/include/filesystem/fat/WearResistFreeClusterFinder.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Free cluster finder suitable for flash media.
     *
     * Find a free cluster by randomly picking a position in the FAT and then iterating
     * until a free entry is found. Scattering writes is desirable for flash devices that
     * will wear out after a certain number of writes. Since the FAT blocks are heavily
     * hit during write activity the benefit of this approach is limited unless the FAT is
     * cached.
     */

    class WearResistFreeClusterFinder : public IteratingFreeClusterFinder {
      public:
        WearResistFreeClusterFinder(FatFileSystem& fs_);
        virtual ~WearResistFreeClusterFinder() {
        }
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/WearResistFreeClusterFinder.h
// START FILE: ../lib/include/filesystem/fat/ShortDirectoryEntry.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#ifdef WIN32
#pragma pack(push,1)
#endif

namespace stm32plus {
  namespace fat {


  /**
   * @brief FAT short directory entry
   *
   * This packed structure maps directly on to the 32 byte FAT directory entry. Full documentation
   * for this structure can be found by searching the net.
   */

    struct ShortDirectoryEntry {

      /// 8.3 name
      uint8_t DIR_Name[11];

      /// file/directory attributes
      uint8_t DIR_Attr;

      /// reserved
      uint8_t DIR_NTRes;

      /// creation time tenths of a second
      uint8_t DIR_CrtTimeTenth;

      /// creation time
      uint16_t DIR_CrtTime;

      /// creation date
      uint16_t DIR_CrtDate;

      /// last access date
      uint16_t DIR_LstAccDate;

      /// first cluster high 16 bits
      uint16_t DIR_FstClusHI;

      /// last write time
      uint16_t DIR_WrtTime;

      /// last write date
      uint16_t DIR_WrtDate;

      /// first cluster low 16 bits
      uint16_t DIR_FstClusLO;

      /// if this is a file then this is the byte size up to 4Gb.
      uint32_t DIR_FileSize;
#ifdef WIN32
    };
#else
  } __attribute__ ((packed));
#endif
  }
}

#ifdef WIN32
#pragma pack(pop)
#endif
// END FILE: ../lib/include/filesystem/fat/ShortDirectoryEntry.h
// START FILE: ../lib/include/filesystem/fat/BootSector16.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#ifdef WIN32
#pragma pack(push,1)
#endif

namespace stm32plus {
  namespace fat {


  /**
   * @brief Fat12/16 specific part of the boot sector
   */

    struct BootSector16 {

      /// Int 0x13 drive number (e.g. 0x80). This field supports MS-DOS bootstrap and is set to the INT 0x13 drive number of the media (0x00 for floppy disks, 0x80 for hard disks).
      uint8_t   BS_DrvNum;

      /// Reserved (used by Windows NT). Code that formats FAT volumes should always set this byte to 0.
      uint8_t   BS_Reserved1;

      /// Extended boot signature (0x29). This is a signature byte that indicates that the following three fields in the boot sector are present.
      uint8_t   BS_BootSig;

      /// Volume serial number. This field, together with BS_VolLab, supports volume tracking on removable media. These values allow FAT file system drivers to detect that the wrong disk is inserted in a removable drive. This ID is usually generated by simply combining the current date and time into a 32-bit value.
      uint32_t  BS_VolID;

      /// Volume label. This field matches the 11-byte volume label recorded in the root directory.
      char      BS_VolLab[11];

      /// One of the strings "FAT12   ", "FAT16   ", or "FAT     ".
      char      BS_FilSysType[8];
#ifdef WIN32
    };
#else
  } __attribute__ ((packed));
#endif
  }
}

#ifdef WIN32
#pragma pack(pop)
#endif
// END FILE: ../lib/include/filesystem/fat/BootSector16.h
// START FILE: ../lib/include/filesystem/fat/FileSectorIterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Iterate through the sectors of a file
     */

    class FileSectorIterator : public Iterator<uint32_t> {

      protected:
        ClusterChainIterator _iterator;
        FatFileSystem& _fs;
        uint32_t _sectorIndexInCluster;
        uint32_t _sectorsPerCluster;

      public:
        FileSectorIterator(FatFileSystem& fs,uint32_t firstClusterIndex,ClusterChainIterator::ExtensionMode extend);

        /**
         * Virtual destructor, does nothing.
         */

        virtual ~FileSectorIterator() {
        }

        uint32_t getClusterNumber();

        bool readSector(void *buffer);
        bool writeSector(void *buffer);

        void reset(uint32_t firstClusterNumber);

        // overrides from Iterator

        virtual bool next() override;
        virtual uint32_t current() override;
    };

  }
}
// END FILE: ../lib/include/filesystem/fat/FileSectorIterator.h
// START FILE: ../lib/include/filesystem/fat/FatFile.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    class FatFileSystem;

    /**
     * @brief Fat file extends the basic File class.
     *
     * FAT implementation of the File base class.
     */

    class FatFile : public File {
      protected:
        FatFileSystem& _fs;
        DirectoryEntryWithLocation _dirent;
        ByteMemblock _sectorBuffer;
        FileSectorIterator _iterator;

      protected:
        void calcIndexes();

      public:
        FatFile(FatFileSystem& fs_,DirectoryEntryWithLocation& dirent_);

        /**
         * Virtual destructor, does nothing.
         */

        virtual ~FatFile() {}

      // get the dirent

        const DirectoryEntryWithLocation& getDirectoryEntryWithLocation();

      // overrides from File

        virtual bool read(void *ptr_,uint32_t size_,uint32_t& actuallyRead) override;
        virtual bool write(const void *ptr,uint32_t size) override;
        virtual bool seek(int32_t offset,SeekFrom origin) override;
        virtual uint32_t getLength() override;
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/FatFile.h
// START FILE: ../lib/include/filesystem/fat/BootSector32.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#ifdef WIN32
#pragma pack(push,1)
#endif

namespace stm32plus {
  namespace fat {


  /**
   * @brief Fat32 specific part of the boot sector
   */

    struct BootSector32 {

      /// This field is the FAT32 32-bit count of sectors occupied by ONE FAT. BPB_FATSz16 must be 0.
      uint32_t BPB_FATSz32;

      /// This field is only defined for FAT32 media and does not exist on FAT12 and FAT16 media.
      uint16_t BPB_ExtFlags;

      /// High byte is major revision number. Low byte is minor revision number. This is the version number of the FAT32 volume. This supports the ability to extend the FAT32 media type in the future without worrying about old FAT32 drivers mounting the volume. This document defines the version to 0:0.  If this field is non-zero, back-level Windows versions will not mount the volume.
      uint16_t BPB_FSVer;

      /// This is set to the cluster number of the first cluster of the root directory, usually 2 but not required to be 2.
      uint32_t BPB_RootClus;

      /// Sector number of FSINFO structure in the reserved area of the FAT32 volume. Usually 1.
      uint16_t BPB_FSInfo;

      /// If non-zero, indicates the sector number in the reserved area of the volume of a copy of the boot record. Usually 6. No value other than 6 is recommended.
      uint16_t BPB_BkBootSec;

      /// Reserved for future expansion. Code that formats FAT32 volumes should always set all of the bytes of this field to 0.
      uint8_t  BPB_Reserved[12];

      /// This field has the same definition as it does for FAT12 and FAT16 media. The only difference for FAT32 media is that the field is at a different offset in the boot sector.
      uint8_t  BS_DrvNum;

      /// This field has the same definition as it does for FAT12 and FAT16 media. The only difference for FAT32 media is that the field is at a different offset in the boot sector.
      uint8_t  BS_Reserved1;

      /// This field has the same definition as it does for FAT12 and FAT16 media. The only difference for FAT32 media is that the field is at a different offset in the boot sector.
      uint8_t  BS_BootSig;

      /// This field has the same definition as it does for FAT12 and FAT16 media. The only difference for FAT32 media is that the field is at a different offset in the boot sector.
      uint32_t BS_VolID;

      /// This field has the same definition as it does for FAT12 and FAT16 media. The only difference for FAT32 media is that the field is at a different offset in the boot sector.
      char     BS_VolLab[11];

      /// Always set to the string "FAT32   ".  Please see the note for this field in the FAT12/FAT16 section earlier. This field has nothing to do with FAT type determination.
      char     BS_FilSysType[8];
#ifdef WIN32
    };
#else
  } __attribute__ ((packed));
#endif
  }
}

#ifdef WIN32
#pragma pack(pop)
#endif
// END FILE: ../lib/include/filesystem/fat/BootSector32.h
// START FILE: ../lib/include/filesystem/fat/Fat32FsInfo.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief FsInfo structure used to accelerate some file system operation.
     *
     * This is not supported in the stm32plus implementation.
     */

    struct Fat32FsInfo {

        /// Value 0x41615252. This lead signature is used to validate that this is in fact an FSInfo sector.
        uint32_t FSI_LeadSig;

        /// This field is currently reserved for future expansion. FAT32 format code should always initialize all bytes of this field to 0. Bytes in this field must currently never be used.
        uint8_t FSI_Reserved1[480];

        /// Value 0x61417272. Another signature that is more localized in the sector to the location of the fields that are used.
        uint32_t FSI_StrucSig;

        /// Contains the last known free cluster count on the volume. If the value is 0xFFFFFFFF, then the free count is unknown and must be computed. Any other value can be used, but is not necessarily correct. It should be range checked at least to make sure it is <= volume cluster count.
        uint32_t FSI_Free_Count;

        /// This is a hint for the FAT driver. It indicates the cluster number at which the driver should start looking for free clusters. Because a FAT32 FAT is large, it can be rather time consuming if there are a lot of allocated clusters at the start of the FAT and the driver starts looking for a free cluster starting at cluster 2. Typically this value is set to the last cluster number that the driver allocated. If the value is 0xFFFFFFFF, then there is no hint and the driver should start looking at cluster 2. Any other value can be used, but should be checked first to make sure it is a valid cluster number for the volume.
        uint32_t FSI_Nxt_Free;

        /// This field is currently reserved for future expansion. FAT32 format code should always initialize all bytes of this field to 0. Bytes in this field must currently never be used.
        uint8_t FSI_Reserved2[12];

        /// Value 0xAA550000. This trail signature is used to validate that this is in fact an FSInfo sector. Note that the high 2 bytes of this valuewhich go into the bytes at offsets 510 and 511match the signature bytes used at the same offsets in sector 0.
        uint32_t FSI_TrailSig;

    } __attribute__ ((packed));
  }
}
// END FILE: ../lib/include/filesystem/fat/Fat32FsInfo.h
// START FILE: ../lib/include/filesystem/fat/FatDirectoryIterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {


  /**
   * @brief Base class for iterating over the entries in a FAT directory.
   *
   * This class provides the static factory method used for returning an appropriate
   * derived class.
   */

    class FatDirectoryIterator : public DirectoryIterator, public FatFileInformation {

      protected:
        FatFileSystem& _fs;
        DirectoryEntryIterator *_entryIterator;

      protected:
        FatDirectoryIterator(FatFileSystem& fs,DirectoryEntryWithLocation& dirent);
        FatDirectoryIterator(FatFileSystem& fs);

      public:
        static bool getInstance(FatFileSystem& fs,const TokenisedPathname& tp,FatDirectoryIterator *& newIterator);

        virtual ~FatDirectoryIterator();

        DirectoryEntryIterator& getDirectoryEntryIterator();

      // overrides from Iterator<FileInformation>

        virtual bool next() override;
        virtual const FileInformation& current() override;

      // overrides from DirectoryIterator

        virtual bool getSubdirectoryIterator(DirectoryIterator *& newIterator) override;
        virtual bool isCurrentDirectory() override;
        virtual bool isParentDirectory() override;
        virtual bool moveTo(const char *filename) override;
        virtual bool openFile(File*& newFile) override;

      // overrides from FileInformation

        virtual const char *getFilename() const override;
        virtual uint32_t getAttributes() const override;
        virtual time_t getCreationDateTime() const override;
        virtual time_t getLastWriteDateTime() const override;
        virtual time_t getLastAccessDateTime() const override;
        virtual uint32_t getLength() const override;

      // overrides from FatFileInformation

        DirectoryEntryWithLocation& getDirectoryEntryWithLocation();
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/FatDirectoryIterator.h
// START FILE: ../lib/include/filesystem/fat/Fat16FileSystemFormatter.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Implementation of a FAT formatter for FAT16 file systems
     */

    class Fat16FileSystemFormatter : public FatFileSystemFormatter {

      protected:
        virtual bool createNewBootSector() override;
        virtual bool writeReservedSectors() override;
        virtual void initReservedClusters(uint8_t *sector) const override;

      public:
        Fat16FileSystemFormatter(BlockDevice& blockDevice,uint32_t firstSectorIndex,uint32_t numSectors,const char *volumeLabel);
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/Fat16FileSystemFormatter.h
// START FILE: ../lib/include/filesystem/fat/LongNameDirentGenerator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Handle the generation of dirents given a long filename.
     *
     * This class does all the work necessary to generate the sequence of directory entries
     * that are required to represent a long file name, i.e. a filename that is more than
     * the 8.3 format supported by old versions of MSDOS.
     *
     * This class does not actually write the new directory entries. The caller is responsible for that.
     */

    class LongNameDirentGenerator {

      protected:
        DirectoryEntryIterator& _targetDir;
        const char *_longName;
        DirectoryEntry *_dirents;
        uint16_t _createDate;
        uint16_t _createTime;
        int _direntCount;
        int _currentIteratorIndex;

      public:

        /**
         * Error codes
         */

        enum {
          /// The filename already exists in the directory.
          E_FILE_EXISTS=1
        };

      public:
        LongNameDirentGenerator(const char *longName_,DirectoryEntryIterator& targetDir_,uint16_t createDate_,uint16_t createTime_);
        ~LongNameDirentGenerator();

        int getDirentCount();
        DirectoryEntry *getDirents();

      protected:
        bool generateDirentsFromLongName();
        void generateShortName(char *shortName_) const;
        void computeLossyShortName(const char *shortName_,char *lossyName_,int tailNumber_) const;
        uint8_t shortNameChecksum(const uint8_t *shortName_) const;
        bool isLongNameValidShortName() const;
        void copyChars(const char *& src_,int& srcLen_,uint16_t *dest_,int destLen_);
        bool findUniqueShortName(char *shortName_);
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/LongNameDirentGenerator.h
// START FILE: ../lib/include/filesystem/fat/DirectoryEntryWithLocation.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Dirent with sector location on device
     */

    struct DirectoryEntryWithLocation {

        /// The directory entry structure
        DirectoryEntry Dirent;

        /// The sector number on the FS where this entry came from
        uint32_t SectorNumber;

        /// The index within the sector where this entry came from. This is a byte offset.
        uint32_t IndexWithinSector;

        bool isFile();
        bool isDirectory();
        void copyTimesTo(DirectoryEntry& dest_);
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/DirectoryEntryWithLocation.h
// START FILE: ../lib/include/filesystem/fat/Fat32FileSystem.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

  /**
   * @brief FAT32 implementation of the filesystem.
   *
   * Provides an implementation of FatFileSystem for FAT32.
   */

    class Fat32FileSystem : public FatFileSystem {

      public:
        Fat32FileSystem(
          BlockDevice& blockDevice,
          const TimeProvider& timeProvider,
          const fat::BootSector& bootSector,
          uint32_t firstSectorIndex,
          uint32_t countOfClusters);
        
        virtual ~Fat32FileSystem();

      // overrides from FatFileSystem

        virtual FileSystemType getFileSystemType() const override;
        virtual uint32_t getFatEntrySizeInBytes() const override;
        virtual uint32_t getBadClusterMarker() const override;
        virtual uint32_t getFatEntryFromMemory(void *addr) const override;
        virtual void setFatEntryToMemory(void *addr,uint32_t entry) const override;
        virtual uint32_t getSectorsPerFat() const override;
        virtual bool isEndOfClusterChainMarker(uint32_t clusterNumber) const override;
        virtual uint32_t getEndOfClusterChainMarker() const override;
        virtual DirectoryEntryIterator *getRootDirectoryIterator(DirectoryEntryIterator::Options options) override;
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/Fat32FileSystem.h
// START FILE: ../lib/include/filesystem/fat/FreeClusterFinder.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Base class for free cluster finders
     */

    class FreeClusterFinder {
      protected:
        FatFileSystem& _fs;

      protected:
        FreeClusterFinder(FatFileSystem& fs);

      public:

        /**
         * Error codes
         */

        enum {
          /// The disk is full. There are no more free clusters available.
          E_NO_FREE_CLUSTERS=1
        };


        /**
         * Virtual destructor. Does nothing
         */

        virtual ~FreeClusterFinder() {
        }


        /**
         * Derivations of this class must implement this. Finds the next free cluster and
         * returns it to the client in the freeCluster_ reference.
         *
         * @param[in] freeCluster_ The next free cluster.
         * @return false if it fails, check error provider for details.
         */

        virtual bool find(uint32_t& freeCluster)=0;
    };

  }
}
// END FILE: ../lib/include/filesystem/fat/FreeClusterFinder.h
// START FILE: ../lib/include/filesystem/fat/FatIterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Iterate over the entries in the FAT sequentially.
     */

    class FatIterator : public Iterator<uint32_t> {

      private:
        FatFileSystem& _fs;
        uint32_t _firstIndex;
        uint32_t _currentIndex;
        uint32_t _entriesPerFat;
        uint32_t _lastSectorIndex;
        bool _wrap;
        bool _first;
        ByteMemblock _sectorBuffer;

      public:
        FatIterator(FatFileSystem& fs_,uint32_t firstIndex_,bool wrap_);

        uint32_t currentContent(); // get the content of the current index

        // overrides from Iterator

        virtual bool next() override;
        virtual uint32_t current() override; // get the current index
    };

  }
}
// END FILE: ../lib/include/filesystem/fat/FatIterator.h
// START FILE: ../lib/include/filesystem/fat/LinearFreeClusterFinder.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Free cluster finder suitable for rotating disks.
     *
     * Find a free cluster by linearly looking in the FAT from cluster zero until a free entry is found.
     * Devices that do not have an MTBF for each block should probably use this as it will tend to keep
     * clusters together.
     */

    class LinearFreeClusterFinder : public IteratingFreeClusterFinder {
      public:
        LinearFreeClusterFinder(FatFileSystem& fs);

        /**
         * Virtual destructor. Does nothing.
         */

        virtual ~LinearFreeClusterFinder() {
        }


        /**
         * Find a sequence of at least the given number of clusters that are all free
         */

        bool findMultipleSequential(uint32_t clustersRequired,uint32_t& firstCluster);
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/LinearFreeClusterFinder.h
// START FILE: ../lib/include/filesystem/fat/FilenameHandler.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Handle constructing a filename from one or more directory entries.
     *
     * This class is used for extracting the true filename from one or more directory
     * entries in a FAT directory. Long filenames are the tricky ones because they
     * occupy more than one entry and have a strange encoding driven by the requirement
     * to be compatible with, and ignored by, earlier systems that don't understand
     * the new entries.
     */

    class FilenameHandler {

      protected:
        enum State {
          STATE_NONE, STATE_READY, STATE_LONG_FILENAME_IN_PROGRESS
        };

        State _state;
        char *_longFilename;             // filenames longer than 29 characters get allocated on the heap
        char _shortFilename[30];         // filenames shorter than 30 characters - quick access
        uint16_t _length;                // length not including nul
        uint8_t _currentIndex;
        uint32_t _direntCount;
        uint32_t *_sectorIndices;         // two arrays to collect sector locations of each dirent that makes
        uint32_t *_sectorOffsetIndices;   // up the filename. Used if the caller decides to delete the file

        bool handleLongName(DirectoryEntryWithLocation& entry);
        bool handleShortName(DirectoryEntryWithLocation& entry);

        void setName(const void *name,uint16_t length);
        void setSectorDetails(DirectoryEntryWithLocation& entry,uint32_t sectorIndex,uint32_t newSize=0);

        void initialise();
        void cleanup();

      public:

        /**
         * Error codes
         */

        enum {
          /// The directory is corrupt. The sequence of entries does not make sense.
          E_INVALID_STATE=1,

          /// The long filename is corrupted
          E_CORRUPT_LONG_FILENAME=2
        };

      public:
        FilenameHandler();
        ~FilenameHandler();

        void reinitialise();
        bool handleEntry(DirectoryEntryWithLocation& entry);
        const char *getFilename();

        uint32_t *getSectorIndices();
        uint32_t *getSectorOffsetIndices();
        uint32_t getDirentCount();
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/FilenameHandler.h
// START FILE: ../lib/include/filesystem/fat/NormalDirectoryEntryIterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * @brief Iterate over normal directory entries.
     *
     * A normal directory entry iterator iterates over directory entries stored in a "file" structure,
     * i.e. a sequence of clusters specified by their FAT entries.
     */

    class NormalDirectoryEntryIterator : public DirectoryEntryIterator {
      protected:
        uint32_t _indexWithinSector;
        FileSectorIterator _iterator;
        uint32_t _firstClusterIndex;
        uint32_t _currentDirentIndex;

      protected:
        // overrides from DirectoryEntryIterator

        virtual bool internalNext() override;
        virtual bool extendDirectory(DirectoryEntry *dirents,uint32_t direntCount) override;

        // overrides from ResettableIterator

        virtual void reset() override;

      public:
        NormalDirectoryEntryIterator(FatFileSystem& fs,uint32_t firstClusterIndex,Options options);

        /**
         * Virtual destructor. Does nothing.
         */

        virtual ~NormalDirectoryEntryIterator() {
        }
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/NormalDirectoryEntryIterator.h
// START FILE: ../lib/include/filesystem/fat/Fat16FileSystem.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

  /**
   * FAT16 implementation of the filesystem
   */

    class Fat16FileSystem : public FatFileSystem {

      protected:
        uint32_t _rootDirSectors;             // number of sectors reserved for the root directory

      public:
        Fat16FileSystem(
          BlockDevice& blockDevice,
          const TimeProvider& timeProvider,
          const fat::BootSector& bootSector,
          uint32_t firstSectorIndex,
          uint32_t countOfClusters);
        
        virtual ~Fat16FileSystem();

        uint32_t getRootDirSectors() const;

        // overrides from FatFileSystem

        virtual FileSystemType getFileSystemType() const override;
        virtual uint32_t getFatEntryFromMemory(void *addr) const override;
        virtual void setFatEntryToMemory(void *addr,uint32_t entry) const override;
        virtual uint32_t getFatEntrySizeInBytes() const override;
        virtual uint32_t getBadClusterMarker() const override;
        virtual uint32_t getEndOfClusterChainMarker() const override;
        virtual uint32_t getSectorsPerFat() const override;
        virtual bool isEndOfClusterChainMarker(uint32_t clusterNumber) const override;
        virtual DirectoryEntryIterator *getRootDirectoryIterator(DirectoryEntryIterator::Options options) override;
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/Fat16FileSystem.h
// START FILE: ../lib/include/filesystem/fat/FatFileSystemFormatter.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * Fat filesystem formatter base class
     */

    class FatFileSystemFormatter {

      protected:
        char _volumeLabel[11];
        BlockDevice& _blockDevice;
        uint32_t _numSectors;
        uint32_t _firstSectorIndex;
        BootSector _bootSector;

      protected:
        FatFileSystemFormatter(BlockDevice& blockDevice,uint32_t firstSectorIndex,uint32_t numSectors,const char *volumeLabel);
        virtual ~FatFileSystemFormatter() {}

        virtual bool createNewBootSector();

        void setReservedSectorSignature(uint8_t *sector) const;
        void initVolumeLabelDirent(uint8_t *rootDirSector) const;
        bool writeBootSector(uint32_t bootSectorIndex);
        bool writeFats(uint32_t firstFatFirstSector,uint32_t sectorsPerFat) const;
        bool writeRootDirectoryEntries(uint32_t sectorIndex) const;

        virtual bool writeReservedSectors()=0;
        virtual void initReservedClusters(uint8_t *sector) const=0;

      protected:
        static const uint8_t MEDIA_TYPE=0xf8;         // fixed media, which this may not be.

      public:

        enum {
          /// tried to format a disk whose size is out of range for the format.
          E_INVALID_DISK_SIZE=1
        };

    };
  }
}


// END FILE: ../lib/include/filesystem/fat/FatFileSystemFormatter.h
// START FILE: ../lib/include/filesystem/fat/DirectoryEntryIterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

  class FatFileSystem;


  /**
   * @brief An iterator over the directory entry structures in a FAT filesystem.
   *
   * A directory entry iterator iterates over the 32 byte DirectoryEntry structures in
   * a FAT directory. A base class is defined here so that the special case of iterating
   * over the FAT16 root directory is abstracted.
   */

    class DirectoryEntryIterator : public ResetableIterator<DirectoryEntryWithLocation&> {

      public:
        /**
         * Options bitmask for the iteration
         */

        enum Options {
          /// No options.
          OPT_NONE              = 0x0,

          /// Entries that are marked as deleted will be skipped over.

          OPT_SKIP_DELETED      = 0x1,

          /// Long names are spread over multiple directory entries. Set this option to parse them as one entry.
          OPT_PARSE_LONG_NAMES  = 0x2,

          /// Default options are to skip deleted and parse long names
          OPT_DEFAULT_REAL_ENTRIES = OPT_SKIP_DELETED | OPT_PARSE_LONG_NAMES
        };

      protected:
        FatFileSystem& _fs;
        DirectoryEntryWithLocation _currentEntry;
        Options _options;
        FilenameHandler _filename;
        time_t _lastAccessDateTime;
        time_t _lastWriteDateTime;
        time_t _creationDateTime;

      protected:
        DirectoryEntryIterator(FatFileSystem& fs_,Options options_);

        virtual bool internalNext()=0;
        virtual bool extendDirectory(DirectoryEntry *dirents_,uint32_t direntCount_)=0;

      public:

        /**
         * Virtual destructor, does nothing
         */

        virtual ~DirectoryEntryIterator() {}

        const char *getFilename();
        FilenameHandler& getFilenameHandler();

        time_t getLastAccessDateTime();
        time_t getLastWriteDateTime();
        time_t getCreationDateTime();

        bool writeDirents(DirectoryEntry *dirents_,int direntCount_);

      // helpers for converting dates and times for directory entries

        static time_t calculateUnixTime(uint16_t date_,uint16_t time_,time_t& result_);
        static void calculateFatDateTime(time_t unixTime_,uint16_t& date_,uint16_t& time);

      // overrides from Iterator<DirectoryEntry>

        virtual DirectoryEntryWithLocation& current() override;
        virtual bool next() override;
    };

  }
}
// END FILE: ../lib/include/filesystem/fat/DirectoryEntryIterator.h
// START FILE: ../lib/include/filesystem/fat/LongDirectoryEntry.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#ifdef WIN32
#pragma pack(push,1)
#endif


namespace stm32plus {
  namespace fat {

  /**
   * @brief Long name FAT directory entry.
   *
   * This packed structure holds part of a long name FAT structure. Search the net for more details.
   */

    struct LongDirectoryEntry {

      /// ordinal number of this entry
      uint8_t  LDIR_Ord;

      /// first part of the name
      uint16_t LDIR_Name1[5];

      /// attributes
      uint8_t  LDIR_Attr;

      /// type
      uint8_t  LDIR_Type;

      /// checksum
      uint8_t  LDIR_Chksum;

      /// second part of the name
      uint16_t LDIR_Name2[6];

      /// first cluster low 16-bits
      uint16_t LDIR_FstClusLO;

      /// third part of the name
      uint16_t LDIR_Name3[2];
#ifdef WIN32
    };
#else
  } __attribute__ ((packed));
#endif
  }
}

#ifdef WIN32
#pragma pack(pop)
#endif
// END FILE: ../lib/include/filesystem/fat/LongDirectoryEntry.h
// START FILE: ../lib/include/filesystem/fat/BootSector.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#ifdef WIN32
#pragma pack(push,1)
#endif

namespace stm32plus {
  namespace fat {


/**
 * @brief FAT Bootsector definition. The members of this structure are packed
 * so they can be exactly mapped on to the disk structure.
 */

    struct BootSector {

      /// Jump instruction to boot code
      uint8_t   BS_jmpBoot[3];

      /// "MSWIN4.1" There are many misconceptions about this field. It is only a name string. Microsoft operating systems don't pay any attention to this field. Some FAT drivers do. This is the reason that the indicated string, "MSWIN4.1", is the recommended setting, because it is the setting least likely to cause compatibility problems. If you want to put something else in here, that is your option, but the result may be that some FAT drivers might not recognize the volume. Typically this is some indication of what system formatted the volume.
      char      BS_OEMName[8];

      /// Count of bytes per sector. This value may take on only the following values: 512, 1024, 2048 or 4096. If maximum compatibility with old implementations is desired, only the value 512 should be used. There is a lot of FAT code in the world that is basically "hard wired" to 512 bytes per sector and doesnt bother to check this field to make sure it is 512. Microsoft operating systems will properly support 1024, 2048, and 4096.
      uint16_t  BPB_BytsPerSec;

      /// Number of sectors per allocation unit. This value must be a power of 2 that is greater than 0. The legal values are 1, 2, 4, 8, 16, 32, 64, and 128. Note however, that a value should never be used that results in a "bytes per cluster" value (BPB_BytsPerSec * BPB_SecPerClus) greater than 32K (32 * 1024). There is a misconception that values greater than this are OK. Values that cause a cluster size greater than 32K bytes do not work properly; do not try to define one. Some versions of some systems allow 64K bytes per cluster value. Many application setup programs will not work correctly on such a FAT volume.
      uint8_t   BPB_SecPerClus;

      /// Number of reserved sectors in the Reserved region of the volume starting at the first sector of the volume. This field must not be 0. For FAT12 and FAT16 volumes, this value should never be anything other than 1. For FAT32 volumes, this value is typically 32. There is a lot of FAT code in the world "hard wired" to 1 reserved sector for FAT12 and FAT16 volumes and that doesnt bother to check this field to make sure it is 1. Microsoft operating systems will properly support any non-zero value in this field.
      uint16_t  BPB_RsvdSecCnt;

      /// The count of FAT data structures on the volume. This field should always contain the value 2 for any FAT volume of any type. Although any value greater than or equal to 1 is perfectly valid, many software programs and a few operating systems FAT file system drivers may not function properly if the value is something other than 2. All Microsoft file system drivers will support a value other than 2, but it is still highly recommended that no value other than 2 be used in this field.
      uint8_t   BPB_NumFATs;

      /// For FAT12 and FAT16 volumes, this field contains the count of 32-byte directory entries in the root directory. For FAT32 volumes, this field must be set to 0. For FAT12 and FAT16 volumes, this value should always specify a count that when multiplied by 32 results in an even multiple of BPB_BytsPerSec. For maximum compatibility, FAT16 volumes should use the value 512.
      uint16_t  BPB_RootEntCnt;

      /// This field is the old 16-bit total count of sectors on the volume. This count includes the count of all sectors in all four regions of the volume. This field can be 0; if it is 0, then BPB_TotSec32 must be non-zero. For FAT32 volumes, this field must be 0. For FAT12 and FAT16 volumes, this field contains the sector count, and BPB_TotSec32 is 0 if the total sector count "fits" (is less than 0x10000).
      uint16_t  BPB_TotSec16;

      /// 0xF8 is the standard value for "fixed" (non-removable) media. For removable media, 0xF0 is frequently used. The legal values for this field are 0xF0, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, and 0xFF. The only other important point is that whatever value is put in here must also be put in the low byte of the FAT[0] entry. This dates back to the old MS-DOS 1.x media determination noted earlier and is no longer usually used for anything.
      uint8_t   BPB_Media;

      /// This field is the FAT12/FAT16 16-bit count of sectors occupied by ONE FAT. On FAT32 volumes this field must be 0, and BPB_FATSz32 contains the FAT size count.
      uint16_t  BPB_FATSz16;

      /// Sectors per track for interrupt 0x13. This field is only relevant for media that have a geometry (volume is broken down into tracks by multiple heads and cylinders) and are visible on interrupt 0x13. This field contains the "sectors per track" geometry value.
      uint16_t  BPB_SecPerTrk;

      /// Number of heads for interrupt 0x13. This field is relevant as discussed earlier for BPB_SecPerTrk. This field contains the one based count of heads. For example, on a 1.44 MB 3.5-inch floppy drive this value is 2.
      uint16_t  BPB_NumHeads;

      /// Count of hidden sectors preceding the partition that contains this FAT volume. This field is generally only relevant for media visible on interrupt 0x13. This field should always be zero on media that are not partitioned. Exactly what value is appropriate is operating system specific.
      uint32_t  BPB_HiddSec;

      /// This field is the new 32-bit total count of sectors on the volume. This count includes the count of all sectors in all four regions of the volume. This field can be 0; if it is 0, then BPB_TotSec16 must be non-zero. For FAT32 volumes, this field must be non-zero. For FAT12/FAT16 volumes, this field contains the sector count if BPB_TotSec16 is 0 (count is greater than or equal to 0x10000).
      uint32_t  BPB_TotSec32;

      /**
       * The union FAT32 and FAT16 boot sectors.
       */
      union {
        BootSector16 fat16;
        BootSector32 fat32;
      };
#ifdef WIN32
    };
#else
  } __attribute__ ((packed));
#endif
  }
}

#ifdef WIN32
#pragma pack(pop)
#endif
// END FILE: ../lib/include/filesystem/fat/BootSector.h
// START FILE: ../lib/include/filesystem/fat/DirectoryEntry.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

    /**
     * FAT directory entry. There are no data members here, just the union of the short and long directory entry
     * implementations.
     */

    struct DirectoryEntry {

    /**
     * Attributes in a directory entry
     */

      enum {
        /// Entry is read only
        ATTR_READ_ONLY = 0x1,

        /// Entry is hidden
        ATTR_HIDDEN    = 0x2,

        /// Entry is a system file
        ATTR_SYSTEM    = 0x4,

        /// Entry is the volume label
        ATTR_VOLUME_ID = 0x8,

        /// Entry is a directory
        ATTR_DIRECTORY = 0x10,

        /// Entry has been archived
        ATTR_ARCHIVE   = 0x20,

        /// The special combination that indicates a long name entry
        ATTR_LONG_NAME = ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID,

        /// The long name mask
        ATTR_LONG_NAME_MASK = ATTR_READ_ONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_VOLUME_ID | ATTR_DIRECTORY | ATTR_ARCHIVE,

        /// The special bit that is set to indicate the last ordinal in a long name sequence
        LAST_LONG_ENTRY = 0x40
      };

      /**
       * The 32 byte structure itself
       */

      union {
        ShortDirectoryEntry sdir;
        LongDirectoryEntry ldir;
      };
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/DirectoryEntry.h
// START FILE: ../lib/include/filesystem/fat/FatFileSystem.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @namespace fat 'fat' is a sub-namespace of stm32plus that contains everything to do with the FAT
   * filesystem. Generally you won't have to go here because the FileSystem API is exposed through the
   * stm32plus::FileSystem class.
   */

  namespace fat {

    class FatDirectoryIterator;

    /**
     * @brief Base class for FAT filesystems.
     *
     * Exposes the common functionality of FAT16 and FAT32 filesystems.
     */

    class FatFileSystem : public FileSystem {
      protected:
        BootSector _bootSector; // the BPB

        uint32_t _firstDataSector; // index of the first data sector
        uint32_t _fatFirstSector; // first sector of the FAT
        uint32_t _rootDirFirstSector; // first sector of the root directory
        uint32_t _countOfClusters; // total # of clusters

      protected:
        FatFileSystem(BlockDevice& blockDevice,const TimeProvider& timeProvider,const fat::BootSector& bootSector,uint32_t firstSectorIndex,uint32_t countOfClusters);

        bool getDirectoryEntry(TokenisedPathname& pathTokens,DirectoryEntryWithLocation& direntCopy);
        bool getDirectoryIteratorPointingToFile(TokenisedPathname& pathTokens,FatDirectoryIterator *& parent);
        bool getParentDirectoryFirstCluster(TokenisedPathname& pathTokens,uint16_t* lo,uint16_t* hi);
        bool fullyDelete(FatDirectoryIterator& it);
        bool deleteDirents(FatDirectoryIterator& fdi);

      public:

        /**
         * Error codes
         */

        enum {
          /// Cluster contains the bad marker
          E_BAD_CLUSTER=1,

          /// Expected a file, got something else.
          E_NOT_A_FILE,

          /// Expected a directory, got something else.
          E_NOT_A_DIRECTORY,

          /// Expected an empty directory but it has content.
          E_DIRECTORY_NOT_EMPTY
        };

        // factory constructor/destructor
        static bool getInstance(BlockDevice& blockDevice,const TimeProvider& timeProvider,FatFileSystem*& newFileSystem);

        virtual ~FatFileSystem();

        // overrides from FileSystem

        virtual bool getFileInformation(const char *filename,FileInformation*& finfo) override;
        virtual bool getDirectoryIterator(const char *pathname,DirectoryIterator*& newIterator) override;
        virtual bool createFile(const char *filename) override;
        virtual bool openFile(const char *filename,File*& newFile) override;
        virtual bool deleteFile(const char *filename) override;
        virtual bool deleteDirectory(const char *dirname) override;
        virtual bool createDirectory(const char *dirname) override;
        virtual uint32_t getSectorSizeInBytes() const override;
        virtual bool getFreeSpace(uint32_t& freeUnits,uint32_t& unitsMultiplier) override;

        const fat::BootSector& getBootSector() const;
        uint32_t getCountOfClusters() const;
        uint32_t clusterToSector(uint32_t clusterNumber) const;
        uint32_t getRootDirectoryFirstSector() const;
        bool readSectorFromCluster(uint32_t clusterIndex,uint32_t sectorIndexInCluster,void *buffer);
        bool writeSectorToCluster(uint32_t clusterIndex,uint32_t sectorIndexInCluster,void *buffer);
        bool readFatEntry(uint32_t clusterNumber,uint32_t& fatEntryForCluster);
        bool allocateNewCluster(uint32_t anyClusterInChain,uint32_t& newCluster);
        bool findFreeCluster(uint32_t& freeCluster);
        bool writeFatEntry(uint32_t fatEntryIndex,uint32_t fatEntryContent);
        bool writeDirectoryEntry(DirectoryEntryWithLocation& dirent);
        bool deAllocateClusterChain(uint32_t firstCluster);
        bool directoryHasContent(const char *dirName,bool& hasContent);

        /**
         * Get a FAT entry from memory. 16-bit entries are up-cast to fill 32 bits.
         * @param[in] addr the address to extract the entry from.
         * @return The extracted FAT entry.
         */

        virtual uint32_t getFatEntryFromMemory(void *addr) const=0;

        /**
         * Write a FAT entry into memory.
         * @param[in] addr The address to write to.
         * @param[in] entry The entry to write, which may be down-cast to 16-bits by the implementation.
         */

        virtual void setFatEntryToMemory(void *addr,uint32_t entry) const=0;


        /**
         * Get the size of a FAT entry in bytes.
         * @return 2 or 4, depending on whether this is FAT16 or FAT32.
         */

        virtual uint32_t getFatEntrySizeInBytes() const=0;

        /**
         * Get the bad cluster marker for this file system.
         * @return The bad cluster marker.
         */

        virtual uint32_t getBadClusterMarker() const=0;

        /**
         * Get the number of sectors per FAT.
         * @return The number of sectors in each FAT.
         */

        virtual uint32_t getSectorsPerFat() const=0;


        /**
         * Test if this cluster number is the end of cluster (EOC) marker.
         * @param[in] clusterNumber The value to test.
         * @return true if it is the EOC marker, false if not.
         */

        virtual bool isEndOfClusterChainMarker(uint32_t clusterNumber) const=0;

        /**
         * Get the EOC marker.
         * @return The EOC marker.
         */

        virtual uint32_t getEndOfClusterChainMarker() const=0;

        /**
         * Get an iterator on to the root directory of this filesystem.
         * @param[in] options The options to use while iterating over this directory.
         * @return A directory entry pointer. The caller owns this pointer and must delete it
         * when finished. nullptr is returned on failure and the error provider is updated.
         */

        virtual DirectoryEntryIterator *getRootDirectoryIterator(DirectoryEntryIterator::Options options)=0;
    };
  }
}
// END FILE: ../lib/include/filesystem/fat/FatFileSystem.h
// START FILE: ../lib/include/filesystem/fat/Fat32FileSystemFormatter.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {


  /**
   * @brief Formatter for fat32 file systems.
   */

    class Fat32FileSystemFormatter : public FatFileSystemFormatter {

      protected:
        virtual bool createNewBootSector() override;
        virtual bool writeReservedSectors() override;
        virtual void initReservedClusters(uint8_t *sector) const override;

        void createNewFsInfo(Fat32FsInfo& fsinfo) const;

      public:
        Fat32FileSystemFormatter(BlockDevice& blockDevice,uint32_t firstSectorIndex,uint32_t numSectors,const char *volumeLabel);
        virtual ~Fat32FileSystemFormatter() {}
    };

  }
}
// END FILE: ../lib/include/filesystem/fat/Fat32FileSystemFormatter.h
// START FILE: ../lib/include/filesystem/fat/Fat16RootDirectoryEntryIterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

  /**
   * @brief Iterator for directory entries in the Fat16 root directory.
   *
   * The Fat16 root directory is a contiguous block of sectors.
   */

    class Fat16RootDirectoryEntryIterator : public DirectoryEntryIterator {

      protected:
        uint32_t _currentIndex;
        uint32_t _firstEntryInCurrentSector;
        uint32_t _entriesPerSector;
        uint32_t _rootDirMaxEntries;
        Memblock<uint8_t> _currentSector;

      protected:
        uint32_t entryOffsetInSector(uint32_t entryIndex) const;
        bool isEntryInCurrentSector() const;
        uint32_t sectorIndexForEntry(uint32_t entryIndex) const;
        bool readSectorForEntry(uint32_t entryIndex);
        
      // overrides from DirectoryEntryIterator

        virtual bool internalNext() override;
        virtual bool extendDirectory(DirectoryEntry *dirents,uint32_t direntCount) override;

      // overrides from ResetableIterator

        virtual void reset() override;

      public:

        /**
         * Error codes
         */

        enum {

          /// The root directory is full
          E_ROOT_DIRECTORY_FULL = 1
        };

      public:
        Fat16RootDirectoryEntryIterator(FatFileSystem& fs_,Options options_);

        /**
         * Virtual destructor. Does nothing
         */

        virtual ~Fat16RootDirectoryEntryIterator() {}
    };

  }
}

// END FILE: ../lib/include/filesystem/fat/Fat16RootDirectoryEntryIterator.h
// START FILE: ../lib/include/filesystem/fat/ClusterChainIterator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fat {

  /**
   * @brief Iterate over the clusters in a chain
   */

    class ClusterChainIterator : public Iterator<uint32_t> {

      public:
        /**
         * Whether to extend the chain when the end is hit
         */

        enum ExtensionMode {
          /// Extend the chain.
          extensionExtend,

          /// Don't extend the chain.
          extensionDontExtend };

      protected:
        bool _first;
        ExtensionMode _extend;
        uint32_t _currentClusterNumber;
        uint32_t _firstClusterNumber;
        FatFileSystem& _fs;

      public:
        ClusterChainIterator(FatFileSystem& fs_,uint32_t firstClusterNumber_,ExtensionMode extend_);

        /**
         * Virtual destructor, do nothing.
         */

        virtual ~ClusterChainIterator() {}

        uint32_t currentSectorNumber();
        void reset(uint32_t firstClusterNumber_);

        // overrides from Iterator

        virtual bool next() override;
        virtual uint32_t current() override;
    };

  }
}


// END FILE: ../lib/include/filesystem/fat/ClusterChainIterator.h
// START FILE: ../lib/include/util/MinMax.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


#error The use of Min, Max and Abs from this file is now deprecated. Please migrate to std::min, std::max and std::abs. This file will be deleted in a future release.


  /**
   * Max implementation with templates
   * @param a
   * @param b
   * @return The greater of a,b
   */

  template<typename T>
  constexpr inline const T& Max(const T& a,const T& b) {
    return (a>b) ? a : b;
  }

  /**
   * Min implementation with templates
   * @param a
   * @param b
   * @return The lesser of a,b
   */

  template<typename T>
  constexpr inline const T& Min(const T& a,const T& b) {
    return (a<b) ? a : b;
  }

  /**
   * Abs implementation with templates
   * @param a negative or positive value
   * @return A positive version of the parameter
   */

  template<typename T>
  constexpr inline const T Abs(const T a) {
    return a<0 ? -a : a;
  }
}
// END FILE: ../lib/include/util/MinMax.h
// START FILE: ../lib/include/util/StdExt.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once

/**
 * This file contains useful STL/libstdc++/boost features not found in the SGI STL
 * included in this library
 */

namespace std {


  typedef char (&_is_base_of_yes)[1];
  typedef char (&_is_base_of_no)[2];

  template <typename B,typename D>
  struct _is_base_of_host {
    operator B*() const;
    operator D*();
  };

  template <typename B,typename D>
  struct is_base_of
  {
    template<typename T>
    static _is_base_of_yes check(D*, T);
    static _is_base_of_no check(B*,int);

    static const bool value=sizeof(check(_is_base_of_host<B,D>(),int()))==sizeof(_is_base_of_yes);
  };


  template<class InputIterator, class UnaryPredicate>
  bool all_of (InputIterator first, InputIterator last, UnaryPredicate pred) {
    while (first!=last) {
      if (!pred(*first)) return false;
      ++first;
    }
    return true;
  }


  template<class InputIterator, class UnaryPredicate>
  bool any_of (InputIterator first, InputIterator last, UnaryPredicate pred) {
    while (first!=last) {
      if (pred(*first)) return true;
      ++first;
    }
    return false;
  }


  template<class InputIterator, class UnaryPredicate>
  bool none_of (InputIterator first, InputIterator last, UnaryPredicate pred) {
    while (first!=last) {
      if (pred(*first)) return false;
      ++first;
    }
    return true;
  }


  template<class InputIterator, class UnaryPredicate>
  InputIterator find_if_not (InputIterator first, InputIterator last, UnaryPredicate pred) {
    while (first!=last) {
      if (!pred(*first)) return first;
      ++first;
    }
    return last;
  }
}
// END FILE: ../lib/include/util/StdExt.h
// START FILE: ../lib/include/util/Meta.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


/**
 * @file
 * This file contains template metaprogramming helpers used elsewhere in the library
 */

namespace stm32plus {

  /**
   * Recursive initialisation of feature classes defined using variadic templates.
   * This initialiser is "void initialise()"
   * Here's the forward definition
   */

  template<class F,class... T>
  struct RecursiveVoidInit;

  /**
   * Recursion termination condition, always return success
   */

  template<class F>
  struct RecursiveVoidInit<F> {
    static void tinit(F *) {
    }
  };


  /**
   * General recursive initialiser
   */

  template<class F,class T,class... G>
  struct RecursiveVoidInit<F,T,G...> {
    static void tinit(F *ptr) {

      ptr->T::initialise();
      RecursiveVoidInit<F,G...>::tinit(ptr);
    }
  };


  /**
   * Recursive initialisation of feature classes defined using variadic templates.
   * This initialiser has a parameters class and returns bool
   * Here's the forward definition
   */

  template<class F,class... T>
  struct RecursiveBoolInitWithParams;

  /**
   * Recursion termination condition, always return success
   */

  template<class F>
  struct RecursiveBoolInitWithParams<F> {
    static bool tinit(F *,typename F::Parameters&) {
      return true;
    }
  };


  /**
   * General recursive initialiser
   */

  template<class F,class T,class... G>
  struct RecursiveBoolInitWithParams<F,T,G...> {
    static bool tinit(F *ptr,typename F::Parameters& p) {

      if(!ptr->T::initialise(p))
        return false;

      return RecursiveBoolInitWithParams<F,G...>::tinit(ptr,p);
    }
  };


  /**
   * Recursive startup of feature classes defined using variadic templates.
   * This initialiser returns bool
   * Here's the forward definition
   */

  template<class F,class... T>
  struct RecursiveBoolStartup;

  /**
   * Recursion termination condition, always return success
   */

  template<class F>
  struct RecursiveBoolStartup<F> {
    static bool tstartup(F *) {
      return true;
    }
  };


  /**
   * General recursive initialiser
   */

  template<class F,class T,class... G>
  struct RecursiveBoolStartup<F,T,G...> {
    static bool tstartup(F *ptr) {

      if(!ptr->T::startup())
        return false;

      return RecursiveBoolStartup<F,G...>::tstartup(ptr);
    }
  };
}
// END FILE: ../lib/include/util/Meta.h
// START FILE: ../lib/include/util/DoublePrecision.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus  {

  /**
   * Carrier class for a double and it's desired output
   * precision
   */

  struct DoublePrecision {

    enum {
      MAX_DOUBLE_FRACTION_DIGITS = 5
    };

    /**
     * The encapsulated value
     */

    double Value;

    /**
     * The number of fractional digits
     */

    uint8_t Precision;


    /**
     * Constructor
     * @param d The value to encapsulate
     * @param precision The number of fractional digits
     */

    DoublePrecision(double d,uint8_t precision) {
      Value=d;
      Precision=precision;
    }
  };
}

// END FILE: ../lib/include/util/DoublePrecision.h
// START FILE: ../lib/include/util/BitHacks.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {
  namespace bithacks {


    /**
     * Get the positional index of the first bit set in 'word'. The 32-bit multiply operation is
     * single-cycle on the m3 and m4 and possibly the m0.
     * @param word the word to scan
     * @return 0..31
     */

    inline uint8_t firstSetBit(uint32_t word) {

      static const uint8_t MultiplyDeBruijnBitPosition[32] = {
        0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
        31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
      };

      return MultiplyDeBruijnBitPosition[((uint32_t)((word & -word) * 0x077CB531U)) >> 27];
    }


    /**
     * Reverse the ordering of bytes in a 16-bit word
     * @param data The word to swap
     * @return The word with byte ordering swapped
     */

    inline uint16_t swapBytes(uint16_t data) {

      uint16_t result;

      asm volatile( "rev16 %0, %1" : "=&r" (result) : "r" (data) );
      return result;
    }
  }
}
// END FILE: ../lib/include/util/BitHacks.h
// START FILE: ../lib/include/timing/RtcTimeProvider.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Time provider that uses the real time clock
   */

  class RtcTimeProvider : public TimeProvider {
    protected:
      const RtcBase& _rtc;

    public:

      /**
       * Constructor.
       * @param[in] rtc_ The RTC. Caller supplied parameter, must not go out of scope.
       */

      RtcTimeProvider(const RtcBase& rtc) :
        _rtc(rtc) {
      }

      /**
       * Virtual destructor
       */

      virtual ~RtcTimeProvider() {}

      /**
       * Return the time. Actually returns the tick-count from the RTC.
       * @return The tick count.
       */

      virtual time_t getTime() const override {
        return _rtc.getTick();
      }
  };

}
// END FILE: ../lib/include/timing/RtcTimeProvider.h
// START FILE: ../lib/include/timing/TimeProvider.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Base class for classes that are able to provide a time.
   * The time is required for file system operations that need to create or write to files.
   */

  class TimeProvider {

    public:

      virtual ~TimeProvider() {}

      /**
       * Return the time as a Unix time_t
       * @return The current time.
       */

      virtual time_t getTime() const=0;
  };
}
// END FILE: ../lib/include/timing/TimeProvider.h
// START FILE: ../lib/include/timing/MicrosecondDelay.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief Delay for a number of microseconds.
   * We use an STM32 timer to provide a microsecond delay. We're agnostic as to which timer you use
   * and this template is parameterised by that timer class. A concrete type 'MicrosecondDelay' is typedef'd
   * that uses TIM6 as the timer.
   * @tparam TTimer The timer type to use for this functionality.
   */

  template<class TTimer>
  class MicrosecondDelayTemplate {

    protected:
      static TTimer *_timer;
      static volatile uint16_t *_counterRegister;

    public:

      /**
       * Initialise the timer.
       */

      static void initialise();

      /**
       * Delay synchronously to the caller for the given number of microseconds.
       * @param[in] us The number of microseconds to delay for.
       */

      static void delay(uint16_t us);
  };


  /**
   * Use the basic timer TIM6 as a default for doing the microsecond delay.
   */

  typedef MicrosecondDelayTemplate<Timer6<Timer6InternalClockFeature> > MicrosecondDelay;


  /**
   * Template static member initialisation
   */

  template<class TTimer> TTimer * MicrosecondDelayTemplate<TTimer>::_timer;
  template<class TTimer> volatile uint16_t *MicrosecondDelayTemplate<TTimer>::_counterRegister;


  /**
   * Initialise the timer by setting it up to tick at 1Mhz
   */

  template<class TTimer>
  inline void MicrosecondDelayTemplate<TTimer>::initialise() {

    uint32_t regbase;

    // create the timer object and configure the timebase

    _timer=new TTimer;
    _timer->setTimeBaseByFrequency(1000000,UINT16_MAX);

    // enable the timer

    _timer->enablePeripheral();

    // remember the counter register

    regbase=(uint32_t)((TIM_TypeDef *)*_timer);
    _counterRegister=(volatile uint16_t *)(regbase+__builtin_offsetof(TIM_TypeDef,CNT));
  }


  /**
   * Delay for the given microseconds. The total delay is approximate. There is a clock-speed
   * dependent constant overhead to calling into, and returning from, this function. Attempting to take
   * this call delay into account without coding the whole thing in asm is folly - the optimiser and
   * the CPU instruction pipeline will all conspire to ensure you get it wrong.
   * @param microseconds the number of microseconds to delay for.
   */

  template<class TTimer>
  inline void MicrosecondDelayTemplate<TTimer>::delay(uint16_t microseconds) {

    // reset the counter register to zero then wait for it to
    // tick up by the required number of microseconds

    *_counterRegister=0;
    while(*_counterRegister<=microseconds);
  }
}
// END FILE: ../lib/include/timing/MicrosecondDelay.h
// START FILE: ../lib/include/timing/NullTimeProvider.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief null time provider, always returns zero
   */

  class NullTimeProvider : public TimeProvider {

    public:
      /**
       * Virtual destructor
       */

      virtual ~NullTimeProvider() {}

      /**
       * Get the current time. For this Null provider it is always zero.
       * @return zero.
       */

      virtual time_t getTime() const override {
        return static_cast<time_t> (0);
      }
  };
}
// END FILE: ../lib/include/timing/NullTimeProvider.h
// START FILE: ../lib/include/timing/MillisecondTimer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/**
 * The stm32plus namespace is the top-level namespace for all classes in the library.
 */

namespace stm32plus {

  /**
   * @brief Millisecond delay counter using the SYSTICK core peripheral
   */

  class MillisecondTimer {

    public:
      volatile static uint32_t _counter;

    public:
      static void initialise();
      static void __attribute__ ((weak)) delay(uint32_t millis_);
      static uint32_t millis();
      static void reset();
      static bool hasTimedOut(uint32_t start,uint32_t timeout);
      static uint32_t difference(uint32_t start);
  };


  /**
   * Get the current value of the systick counter.
   * @return The current value of the counter.
   */

  inline uint32_t MillisecondTimer::millis() {
    return _counter;
  }


  /**
   * Reset the counter to zero
   */

  inline void MillisecondTimer::reset() {
    _counter=0;
  }


  /**
   * Check if a timeout has been exceeded. This is designed to cope with wrap around
   * @return true if the timeout has expired
   */

  inline bool MillisecondTimer::hasTimedOut(uint32_t start,uint32_t timeout) {
    return difference(start)>timeout;
  }


  /**
   * Return the difference between a starting time and now, taking into account
   * wrap around
   * @param start when we started timing
   * @return The difference
   */

  inline uint32_t MillisecondTimer::difference(uint32_t start) {

    uint32_t now=millis();

    if(now>=start)
      return now-start;
    else
      return now+(UINT32_MAX-start+1);
  }
}

// END FILE: ../lib/include/timing/MillisecondTimer.h
// START FILE: ../lib/include/debug/usartHeapMonitor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {


  /**
   * Convenient extension of the heap monitor to output to a usart
   */

  class UsartHeapMonitor : public HeapMonitor {

    protected:
      UsartPollingOutputStream *_usartOutputStream;

    public:
      UsartHeapMonitor();
      void start(RtcSecondInterruptFeature& rtc,uint32_t frequency,Usart& usart);
  };


  /**
   * Constructor
   */

  inline UsartHeapMonitor::UsartHeapMonitor()
    : _usartOutputStream(nullptr) {
  }


  /**
   * Start it off
   * @param rtc RTC instance
   * @param usart The usart to use
   * @param frequency
   */

  inline void UsartHeapMonitor::start(RtcSecondInterruptFeature& rtc,uint32_t frequency,Usart& usart) {

    if(_usartOutputStream)
      delete _usartOutputStream;

    _usartOutputStream=new UsartPollingOutputStream(usart);
    HeapMonitor::start(rtc,*_usartOutputStream,frequency);
  }
}
// END FILE: ../lib/include/debug/usartHeapMonitor.h
// START FILE: ../lib/include/debug/heapMonitor.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {


  /**
   * The heap monitor class provides a period dump of the state of the heap
   * to an output stream. The RTC is used to provide the interrupt that we
   * use to get the heap state.
   */

  class HeapMonitor {

    protected:
      RtcSecondInterruptFeature *_rtc;
      TextOutputStream  *_os;
      uint32_t _frequency;
      uint32_t _currentTick;

    protected:
    #if defined(STM32PLUS_F4)
      void onTick(uint8_t extiNumber);
    #elif defined(STM32PLUS_F1)
      void onTick(void);
    #else
      #error Unsupported MCU
    #endif

    public:
      HeapMonitor();
      ~HeapMonitor();

      void start(RtcSecondInterruptFeature& rtc,OutputStream& os,uint32_t frequency);
      void stop();
  };


  /**
   * Constructor
   */

  inline HeapMonitor::HeapMonitor()
    : _rtc(nullptr),
      _os(nullptr) {
  }


  /**
   * Destructor, stop ticking
   */

  inline HeapMonitor::~HeapMonitor() {

    stop();

    if(_os)
      delete _os;
  }


  /**
   * start ticking
   * @param rtc Rtc interrupt feature
   * @param os output stream
   * @param frequency how many seconds between statistics
   */

  inline void HeapMonitor::start(RtcSecondInterruptFeature& rtc,OutputStream& os,uint32_t frequency) {

    _rtc=&rtc;
    _os=new TextOutputStream(os);
    _frequency=frequency;
    _currentTick=0;

    #if defined(STM32PLUS_F4)
      rtc.ExtiInterruptEventSender.insertSubscriber(ExtiInterruptEventSourceSlot::bind(this,&HeapMonitor::onTick));
    #elif defined(STM32PLUS_F1)
      rtc.RtcSecondInterruptEventSender.insertSubscriber(RtcSecondInterruptEventSourceSlot::bind(this,&HeapMonitor::onTick));
    #else
      #error Unsupported MCU
    #endif
  }


  /**
   * stop ticking
   */

  inline void HeapMonitor::stop() {

    _currentTick=0;

    #if defined(STM32PLUS_F4)
      _rtc->ExtiInterruptEventSender.removeSubscriber(ExtiInterruptEventSourceSlot::bind(this,&HeapMonitor::onTick));
    #elif defined(STM32PLUS_F1)
      _rtc->RtcSecondInterruptEventSender.removeSubscriber(RtcSecondInterruptEventSourceSlot::bind(this,&HeapMonitor::onTick));
    #else
      #error Unsupported MCU
    #endif
  }


  /**
   * We ticked.
   */

#if defined(STM32PLUS_F4)

  inline void HeapMonitor::onTick(uint8_t /* extiNumber */) {

    // check frequency

    if(++_currentTick<_frequency)
      return;

    // get statistics

    struct mallinfo minfo=mallinfo();

    // send to the output stream

    *_os << (uint32_t)minfo.arena << ","
         << (uint32_t)minfo.ordblks << ","
         << (uint32_t)minfo.hblks << ","
         << (uint32_t)minfo.hblkhd << ","
         << (uint32_t)minfo.uordblks << ","
         << (uint32_t)minfo.fordblks << ","
         << (uint32_t)minfo.keepcost << "\r\n";
  }

#elif defined(STM32PLUS_F1)

  inline void HeapMonitor::onTick(void) {

    // check frequency

    if(++_currentTick<_frequency)
      return;

    // get statistics

    struct mallinfo minfo=mallinfo();

    // send to the output stream

    *_os << (uint32_t)minfo.arena << ","
         << (uint32_t)minfo.ordblks << ","
         << (uint32_t)minfo.hblks << ","
         << (uint32_t)minfo.hblkhd << ","
         << (uint32_t)minfo.uordblks << ","
         << (uint32_t)minfo.fordblks << ","
         << (uint32_t)minfo.keepcost << "\r\n";
  }

#else
    #error Unsupported MCU
#endif

}
// END FILE: ../lib/include/debug/heapMonitor.h
// START FILE: ../lib/include/debug/SemiHosting.h
/**
 * Copyright (c) 2012 Linaro Limited
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of Linaro Limited nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 */


#pragma once


/**
 * In accordance with the above license I need to point out that this file
 * was modified in order to port it to C++. There was some adjustments and
 * the operator<< was added.
 */


#define SYS_OPEN	1
#define OPEN_RDONLY	1
#define SYS_CLOSE	2
#define SYS_WRITEC  3
#define SYS_WRITE0	4
#define SYS_WRITE   5
#define SYS_READ	6
#define SYS_READC   7
#define SYS_FLEN	0x0C
#define SYS_GET_CMDLINE	0x15
#define SYS_REPORTEXC	0x18
#define REPORTEXC_REASON_APP_EXIT 0x20026
#define SEMIHOSTING_SVC	0x123456	/* SVC comment field for semihosting */


namespace stm32plus {


#if defined(SEMIHOSTING)


  /**
   * Class for using the SemiHosting capabilities. This prevents the use of the printf and
   * friends, saving precious memory.
   */

  class SemiHosting {

    protected:

      /**
       * \brief Executes the call to the SemiHost
       * \details This is the core of the class.
       * \param id - The function to perform. This will be R0
       * \param arg - The pointer to the arguments to the function. This will be R1
       * \return The new value for R0
       */
      //This function can't be optimized because of the reg0 and reg1 assignments
      static inline int __semi_call(int id,const char *arg) __attribute__((optimize ("O0") )) {
        register int reg0 asm("r0") __attribute__((__unused__));
        register int reg1 asm("r1") __attribute__((__unused__));
        reg0=id;
        reg1=(int)arg;

#if defined(MACH_MPS)
        //profile semihosting is via bpkt
        asm("bkpt    0xab");
#elif defined(__thumb__)
        //Otherwise, different SVC numbers for ARM or Thumb mode
        asm("bkpt #0xAB");
#else
        asm("svc 0x00123456");
#endif
        //asm("mov pc, lr");

        return (reg0);
      }

    public:
      /**
       * \brief Opens a file
       * \details The following table gives the valid values for the integer,
       * and their corresponding ISO C fopen() mode.:

       mode            | 0 | 1  |  2 |	 3  | 4  | 5  | 6  |  7  |	8 |  9 | 10 | 11
       --------------- |-- | -- | -- | --- | -- | -- | -- | --  | -- | -- | -- | --
       ISO C fopen mode| r | rb | r+ |	r+b |  w | wb |	w+ | w+b |	a |	ab | a+ | a+b

       * \param filename - The name of the file
       * \param mode - The open mode.
       * \return A file descriptor (FD)
       * \warning Not tested!
       */
      static int open(const char *filename,int mode) {
        struct {
          char const *filename;
          int mode;
          int filename_length;
        }args;

        args.filename=filename;
        args.mode=mode;
        args.filename_length=strlen(filename);

        return __semi_call(SYS_OPEN,(char*)&args);
      }

      /**
       * \brief Closes a file
       * \param fd - The file descriptor
       * \return 0 if successful | -1 if error
       * \warning Not tested!
       */
      static int close(int fd) {
        return __semi_call(SYS_CLOSE,(char*)&fd);
      }

      /**
       * \brief Writes a string to the SemiHost
       * \param s - The string to print
       * \return N.A.
       */
      static int puts(const char *s) {
        return __semi_call(SYS_WRITE0,s);
      }

      /**
       * \brief Writes to a file using the SemiHost
       * \param fd - The file descriptor
       * \param buffer - The string
       * \param length - The string lenght
       * \return 0 if successful or the number of bytes that are not written, if there is an error.
       */
      static int write(int fd,char *buffer,int length) {
        struct {
            int fd;
            char *buffer;
            int length;
        } args;

        args.fd=fd;
        args.buffer=buffer;
        args.length=length;

        return __semi_call(SYS_WRITE,(char*)&args);
      }

      /**
       * \brief Reads from a file using the SemiHost
       * \param fd - The file descriptor
       * \param buffer - The string
       * \param length - The string lenght
       * \return 0 if successful. If it returns the same value as the length the call has failed and EOF is assumed.
       * If it returns a smaller value as the length, the call was partially successful. No error is assumed, but the buffer has not been filled.
       * \warning Not tested!
       */
      static int read(int fd,char *buffer,int length) {
        struct {
            int fd;
            char *buffer;
            int length;
        } args;

        args.fd=fd;
        args.buffer=buffer;
        args.length=length;

        return __semi_call(SYS_READ,(char*)&args);
      }

      /**
       * \brief Returns the length of a specified file.
       * \param fd - The file descriptor
       * \return the current length of the file object, if the call is successful. -1 if an error occurs.
       * \warning Not tested!
       */
      static int flen(int fd) {
        return __semi_call(SYS_FLEN,(char*)&fd);
      }

      /**
       * \brief Returns the command line used to call the executable, that is, argc and argv.
       * \param buffer - A buffer to write to
       * \param size - The size of the buffer
       * \param length - The length of the buffer after executing
       * \return 0 if successful. -1 if not successful
       * \warning Not tested!
       */
      static int get_cmdline(char *buffer,int size,int *length) {
        int result;
        struct {
            char *buffer;
            int size;
        } args;

        args.buffer=buffer;
        args.size=size;

        result=__semi_call(SYS_GET_CMDLINE,(char *)&args);
        if(result)
          return result;

        if(length)
          *length=args.size;

        return 0;
      }

      /**
       * \brief Report an exception to the debugger directly
       * \param reason - The exception. \see http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0471g/Bgbjjgij.html
       * \return Not used
       * \warning Not tested!
       */
      static int reportexc(int reason) {
        return __semi_call(SYS_REPORTEXC,(char *)reason);
      }

      /**
       * \brief Prints a error message
       * \param message - The error message
       * \return Not used
       * \warning Not tested!
       */
      static void fatal(const char *message) {
        puts(message);
        exit();
      }

      /**
       * \brief Create a report for the APP EXIT
       * \return Not used
       * \warning Not tested!
       */
      static void exit(void) {
        reportexc(REPORTEXC_REASON_APP_EXIT);
        for(;;);
      }

      /**
       * \brief Opens a file (read only) and points to the EOF
       * \param dest - The file carret position
       * \param size - The amount of data readed.
       * \param filename - The filename.
       * \return 0 if successful. -1 if an error occurred
       * \warning Not tested!
       */
      /* semi_load_file: *dest is advanced to point to the end of the loaded data */
      static int load_file(void **dest,unsigned *size,const char *filename) {
        int result=-1; /* fail by default */
        int fd=-1;
        int filesize;

        fd=open(filename,OPEN_RDONLY);
        if(fd == -1) {
          puts("Cannot open file: ");
          goto out;
        }

        filesize=flen(fd);
        if(filesize == -1) {
          puts("Cannot get file size for: ");
          goto out;
        }

        if(read(fd,(char*)*dest,filesize)) {
          puts("Could not read: ");
          goto out;
        }

        result=0; /* success */
        *dest=(char *)*dest + filesize;

        out: if(fd != -1)
          close(fd);

        if(result) { /* print context for the error message */
          puts(filename);
          puts("\n");
        } else if(size)
          *size=filesize;

        return result;
      }

      /**
       * Operator redefinition to print strings and variables.
       */
      SemiHosting& operator<<(const char* s) {
        __semi_call(SYS_WRITE0,s);
        return *this;
      }

      SemiHosting& operator<<(const DoublePrecision& val) {
        char buffer[25];
        StringUtil::modp_dtoa(val.Value,val.Precision,buffer);
        __semi_call(SYS_WRITE0,buffer);
        return *this;
      }

      SemiHosting& operator<<(double val) {
        return operator<<(DoublePrecision(val,DoublePrecision::MAX_DOUBLE_FRACTION_DIGITS));
      }

      SemiHosting& operator<<(int32_t i) {
        char buffer[15];
        StringUtil::itoa(i,buffer,10);
        __semi_call(SYS_WRITE0,buffer);
        return *this;
      }

      SemiHosting& operator<<(uint32_t i) {
        char buffer[15];
        StringUtil::modp_uitoa10(i,buffer);
        __semi_call(SYS_WRITE0,buffer);
        return *this;
      }

      SemiHosting& operator<<(int i) {
        char buffer[15];
        StringUtil::itoa(i,buffer,10);
        __semi_call(SYS_WRITE0,buffer);
        return *this;
      }

      SemiHosting& operator<<(unsigned int i) {
        char buffer[15];
        StringUtil::modp_uitoa10(i,buffer);
        __semi_call(SYS_WRITE0,buffer);
        return *this;
      }

      SemiHosting& operator<<(int16_t i) {
        return operator<<((int32_t)i);
      }

      SemiHosting& operator<<(uint16_t i) {
        return operator<<((uint32_t)i);
      }

      SemiHosting& operator<<(int8_t i) {
        return operator<<((int32_t)i);
      }

      SemiHosting& operator<<(uint8_t i) {
        return operator<<((uint32_t)i);
      }
  };

#else

  /**
   * Stub class for builds where SEMIHOSTING is not defined. This will be optimised to nothing
   * by the gcc optimiser
   */

  class SemiHosting {

    public:
      static int open(const char *,int) { return 0; }
      static int close(int) { return 0; }
      static int puts(const char *) { return 0; }
      static int write(int,char *,int) { return 0; }
      static int read(int,char *,int) { return 0; }
      static int flen(int) { return 0; }
      static int get_cmdline(char *,int,int *) { return 0; }
      static int reportexc(int) { return 0; }
      static void fatal(const char *) {}
      static void exit(void) {}
      static int load_file(void **,unsigned *,const char *) { return 0; }

      SemiHosting& operator<<(const char*) { return *this; }
      SemiHosting& operator<<(const DoublePrecision&) { return *this; }
      SemiHosting& operator<<(double) { return *this; }
      SemiHosting& operator<<(int32_t) { return *this; }
      SemiHosting& operator<<(uint32_t) { return *this; }
      SemiHosting& operator<<(int) { return *this; }
      SemiHosting& operator<<(unsigned int) { return *this; }
      SemiHosting& operator<<(int16_t) { return *this; }
      SemiHosting& operator<<(uint16_t) { return *this; }
      SemiHosting& operator<<(int8_t) { return *this; }
      SemiHosting& operator<<(uint8_t) { return *this; }
  };

#endif
}
// END FILE: ../lib/include/debug/SemiHosting.h
// START FILE: ../lib/include/nvic/f4/NvicPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#if !defined(STM32PLUS_F4)
#error This include file is only for the F4
#endif


namespace stm32plus {

  /**
   * @brief F4 implementation of the NVIC
   *
   * The NVIC methods allow us to configure the number of bits available for priority and subpriority. The default
   * is all 4 bits for priority and none for subpriority. Other methods allow us to enable/disable the IRQ for
   * a given peripheral.
   */

  class Nvic {

    public:
      static void initialise(uint32_t priorityGroup=NVIC_PriorityGroup_4);
      static void configureIrq(uint8_t interrupt,FunctionalState state=ENABLE,uint8_t preemptionPriority=0,uint8_t subPriority=0);
      static void disableAllInterrupts();
      static void enableAllInterrupts();
      static bool isAnyIrqActive();
      static void systemReset();
  };


  /**
   * Initialise the Nvic group that determines the bits available for priority/subpriority
   */

  inline void Nvic::initialise(uint32_t priorityGroup) {
    NVIC_PriorityGroupConfig(priorityGroup);
  }


  /**
   * Enable or disable an interrupt.
   * @param[in] interrupt The peripheral identifier.
   * @param[in] state The new state, ENABLE or DISABLE. Default is ENABLE.
   * @param[in] preemptionPriority The new preemption priority. Default is 0.
   * @param[in] subPriority The new preemption subpriority. Default is 0.
   */

  inline void Nvic::configureIrq(uint8_t interrupt,FunctionalState state,uint8_t preemptionPriority,uint8_t subPriority) {

    NVIC_InitTypeDef nit;

    nit.NVIC_IRQChannel=interrupt;
    nit.NVIC_IRQChannelPreemptionPriority=preemptionPriority;
    nit.NVIC_IRQChannelSubPriority=subPriority;
    nit.NVIC_IRQChannelCmd=state;

    NVIC_Init(&nit);
  }


  /**
   * Disable all the interrupts
   */

  inline void Nvic::disableAllInterrupts() {
    __disable_irq();
  }


  /**
   * Enable all the interrupts
   */

  inline void Nvic::enableAllInterrupts() {
    __enable_irq();
  }


  /**
   * Return true if any IRQ is currently active
   */

  inline bool Nvic::isAnyIrqActive() {
    return NVIC->IABR[0]!=0 ||
           NVIC->IABR[1]!=0 ||
           NVIC->IABR[2]!=0 ||
           NVIC->IABR[3]!=0 ||
           NVIC->IABR[4]!=0 ||
           NVIC->IABR[5]!=0 ||
           NVIC->IABR[6]!=0 ||
           NVIC->IABR[7]!=0;
  }
  
  
  /**
   * Trigger a soft reset of the MCU.
   */
  
  inline void Nvic::systemReset() {
    NVIC_SystemReset(); 
  }
}
// END FILE: ../lib/include/nvic/f4/NvicPeripheral.h
// START FILE: ../lib/include/memory/circular_buffer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Template class to manage a circular buffer of types. Separate read and write pointers are
   * maintained. Methods are provided to read from and write to the buffer. More methods are provided
   * to find out how much read space and write space is available without overrunning the other
   * position.
   *
   * The 'last operation type' flag is stored in the high bit of the read index. This allows the
   * availableToWrite() and availableToRead() methods to get at the read index and the flag in an
   * atomic operation. This makes this class safe to use for an IRQ-based writer and a normal code
   * reader - but not the other way around.
   */

  template<typename T>
  class circular_buffer {

    protected:

      enum {
        LAST_OP_READ_FLAG = 0x80000000,
        READ_INDEX_MASK = ~LAST_OP_READ_FLAG
      };

      T *_buffer;
      uint32_t _size;
      uint32_t _readIndex;
      uint32_t _writeIndex;

    public:
      circular_buffer(uint32_t size);
      ~circular_buffer();

      void read(T *output,uint32_t size) volatile;
      T read() volatile;

      void write(const T *input,uint32_t size) volatile;
      void write(const T& input) volatile;

      uint32_t availableToWrite() const volatile;
      uint32_t availableToRead() const volatile;
  };


  /**
   * Constructor
   * @param size The number of types to store in the buffer
   */

  template<typename T>
  inline circular_buffer<T>::circular_buffer(uint32_t size)
    : _buffer(new T[size]),
      _size(size),
      _readIndex(LAST_OP_READ_FLAG),
      _writeIndex(0) {
  }


  /**
   * Destructor
   */

  template<typename T>
  inline circular_buffer<T>::~circular_buffer() {
    delete[] _buffer;
  }


  /**
   * get the number of types that available to write without overrunning the read pointer. In
   * an IRQ-writer, normal reader scenario this method is safe for the IRQ writer to call.
   * @return The number of available types
   */

  template<typename T>
  inline uint32_t circular_buffer<T>::availableToWrite() const volatile {

    volatile uint32_t readIndex;
    bool lastOpRead;

    readIndex=_readIndex;
    lastOpRead=(readIndex & LAST_OP_READ_FLAG)!=0;
    readIndex&=READ_INDEX_MASK;

    if(_writeIndex==readIndex)
      return lastOpRead ? _size : 0;
    else if(_writeIndex>readIndex)
      return _size-_writeIndex+readIndex;
    else
      return readIndex-_writeIndex;
  }


  /**
   * get the number of types that available to read without overrunning the write pointer
   * @return The number of available types
   */

  template<typename T>
  inline uint32_t circular_buffer<T>::availableToRead() const volatile {

    volatile uint32_t readIndex;
    uint32_t ret;
    bool lastOpRead;

    // the loop catches a nasty case where an interrupt gets in between the lines labelled
    // 1 and 2 below and the write index subsequently wraps below the read index

    do {
      readIndex=_readIndex;
      lastOpRead=(readIndex & LAST_OP_READ_FLAG)!=0;
      readIndex&=READ_INDEX_MASK;

      if(_writeIndex==readIndex)
        ret=lastOpRead ? 0 : _size;
      else if(_writeIndex>readIndex)    // 1
        ret=_writeIndex-readIndex;      // 2
      else
        ret=_size-readIndex+_writeIndex;
    } while(ret>_size);

    return ret;
  }


  /**
   * Read a number of types from the buffer. It's your responsibility to ensure that the
   * types are there to read.
   * @param output Where to store the data
   * @param size How many types to read
   */

  template<typename T>
  inline void circular_buffer<T>::read(T *output,uint32_t size) volatile {

    uint32_t pos;

    for(pos=(_readIndex & READ_INDEX_MASK);size!=0;size--) {

      *output++=_buffer[pos];

      if(++pos==_size)
        pos=0;
    }

    _readIndex=pos | LAST_OP_READ_FLAG;
  }


  /*
   * Read a single type
   * @return The next type
   */

  template<typename T>
  inline T circular_buffer<T>::read() volatile {

    uint32_t pos;
    T retval;

    pos=_readIndex & READ_INDEX_MASK;
    retval=_buffer[pos];

    if(++pos==_size)
      pos=0;

    _readIndex=pos | LAST_OP_READ_FLAG;
    return retval;
  }


  /**
   * Write a number of types to the internal buffer. It's your responsibility to ensure that there
   * is sufficient space in the circular buffer to write your data.
   * @param input Your buffer to copy from
   * @param size The number of types to write
   */

  template<typename T>
  inline void circular_buffer<T>::write(const T *input,uint32_t size) volatile {

    uint32_t pos;

    // operate on local version of write index until we're sure it's valid when written back.

    for(pos=_writeIndex;size!=0;size--) {

      _buffer[pos]=*input++;

      if(++pos==_size)
        pos=0;
    }

    _writeIndex=pos;
    _readIndex&=~LAST_OP_READ_FLAG;
  }


  /*
   * Write a single type
   * @param input the single type to write
   */

  template<typename T>
  inline void circular_buffer<T>::write(const T& input) volatile {

    uint32_t pos;

    // operate on local version of write index until we're sure it's valid when written back.

    pos=_writeIndex;
    _buffer[pos]=input;

    if(++pos==_size)
      pos=0;

    _writeIndex=pos;
    _readIndex&=~LAST_OP_READ_FLAG;
  }
}
// END FILE: ../lib/include/memory/circular_buffer.h
// START FILE: ../lib/include/memory/Memblock.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


/**
 * @brief Template class to manage a block of data on the heap
 * @tparam T The type being managed here.
 *
 * Assignment makes a copy and does not transfer ownership of the original. Therefore a=b
 * will make a new copy of b. Memory is copied from b to a using memcpy so obviously this
 * only works with simple types and structures.
 */

  template<typename T>
  class Memblock {

    private:
      T *_data;
      uint32_t _size;

    public:

      /**
       * Default constructor
       */

      Memblock() {
        _data=nullptr;
        _size=0;
      }


      /**
       * Construct with space for the given number of types.
       * @param[in] numTypes The number of types to store here.
       */

      Memblock(uint32_t numTypes) {
        allocate(numTypes);
      }


      /**
       * Copy constructor.
       * @param[in] src The memory block to copy from
       */

      Memblock(const Memblock<T>& src) {
        assign(src);
      }


      /**
       * Destructor, de-allocate memory
       */

      ~Memblock() {
        cleanup();
      }


      /**
       * Get a pointer to the data block.
       * @return A pointer.
       */

      T *getData() const {
        return _data;
      }


      /**
       * Get the number of types being stored here.
       * @return The number of types.
       */

      uint32_t getSize() const {
        return _size;
      }


      /**
       * Cast operator
       * @return A pointer to the data.
       */

      operator T* () {
        return _data;
      }


      /**
       * Assignment operator.
       * @param[in] src The block to assign from.
       * @return A reference to this.
       */

      Memblock<T>& operator=(const Memblock<T>& src) {
        cleanup();
        assign(src);

        return *this;
      }


      /**
       * Array access operator.
       * @param[in] pos The index in the block to return.
       * @return A reference to the item at the index.
       */

      T& operator[](int pos) const {
        return _data[pos];
      }


      /**
       * Reallocate to handle new data. Only increases are supported.
       * @param[in] newSize The size to increase to.
       */

      void reallocate(uint32_t newSize) {
        T *newData;

        if(_data==nullptr)
          allocate(newSize);
        else {
          newData=new T[newSize];
          memcpy(newData,_data,_size*sizeof(T));
          delete [] _data;
          _data=newData;
          _size=newSize;
        }
      }

      /**
       * Free existing data and start with a fresh buffer of the given size
       * @param[in] resetSize The size to start again with
       */

      void reset(uint32_t resetSize) {
        cleanup();
        allocate(resetSize);
      }

    private:

      void allocate(uint32_t numTypes) {
        _data=new T[numTypes];
        _size=numTypes;
      }

      void cleanup() {
        if(_data!=nullptr) {
          delete [] _data;
          _data=nullptr;
          _size=0;
        }
      }

      void assign(const Memblock<T>& src) {
        _data=new T[src.getSize()];
        _size=src.getSize();
        memcpy(_data,const_cast<Memblock<T>&>(src),_size*sizeof(T));
      }
  };


  /// Typedef for the common case of a block of bytes
  typedef Memblock<uint8_t> ByteMemblock;
}
// END FILE: ../lib/include/memory/Memblock.h
// START FILE: ../lib/include/memory/scoped_ptr.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   *
   * A scoped_ptr<T> is like a T*, except that the destructor of scoped_ptr<T>
   * automatically deletes the pointer it holds (if any).
   * That is, scoped_ptr<T> owns the T object that it points to.
   * Like a T*, a scoped_ptr<T> may hold either nullptr or a pointer to a T object.
   * Also like T*, scoped_ptr<T> is thread-compatible, and once you
   * dereference it, you get the threadsafety guarantees of T.
   *
   * The size of a scoped_ptr is small:
   * sizeof(scoped_ptr<C>) == sizeof(C*)
   *
   * This class comes from the Chromium project: http://www.chromium.org/
   * The Chromium license and the rights of the original authors are
   * preserved in full. The stm32plus license does not apply to this file.
   */

  template<class C>
  class scoped_ptr {
    public:

      // The element type
      typedef C element_type;

      // Constructor.  Defaults to intializing with nullptr.
      // There is no way to create an uninitialized scoped_ptr.
      // The input parameter must be allocated with new.
      explicit scoped_ptr(C* p=nullptr) :
          ptr_(p) {
      }

      // Destructor.  If there is a C object, delete it.
      // We don't need to test ptr_ == nullptr because C++ does that for us.
      ~scoped_ptr() {
        enum {
          type_must_be_complete=sizeof(C)
        };
        delete ptr_;
      }

      // Reset.  Deletes the current owned object, if any.
      // Then takes ownership of a new object, if given.
      // this->reset(this->get()) works.
      void reset(C* p=nullptr) {
        if(p != ptr_) {
          enum {
            type_must_be_complete=sizeof(C)
          };
          delete ptr_;
          ptr_=p;
        }
      }

      // Accessors to get the owned object.
      C& operator*() const {
        return *ptr_;
      }
      C* operator->() const {
        return ptr_;
      }
      C* get() const {
        return ptr_;
      }

      C*& address() {
        return ptr_;
      }

      // Comparison operators.
      // These return whether two scoped_ptr refer to the same object, not just to
      // two different but equal objects.
      bool operator==(C* p) const {
        return ptr_ == p;
      }
      bool operator!=(C* p) const {
        return ptr_ != p;
      }

      // Swap two scoped pointers.
      void swap(scoped_ptr& p2) {
        C* tmp=ptr_;
        ptr_=p2.ptr_;
        p2.ptr_=tmp;
      }

      // Release a pointer.
      // The return value is the current pointer held by this object.
      // If this object holds a nullptr pointer, the return value is nullptr.
      // After this operation, this object will hold a nullptr pointer,
      // and will not own the object any more.
      C* release() {
        C* retVal=ptr_;
        ptr_=nullptr;
        return retVal;
      }

    private:
      C* ptr_;

      // Forbid comparison of scoped_ptr types.  If C2 != C, it totally doesn't
      // make sense, and if C2 == C, it still doesn't make sense because you should
      // never have the same object owned by two different scoped_ptrs.
      template<class C2> bool operator==(scoped_ptr<C2> const& p2) const;
      template<class C2> bool operator!=(scoped_ptr<C2> const& p2) const;

      // Disallow evil constructors
      scoped_ptr(const scoped_ptr&);
      void operator=(const scoped_ptr&);
  };

  // Free functions
  template<class C>
  void swap(scoped_ptr<C>& p1,scoped_ptr<C>& p2) {
    p1.swap(p2);
  }

  template<class C>
  bool operator==(C* p1,const scoped_ptr<C>& p2) {
    return p1 == p2.get();
  }

  template<class C>
  bool operator!=(C* p1,const scoped_ptr<C>& p2) {
    return p1 != p2.get();
  }
}
// END FILE: ../lib/include/memory/scoped_ptr.h
// START FILE: ../lib/include/memory/scoped_array.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

namespace stm32plus {

  /**
   * scoped_array<C> is like scoped_ptr<C>, except that the caller must allocate
   * with new [] and the destructor deletes objects with delete [].
   *
   * As with scoped_ptr<C>, a scoped_array<C> either points to an object
   * or is nullptr.  A scoped_array<C> owns the object that it points to.
   * scoped_array<T> is thread-compatible, and once you index into it,
   * the returned objects have only the threadsafety guarantees of T.
   *
   * Size: sizeof(scoped_array<C>) == sizeof(C*)
   * template <class C>
   *
   * This class comes from the Chromium project: http://www.chromium.org/
   * The Chromium license and the rights of the original authors are
   * preserved in full. The stm32plus license does not apply to this file.
   */

  template <class C>
  class scoped_array {

    public:

      // The element type
      typedef C element_type;

      // Constructor.  Defaults to intializing with nullptr.
      // There is no way to create an uninitialized scoped_array.
      // The input parameter must be allocated with new [].
      explicit scoped_array(C* p=nullptr) :
          array_(p) {
      }

      // Destructor.  If there is a C object, delete it.
      // We don't need to test ptr_ == nullptr because C++ does that for us.
      ~scoped_array() {
        enum {
          type_must_be_complete=sizeof(C)
        };
        delete[] array_;
      }

      // Reset.  Deletes the current owned object, if any.
      // Then takes ownership of a new object, if given.
      // this->reset(this->get()) works.
      void reset(C* p=nullptr) {
        if(p != array_) {
          enum {
            type_must_be_complete=sizeof(C)
          };
          delete[] array_;
          array_=p;
        }
      }

      // Get one element of the current object.
      C& operator[](std::ptrdiff_t i) const {
        return array_[i];
      }

      // Get a pointer to the zeroth element of the current object.
      // If there is no current object, return nullptr.
      C* get() const {
        return array_;
      }

      // Comparison operators.
      // These return whether two scoped_array refer to the same object, not just to
      // two different but equal objects.
      bool operator==(C* p) const {
        return array_ == p;
      }
      bool operator!=(C* p) const {
        return array_ != p;
      }

      // Swap two scoped arrays.
      void swap(scoped_array& p2) {
        C* tmp=array_;
        array_=p2.array_;
        p2.array_=tmp;
      }

      // Release an array.
      // The return value is the current pointer held by this object.
      // If this object holds a nullptr pointer, the return value is nullptr.
      // After this operation, this object will hold a nullptr pointer,
      // and will not own the object any more.
      C* release() {
        C* retVal=array_;
        array_=nullptr;
        return retVal;
      }

    private:
      C* array_;

      // Forbid comparison of different scoped_array types.
      template<class C2> bool operator==(scoped_array<C2> const& p2) const;
      template<class C2> bool operator!=(scoped_array<C2> const& p2) const;

      // Disallow evil constructors
      scoped_array(const scoped_array&);
      void operator=(const scoped_array&);
  };


  // Free functions
  template<class C>
  void swap(scoped_array<C>& p1,scoped_array<C>& p2) {
    p1.swap(p2);
  }

  template<class C>
  bool operator==(C* p1,const scoped_array<C>& p2) {
    return p1 == p2.get();
  }

  template<class C>
  bool operator!=(C* p1,const scoped_array<C>& p2) {
    return p1 != p2.get();
  }
}
// END FILE: ../lib/include/memory/scoped_array.h
// START FILE: ../lib/include/memory/linked_ptr.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * A "smart" pointer type with reference tracking.  Every pointer to a
   * particular object is kept on a circular linked list.  When the last pointer
   * to an object is destroyed or reassigned, the object is deleted.
   *
   * Used properly, this deletes the object when the last reference goes away.
   * There are several caveats:
   * - Like all reference counting schemes, cycles lead to leaks.
   * - Each smart pointer is actually two pointers (8 bytes instead of 4).
   * - Every time a pointer is released, the entire list of pointers to that
   *   object is traversed.  This class is therefore NOT SUITABLE when there
   *   will often be more than two or three pointers to a particular object.
   * - References are only tracked as long as linked_ptr<> objects are copied.
   *   If a linked_ptr<> is converted to a raw pointer and back, BAD THINGS
   *   will happen (double deletion).
   *
   * A good use of this class is storing object references in STL containers.
   * You can safely put linked_ptr<> in a vector<>.
   * Other uses may not be as good.
   *
   * Note: If you use an incomplete type with linked_ptr<>, the class
   * *containing* linked_ptr<> must have a constructor and destructor (even
   * if they do nothing!).
   *
   * This class comes from the Chromium project: http://www.chromium.org/
   * The Chromium license and the rights of the original authors are
   * preserved in full. The stm32plus license does not apply to this file.
   */


  // This is used internally by all instances of linked_ptr<>.  It needs to be
  // a non-template class because different types of linked_ptr<> can refer to
  // the same object (linked_ptr<Superclass>(obj) vs linked_ptr<Subclass>(obj)).
  // So, it needs to be possible for different types of linked_ptr to participate
  // in the same circular linked list, so we need a single class type here.
  //
  // DO NOT USE THIS CLASS DIRECTLY YOURSELF.  Use linked_ptr<T>.

  class linked_ptr_internal {
    public:
      // Create a new circle that includes only this instance.
      void join_new() {
        next_ = this;
      }

      // Join an existing circle.
      void join(linked_ptr_internal const* ptr) {
        next_ = ptr->next_;
        ptr->next_ = this;
      }

      // Leave whatever circle we're part of.  Returns true iff we were the
      // last member of the circle.  Once this is done, you can join() another.
      bool depart() {
        if (next_ == this)
          return true;
        linked_ptr_internal const* p = next_;
        while (p->next_ != this)
          p = p->next_;
        p->next_ = next_;
        return false;
      }

    private:
      mutable linked_ptr_internal const* next_;
  };

  template<typename T>
  class linked_ptr {
    public:
      typedef T element_type;

      // Take over ownership of a raw pointer.  This should happen as soon as
      // possible after the object is created.
      explicit linked_ptr(T* ptr = nullptr) {
        capture(ptr);
      }
      ~linked_ptr() {
        depart();
      }

      // Copy an existing linked_ptr<>, adding ourselves to the list of references.
      template<typename U> linked_ptr(linked_ptr<U> const& ptr) {
        copy(&ptr);
      }

      linked_ptr(linked_ptr const& ptr) {
        copy(&ptr);
      }

      // Assignment releases the old value and acquires the new.
      template<typename U> linked_ptr& operator=(linked_ptr<U> const& ptr) {
        depart();
        copy(&ptr);
        return *this;
      }

      linked_ptr& operator=(linked_ptr const& ptr) {
        if (&ptr != this) {
          depart();
          copy(&ptr);
        }
        return *this;
      }

      // Smart pointer members.
      void reset(T* ptr = nullptr) {
        depart();
        capture(ptr);
      }
      T* get() const {
        return value_;
      }
      T* operator->() const {
        return value_;
      }
      T& operator*() const {
        return *value_;
      }
      // Release ownership of the pointed object and returns it.
      // Sole ownership by this linked_ptr object is required.
      T* release() {
        bool last = link_.depart();
        T* v = value_;
        value_ = nullptr;
        return v;
      }

      bool operator==(const T* p) const {
        return value_ == p;
      }
      bool operator!=(const T* p) const {
        return value_ != p;
      }
      template<typename U>
      bool operator==(linked_ptr<U> const& ptr) const {
        return value_ == ptr.get();
      }
      template<typename U>
      bool operator!=(linked_ptr<U> const& ptr) const {
        return value_ != ptr.get();
      }

    private:
      template<typename U>
      friend class linked_ptr;

      T* value_;
      linked_ptr_internal link_;

      void depart() {
        if (link_.depart())
          delete value_;
      }

      void capture(T* ptr) {
        value_ = ptr;
        link_.join_new();
      }

      template<typename U> void copy(linked_ptr<U> const* ptr) {
        value_ = ptr->get();
        if (value_)
          link_.join(&ptr->link_);
        else
          link_.join_new();
      }
  };

  template<typename T> inline
  bool operator==(T* ptr, const linked_ptr<T>& x) {
    return ptr == x.get();
  }

  template<typename T> inline
  bool operator!=(T* ptr, const linked_ptr<T>& x) {
    return ptr != x.get();
  }
}
// END FILE: ../lib/include/memory/linked_ptr.h
// START FILE: ../lib/include/memory/MEM_DataCopy.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


extern "C" {

  void MEM_DataCopy(void *,const void *,size_t);
}


/**
 * Hard-fault issues have been reported with MEM_DataCopy that I have not yet been able
 * to reproduce. For that reason it's now an opt-in optimisation
 */

#if defined(USE_MEMDATACOPY)
#undef memcpy                   // just in case
#define memcpy(a,b,c) MEM_DataCopy(a,b,c)
#endif
// END FILE: ../lib/include/memory/MEM_DataCopy.h
// START FILE: ../lib/include/i2c/f4/I2C1.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct I2C1_Custom : I2CPeripheral<TPinPackage,PERIPHERAL_I2C1>,
                       Features... {

    I2C1_Custom(const typename I2CPeripheral<TPinPackage,PERIPHERAL_I2C1>::Parameters& params)
      : I2CPeripheral<TPinPackage,PERIPHERAL_I2C1>(params),
        Features(static_cast<I2C&>(*this))... {
    }
  };


  /*
   * Default pin package:
   * (SCL,SDA) = (PB6,PB7)
   */

  struct I2C1DefaultPinPackage {
    enum {
      Port_SCL=GPIOB_BASE,
      Port_SDA=GPIOB_BASE,

      Pin_SCL=GPIO_Pin_6,
      Pin_SDA=GPIO_Pin_7
    };
  };


  /**
   * Convenience class to match the F1 pin for pin. This can't be named I2C1 because of
   * a name clash in the std peripheral library
   */

  template<class... Features>
  struct I2C1_Default : I2CPeripheral<I2C1DefaultPinPackage,PERIPHERAL_I2C1>,
                        Features... {

    I2C1_Default(const Parameters& params)
      : I2CPeripheral<I2C1DefaultPinPackage,PERIPHERAL_I2C1>(params),
        Features(static_cast<I2C&>(*this))... {
    }
  };


  /*
   * Remap #1:
   * (SCL,SDA) = (PB8,PB9)
   */

  struct I2C1RemapPinPackage {
    enum {
      Port_SCL=GPIOB_BASE,
      Port_SDA=GPIOB_BASE,

      Pin_SCL=GPIO_Pin_8,
      Pin_SDA=GPIO_Pin_9
    };
  };


  /**
   * Convenience class to match the F1 pin for pin.
   */

  template<class... Features>
  struct I2C1_Remap : I2CPeripheral<I2C1RemapPinPackage,PERIPHERAL_I2C1>,
                      Features... {

    I2C1_Remap(const Parameters& params)
      : I2CPeripheral<I2C1RemapPinPackage,PERIPHERAL_I2C1>(params),
        Features(static_cast<I2C&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/i2c/f4/I2C1.h
// START FILE: ../lib/include/i2c/f4/I2C2Remap.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /*
   * Remap #1 pin package:
   * (SCL,SDA) = (PF1,PF0)
   */

  struct I2C2Remap1PinPackage {
    enum {
      Port_SCL=GPIOF_BASE,
      Port_SDA=GPIOF_BASE,

      Pin_SCL=GPIO_Pin_1,
      Pin_SDA=GPIO_Pin_0
    };
  };


  /**
   * Class to manage the remap package
   */

  template<class... Features>
  struct I2C2_Remap1 : I2CPeripheral<I2C2Remap1PinPackage,PERIPHERAL_I2C2>,
                       Features... {

    I2C2_Remap1(const Parameters& params)
      : I2CPeripheral<I2C2Remap1PinPackage,PERIPHERAL_I2C2>(params),
        Features(static_cast<I2C&>(*this))... {
    }
  };


  /*
   * Remap #2 pin package:
   * (SCL,SDA) = (PH4,PH5)
   */

  struct I2C2Remap2PinPackage {
    enum {
      Port_SCL=GPIOH_BASE,
      Port_SDA=GPIOH_BASE,

      Pin_SCL=GPIO_Pin_4,
      Pin_SDA=GPIO_Pin_5
    };
  };


  /**
   * Class to manage the remap package
   */

  template<class... Features>
  struct I2C2_Remap2 : I2CPeripheral<I2C2Remap2PinPackage,PERIPHERAL_I2C2>,
                       Features... {

    I2C2_Remap2(const Parameters& params)
      : I2CPeripheral<I2C2Remap2PinPackage,PERIPHERAL_I2C2>(params),
        Features(static_cast<I2C&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/i2c/f4/I2C2Remap.h
// START FILE: ../lib/include/i2c/f4/I2CAlternateFunctionMapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Specialisation of the AF mapper for this peripheral. The F4 has the same AF ID
   * regardless of the port so we specialise only on the peripheral
   */

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_I2C1,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_I2C1
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_I2C2,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_I2C2
    };
  };

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_I2C3,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_I2C3
    };
  };
}
// END FILE: ../lib/include/i2c/f4/I2CAlternateFunctionMapper.h
// START FILE: ../lib/include/i2c/f4/I2C3.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct I2C3_Custom : I2CPeripheral<TPinPackage,PERIPHERAL_I2C3>,
                       Features... {

    I2C3_Custom(const typename I2CPeripheral<TPinPackage,PERIPHERAL_I2C3>::Parameters& params)
      : I2CPeripheral<TPinPackage,PERIPHERAL_I2C3>(params),
        Features(static_cast<I2C&>(*this))... {
    }
  };


  /*
   * Default pin package:
   * (SCL,SDA) = (PH7,PH8)
   */

  struct I2C3DefaultPinPackage {
    enum {
      Port_SCL=GPIOH_BASE,
      Port_SDA=GPIOH_BASE,

      Pin_SCL=GPIO_Pin_7,
      Pin_SDA=GPIO_Pin_8
    };
  };


  /**
   * This peripheral is unique to the F4. We'll call this one the default pin set.
   */

  template<class... Features>
  struct I2C3_Default : I2CPeripheral<I2C3DefaultPinPackage,PERIPHERAL_I2C3>,
                        Features... {

    I2C3_Default(const Parameters& params)
      : I2CPeripheral<I2C3DefaultPinPackage,PERIPHERAL_I2C3>(params),
        Features(static_cast<I2C&>(*this))... {
    }
  };


  /*
   * Remap #1:
   * (SCL,SDA) = (PA8,PC9)
   */

  struct I2C3RemapPinPackage {
    enum {
      Port_SCL=GPIOA_BASE,
      Port_SDA=GPIOC_BASE,

      Pin_SCL=GPIO_Pin_8,
      Pin_SDA=GPIO_Pin_9
    };
  };


  /**
   * Remap class
   */

  template<class... Features>
  struct I2C3_Remap : I2CPeripheral<I2C3RemapPinPackage,PERIPHERAL_I2C3>,
                      Features... {

    I2C3_Remap(const Parameters& params)
      : I2CPeripheral<I2C3RemapPinPackage,PERIPHERAL_I2C3>(params),
        Features(static_cast<I2C&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/i2c/f4/I2C3.h
// START FILE: ../lib/include/i2c/I2C2.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Generic class for any pin package
   */

  template<class TPinPackage,class... Features>
  struct I2C2_Custom : I2CPeripheral<TPinPackage,PERIPHERAL_I2C2>,
                       Features... {

    I2C2_Custom(const typename I2CPeripheral<TPinPackage,PERIPHERAL_I2C2>::Parameters& params)
      : I2CPeripheral<TPinPackage,PERIPHERAL_I2C2>(params),
        Features(static_cast<I2C&>(*this))... {
    }
  };


  /*
   * Default pin package:
   * (SCL,SDA) = (PB10,PB11)
   */

  struct I2C2DefaultPinPackage {
    enum {
      Port_SCL=GPIOB_BASE,
      Port_SDA=GPIOB_BASE,

      Pin_SCL=GPIO_Pin_10,
      Pin_SDA=GPIO_Pin_11
    };
  };


  /**
   * Convenience class to match the F1 pin for pin. This can't be named I2C2 because of
   * a name clash in the std peripheral library
   */

  template<class... Features>
  struct I2C2_Default : I2CPeripheral<I2C2DefaultPinPackage,PERIPHERAL_I2C2>,
                        Features... {

    I2C2_Default(const Parameters& params)
      : I2CPeripheral<I2C2DefaultPinPackage,PERIPHERAL_I2C2>(params),
        Features(static_cast<I2C&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/i2c/I2C2.h
// START FILE: ../lib/include/i2c/f1,f4/I2CPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#if !defined(STM32PLUS_F1) && !defined(STM32PLUS_F4)
#error This class can only be used with the STM32F1 and F4 series
#endif


namespace stm32plus {

  /**
   * Base class for I2C peripherals. Takes care of the common operations
   * that each peripheral can have
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  class I2CPeripheral : public I2C {

    protected:
      I2CPeripheral(const Parameters& params);
      ~I2CPeripheral();
  };


  /**
   * Constructor
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline I2CPeripheral<TPinPackage,TPeripheralName>::I2CPeripheral(const struct Parameters& params)
    : I2C(params,(I2C_TypeDef *)PeripheralTraits<TPeripheralName>::PERIPHERAL_BASE) {

    I2C_InitTypeDef init;

    // clocks on first before any features get initialised

    ClockControl<TPeripheralName>::On();

    // and next the GPIO pins, also before any features get initialised

    I2CPinInitialiser<TPinPackage,TPeripheralName>::initialise();

    // initialise the peripheral

    init.I2C_ClockSpeed=params.i2c_clockSpeed;
    init.I2C_Mode=I2C_Mode_I2C;
    init.I2C_DutyCycle=params.i2c_dutyCycle;
    init.I2C_OwnAddress1=params.i2c_ownAddress;
    init.I2C_Ack=params.i2c_ack;
    init.I2C_AcknowledgedAddress=params.i2c_ackAddress;

    I2C_Init(_peripheralAddress,&init);

    // enable peripheral

    enablePeripheral();
  }


  /**
   * Destructor
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline I2CPeripheral<TPinPackage,TPeripheralName>::~I2CPeripheral() {

    // disable and clock off

    disablePeripheral();
    ClockControl<TPeripheralName>::Off();
  }
}
// END FILE: ../lib/include/i2c/f1,f4/I2CPeripheral.h
// START FILE: ../lib/include/i2c/f1,f4/I2C.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#if !defined(STM32PLUS_F1) && !defined(STM32PLUS_F4)
#error This class can only be used with the STM32F1 and F4 series
#endif


namespace stm32plus {

  /**
   * Base class for I2C peripherals. Takes care of the common operations
   * that each peripheral can have
   */

  class I2C {

    public:

      /**
       * I2C parameters class
       */

      struct Parameters {
        uint32_t i2c_clockSpeed;
        uint16_t i2c_ack;
        uint16_t i2c_dutyCycle;
        uint16_t i2c_ackAddress;
        uint16_t i2c_ownAddress;
        uint8_t i2c_addressSize;        // byte-size of the 'address' or 'register' index on the peripheral

        Parameters(uint32_t clockSpeed=100000) {
          i2c_clockSpeed=clockSpeed;
          i2c_ack=I2C_Ack_Enable;
          i2c_dutyCycle=I2C_DutyCycle_2;
          i2c_ackAddress=I2C_AcknowledgedAddress_7bit;
          i2c_ownAddress=0xFE;
          i2c_addressSize=1;
        }
      };

      enum {
        E_I2C_TIMEOUT=1         ///< timed out waiting for a response
      };

    protected:
      I2C_TypeDef *_peripheralAddress;
      uint8_t _addressSize;

    protected:
      I2C(const Parameters& params,I2C_TypeDef *peripheralAddress);

    public:
      void enablePeripheral() const;
      void disablePeripheral() const;

      void reset(bool enterReset) const;

      uint8_t getAddressSize() const;
      void setAddressSize(uint8_t addressSize);

      operator I2C_TypeDef *();
  };


  /**
   * Constructor
   */

  inline I2C::I2C(const Parameters& params,I2C_TypeDef *peripheralAddress)
    : _peripheralAddress(peripheralAddress),
      _addressSize(params.i2c_addressSize) {
  }


  /**
   * Enable the peripheral
   */

  inline void I2C::enablePeripheral() const {
    I2C_Cmd(_peripheralAddress,ENABLE);
  }


  /**
   * Disable the peripheral
   */

  inline void I2C::disablePeripheral() const {
    I2C_Cmd(_peripheralAddress,DISABLE);
  }


  /**
   * Enter/exit the reset condition.
   * @param enterReset true to enter the software reset state, false to exit from it
   */

  inline void I2C::reset(bool enterReset) const {
    I2C_SoftwareResetCmd(_peripheralAddress,enterReset ? ENABLE : DISABLE);
  }


  /**
   * Cast to a I2C peripheral structure
   */

  inline I2C::operator I2C_TypeDef *() {
    return _peripheralAddress;
  }


  /**
   * Get the address or register size in bytes. Often this is just one byte where the IC has
   * less than 255 registers but in EEPROMs etc. could be multiple bytes to fit in an 'address'
   * to read or write from/to.
   * @return The byte width
   */

  inline uint8_t I2C::getAddressSize() const {
    return _addressSize;
  }


  /**
   * Set the address size
   * @param addressSize The new address size
   */

  inline void I2C::setAddressSize(uint8_t addressSize) {
    _addressSize=addressSize;
  }
}
// END FILE: ../lib/include/i2c/f1,f4/I2C.h
// START FILE: ../lib/include/i2c/features/I2CTwoByteMasterPollingFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Subclass of the I2CMasterPollingFeature that specialises it for the case
   * where both the address (which in this case is probably an EEPROM index) is
   * two bytes wide. The MSB of the address is the first to be transmitted,
   * the LSB the second.
   */

  class I2CTwoByteMasterPollingFeature : public I2CMasterPollingFeature {

    public:
      I2CTwoByteMasterPollingFeature(I2C& i2c);

      bool writeByte(uint16_t address,uint8_t input) const;
      bool readByte(uint16_t address,uint8_t& output) const;

      bool prepareRead(uint16_t address) const;
      bool readBytes(uint16_t address,uint8_t *output,uint32_t count) const;

      bool prepareWrite(uint16_t address) const;
      bool writeBytes(uint16_t address,const uint8_t *input,uint32_t count) const;
  };


  /**
   * Constructor
   * @param i2c The base peripheral class
   */

  inline I2CTwoByteMasterPollingFeature::I2CTwoByteMasterPollingFeature(I2C& i2c)
    : I2CMasterPollingFeature(i2c) {

    // force the address width to two bytes

    i2c.setAddressSize(2);

    // default timeout is 5 seconds

    _timeout=5000;
  }


  /**
   * Prepare for reading
   * @param address The register index
   * @return true if it worked
   */

  inline bool I2CTwoByteMasterPollingFeature::prepareRead(uint16_t address) const {

    uint8_t bytes[2];

    bytes[0]=address>>8;
    bytes[1]=address;

    return I2CMasterPollingFeature::prepareRead(bytes);
  }


  /**
   * Read multiple bytes
   * @param address The register index
   * @param output Where to store them
   * @param count how many to read
   * @return true if it worked
   */

  inline bool I2CTwoByteMasterPollingFeature::readBytes(uint16_t address,uint8_t *output,uint32_t count) const {

    uint8_t bytes[2];

    bytes[0]=address>>8;
    bytes[1]=address;

    return I2CMasterPollingFeature::readBytes(bytes,output,count);
  }


  /**
   * Prepare for writing
   * @param address The register index
   * @return true if it worked
   */

  inline bool I2CTwoByteMasterPollingFeature::prepareWrite(uint16_t address) const {

    uint8_t bytes[2];

    bytes[0]=address>>8;
    bytes[1]=address;

    return I2CMasterPollingFeature::prepareWrite(bytes);
  }


  /**
   * Write multiple bytes
   * @param address The register index
   * @param input The bytes to write
   * @param count how many to write
   * @return true if it worked
   */

  inline bool I2CTwoByteMasterPollingFeature::writeBytes(uint16_t address,const uint8_t *input,uint32_t count) const {

    uint8_t bytes[2];

    bytes[0]=address>>8;
    bytes[1]=address;

    return I2CMasterPollingFeature::writeBytes(bytes,input,count);
  }


  /**
   * Read a byte from the slave
   * @param address The register number
   * @param output Where to put the byte
   * @return false if there's an error, true otherwise
   */

  inline bool I2CTwoByteMasterPollingFeature::readByte(uint16_t address,uint8_t& output) const {

    uint8_t bytes[2];

    bytes[0]=address>>8;
    bytes[1]=address;

    return I2CMasterPollingFeature::readBytes(bytes,&output,1);
  }


  /**
   * Write a single byte
   * @param address The register address
   * @param input The byte to write
   * @return true if it works, false if not
   */

  inline bool I2CTwoByteMasterPollingFeature::writeByte(uint16_t address,uint8_t input) const {

    uint8_t bytes[2];

    bytes[0]=address>>8;
    bytes[1]=address;

    return I2CMasterPollingFeature::writeBytes(bytes,&input,1);
  }
}
// END FILE: ../lib/include/i2c/features/I2CTwoByteMasterPollingFeature.h
// START FILE: ../lib/include/i2c/features/f4/I2CInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


/*
 * Forward declare the IRQ handler names
 */

extern "C" void I2C3_EV_IRQHandler();


namespace stm32plus {

  /*
   * Typedefs for easy use
   */

  typedef I2CInterruptFeature<3> I2C3InterruptFeature;


  /**
   * Enabler specialisation, I2C 3
   */

  template<>
  inline void I2CInterruptFeatureEnabler<3>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&I2C3_EV_IRQHandler;
    Nvic::configureIrq(I2C3_EV_IRQn,ENABLE,priority,subPriority);
    Nvic::configureIrq(I2C3_ER_IRQn,ENABLE,priority,subPriority);
  }
}
// END FILE: ../lib/include/i2c/features/f4/I2CInterruptFeature.h
// START FILE: ../lib/include/i2c/features/f4/I2CSecondSlaveFeature.h
/*
 * This file is a part of the open source Arduino Graphics Coprocessor project
 * Copyright (c) 2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Feature template for enabling a second slave address. The address mask allows
   * less than the full 8 bits to be compared (see OA2MSK).
   * @tparam TSecondSlaveAddress Your second slave address.
   */

  template<uint8_t TSecondSlaveAddress>
  struct I2CSecondSlaveFeature : public I2CFeatureBase {
    I2CSecondSlaveFeature(I2C& i2c);
  };


  /**
   * Constructor
   */

  template<uint8_t TSecondSlaveAddress>
  I2CSecondSlaveFeature<TSecondSlaveAddress>::I2CSecondSlaveFeature(I2C& i2c)
    : I2CFeatureBase(i2c) {

    // configure the values

    I2C_OwnAddress2Config(_i2c,TSecondSlaveAddress);
    I2C_DualAddressCmd(_i2c,ENABLE);
  }
}
// END FILE: ../lib/include/i2c/features/f4/I2CSecondSlaveFeature.h
// START FILE: ../lib/include/i2c/features/I2CFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for i2c features
   */

  class I2CFeatureBase {
    protected:
      I2C& _i2c;

    public:
      I2CFeatureBase(I2C& i2c);
      operator I2C&();
  };


  /**
   * Constructor
   * @param i2c
   */

  inline I2CFeatureBase::I2CFeatureBase(I2C& i2c)
    : _i2c(i2c) {
  }


  /**
   * Cast to I2C reference
   */

  inline I2CFeatureBase::operator I2C&() {
    return _i2c;
  }
}
// END FILE: ../lib/include/i2c/features/I2CFeatureBase.h
// START FILE: ../lib/include/i2c/features/f1,f4/I2CSlaveFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#if !defined(STM32PLUS_F1) && !defined(STM32PLUS_F4)
#error Only F1 and F4 supported
#endif


namespace stm32plus {


  /**
   * The slave feature class provides access to operations applicable to an I2C slave
   */

  class I2CSlaveFeature : public I2CIoFeature {

    public:
      I2CSlaveFeature(I2C& i2c);

      bool prepareRead() const;
      bool readBytes(void *buffer,uint32_t count,uint32_t& actuallyRead) const;
      bool finishRead() const;

      bool prepareWrite() const;
      bool writeBytes(const void *buffer,uint32_t count,uint32_t& actuallyWritten) const;
  };


  /**
   * Constructor
   * @param i2c The i2c feature base reference
   */

  inline I2CSlaveFeature::I2CSlaveFeature(I2C& i2c)
    : I2CIoFeature(i2c) {
  }


  /**
   * Prepare for reading by blocking until the slave address is detected on the bus or the timeout
   * expires. When this method has successfully returned then you can call readBytes() as many times
   * as necessary to read the data stream followed by finishRead() to ensure that the master has
   * sent the STOP condition.
   * @return true if it works, false if there's a timeout
   */

  inline bool I2CSlaveFeature::prepareRead() const {

    uint32_t timeoutStart;

    // wait until the slave address (or the optional second address) is matched on the bus (EV1)

    timeoutStart=MillisecondTimer::millis();

    while(!I2C_CheckEvent(_i2c,I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) && !I2C_CheckEvent(_i2c,I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED))
      if(MillisecondTimer::millis()-timeoutStart>_timeout)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_I2C,I2C::E_I2C_TIMEOUT);

    // the slave address has been matched on the bus

    return true;
  }


  /**
   * Synchronously read some bytes from the master, aborting after the timeout has expired. This method
   * will read up to 'count' bytes from the master. If the master sends the STOP condition or there is
   * an error then 'actuallyRead' will be less than 'count'. Receipt of the STOP condition does not
   * result in an error.
   * @param buffer Where to read the bytes to
   * @param count The number of bytes to read
   * @return true if it works, false if there's a timeout
   */

  inline bool I2CSlaveFeature::readBytes(void *buffer,uint32_t count,uint32_t& actuallyRead) const {

    uint32_t timeoutStart;
    uint8_t *ptr;

    // reset the read count and get a byte pointer

    actuallyRead=0;
    ptr=reinterpret_cast<uint8_t *>(buffer);

    // now we're expecting a stream of bytes

    timeoutStart=MillisecondTimer::millis();

    while(count) {

      if(I2C_CheckEvent(_i2c,I2C_EVENT_SLAVE_BYTE_RECEIVED)) {

        // data ready to read

        *ptr++=I2C_ReceiveData(_i2c);
        actuallyRead++;
        count--;

        // reset the timeout for the next byte

        timeoutStart=MillisecondTimer::millis();
      }
      else if(I2C_CheckEvent(_i2c,I2C_EVENT_SLAVE_STOP_DETECTED)) {    // EOF from the master
        I2C_ClearFlag(_i2c,I2C_FLAG_STOPF);
        break;
      }

      // check for timeout

      if(MillisecondTimer::millis()-timeoutStart>_timeout)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_I2C,I2C::E_I2C_TIMEOUT);
    }

    // all done

    return true;
  }


  /**
   * When readReadBytes() has been used to read the exact full number of bytes from the master
   * (actuallyRead==count==data transmitted by master) then finishRead() is required to be called
   * so that the STOP condition is read.
   * @return true if it worked, false if there's a timeout
   */

  inline bool I2CSlaveFeature::finishRead() const {

    uint32_t timeoutStart;

    // wait until the slave address (or the optional second address) is matched on the bus (EV1)

    timeoutStart=MillisecondTimer::millis();

    while(!I2C_CheckEvent(_i2c,I2C_EVENT_SLAVE_STOP_DETECTED))
      if(MillisecondTimer::millis()-timeoutStart>_timeout)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_I2C,I2C::E_I2C_TIMEOUT);

    // all OK

    I2C_ClearFlag(_i2c,I2C_FLAG_STOPF);
    return true;
  }


  /**
   * Wait until the slave address (TX mode) is matched on the bus or a timeout occurs. When this method
   * returns you can call writeBytes() to write out as many bytes as required.
   * @return true if it worked, false if there was a timeout
   */

  inline bool I2CSlaveFeature::prepareWrite() const {

    uint32_t timeoutStart;

    // wait until the slave address (or the optional second address) is matched on the bus (EV1)

    timeoutStart=MillisecondTimer::millis();

    while(!I2C_CheckEvent(_i2c,I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) && !I2C_CheckEvent(_i2c,I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED))
      if(MillisecondTimer::millis()-timeoutStart>_timeout)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_I2C,I2C::E_I2C_TIMEOUT);

    // the slave address has been matched on the bus

    return true;
  }


  /**
   * Write a
   * @param buffer
   * @param count
   * @param actuallyRead
   * @return
   */

  inline bool I2CSlaveFeature::writeBytes(const void *buffer,uint32_t count,uint32_t& actuallyWritten) const {

    uint32_t timeoutStart;
    const uint8_t *ptr;

    // reset the read count and get a byte pointer

    actuallyWritten=0;
    ptr=reinterpret_cast<const uint8_t *>(buffer);
    timeoutStart=MillisecondTimer::millis();

    while(count) {

      // check for NACK (master telling us to stop sending data)

      if(I2C_CheckEvent(_i2c,I2C_EVENT_SLAVE_ACK_FAILURE))
        break;

      // write a byte

      I2C_SendData(_i2c,*ptr);

      // wait for TXE or NACK

      while(!I2C_CheckEvent(_i2c,I2C_EVENT_SLAVE_BYTE_TRANSMITTED)) {

        // NACK is possible here

        if(I2C_CheckEvent(_i2c,I2C_EVENT_SLAVE_ACK_FAILURE))
          goto end;

        // check for timeout

        if(MillisecondTimer::millis()-timeoutStart>_timeout)
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_I2C,I2C::E_I2C_TIMEOUT);
      }

      // byte sent, reset timeout

      timeoutStart=MillisecondTimer::millis();
    }

  end:
    return true;
  }
}
// END FILE: ../lib/include/i2c/features/f1,f4/I2CSlaveFeature.h
// START FILE: ../lib/include/i2c/features/I2CMasterPollingFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Base feature class to enable polling communication in master mode. This class manages
   * the actual I2C protocol interaction. It makes the assumption that the exchange with a
   * peripheral consists of sending N bytes as an "address" and then either reading or
   * writing some data. The address size (N) can be 1..255. That size can be found in
   * the I2C Parameters class.
   */

  class I2CMasterPollingFeature : public I2CIoFeature {

    protected:
      uint8_t _slaveAddress;

    protected:
      bool checkEvent(uint32_t eventId) const;

    public:
      I2CMasterPollingFeature(I2C& i2c);

      bool prepareRead(const uint8_t *address) const;
      bool readBytes(const uint8_t *address,uint8_t *output,uint32_t count) const;

      bool prepareWrite(const uint8_t *address) const;
      bool writeBytes(const uint8_t *address,const uint8_t *input,uint32_t count) const;

      void setSlaveAddress(uint8_t address);
  };


  /**
   * Constructor
   * @param i2c The i2c feature base reference
   */

  inline I2CMasterPollingFeature::I2CMasterPollingFeature(I2C& i2c)
    : I2CIoFeature(i2c) {
  }


  /**
   * Set the slave peripheral address
   * @param address The 7-bit slave address is left aligned within the byte. i.e. the MSB
   * of the slave address is bit 7 (the 8th bit) in this parameter.
   */

  inline void I2CMasterPollingFeature::setSlaveAddress(uint8_t address) {
    _slaveAddress=address;
  }
}
// END FILE: ../lib/include/i2c/features/I2CMasterPollingFeature.h
// START FILE: ../lib/include/i2c/features/I2CSingleByteMasterPollingFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Subclass of the I2CMasterPollingFeature that specialises it for the case
   * where both the data and the register address are just a single byte each.
   * This caters for a lot of the simple I2C devices. Convenience functions are
   * provided to set and clear single bits in the register.
   */

  class I2CSingleByteMasterPollingFeature : public I2CMasterPollingFeature {

    public:
      I2CSingleByteMasterPollingFeature(I2C& i2c);

      bool writeByte(uint8_t address,uint8_t input) const;
      bool readByte(uint8_t address,uint8_t& output) const;

      bool prepareRead(uint8_t address) const;
      bool readBytes(uint8_t address,uint8_t *output,uint32_t count) const;

      bool prepareWrite(uint8_t address) const;
      bool writeBytes(uint8_t address,const uint8_t *input,uint32_t count) const;

      bool resetBits(uint8_t address,uint8_t mask) const;
      bool setBits(uint8_t address,uint8_t mask) const;

      bool setMask(uint8_t address,uint8_t newbits,uint8_t mask) const;
  };


  /**
   * Constructor
   * @param i2c
   */

  inline I2CSingleByteMasterPollingFeature::I2CSingleByteMasterPollingFeature(I2C& i2c)
    : I2CMasterPollingFeature(i2c) {

    // default timeout is 5 seconds

    _timeout=5000;
  }


  /**
   * Prepare for reading
   * @param address The register index
   * @return true if it worked
   */

  inline bool I2CSingleByteMasterPollingFeature::prepareRead(uint8_t address) const {
    return I2CMasterPollingFeature::prepareRead(&address);
  }


  /**
   * Read multiple bytes
   * @param address The register index
   * @param output Where to store them
   * @param count how many to read
   * @return true if it worked
   */

  inline bool I2CSingleByteMasterPollingFeature::readBytes(uint8_t address,uint8_t *output,uint32_t count) const {
    return I2CMasterPollingFeature::readBytes(&address,output,count);
  }


  /**
   * Prepare for writing
   * @param address The register index
   * @return true if it worked
   */

  inline bool I2CSingleByteMasterPollingFeature::prepareWrite(uint8_t address) const {
    return I2CMasterPollingFeature::prepareWrite(&address);
  }


  /**
   * Write multiple bytes
   * @param address The register index
   * @param input The bytes to write
   * @param count how many to write
   * @return true if it worked
   */

  inline bool I2CSingleByteMasterPollingFeature::writeBytes(uint8_t address,const uint8_t *input,uint32_t count) const {
    return I2CMasterPollingFeature::writeBytes(&address,input,count);
  }


  /**
   * Read a byte from the slave
   * @param address The register number
   * @param output Where to put the byte
   * @return false if there's an error, true otherwise
   */

  inline bool I2CSingleByteMasterPollingFeature::readByte(uint8_t address,uint8_t& output) const {
    return readBytes(address,&output,1);
  }


  /**
   * Write a single byte
   * @param address The register address
   * @param input The byte to write
   * @return true if it works, false if not
   */

  inline bool I2CSingleByteMasterPollingFeature::writeByte(uint8_t address,uint8_t input) const {
    return writeBytes(address,&input,1);
  }
}
// END FILE: ../lib/include/i2c/features/I2CSingleByteMasterPollingFeature.h
// START FILE: ../lib/include/i2c/features/I2CInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Forward declare the IRQ handler names
 */

extern "C" void I2C1_EV_IRQHandler();
extern "C" void I2C2_EV_IRQHandler();
extern "C" void I2C1_IRQHandler();        // F0

#if !defined(STM32PLUS_F0_42)
extern "C" void I2C2_IRQHandler();        // F0
#endif


namespace stm32plus {

  /**
   * Helper class to enable only the desired interrupts in the NVIC. This will
   * be fully specialised for each I2C peripheral
   * @tparam TI2CNumber The number of the I2C peripheral (1..3)
   */

  template<uint8_t TI2CNumber>
  class I2CInterruptFeatureEnabler {

    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

    public:
      static void enable(uint8_t priority,uint8_t subPriority);
  };


  /**
   * I2C feature to handle interrupts
   * @tparam TI2CNumber The number of the I2C peripheral (1..5)
   */

  template<uint8_t TI2CNumber>
  class I2CInterruptFeature : public I2CEventSource,
                              public I2CFeatureBase {

    protected:
      uint16_t _interruptMask;
      uint8_t _nvicPriority;
      uint8_t _nvicSubPriority;

    public:
      static I2CEventSource *_i2cInstance;

    public:
      I2CInterruptFeature(I2C& I2C);
      ~I2CInterruptFeature();

      void setNvicPriorities(uint8_t priority,uint8_t subPriority=0);

      void enableInterrupts(uint16_t interruptMask);
      void disableInterrupts(uint16_t interruptMask);

      void clearPendingInterruptsFlag(uint16_t interruptMask) const;
  };


  /*
   * Typedefs for easy use
   */

  typedef I2CInterruptFeature<1> I2C1InterruptFeature;

#if !defined(STM32PLUS_F0_42)
  typedef I2CInterruptFeature<2> I2C2InterruptFeature;
#endif

  /**
   * Template static data member initialisation
   */

  template<uint8_t TI2CNumber>
  I2CEventSource *I2CInterruptFeature<TI2CNumber> ::_i2cInstance;


  /**
   * Constructor, initialises the interrupt mask for this class to zero.
   */

  template<uint8_t TI2CNumber>
  inline I2CInterruptFeature<TI2CNumber>::I2CInterruptFeature(I2C& I2C)
    : I2CFeatureBase(I2C) {
    _interruptMask=0;
    _nvicPriority=_nvicSubPriority=0;
    _i2cInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  template<uint8_t TI2CNumber>
  inline I2CInterruptFeature<TI2CNumber>::~I2CInterruptFeature() {
    if(_interruptMask!=0)
      disableInterrupts(_interruptMask);
  }


  /**
   * Set the NVIC priority and subpriority numbers.  This function just remembers your
   * numbers. The actual setting of the priority happens in enableInterrupts()
   * @param priority
   * @param subPriority
   */

  template<uint8_t TI2CNumber>
  inline void I2CInterruptFeature<TI2CNumber>::setNvicPriorities(uint8_t priority,uint8_t subPriority) {
    _nvicPriority=priority;
    _nvicSubPriority=subPriority;
  }


  /**
   * Enable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. I2C_IT_BUF / I2C_IT_EVT / I2C_IT_ERR
   */

  template<uint8_t TI2CNumber>
  inline void I2CInterruptFeature<TI2CNumber>::enableInterrupts(uint16_t interruptMask) {

    _interruptMask|=interruptMask;
    I2CInterruptFeatureEnabler<TI2CNumber>::enable(_nvicPriority,_nvicSubPriority);
    I2C_ITConfig(_i2c,interruptMask,ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. I2C_IT_TXE / I2C_IT_RXNE
   */

  template<uint8_t TI2CNumber>
  inline void I2CInterruptFeature<TI2CNumber>::disableInterrupts(uint16_t interruptMask) {
    _interruptMask&=~interruptMask;
    I2C_ITConfig(_i2c,interruptMask,DISABLE);
  }


  /**
   * Clear the pending bit(s) for interrupt
   * @param interruptMask The bitmask of interrupts, e.g. I2C_IT_TXE / I2C_IT_RXNE
   */

  template<uint8_t TI2CNumber>
  inline void I2CInterruptFeature<TI2CNumber>::clearPendingInterruptsFlag(uint16_t interruptMask) const {
    I2C_ClearITPendingBit(_i2c,interruptMask);
  }


#if defined(STM32PLUS_F1) || defined(STM32PLUS_F4)

  /**
   * Enabler specialisation, I2C 1
   */

  template<>
  inline void I2CInterruptFeatureEnabler<1>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&I2C1_EV_IRQHandler;
    Nvic::configureIrq(I2C1_EV_IRQn,ENABLE,priority,subPriority);
    Nvic::configureIrq(I2C1_ER_IRQn,ENABLE,priority,subPriority);
  }

  /**
   * Enabler specialisation, I2C 2
   */

  template<>
  inline void I2CInterruptFeatureEnabler<2>::enable(uint8_t priority,uint8_t subPriority) {
    _forceLinkage=&I2C2_EV_IRQHandler;
    Nvic::configureIrq(I2C2_EV_IRQn,ENABLE,priority,subPriority);
    Nvic::configureIrq(I2C2_ER_IRQn,ENABLE,priority,subPriority);
  }

#elif defined(STM32PLUS_F0)

  /**
   * Enabler specialisation, I2C 1
   */

  template<>
  inline void I2CInterruptFeatureEnabler<1>::enable(uint8_t priority,uint8_t /* subPriority */) {
    _forceLinkage=&I2C1_IRQHandler;
    Nvic::configureIrq(I2C1_IRQn,ENABLE,priority);
  }


#if !defined(STM32PLUS_F0_42)
  /**
   * Enabler specialisation, I2C 2
   */

  template<>
  inline void I2CInterruptFeatureEnabler<2>::enable(uint8_t priority,uint8_t /* subPriority */) {
    _forceLinkage=&I2C2_IRQHandler;
    Nvic::configureIrq(I2C2_IRQn,ENABLE,priority);
  }
#endif

#endif
}
// END FILE: ../lib/include/i2c/features/I2CInterruptFeature.h
// START FILE: ../lib/include/i2c/features/I2CIoFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Base feature class to enable polling communication in master mode. This class manages
   * the actual I2C protocol interaction. It makes the assumption that the exchange with a
   * peripheral consists of sending N bytes as an "address" and then either reading or
   * writing some data. The address size (N) can be 1..255. That size can be found in
   * the I2C Parameters class.
   */

  class I2CIoFeature : public I2CFeatureBase {

    protected:
      uint32_t _timeout;

    public:
      I2CIoFeature(I2C& i2c);

      void setTimeout(uint32_t timeout);
  };


  /**
   * Constructor
   * @param i2c The i2c feature base reference
   */

  inline I2CIoFeature::I2CIoFeature(I2C& i2c)
    : I2CFeatureBase(i2c) {
    // default timeout is 5 seconds

    _timeout=5000;
  }


  /**
   * Set the timeout, after which an error will be raised
   * @param timeout The number of milliseconds to wait for a reply on the bus before considering it an error
   */

  inline void I2CIoFeature::setTimeout(uint32_t timeout) {
    _timeout=timeout;
  }
}
// END FILE: ../lib/include/i2c/features/I2CIoFeature.h
// START FILE: ../lib/include/i2c/I2CEventSource.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * I2C event types
   */

  enum class I2CEventType : uint8_t {
    EVENT_READY_TO_TRANSMIT,
    EVENT_RECEIVE,
    EVENT_STOP_BIT_RECEIVED,
    EVENT_10_BIT_HEADER_SENT,
    EVENT_BYTE_TRANSFER_SENT,
    EVENT_ADDRESS_SENT,
    EVENT_START_BIT_SENT,
    EVENT_SMB_ALERT,
    EVENT_TIMEOUT,
    EVENT_PEC_ERROR,
    EVENT_OVERRUN,
    EVENT_ACK_FAILURE,
    EVENT_ARBITRATION_LOSS,
    EVENT_BUS_ERROR,
    EVENT_ERROR,                    // F0
    EVENT_TRANSFER_COMPLETE,        // F0
    EVENT_ADDRESS_MATCH,            // F0
    EVENT_NOT_ACKNOWLEDGE           // F0
  };


  /**
   * The signature for I2C events: void myHandler(I2CEventType iet);
   */

  DECLARE_EVENT_SIGNATURE(I2CInterrupt,void(I2CEventType));


  /**
   * Base structure that holds just the event subscriber/publisher for I2C
   */

  struct I2CEventSource {
    DECLARE_EVENT_SOURCE(I2CInterrupt);
  };
}
// END FILE: ../lib/include/i2c/I2CEventSource.h
// START FILE: ../lib/include/i2c/I2CPinInitialiser.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Convenience template to initialise an I2C pin package
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  class I2CPinInitialiser {
    public:
      static void initialise();
  };


  /**
   * Initialise the pin package that we were parameterised with. The pin modes are the
   * same on the F0, F1 and F4 - both are AF-OD.
   */

  template<class TPinPackage,PeripheralName TPeripheralName>
  inline void I2CPinInitialiser<TPinPackage,TPeripheralName>::initialise() {

    GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_SCL,
                                   TPinPackage::Pin_SCL,
                                   Gpio::ALTERNATE_FUNCTION,
                                   (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                   Gpio::PUPD_NONE,
                                   Gpio::OPEN_DRAIN,
                                   GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_SCL,TPinPackage::Pin_SCL>::GPIO_AF);

    GpioPinInitialiser::initialise((GPIO_TypeDef *)TPinPackage::Port_SDA,
                                   TPinPackage::Pin_SDA,
                                   Gpio::ALTERNATE_FUNCTION,
                                   (GPIOSpeed_TypeDef)PeripheralTraits<TPeripheralName>::GPIO_SPEED,
                                   Gpio::PUPD_NONE,
                                   Gpio::OPEN_DRAIN,
                                   GpioAlternateFunctionMapper<TPeripheralName,TPinPackage::Port_SDA,TPinPackage::Pin_SDA>::GPIO_AF);
  }
}
// END FILE: ../lib/include/i2c/I2CPinInitialiser.h
// START FILE: ../lib/include/fx/easing/SineEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {

    /**
     * @brief The motion is defined by a sine wave.
     */

    template<class TDataType>
    class SineEaseT : public EasingBaseT<TDataType> {
      public:
        virtual ~SineEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;
    };


    /**
     * Compatibility typedef
     */

    typedef SineEaseT<float> SineEase;


    /**
     * starts motion from a zero velocity, and then accelerates motion as it executes.
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType SineEaseT<TDataType>::easeIn(TDataType time) const {
      return -this->_change * cos(time / this->_duration * (TDataType)M_PI_2) + this->_change;
    }


    /**
     * starts motion fast, and then decelerates motion to a zero velocity as it executes
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType SineEaseT<TDataType>::easeOut(TDataType time) const {
      return this->_change * sin(time / this->_duration * (TDataType)M_PI_2);
    }


    /**
     * Combines the motion of the easeIn and easeOut methods to
     * to start the motion from a zero velocity, accelerate motion,
     * then decelerate to a zero velocity
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType SineEaseT<TDataType>::easeInOut(TDataType time) const {
      return -this->_change / 2 * (cos((TDataType)M_PI * time / this->_duration) - 1);
    }
  }
}
// END FILE: ../lib/include/fx/easing/SineEase.h
// START FILE: ../lib/include/fx/easing/ExponentialEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {

    /**
     * @brief The motion is defined by an exponentially decaying sine wave
     */

    template<class TDataType>
    class ExponentialEaseT : public EasingBaseT<TDataType> {

      public:
        virtual ~ExponentialEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;
    };


    /**
     * Compatibility typedef
     */

    typedef ExponentialEaseT<float> ExponentialEase;


    /**
     * starts motion slowly, and then accelerates motion as it executes
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType ExponentialEaseT<TDataType>::easeIn(TDataType time) const {
      return time == 0 ? 0 : this->_change * pow(2,10 * (time / this->_duration - 1));
    }


    /**
     * starts motion fast, and then decelerates motion as it executes
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType ExponentialEaseT<TDataType>::easeOut(TDataType time) const {
      return time == this->_duration ? this->_change : this->_change * (-pow(2,-10 * time / this->_duration) + 1);
    }


    /**
     * combines the motion of the easeIn and easeOut methods to start the
     * motion slowly, accelerate motion, then decelerate
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType ExponentialEaseT<TDataType>::easeInOut(TDataType time) const {
      if(time == 0)
        return 0;

      if(time == this->_duration)
        return this->_change;

      time/=this->_duration / 2;

      if(time < 1)
        return this->_change / 2 * pow(2,10 * (time - 1));

      time--;
      return this->_change / 2 * (-pow(2,-10 * time) + 2);
    }
  }
}
// END FILE: ../lib/include/fx/easing/ExponentialEase.h
// START FILE: ../lib/include/fx/easing/BounceEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {


    /**
     * Bouncing easing function
     */

    template<class TDataType>
    class BounceEaseT : public EasingBaseT<TDataType> {

      public:
        virtual ~BounceEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;
    };


    /**
     * Compatibility typedef
     */

    typedef BounceEaseT<float> BounceEase;


    /**
     * starts the bounce motion slowly, then accelerates motion as it executes
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType BounceEaseT<TDataType>::easeIn(TDataType time) const {
      return this->_change - easeOut(this->_duration - time);
    }


    /**
     * starts the bounce motion fast, and then decelerates motion as it executes.
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType BounceEaseT<TDataType>::easeOut(TDataType time) const {
      time/=this->_duration;

      if(time < (1 / 2.75f))
        return this->_change * (7.5625f * time * time);

      if(time < (2 / 2.75f)) {
        time-=1.5f / 2.75f;
        return this->_change * (7.5625f * time * time + 0.75f);
      }

      if(time < (2.5f / 2.75f)) {
        time-=2.25f / 2.75f;
        return this->_change * (7.5625f * time * time + 0.9375f);
      }

      time-=2.625f / 2.75f;
      return this->_change * (7.5625f * time * time + 0.984375f);
    }


    /**
     * combines the motion of the easeIn and easeOut methods to start the bounce motion slowly,
     * accelerate motion, then decelerate.
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType BounceEaseT<TDataType>::easeInOut(TDataType time) const {
      if(time < this->_duration / 2)
        return easeIn(time * 2) * 0.5f;
      else
        return easeOut(time * 2 - this->_duration) * 0.5f + this->_change * 0.5f;
    }
  }
}
// END FILE: ../lib/include/fx/easing/BounceEase.h
// START FILE: ../lib/include/fx/easing/QuarticEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {

    /**
     * @brief x^4 based easing.
     * The acceleration of motion for a Quart easing
     * equation is greater than for a Quad or Cubic.
     */

    template<typename TDataType>
    class QuarticEaseT : public EasingBaseT<TDataType> {

      public:
        virtual ~QuarticEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;
    };


    /**
     * Compatibility typedef
     */

    typedef QuarticEaseT<float> QuarticEase;


    /**
     * starts motion from a zero velocity, and then accelerates
     * motion as it executes.
     * @param time the current animation time
     * @return the position at the time
     */

    template<typename TDataType>
    inline TDataType QuarticEaseT<TDataType>::easeIn(TDataType time) const {
      time/=this->_duration;
      return this->_change * time * time * time * time;
    }


    /**
     * Ease out
     * @param time the current animation time
     * @return the position at the time
     */

    template<typename TDataType>
    inline TDataType QuarticEaseT<TDataType>::easeOut(TDataType time) const {
      time=time / this->_duration - 1;
      return -this->_change * (time * time * time * time - 1);
    }


    /**
     * Ease in and out
     * @param time the current animation time
     * @return the position at the time
     */

    template<typename TDataType>
    inline TDataType QuarticEaseT<TDataType>::easeInOut(TDataType time) const {
      time/=this->_duration / 2;

      if(time < 1)
        return this->_change / 2 * time * time * time * time;

      time-=2;
      return -this->_change / 2 * (time * time * time * time - 2);
    }
  }
}
// END FILE: ../lib/include/fx/easing/QuarticEase.h
// START FILE: ../lib/include/fx/easing/ElasticEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {

    /**
     * Elastic easing function. The motion is defined by
     * an exponentially decaying sine wave.
     */

    template<class TDataType>
    class ElasticEaseT : public EasingBaseT<TDataType> {

      protected:
        TDataType _period;
        TDataType _amplitude;

      public:
        ElasticEaseT();
        ElasticEaseT(TDataType period,TDataType amplitude);
        virtual ~ElasticEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;

        void setPeriod(TDataType period);
        void setAmplitude(TDataType amplitude);

        TDataType getPeriod() const;
        TDataType getAmplitude() const;
    };


    /**
     * Compatibility typedef
     */

    typedef ElasticEaseT<float> ElasticEase;


    /**
     * constructor - sets zero values
     */

    template<class TDataType>
    inline ElasticEaseT<TDataType>::ElasticEaseT() {
      _amplitude=_period=0;
    }


    /**
     * constructor - sets values from parameters
     * @param period the period
     * @param amplitude the amplitude
     */

    template<class TDataType>
    inline ElasticEaseT<TDataType>::ElasticEaseT(TDataType period,TDataType amplitude)
      : _amplitude(amplitude),
        _period(period) {
    }


    /**
     * Starts motion slowly, and then accelerates motion as it executes.
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType ElasticEaseT<TDataType>::easeIn(TDataType time) const {
      TDataType p,a,s;

      if(time == 0)
        return 0;

      time/=this->_duration;

      if(time == 1)
        return this->_change;

      if(_period == 0)
        p=this->_duration * 0.3f;
      else
        p=_period;

      a=_amplitude;
      if(a == 0 || a < fabs(this->_change)) {
        a=this->_change;
        s=p / 4;
      } else
        s=p / (2 * (TDataType)M_PI) * asin(this->_change / a);

      time-=1;
      return -(a * pow(2,10 * time) * sin((time * this->_duration - s) * (2 * (TDataType)M_PI) / p));
    }


    /**
     * Starts motion fast, and then decelerates motion as it executes
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType ElasticEaseT<TDataType>::easeOut(TDataType time) const {
      TDataType p,a,s;

      if(time == 0)
        return 0;

      time/=this->_duration;
      if(time == 1)
        return this->_change;

      if(_period == 0)
        p=this->_duration * 0.3f;
      else
        p=_period;

      a=_amplitude;
      if(a == 0 || a < fabs(this->_change)) {
        a=this->_change;
        s=p / 4;
      } else
        s=p / (2 * (TDataType)M_PI) * asin(this->_change / a);

      return a * pow(2,-10 * time) * sin((time * this->_duration - s) * (2 * (TDataType)M_PI) / p) + this->_change;
    }


    /**
     * combines the motion of the easeIn and easeOut methods
     * to start the motion slowly, accelerate motion, then decelerate
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType ElasticEaseT<TDataType>::easeInOut(TDataType time) const {
      TDataType p,a,s;

      if(time == 0)
        return 0;

      time/=this->_duration / 2;
      if(time == 2)
        return this->_change;

      if(_period == 0)
        p=this->_duration * (0.3f * 1.5f);
      else
        p=_period;

      a=_amplitude;
      if(a == 0 || a < fabs(this->_change)) {
        a=this->_change;
        s=p / 4;
      } else
        s=p / (2 * (TDataType)M_PI) * asin(this->_change / a);

      if(time < 1) {
        time-=1;
        return -0.5f * (a * pow(2,10 * time) * sin((time * this->_duration - s) * (2 * (TDataType)M_PI) / p));
      }

      time-=1;
      return a * pow(2,-10 * time) * sin((time * this->_duration - s) * (2 * (TDataType)M_PI) / p) * 0.5f + this->_change;
    }


    /**
     * Set the period
     */

    template<class TDataType>
    inline void ElasticEaseT<TDataType>::setPeriod(TDataType period) {
      _period=period;
    }


    /**
     * Set the amplitude
     */

    template<class TDataType>
    inline void ElasticEaseT<TDataType>::setAmplitude(TDataType amplitude) {
      _amplitude=amplitude;
    }


    /**
     * Get the period
     * @return the period
     */

    template<class TDataType>
    inline TDataType ElasticEaseT<TDataType>::getPeriod() const {
      return _period;
    }


    /**
     * Get the amplitude
     * @return the amplitude
     */

    template<class TDataType>
    TDataType ElasticEaseT<TDataType>::getAmplitude() const {
      return _amplitude;
    }
  }
}
// END FILE: ../lib/include/fx/easing/ElasticEase.h
// START FILE: ../lib/include/fx/easing/QuinticEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {

    /**
     * @brief x^5 based easing.
     * The acceleration of motion for a Quint easing
     * equation is greater than for a Quad, Cubic,
     * or Quart easing equation.
     */

    template<typename TDataType>
    class QuinticEaseT : public EasingBaseT<TDataType> {

      public:
        virtual ~QuinticEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;
    };


    /**
     * Compatibility typedef
     */

    typedef QuinticEaseT<float> QuinticEase;


    /**
     * starts motion from a zero velocity, and then accelerates motion as it executes.
     * @param time the current animation time
     * @return the position at the time;
     */

    template<typename TDataType>
    inline TDataType QuinticEaseT<TDataType>::easeIn(TDataType time) const {
      time/=this->_duration;
      return this->_change * time * time * time * time * time;
    }


    /**
     * starts motion fast, and then decelerates motion to
     * a zero velocity as it executes
     * @param time the current animation time
     * @return the position at the time;
     */

    template<typename TDataType>
    inline TDataType QuinticEaseT<TDataType>::easeOut(TDataType time) const {
      time=time / this->_duration - 1;
      return this->_change * (time * time * time * time * time + 1);
    }


    /**
     * Combines the motion of the easeIn and easeOut methods to
     * to start the motion from a zero velocity, accelerate motion,
     * then decelerate to a zero velocity
     * @param time the current animation time
     * @return the position at the time;
     */

    template<typename TDataType>
    inline TDataType QuinticEaseT<TDataType>::easeInOut(TDataType time) const {
      time/=this->_duration / 2;

      if(time < 1)
        return this->_change / 2 * time * time * time * time * time;

      time-=2;
      return this->_change / 2 * (time * time * time * time * time + 2);
    }
  }
}
// END FILE: ../lib/include/fx/easing/QuinticEase.h
// START FILE: ../lib/include/fx/easing/EasingBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {

    /**
     * Base class for easing functions
     */

    template<typename TDataType>
    class EasingBaseT {

      protected:
        TDataType _change;
        TDataType _duration;

      public:
        EasingBaseT();
        virtual ~EasingBaseT() {}

        /**
         * Ease a transition in
         * @param[in] time The time to do the transition.
         */

        virtual TDataType easeIn(TDataType time) const=0;

        /**
         * Ease a transition out.
         * @param[in] time The time to do the transition.
         */

        virtual TDataType easeOut(TDataType time) const=0;

        /**
         * Ease a transition in and out.
         * @param[in] time The time to do the transition.
         */

        virtual TDataType easeInOut(TDataType time) const=0;

        void setDuration(TDataType duration);
        void setTotalChangeInPosition(TDataType totalChangeInPosition);

        TDataType getTotalChangeInPosition() const;
        TDataType getDuration() const;
    };

    /**
     * Compatibility typedef
     */

    typedef EasingBaseT<float> EasingBase;


    /**
     * Default constructor
     */

    template<typename TDataType>
    inline EasingBaseT<TDataType>::EasingBaseT() {
      _change=0;
    }


    /**
     * Set the duration
     * @param[in] duration The duration
     */

    template<typename TDataType>
    inline void EasingBaseT<TDataType>::setDuration(TDataType duration) {
      _duration=duration;
    }


    /**
     * Set the total change in position
     * @param[in] totalChangeInPosition The total change in position.
     */

    template<typename TDataType>
    inline void EasingBaseT<TDataType>::setTotalChangeInPosition(TDataType totalChangeInPosition) {
      _change=totalChangeInPosition;
    }


    /**
     * Get the total change in position
     * @return the total change in position
     */

    template<typename TDataType>
    inline TDataType EasingBaseT<TDataType>::getTotalChangeInPosition() const {
      return _change;
    }


    /**
     * Get the duration
     * @return the duration
     */

    template<typename TDataType>
    inline TDataType EasingBaseT<TDataType>::getDuration() const {
      return _duration;
    }
  }
}
// END FILE: ../lib/include/fx/easing/EasingBase.h
// START FILE: ../lib/include/fx/easing/QuadraticEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {

    /**
     * @brief quadratic equation based easing.
     * The acceleration of motion for a Quad easing equation is
     * slower than for a Cubic or Quart easing equation.
     */

    template<class TDataType>
    class QuadraticEaseT : public EasingBaseT<TDataType> {

      public:
        virtual ~QuadraticEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;
    };


    /**
     * Compatibility typedef
     */

    typedef QuadraticEaseT<float> QuadraticEase;


    /**
     * Ease in
     * starts motion from a zero velocity, and then accelerates motion as it executes.
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType QuadraticEaseT<TDataType>::easeIn(TDataType time) const {
      time/=this->_duration;
      return this->_change * time * time;
    }


    /**
     * starts motion fast, and then decelerates motion to
     * a zero velocity as it executes
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType QuadraticEaseT<TDataType>::easeOut(TDataType time) const {
      time/=this->_duration;
      return -this->_change * time * (time - 2);
    }


    /**
     * Combines the motion of the easeIn and easeOut methods to
     * to start the motion from a zero velocity, accelerate motion,
     * then decelerate to a zero velocity
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType QuadraticEaseT<TDataType>::easeInOut(TDataType time) const {
      time/=this->_duration / 2;

      if(time < 1)
        return this->_change / 2 * time * time;

      time--;
      return -this->_change / 2 * (time * (time - 2) - 1);
    }
  }
}
// END FILE: ../lib/include/fx/easing/QuadraticEase.h
// START FILE: ../lib/include/fx/easing/CubicEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {

    /**
     * @brief x^3 based easing.
     * The acceleration of motion for a Cubic easing
     * equation is greater than for a Quad easing equation.
     */

    template<class TDataType>
    class CubicEaseT : public EasingBaseT<TDataType> {

      public:
        virtual ~CubicEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;
    };


    /**
     * Compatibility typedef
     */

    typedef CubicEaseT<float> CubicEase;


    /**
     * Starts the motion by backtracking, then reversing
     * direction and moving toward the target
     * accelerates motion as it executes.
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType CubicEaseT<TDataType>::easeIn(TDataType time) const {
      time/=this->_duration;

      return this->_change * time * time * time;
    }


    /**
     * Starts the motion by moving towards the target, overshooting
     * it slightly, and then reversing direction back toward the target
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType CubicEaseT<TDataType>::easeOut(TDataType time) const {
      time=time / this->_duration - 1;

      return this->_change * (time * time * time + 1);
    }


    /**
     * Combines the motion of the easeIn and easeOut methods to
     * start the motion by backtracking, then reversing direction
     * and moving toward target, overshooting target slightly,
     * reversing direction again, and then moving back toward the target
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType CubicEaseT<TDataType>::easeInOut(TDataType time) const {
      time/=this->_duration / 2;

      if(time < 1)
        return this->_change / 2 * time * time * time;

      time-=2;
      return this->_change / 2 * (time * time * time + 2);
    }
  }
}
// END FILE: ../lib/include/fx/easing/CubicEase.h
// START FILE: ../lib/include/fx/easing/LinearEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {

    /**
     * @brief Linear ease. Really a dummy as it doesn't ease at all.
     */

    template<class TDataType>
    class LinearEaseT : public EasingBaseT<TDataType> {

      public:
        virtual ~LinearEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;
    };


    /**
     * Compatibility typedef
     */

    typedef LinearEaseT<float> LinearEase;


    /**
     * no acceleration
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType LinearEaseT<TDataType>::easeIn(TDataType time) const {
      return this->_change * time / this->_duration;
    }


    /**
     * no acceleration
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType LinearEaseT<TDataType>::easeOut(TDataType time) const {
      return easeIn(time);
    }


    /**
     * no acceleration
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType LinearEaseT<TDataType>::easeInOut(TDataType time) const {
      return easeIn(time);
    }
  }
}
// END FILE: ../lib/include/fx/easing/LinearEase.h
// START FILE: ../lib/include/fx/easing/BackEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {

    /**
     * @brief Back easing function. Goes back on itself.
     */

    template<class TDataType>
    class BackEaseT : public EasingBaseT<TDataType> {

      protected:
        TDataType _overshoot;

      public:
        BackEaseT();
        BackEaseT(TDataType overshoot);
        virtual ~BackEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;

        void setOvershoot(TDataType overshoot);
        TDataType getOvershoot() const;
    };


    /**
     * Constructor - sets a default value for the overshoot
     */

    template<class TDataType>
    inline BackEaseT<TDataType>::BackEaseT() {
      _overshoot=1.70158;
    }


    /**
     * Constructor with parameter
     * @param overshoot
     */

    template<class TDataType>
    inline BackEaseT<TDataType>::BackEaseT(TDataType overshoot)
      : _overshoot(overshoot) {
    }


    /**
     * Set the overshoot value
     * @param overshoot the new value
     */

    template<class TDataType>
    inline void BackEaseT<TDataType>::setOvershoot(TDataType overshoot) {
      _overshoot=overshoot;
    }


    /**
     * Get the overshoot value
     * @return the value
     */

    template<class TDataType>
    inline TDataType BackEaseT<TDataType>::getOvershoot() const {
      return _overshoot;
    }


    /**
     * Starts the motion by backtracking, then reversing direction and moving toward the target
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType BackEaseT<TDataType>::easeIn(TDataType time) const {
      time/=this->_duration;
      return this->_change * time * time * ((_overshoot + 1) * time - _overshoot);
    }


    /**
     * Starts the motion by moving towards the target, overshooting
     * it slightly, and then reversing direction back toward the target
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType BackEaseT<TDataType>::easeOut(TDataType time) const {
      time=time / this->_duration - 1;
      return this->_change * (time * time * ((_overshoot + 1) * time + _overshoot) + 1);
    }


    /**
     * Combines the motion of the easeIn and easeOut methods to
     * start the motion by backtracking, then reversing direction
     * and moving toward target, overshooting target slightly,
     * reversing direction again, and then moving back toward the target
     * @param time the current animation time
     * @return the position at the time
     */

    template<class TDataType>
    inline TDataType BackEaseT<TDataType>::easeInOut(TDataType time) const {
      TDataType overshoot;

      overshoot=_overshoot * 1.525;
      time/=this->_duration / 2;

      if(time < 1)
        return this->_change / 2 * (time * time * ((overshoot + 1) * time - overshoot));

      time-=2;
      return this->_change / 2 * (time * time * ((overshoot + 1) * time + overshoot) + 2);
    }
  }
}
// END FILE: ../lib/include/fx/easing/BackEase.h
// START FILE: ../lib/include/fx/easing/CircularEase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace fx {


    /**
     * Circular easing
     */

    template<typename TDataType>
    class CircularEaseT : public EasingBaseT<TDataType> {

      public:
        virtual ~CircularEaseT() {}

        virtual TDataType easeIn(TDataType time) const override;
        virtual TDataType easeOut(TDataType time) const override;
        virtual TDataType easeInOut(TDataType time) const override;
    };


    /**
     * Compatibility typedef
     */

    typedef CircularEaseT<float> CircularEase;


    /**
     * starts motion slowly, and then accelerates motion as it executes
     * @param time the current animation time
     * @return the position at the time
     */

    template<typename TDataType>
    inline TDataType CircularEaseT<TDataType>::easeIn(TDataType time) const {

      time/=this->_duration;
      return -this->_change * (sqrt(1 - time * time) - 1);
    }


    /**
     * starts motion fast, and then decelerates motion as it executes.
     * @param time the current animation time
     * @return the position at the time
     */

    template<typename TDataType>
    inline TDataType CircularEaseT<TDataType>::easeOut(TDataType time) const {

      time=time / this->_duration - 1;
      return this->_change * sqrt(1 - time * time);
    }


    /**
     * combines the motion of the easeIn and easeOut methods to start the motion slowly, accelerate
     * motion, then decelerate.
     * @param time the current animation time
     * @return the position at the time
     */

    template<typename TDataType>
    inline TDataType CircularEaseT<TDataType>::easeInOut(TDataType time) const {

      time/=this->_duration / 2;

      if(time < 1)
        return -this->_change / 2 * (sqrt(1 - time * time) - 1);

      time-=2;
      return this->_change / 2 * (sqrt(1 - time * time) + 1);
    }
  }
}
// END FILE: ../lib/include/fx/easing/CircularEase.h
// START FILE: ../lib/include/concurrent/atomic.h
#pragma once

// ARMV6 , ARMV7 Atomic primitives
// Based on knowledge
// http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0489b/Cihbghef.html
//
// Autor Artur Bac 2010 EBASoft
//
// Under BSD License
//
// version 1.0.0
// Written for Bada & GCC C++ but will also work on any other platform with Cortex CPU like IPhone, Android
// ARMv6 introduces a new mechanism, known as "exclusives",
// using the LDREX and STREX instructions.
// Direct use of these instructions is not
// recommended for new code (see "GCC atomic primitives" for a better alternative).
// However, to assist with understanding existing code, a quick overview follows:
//      LDREX   r0, [r1]
//            // do something with r0
//           // no other load or store operations can occur between a LDREX and its corresponding STREX
//       STREX   r2, r0, [r1]
//            // now r2 = 0 if the new value was stored
//            // r2 = 1 if the store was abandoned
//
//Because the STREX is allowed to "fail", it is no longer necessary to lock out other bus activity,
// or stop other threads from executing (whether on the same CPU or on another CPU in a multiprocessor system);
// atomic use in a thread can preempt a pending atomic in another thread.
// For this reason, these primitives are usually also placed in a loop.
//Note that extra load and store instruction (of any kind) between LDREX and STREX can cause the STREX always to fail in some implementations,
//which is why you shouldn't access memory between the LDREX and the corresponding STREX,
//except in cases where it's sensible to abandon the operation such as context switches or exceptions.

//These builtins perform an atomic compare and swap.
//That is, if the current value of *ptr is oldval, then write newval into *ptr.
//The val version returns the contents of *ptr before the operation.

namespace stm32plus {


  /**
   * compare-and-swap internal definitions
   */

  namespace __atomic_internal {

    template<typename T, typename U, size_t sz>
    struct sync_bool_compare_and_swap_internal {
    };

    template<typename T, typename U>
    struct sync_bool_compare_and_swap_internal<T, U, sizeof(long)> {
      bool operator()(T *ptr, U oldval, U newval) const {
        register int result;
        asm volatile (
            "ldrex    r0, [%1]         \n\t" /*exclusive load of ptr */
            "cmp      r0,  %2          \n\t" /*compare the oldval ==  *ptr */
            "ite eq\n\t"
            "strexeq  %0,  %3, [%1]\n\t" /*store if eq, strex+eq*/
            "clrexne"
            : "=&r" (result)
            : "r"(ptr), "r"(oldval),"r"(newval)
            : "r0"
        );
        return result == 0;
      }
    };

    template<typename T, typename U>
    struct sync_bool_compare_and_swap_internal<T, U, sizeof(short)> {
      bool operator()(T *ptr, U oldval, U newval) const {
        register int result;
        asm volatile (
            "ldrexh   r1, [%1]         \n\t" /*exclusive load of ptr*/
            "cmp      r1,  %2          \n\t"/*compare the low reg oldval == low *ptr*/
            "ite eq\n\t"
            "strexheq %0,  %3, [%1]\n\t" /*store if eq, strex+eq*/
            "clrexne"
            : "=&r" (result)
            : "r"(ptr), "r"(oldval),"r"(newval)
            : "r1"
        );
        return result == 0;
      }
    };

    template<typename T, typename U>
    struct sync_bool_compare_and_swap_internal<T, U, sizeof(char)> {
      bool operator()(T *ptr, U oldval, U newval) const {
        register int result;
        asm volatile (
            "ldrexb   r1, [%1]         \n\t" /*exclusive load of ptr*/
            "cmp      r1,  %2          \n\t"/*compare the low reg oldval == low *ptr*/
            "ite eq\n\t"
            "strexbeq %0,  %3, [%1]" /*store if eq, strex+eq*/
            "clrexne"
            : "=&r" (result)
            : "r"(ptr), "r"(oldval),"r"(newval)
            : "r1"
        );
        return result == 0;
      }
    };
  }

  /*
   * Compare-and-swap API
   */

  template<typename T, typename U>
  bool sync_bool_compare_and_swap(T *ptr, U oldval, U newval) {
    return __atomic_internal::sync_bool_compare_and_swap_internal<T, U, sizeof(T)>()(ptr, oldval, newval);
  }


  /*
   * Test-and-set internal definitions
   */

  namespace __atomic_internal {

    template<typename T, typename U, size_t sz>
    struct sync_lock_test_and_set {
    };


    template<typename T, typename U>
    struct sync_lock_test_and_set<T, U, sizeof(long)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm (
            "1: ldrex   %0,  [%1]   \n\t"
            "strex   r4,   %2, [%1]   \n\t"
            "cmp     r4,   #0   \n\t"
            "bne     1b     \n\t "
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r4"
        );
        return result;
      }
    };

    template<typename T, typename U>
    struct sync_lock_test_and_set<T, U, sizeof(short)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm (
            "1: ldrexh   %0,  [%1]    \n\t"
            "strexh   r4,   %2, [%1]    \n\t"
            "cmp     r4,   #0   \n\t"
            "bne     1b     \n\t "
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r4"
        );
        return result;
      }
    };


    template<typename T, typename U>
    struct sync_lock_test_and_set<T, U, sizeof(char)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm (
            "1: ldrexb   %0,  [%1]\n\t"
            "strexb   r4,   %2, [%1]\n\t"
            "cmp     r4,   #0\n\t"
            "bne     1b \n\t "
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r4"
        );
        return result;
      }
    };
  }

  /*
   * Test-and-set API
   */

  template<typename T, typename U>
  inline T sync_lock_test_and_set(T *ptr, U value) {
    return __atomic_internal::sync_lock_test_and_set<T, U, sizeof(T)>()(ptr,value);
  }


  /*
   * fetch-and-add internal definitions
   */

  namespace __atomic_internal {

    template<typename T, typename U, size_t sz>
    struct sync_fetch_and_add {
    };

    template<typename T, typename U>
    struct sync_fetch_and_add<T, U, sizeof(long)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1: ldrex   %0,  [%1] \n\t"
            "add     r1,   %0,  %2  \n\t"
            "strex   r2,   r1, [%1] \n\t"
            "cmp     r2,   #0 \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1","r2"
        );
        return result;
      }
    };

    template<typename T, typename U>
    struct sync_fetch_and_add<T, U, sizeof(short)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1: ldrexh  %0,  [%1] \n\t"
            "add     r1,   %0,  %2  \n\t"
            "strexh  r2,   r1, [%1] \n\t"
            "cmp     r2,   #0 \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1","r2"
        );
        return result;
      }
    };

    template<typename T, typename U>
    struct sync_fetch_and_add<T, U, sizeof(char)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1: ldrexb  %0,  [%1] \n\t"
            "add     r1,   %0,  %2  \n\t"
            "strexb  r2,   r1, [%1] \n\t"
            "cmp     r2,   #0 \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1","r2"
        );
        return result;
      }
    };
  }

  /*
   * Fetch-and-add API
   */

  template<typename T, typename U>
  inline T sync_fetch_and_add(T *ptr, U value) {
    return __atomic_internal::sync_fetch_and_add<T, U, sizeof(T)>()(ptr, value);
  }


  /*
   * add-and-fetch internal definitions
   */


  namespace __atomic_internal {

    template<typename T, typename U, size_t sz>
    struct sync_add_and_fetch {
    };

    template<typename T, typename U>
    struct sync_add_and_fetch<T, U, sizeof(long)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1:   ldrex   %0,  [%1]     \n\t"
            "add     %0,   %0,  %2    \n\t"
            "strex   r1,   %0, [%1] \n\t"
            "cmp     r1,   #0     \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1"
        );
        return result;
      }
    };

    template<typename T, typename U>
    struct sync_add_and_fetch<T, U, sizeof(short)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1:   ldrexh  %0,  [%1]     \n\t"
            "add     %0,   %0,  %2    \n\t"
            "strexh  r1,   %0, [%1] \n\t"
            "cmp     r1,   #0     \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1"
        );
        return result;
      }
    };

    template<typename T, typename U>
    struct sync_add_and_fetch<T, U, sizeof(char)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1:   ldrexb  %0,  [%1]     \n\t"
            "add     %0,   %0,  %2    \n\t"
            "strexb  r1,   %0, [%1] \n\t"
            "cmp     r1,   #0     \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1"
        );
        return result;
      }
    };
  }

  /*
   * add-and-fetch API
   */

  template<typename T, typename U>
  inline T sync_add_and_fetch(T *ptr, U value) {
    return __atomic_internal::sync_add_and_fetch<T, U, sizeof(T)>()(ptr, value);
  }


  /*
   * Fetch and sub internal definitions
   */

  namespace __atomic_internal {

    template<typename T, typename U, size_t sz>
    struct sync_fetch_and_sub {
    };

    template<typename T, typename U>
    struct sync_fetch_and_sub<T, U, sizeof(long)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1: ldrex   %0,  [%1] \n\t"
            "sub     r1,   %0,  %2  \n\t"
            "strex   r2,   r1, [%1] \n\t"
            "cmp     r2,   #0 \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1","r2"
        );
        return result;
      }
    };

    template<typename T, typename U>
    struct sync_fetch_and_sub<T, U, sizeof(short)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1: ldrexh  %0,  [%1] \n\t"
            "sub     r1,   %0,  %2  \n\t"
            "strexh  r2,   r1, [%1] \n\t"
            "cmp     r2,   #0 \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1","r2"
        );
        return result;
      }
    };

    template<typename T, typename U>
    struct sync_fetch_and_sub<T, U, sizeof(char)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1: ldrexb  %0,  [%1] \n\t"
            "sub     r1,   %0,  %2  \n\t"
            "strexb  r2,   r1, [%1] \n\t"
            "cmp     r2,   #0 \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1","r2"
        );
        return result;
      }
    };
  }

  /*
   * fetch-and-sub API
   */

  template<typename T, typename U>
  inline T sync_fetch_and_sub(T *ptr, U value) {
    return __atomic_internal::sync_fetch_and_sub<T, U, sizeof(T)>()(ptr, value);
  }


  /*
   * sub-and-fetch internal definitions
   */

  namespace __atomic_internal {

    template<typename T, typename U, size_t sz>
    struct sync_sub_and_fetch {
    };

    template<typename T, typename U>
    struct sync_sub_and_fetch<T, U, sizeof(long)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1:   ldrex   %0,  [%1]     \n\t"
            "sub     %0,   %0,  %2    \n\t"
            "strex   r1,   %0, [%1] \n\t"
            "cmp     r1,   #0     \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1"
        );
        return result;
      }
    };

    template<typename T, typename U>
    struct sync_sub_and_fetch<T, U, sizeof(short)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1:   ldrexh  %0,  [%1]     \n\t"
            "sub     %0,   %0,  %2    \n\t"
            "strexh  r1,   %0, [%1] \n\t"
            "cmp     r1,   #0     \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1"
        );
        return result;
      }
    };

    template<typename T, typename U>
    struct sync_sub_and_fetch<T, U, sizeof(char)> {
      T operator()(T *ptr, U value) const {
        register T result;
        asm volatile (
            "1:   ldrexb  %0,  [%1]     \n\t"
            "sub     %0,   %0,  %2    \n\t"
            "strexb  r1,   %0, [%1] \n\t"
            "cmp     r1,   #0     \n\t"
            "bne     1b"
            : "=&r" (result)
            : "r"(ptr), "r"(value)
            : "r1"
        );
        return result;
      }
    };
  }

  /*
   * increment/decrement API
   */

  template<typename T, typename U>
  inline T sync_sub_and_fetch(T *ptr, U value) {
    return __atomic_internal::sync_sub_and_fetch<T, U, sizeof(T)>()(ptr, value);
  }

  template<typename T>
  inline T sync_increment_and_fetch(T *ptr) {
    return __atomic_internal::sync_add_and_fetch<T, int, sizeof(T)>()(ptr, 1);
  }

  template<typename T>
  inline T sync_decrement_and_fetch(T *ptr) {
    return __atomic_internal::sync_sub_and_fetch<T, int, sizeof(T)>()(ptr, 1);
  }

  template<typename T>
  inline T sync_fetch_and_increment(T *ptr) {
    return __atomic_internal::sync_fetch_and_add<T, int, sizeof(T)>()(ptr, 1);
  }

  template<typename T>
  inline T sync_fetch_and_decrement(T *ptr) {
    return __atomic_internal::sync_fetch_and_sub<T, int, sizeof(T)>()(ptr, 1);
  }
}
// END FILE: ../lib/include/concurrent/atomic.h
// START FILE: ../lib/include/concurrent/CriticalSection.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * This class implements Peterson's algorithm for mutual exclusion. It is useful
   * where you have exactly two contenders for a resource and you know at the time
   * of calling who is who. e.g. normal code and an IRQ handler. This class has
   * the benefit of being nestable.
   */

  class CriticalSection {

    public:

      /**
       * Who wants to enter the critical section
       */

      enum class Identity : uint8_t {
        NORMAL_CODE = 0,      //!< NORMAL_CODE
        IRQ_CODE    = 1,      //!< IRQ_CODE
      };

    protected:
      volatile uint8_t _flags[2];
      volatile Identity _turn;

    public:
      CriticalSection();

      bool claim(Identity id,uint32_t millisToWait=0);
      void release(Identity id);
  };


  /**
   * Constructor
   */

  inline CriticalSection::CriticalSection() {
    _flags[0]=_flags[1]=false;
  }


  /**
   * Claim the critical section for your identity
   * @param id The identity to claim for
   * @param millisToWait The number of ms to block waiting for the critical section or zero to not block. Do not try
   *   to block if you are an IRQ source.
   * @return true if it worked, false if the critical section is busy
   */

  inline bool CriticalSection::claim(Identity id,uint32_t millisToWait) {

    Identity otherId;
    uint32_t now;

    // check that an IRQ is not trying to block

    if(id==Identity::IRQ_CODE)
      millisToWait=0;

    if(millisToWait)
      now=MillisecondTimer::millis();

    // get the other id

    otherId=id==Identity::IRQ_CODE ? Identity::NORMAL_CODE : Identity::IRQ_CODE;

    // set the entry condition

    _flags[static_cast<uint8_t>(id)]=true;
    _turn=otherId;

    // try to claim the critical section

    while(_flags[static_cast<uint8_t>(otherId)] && _turn==otherId)
      if(!millisToWait || MillisecondTimer::hasTimedOut(now,millisToWait))
        return false;

    // it's ours

    return true;
  }


  /**
   * Release the critical section
   * @param id The identity of the caller
   */

  inline void CriticalSection::release(Identity id) {
    _flags[static_cast<uint8_t>(id)]=false;
  }
}
// END FILE: ../lib/include/concurrent/CriticalSection.h
// START FILE: ../lib/include/concurrent/IrqSuspend.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Simple utility structure to enable temporary suspension of IRQs on construction and
   * re-enable on destruction. This is used quite heavily in the net code where there are
   * shared data structures between IRQ servicing and regular code.
   */

  struct IrqSuspend {

    /**
     * The counter
     */

    static uint32_t _counter;


    /**
     * Constructor
     */

    IrqSuspend() {
      suspend();
    }


    /**
     * Destructor
     */

    ~IrqSuspend() {
      resume();
    }


    /**
     * Suspend IRQs if they're not already suspended. We maintain an atomic counter
     * that ensures we can nest calls to suspend() - resume() pairs.
     */

    static void suspend() {

      if(sync_fetch_and_increment(&_counter)==0)
        Nvic::disableAllInterrupts();
    }


    /**
     * Decrement the counter and re-enable interrupts if we are the last in the nest
     * of callers.
     */

    static void resume() {
      if(sync_decrement_and_fetch(&_counter)==0)
        Nvic::enableAllInterrupts();
    }
  };
}
// END FILE: ../lib/include/concurrent/IrqSuspend.h
// START FILE: ../lib/include/concurrent/Mutex.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Mutex class using the ARM primitive LRDEX/STREX instructions.
   * Do not nest Mutex's. i.e. Do not call claim() on Mutex #1 and then call claim() somewhere
   * else on Mutex #2 before Mutex #1 has been released. The ARM synchronisation primitives
   * will automatically release #1 if you do that.
   */

  class Mutex {

    protected:
      volatile uint8_t _flag;

    public:
      Mutex();

      bool claim(uint32_t millisToWait=0);
      void release();
  };
}
// END FILE: ../lib/include/concurrent/Mutex.h
// START FILE: ../lib/include/fsmc/f4/FsmcPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * FSMC_Bank1_NORSRAM1 implementation
   */

  template<>
  class FsmcPeripheral<FSMC_Bank1_NORSRAM1> {

    public:
      static void initialise() {

        ClockControl<PERIPHERAL_FSMC>::On();

        // initialise NE

        GpioPinInitialiser::initialise(
          GPIOD,
          GPIO_Pin_7,         // NE
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GPIO_AF_FSMC);
      }

      /**
       * Static access to the base address
       */

      template<typename T>
      static T *getBaseAddress() {
        return reinterpret_cast<T *>(0x60000000);
      }


      /**
       * Static access to the bank number
       */

      static uint32_t getBank() {
        return FSMC_Bank1_NORSRAM1;
      }
  };


  /**
   * FSMC_Bank1_NORSRAM2 implementation
   */

  template<>
  class FsmcPeripheral<FSMC_Bank1_NORSRAM2> {

    public:
      static void initialise() {

        ClockControl<PERIPHERAL_FSMC>::On();

        // initialise NE

        GpioPinInitialiser::initialise(
          GPIOG,
          GPIO_Pin_9,         // NE
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GPIO_AF_FSMC);
      }

      /**
       * Static access to the base address
       */

      template<typename T>
      static T *getBaseAddress() {
        return reinterpret_cast<T *>(0x64000000);
      }


      /**
       * Static access to the bank number
       */

      static uint32_t getBank() {
        return FSMC_Bank1_NORSRAM2;
      }
  };


  /**
   * FSMC_Bank1_NORSRAM3 implementation
   */

  template<>
  class FsmcPeripheral<FSMC_Bank1_NORSRAM3> {

    public:
      static void initialise() {

        ClockControl<PERIPHERAL_FSMC>::On();

        // initialise NE

        GpioPinInitialiser::initialise(
          GPIOG,
          GPIO_Pin_10,          // NE
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GPIO_AF_FSMC);
      }

      /**
       * Static access to the base address
       */

      template<typename T>
      static T* getBaseAddress() {
        return reinterpret_cast<T *>(0x68000000);
      }


      /**
       * Static access to the bank number
       */

      static uint32_t getBank() {
        return FSMC_Bank1_NORSRAM3;
      }
  };


  /**
   * FSMC_Bank1_NORSRAM4 implementation
   */

  template<>
  class FsmcPeripheral<FSMC_Bank1_NORSRAM4> {

    public:
      static void initialise() {

        ClockControl<PERIPHERAL_FSMC>::On();

        // initialise NE

        GpioPinInitialiser::initialise(
          GPIOG,
          GPIO_Pin_12,          // NE
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GPIO_AF_FSMC);
      }

      /**
       * Static access to the base address
       */

      template<typename T>
      static T *getBaseAddress() {
        return reinterpret_cast<T *>(0x6C000000);
      }


      /**
       * Static access to the bank number
       */

      static uint32_t getBank() {
        return FSMC_Bank1_NORSRAM4;
      }
  };


  /**
   * FSMC_Bank2_NAND implementation
   */

  template<>
  class FsmcPeripheral<FSMC_Bank2_NAND> {

    public:
      static void initialise() {

        ClockControl<PERIPHERAL_FSMC>::On();

        // initialise NE

        GpioPinInitialiser::initialise(
          GPIOD,
          GPIO_Pin_7,         // NE
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GPIO_AF_FSMC);
      }

      /**
       * Static access to the base address
       */

      template<typename T>
      static T *getBaseAddress() {
        return reinterpret_cast<T *>(0x70000000);
      }


      /**
       * Static access to the bank number
       */

      static uint32_t getBank() {
        return FSMC_Bank2_NAND;
      }
  };


  /**
   * FSMC_Bank3_NAND implementation
   */

  template<>
  class FsmcPeripheral<FSMC_Bank3_NAND> {

    public:
      static void initialise() {

        ClockControl<PERIPHERAL_FSMC>::On();

        // initialise NE

        GpioPinInitialiser::initialise(
          GPIOG,
          GPIO_Pin_9,         // NE
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GPIO_AF_FSMC);
      }

      /**
       * Static access to the base address
       */

      template<typename T>
      static T *getBaseAddress() {
        return reinterpret_cast<T *>(0x80000000);
      }


      /**
       * Static access to the bank number
       */

      static uint32_t getBank() {
        return FSMC_Bank3_NAND;
      }
  };


  /**
   * FSMC_Bank4_PCCARD implementation
   */

  template<>
  class FsmcPeripheral<FSMC_Bank4_PCCARD> {

    public:
      static void initialise() {

        ClockControl<PERIPHERAL_FSMC>::On();

        // initialise NE

        GpioPinInitialiser::initialise(
          GPIOG,
          GPIO_Pin_10,          // NE
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GPIO_AF_FSMC);
      }

      /**
       * Static access to the base address
       */

      template<typename T>
      static T *getBaseAddress() {
        return reinterpret_cast<T *>(0x90000000);
      }


      /**
       * Static access to the bank number
       */

      static uint32_t getBank() {
        return FSMC_Bank4_PCCARD;
      }
  };


  /**
   * Typedefs for easy use
   */

  typedef FsmcPeripheral<FSMC_Bank1_NORSRAM1> FsmcBank1NorSram1;
  typedef FsmcPeripheral<FSMC_Bank1_NORSRAM2> FsmcBank1NorSram2;
  typedef FsmcPeripheral<FSMC_Bank1_NORSRAM3> FsmcBank1NorSram3;
  typedef FsmcPeripheral<FSMC_Bank1_NORSRAM4> FsmcBank1NorSram4;
  typedef FsmcPeripheral<FSMC_Bank2_NAND> FsmcBank2Nand;
  typedef FsmcPeripheral<FSMC_Bank3_NAND> FsmcBank3Nand;
  typedef FsmcPeripheral<FSMC_Bank4_PCCARD> FsmcBank4PcCard;
}
// END FILE: ../lib/include/fsmc/f4/FsmcPeripheral.h
// START FILE: ../lib/include/fsmc/f4/FsmcAlternateFunctionMapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Specialisation of the AF mapper for this peripheral. The F4 has the same AF ID
   * regardless of the port so we specialise only on the peripheral
   */

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_FSMC,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_FSMC
    };
  };
}
// END FILE: ../lib/include/fsmc/f4/FsmcAlternateFunctionMapper.h
// START FILE: ../lib/include/fsmc/FsmcAddressDataSetupTiming.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#if !defined(STM32PLUS_F1_HD) && !defined(STM32PLUS_F4)
#error "Unsupported MCU"
#elif defined(STM32F427_437xx) || defined(STM32F429_439xx)
#error "This MCU uses the FMC not the FSMC"
#endif


namespace stm32plus {

  /**
   * @brief Timing class for devices that just need address and data setup times
   *
   * Inherits from FSMC_NORSRAMTimingInitTypeDef to allow
   * the user to customise it.
   */

  struct FsmcAddressDataSetupTiming : FSMC_NORSRAMTimingInitTypeDef {

      FsmcAddressDataSetupTiming()
        : FSMC_NORSRAMTimingInitTypeDef() {
      }


      FsmcAddressDataSetupTiming(uint32_t addressSetup,uint32_t dataSetup)
        : FSMC_NORSRAMTimingInitTypeDef() {

        FSMC_AddressSetupTime=addressSetup;
        FSMC_DataSetupTime=dataSetup;
      }
  };
}
// END FILE: ../lib/include/fsmc/FsmcAddressDataSetupTiming.h
// START FILE: ../lib/include/fsmc/FsmcNand.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief FSMC implementation for NAND flash memory
   */

  template<class TFsmc>
  class FsmcNand : public FSMC_NANDInitTypeDef {

    public:
      FsmcNand(const FsmcNandTiming& timing);
      ~FsmcNand();
  };


  /**
   * Constructor. Setup the FSMC ready for use
   */

  template<class TFsmc>
  inline FsmcNand<TFsmc>::FsmcNand(const FsmcNandTiming& timing) {

    // initialise the FSMC and the NE line (different for each bank)

    TFsmc::initialise();

    // port D alternate function initialisation

    GpioPinInitialiser::initialise(
        GPIOD,
        GPIO_Pin_0 |        // D2
        GPIO_Pin_1 |        // D3
        GPIO_Pin_4 |        // nOE
        GPIO_Pin_5 |        // nWE
        GPIO_Pin_7 |        // NE2
        GPIO_Pin_11 |       // CLE
        GPIO_Pin_12 |       // ALE
        GPIO_Pin_14 |       // D0
        GPIO_Pin_15,        // D1
        Gpio::ALTERNATE_FUNCTION,
        (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
        Gpio::PUPD_NONE,
        Gpio::PUSH_PULL,
        GpioAlternateFunctionMapper<PERIPHERAL_FSMC,GPIOD_BASE,0>::GPIO_AF);

    // port E alternate function initialisation

    GpioPinInitialiser::initialise(
        GPIOE,
        GPIO_Pin_7 |        // D4
        GPIO_Pin_8 |        // D5
        GPIO_Pin_9 |        // D6
        GPIO_Pin_10,        // D7
        Gpio::ALTERNATE_FUNCTION,
        (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
        Gpio::PUPD_NONE,
        Gpio::PUSH_PULL,
        GpioAlternateFunctionMapper<PERIPHERAL_FSMC,GPIOE_BASE,0>::GPIO_AF);

    // port D nWAIT input pin, pull up (nWAIT is active low)

    GpioPinInitialiser::initialise(
        GPIOD,
        GPIO_Pin_6,         // nWait
        Gpio::INPUT,
        (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
        Gpio::PUPD_UP);

    // port G INT2 input pin, pull up (nWAIT is active low)
    // not available on LQFP100

    GpioPinInitialiser::initialise(
        GPIOG,
        GPIO_Pin_6,         // INT2
        Gpio::INPUT,
        (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
        Gpio::PUPD_UP);

    // initialise how the FSMC will work

    FSMC_Bank=TFsmc::getBank();
    FSMC_Waitfeature=FSMC_Waitfeature_Enable;
    FSMC_MemoryDataWidth=FSMC_MemoryDataWidth_8b;
    FSMC_ECC=FSMC_ECC_Enable;
    FSMC_ECCPageSize=FSMC_ECCPageSize_512Bytes;
    FSMC_TCLRSetupTime=0x00;
    FSMC_TARSetupTime=0x00;
    FSMC_CommonSpaceTimingStruct=const_cast<FsmcNandTiming *>(&timing);
    FSMC_AttributeSpaceTimingStruct=const_cast<FsmcNandTiming *>(&timing);

    FSMC_NANDInit(this);

    // enable it

    FSMC_NANDCmd(TFsmc::getBank(),ENABLE);
  }


  /**
   * Destructor. De-init the FSMC.
   */

  template<class TFsmc>
  inline FsmcNand<TFsmc>::~FsmcNand() {

    FSMC_NANDCmd(TFsmc::getBank(),DISABLE);
    FSMC_NANDDeInit(TFsmc::getBank());
  }
}
// END FILE: ../lib/include/fsmc/FsmcNand.h
// START FILE: ../lib/include/fsmc/FsmcSram.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief FSMC implementation for SRAM memory.
   *
   * The memory is assumed to be connected in the manner documented by ST in AN2784. The STM32
   * package is assumed to be 144 pin and the memory transfers are 16-bit.
   */

  template<class TFsmc>
  class FsmcSram : public FSMC_NORSRAMInitTypeDef {

    public:
      FsmcSram(const FsmcSramTiming& timing,const uint32_t lastAddressLineIndex);
      ~FsmcSram();
  };


  /**
   * Constructor. Initialises the AFIO GPIO pins for the FSMC.
   * @param[in] bank The FSMC bank e.g. FSMC_Bank1_NORSRAM1
   * @param[in] timing The timing structure for this SRAM memory.
   * @param[in] lastAddressLineIndex The last address line needed to fully address this memory. e.g. 18 = A18 = (2**19) 16-bit words
   */

  template<class TFsmc>
  inline FsmcSram<TFsmc>::FsmcSram(const FsmcSramTiming& timing,uint32_t lastAddressLineIndex) {

    extern const uint16_t Sram_pgmap[16],Sram_pfmap[10],Sram_pemap[7],Sram_pdmap[3];

    // initialise the FSMC and the NE line (different for each bank)
    // the FSMC peripheral is present on the F1HD and F4 but not the F3
    // therefore the AF ID is the same for all pins

    TFsmc::initialise();

    // A10 is the first line to appear on port G

    if(lastAddressLineIndex>=10)
      GpioPinInitialiser::initialise(
          GPIOG,
          Sram_pgmap[lastAddressLineIndex-10],
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_FSMC,GPIOG_BASE,0>::GPIO_AF);

    // A0..A9 are on port F

    GpioPinInitialiser::initialise(
        GPIOF,
        Sram_pfmap[lastAddressLineIndex>9 ? 9 : lastAddressLineIndex],
        Gpio::ALTERNATE_FUNCTION,
        (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
        Gpio::PUPD_NONE,
        Gpio::PUSH_PULL,
        GpioAlternateFunctionMapper<PERIPHERAL_FSMC,GPIOF_BASE,0>::GPIO_AF);

    // A19..A23 are on port E

    if(lastAddressLineIndex>=19)
      GpioPinInitialiser::initialise(
          GPIOE,
          Sram_pemap[lastAddressLineIndex-19],
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_FSMC,GPIOE_BASE,0>::GPIO_AF);

    // A16..A18 are on port D

    if(lastAddressLineIndex>=16)
      GpioPinInitialiser::initialise(
          GPIOD,
          Sram_pdmap[(lastAddressLineIndex>18 ? 18 : lastAddressLineIndex)-16],
          Gpio::ALTERNATE_FUNCTION,
          (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
          Gpio::PUPD_NONE,
          Gpio::PUSH_PULL,
          GpioAlternateFunctionMapper<PERIPHERAL_FSMC,GPIOD_BASE,0>::GPIO_AF);

    // data and control lines

    GpioPinInitialiser::initialise(
        GPIOD,
        GPIO_Pin_0 |    // D2
        GPIO_Pin_1 |    // D3
        GPIO_Pin_4 |    // NOE
        GPIO_Pin_5 |    // NWE
        GPIO_Pin_8 |    // D13
        GPIO_Pin_9 |    // D14
        GPIO_Pin_10 |   // D15
        GPIO_Pin_14 |   // D0
        GPIO_Pin_15,    // D1
        Gpio::ALTERNATE_FUNCTION,
        (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
        Gpio::PUPD_NONE,
        Gpio::PUSH_PULL,
        GpioAlternateFunctionMapper<PERIPHERAL_FSMC,GPIOD_BASE,0>::GPIO_AF);

    GpioPinInitialiser::initialise(
        GPIOE,
        GPIO_Pin_0 |    // NBL0
        GPIO_Pin_1 |    // NBL1
        GPIO_Pin_7 |    // D4
        GPIO_Pin_8 |    // D5
        GPIO_Pin_9 |    // D6
        GPIO_Pin_10 |   // D7
        GPIO_Pin_11 |   // D8
        GPIO_Pin_12 |   // D9
        GPIO_Pin_13 |   // D10
        GPIO_Pin_14 |   // D11
        GPIO_Pin_15,    // D12
        Gpio::ALTERNATE_FUNCTION,
        (GPIOSpeed_TypeDef)FsmcPeripheralTraits::GPIO_SPEED,
        Gpio::PUPD_NONE,
        Gpio::PUSH_PULL,
        GpioAlternateFunctionMapper<PERIPHERAL_FSMC,GPIOE_BASE,0>::GPIO_AF);

    // initialise how the FSMC will work and then enable it

    FSMC_Bank=TFsmc::getBank();
    FSMC_DataAddressMux=FSMC_DataAddressMux_Disable;
    FSMC_MemoryType=FSMC_MemoryType_SRAM;
    FSMC_MemoryDataWidth=FSMC_MemoryDataWidth_16b;
    FSMC_BurstAccessMode=FSMC_BurstAccessMode_Disable;
    FSMC_WaitSignalPolarity=FSMC_WaitSignalPolarity_Low;
    FSMC_WrapMode=FSMC_WrapMode_Disable;
    FSMC_WaitSignalActive=FSMC_WaitSignalActive_BeforeWaitState;
    FSMC_WriteOperation=FSMC_WriteOperation_Enable;
    FSMC_WaitSignal=FSMC_WaitSignal_Disable;
    FSMC_ExtendedMode=FSMC_ExtendedMode_Disable;
    FSMC_WriteBurst=FSMC_WriteBurst_Disable;
    FSMC_ReadWriteTimingStruct=const_cast<FsmcSramTiming *> (&timing);
    FSMC_WriteTimingStruct=const_cast<FsmcSramTiming *> (&timing);
    FSMC_AsynchronousWait=FSMC_AsynchronousWait_Disable;

    // initialise the FSMC and then enable it

    FSMC_NORSRAMInit(this);
    FSMC_NORSRAMCmd(TFsmc::getBank(),ENABLE);
  }

  /**
   * Destructor. De-init the FSMC.
   */

  template<class TFsmc>
  inline FsmcSram<TFsmc>::~FsmcSram() {
    FSMC_NORSRAMCmd(TFsmc::getBank(),DISABLE);
    FSMC_NORSRAMDeInit(TFsmc::getBank());
  }
}
// END FILE: ../lib/include/fsmc/FsmcSram.h
// START FILE: ../lib/include/fsmc/Fsmc8080LcdTiming.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * 8080 LCD timing just needs address and data setup
   */

  class Fsmc8080LcdTiming : public FsmcAddressDataSetupTiming {
    public:

      /**
       * We change the access mode to mode B for the 8080 LCD devices.
       */

    Fsmc8080LcdTiming(uint32_t addressSetup,uint32_t dataSetup)
      : FsmcAddressDataSetupTiming(addressSetup,dataSetup) {
        FSMC_AccessMode=FSMC_AccessMode_B;    // doesn't really matter. mode B toggles NADV for mux'd memories with a latch
      }
  };
}
// END FILE: ../lib/include/fsmc/Fsmc8080LcdTiming.h
// START FILE: ../lib/include/fsmc/FsmcSramTiming.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Sram timing just needs address and data setup
   */

  typedef FsmcAddressDataSetupTiming FsmcSramTiming;
}
// END FILE: ../lib/include/fsmc/FsmcSramTiming.h
// START FILE: ../lib/include/fsmc/FsmcPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * base class for FSMC implementations
   * @tparam TBankIdentifier FSMC_Bank1_NORSRAM1 etc...
   */

  template<uint32_t TBankIdentifier> class FsmcPeripheral;
}
// END FILE: ../lib/include/fsmc/FsmcPeripheral.h
// START FILE: ../lib/include/fsmc/FsmcNandTiming.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#if !defined(STM32PLUS_F1_HD) && !defined(STM32PLUS_F4)
#error "Unsupported MCU"
#elif defined(STM32F427_437xx) || defined(STM32F429_439xx)
#error "This MCU uses the FMC not the FSMC"
#endif


namespace stm32plus {

  /**
   * @brief Timing class for NAND flash devices
   */

  struct FsmcNandTiming : FSMC_NAND_PCCARDTimingInitTypeDef {

    FsmcNandTiming(
        uint32_t setupTime,
        uint32_t waitSetupTime,
        uint32_t holdSetupTime,
        uint32_t hizSetupTime) {

      // setup the parameters

      FSMC_SetupTime=setupTime;
      FSMC_WaitSetupTime=waitSetupTime;
      FSMC_HoldSetupTime=holdSetupTime;
      FSMC_HiZSetupTime=hizSetupTime;
    }
  };
}
// END FILE: ../lib/include/fsmc/FsmcNandTiming.h
// START FILE: ../lib/include/button/AutoRepeatPushButton.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief A debounced pushbutton with autorepeat
   *
   * This class includes customised delay before the auto-repeat as well as
   * the delay between repeats.
   */

  class AutoRepeatPushButton : public PushButton {

    private:

      /**
       * our internal state
       */

      enum InternalState {

        /// waiting for action
        Idle,

        /// pressed, waiting to start repeating
        WaitingForInitial,

        /// repeating, waiting for next repeat
        WaitingForRepeat
      } _internalState;

      /// the time before repeating starts
      uint32_t _initialDelayMillis;

      /// the time between each repeat
      uint32_t _repeatDelayMillis;

      /// the last time something happened
      uint32_t _lastEventTime;

    public:
      AutoRepeatPushButton(const GpioPinRef& pin,bool pressedState,uint32_t initialDelayMillis,uint32_t repeatDelayMillis);

      ButtonState getState();
  };
}
// END FILE: ../lib/include/button/AutoRepeatPushButton.h
// START FILE: ../lib/include/button/PushButton.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {

/**
 * @brief Pushbutton with debouncing
 */

  class PushButton {

    private:

      /// configuration
      static const uint32_t DEBOUNCE_DELAY_MILLIS=50;

      /// Internal button state
      enum InternalState {
        Idle,                         // nothing happening
        DebounceDelay                 // delaying...
      };

      /// The digital pin where the button is connected
      uint8_t _digitalPin;

      /// The pressed state (true=HIGH/falas=LOW)
      bool _pressedState;

      /// Internal state of the class
      InternalState _internalState;

      /// The last time we sampled our button
      uint32_t _lastTime;

      /// The pin
      GpioPinRef _pin;

    public:

      /**
       * Possible button states
       */

      enum ButtonState {
        /// button is up
        NotPressed,

        /// button is down
        Pressed
      };

      PushButton(const GpioPinRef& pin,bool pressedState);
      ButtonState getState();
  };
}
// END FILE: ../lib/include/button/PushButton.h
// START FILE: ../lib/include/sdcard/f4/SdioAlternateFunctionMapper.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Specialisation of the AF mapper for this peripheral. The F4 has the same AF ID
   * regardless of the port so we specialise only on the peripheral
   */

  template<uint32_t TPort,uint16_t TPin>
  struct GpioAlternateFunctionMapper<PERIPHERAL_SDIO,TPort,TPin> {
    enum {
      GPIO_AF = GPIO_AF_SDIO
    };
  };
}
// END FILE: ../lib/include/sdcard/f4/SdioAlternateFunctionMapper.h
// START FILE: ../lib/include/sdcard/SdCardBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for SD card classes
   */

  class SdCardBase {

    public:
      SdCardBase();
  };


  /**
   * Constructor
   */

  inline SdCardBase::SdCardBase() {

    // this constructor is called before the features
  }
}

// END FILE: ../lib/include/sdcard/SdCardBase.h
// START FILE: ../lib/include/sdcard/SdCardDetector.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {

  /**
   * Helper class to assist with SD card detection
   */

  class SdCardDetector {

    protected:
      GpioPinRef _cardDetect;

    public:
      SdCardDetector(const GpioPinRef& pin);

      bool isCardPresent() const;
  };


  /**
   * Constructor
   * @param pin
   */

  inline SdCardDetector::SdCardDetector(const GpioPinRef& pin)
    : _cardDetect(pin) {
  }


  /**
   * Return true if the card is present (the line is active low)
   * @return true if present
   */

  inline bool SdCardDetector::isCardPresent() const {
    return !_cardDetect.read();
  }
}
// END FILE: ../lib/include/sdcard/SdCardDetector.h
// START FILE: ../lib/include/sdcard/SdioDmaSdCard.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {

  /**
   * Implementation of BlockDevice for an SD Card accessed over DMA. This class gathers
   * together the required parts to form a coherent read/write SDIO accessor that
   * uses the DMA channels, albeit blocking the CPU until DMA transfer is complete
   */

  class SdioDmaSdCard : public BlockDevice,
                        public SdCard<SdCardSdioFeature,SdioInterruptFeature>,
                        public SdioDmaChannel<SdioDmaChannelInterruptFeature,
                                              SdioDmaReaderFeature<>,
                                              SdioDmaWriterFeature<> > {

    protected:
      volatile int _sdioErrorCode;
      volatile int _dmaErrorCode;
      volatile bool _dmaFinished;
      volatile bool _sdioFinished;

    public:
      enum { BLOCK_SIZE = 512 };

    public:
      SdioDmaSdCard(bool autoInitialise=true);
      virtual ~SdioDmaSdCard() {}

      bool waitForTransfer() const;
      uint64_t getCardCapacityInBytes() const;

      // overrides from BlockDevice

      virtual uint32_t getTotalBlocksOnDevice() override;
      virtual uint32_t getBlockSizeInBytes() override;

      virtual bool readBlock(void *dest,uint32_t blockIndex) override;
      virtual bool readBlocks(void *dest,uint32_t blockIndex,uint32_t numBlocks) override;

      virtual bool writeBlock(const void *src,uint32_t blockIndex) override;
      virtual bool writeBlocks(const void *src,uint32_t blockIndex,uint32_t numBlocks) override;

      virtual formatType getFormatType() override;

      // SDIO event subscription

      void onSdioEvent(SdioEventType set);
      void onDmaEvent(DmaEventType det);
  };
}
// END FILE: ../lib/include/sdcard/SdioDmaSdCard.h
// START FILE: ../lib/include/sdcard/SdioEventSource.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * SDIO event types
   */

  enum class SdioEventType : uint8_t {
    EVENT_DATA_END,
    EVENT_CRC_FAIL,
    EVENT_TIMEOUT,
    EVENT_RX_OVERRUN,
    EVENT_TX_OVERRUN,
    EVENT_START_BIT_ERROR
  };


  /**
   * The signature for SDIO events: void myHandler(SdioEventType set);
   */

  DECLARE_EVENT_SIGNATURE(SdioInterrupt,void(SdioEventType));


  /**
   * Base structure that holds just the event subscriber/publisher for SDIO
   */

  struct SdioEventSource {
    DECLARE_EVENT_SOURCE(SdioInterrupt);
  };
}
// END FILE: ../lib/include/sdcard/SdioEventSource.h
// START FILE: ../lib/include/sdcard/SdCard.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * Template feature collection class for the sd-card peripheral.
   */

  template<class... Features>
  struct SdCard : SdCardBase,
                  Features... {

    SdCard() :
      Features(static_cast<SdCardBase&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/sdcard/SdCard.h
// START FILE: ../lib/include/sdcard/features/SdCardWriteProtectFeature.h
// END FILE: ../lib/include/sdcard/features/SdCardWriteProtectFeature.h
// START FILE: ../lib/include/sdcard/features/SdioInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Forward declare the IRQ handler names
 */

extern "C" void SDIO_IRQHandler();


namespace stm32plus {


  /**
   * SDIO feature to handle interrupts
   */

  class SdioInterruptFeature : public SdioEventSource,
                               public SdCardFeatureBase {

    protected:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

      uint16_t _interruptMask;
      uint8_t _nvicPriority;
      uint8_t _nvicSubPriority;

    public:
      static SdioEventSource *_sdioInstance;

    public:
      SdioInterruptFeature(SdCardBase& sdcard);
      ~SdioInterruptFeature();

      void setNvicPriorities(uint8_t priority,uint8_t subPriority=0);

      void enableInterrupts(uint16_t interruptMask);
      void disableInterrupts(uint16_t interruptMask);
  };


  /**
   * Constructor, initialises the interrupt mask for this class to zero.
   */

  inline SdioInterruptFeature::SdioInterruptFeature(SdCardBase& sdcard)
    : SdCardFeatureBase(sdcard) {
    _interruptMask=0;
    _nvicPriority=_nvicSubPriority=0;
    _sdioInstance=this;
  }


  /**
   * Destructor, if any interrupts are configured for this class then
   * disable them so that ISR calls don't disappear off into nothing
   */

  inline SdioInterruptFeature::~SdioInterruptFeature() {
    if(_interruptMask!=0)
      disableInterrupts(_interruptMask);
  }


  /**
   * Set the NVIC priority and subpriority numbers.  This function just remembers your
   * numbers. The actual setting of the priority happens in enableInterrupts()
   * @param priority
   * @param subPriority
   */

  inline void SdioInterruptFeature::setNvicPriorities(uint8_t priority,uint8_t subPriority) {
    _nvicPriority=priority;
    _nvicSubPriority=subPriority;
  }


  /**
   * Enable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. SDIO_IT_DCRCFAIL
   */

  inline void SdioInterruptFeature::enableInterrupts(uint16_t interruptMask) {

    _interruptMask|=interruptMask;
    _forceLinkage=&SDIO_IRQHandler;

    Nvic::configureIrq(SDIO_IRQn,ENABLE,_nvicPriority,_nvicSubPriority);
    SDIO_ITConfig(interruptMask,ENABLE);
  }


  /**
   * Disable the interrupts specified in the mask
   * @param interruptMask The bitmask of interrupts, e.g. SDIO_IT_DCRCFAIL
   */

  inline void SdioInterruptFeature::disableInterrupts(uint16_t interruptMask) {
    _interruptMask&=~interruptMask;
    SDIO_ITConfig(interruptMask,DISABLE);
  }
}
// END FILE: ../lib/include/sdcard/features/SdioInterruptFeature.h
// START FILE: ../lib/include/sdcard/features/SdCardFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for sdcard features
   */

  class SdCardFeatureBase {

    protected:
      SdCardBase& _sdcard;

    public:
      SdCardFeatureBase(SdCardBase& sdcard);
      operator SdCardBase&();
  };


  /**
   * Constructor
   * @param SdCard
   */

  inline SdCardFeatureBase::SdCardFeatureBase(SdCardBase& sdcard)
    : _sdcard(sdcard) {
  }


  /**
   * Cast to SdCard reference
   */

  inline SdCardFeatureBase::operator SdCardBase&() {
    return _sdcard;
  }
}
// END FILE: ../lib/include/sdcard/features/SdCardFeatureBase.h
// START FILE: ../lib/include/sdcard/features/SdCardIoFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Generic base class for the possible IO interfaces to the SD card
   */

  class SdCardIoFeature : public SdCardFeatureBase {

    public:
      struct SdCsd {
        volatile uint8_t  CSDStruct;            /*!< CSD structure */
        volatile uint8_t  SysSpecVersion;       /*!< System specification version */
        volatile uint8_t  Reserved1;            /*!< Reserved */
        volatile uint8_t  TAAC;                 /*!< Data read access-time 1 */
        volatile uint8_t  NSAC;                 /*!< Data read access-time 2 in CLK cycles */
        volatile uint8_t  MaxBusClkFrec;        /*!< Max. bus clock frequency */
        volatile uint16_t CardComdClasses;      /*!< Card command classes */
        volatile uint8_t  RdBlockLen;           /*!< Max. read data block length */
        volatile uint8_t  PartBlockRead;        /*!< Partial blocks for read allowed */
        volatile uint8_t  WrBlockMisalign;      /*!< Write block misalignment */
        volatile uint8_t  RdBlockMisalign;      /*!< Read block misalignment */
        volatile uint8_t  DSRImpl;              /*!< DSR implemented */
        volatile uint8_t  Reserved2;            /*!< Reserved */
        volatile uint32_t DeviceSize;           /*!< Device Size */
        volatile uint8_t  MaxRdCurrentVDDMin;   /*!< Max. read current @ VDD min */
        volatile uint8_t  MaxRdCurrentVDDMax;   /*!< Max. read current @ VDD max */
        volatile uint8_t  MaxWrCurrentVDDMin;   /*!< Max. write current @ VDD min */
        volatile uint8_t  MaxWrCurrentVDDMax;   /*!< Max. write current @ VDD max */
        volatile uint8_t  DeviceSizeMul;        /*!< Device size multiplier */
        volatile uint8_t  EraseGrSize;          /*!< Erase group size */
        volatile uint8_t  EraseGrMul;           /*!< Erase group size multiplier */
        volatile uint8_t  WrProtectGrSize;      /*!< Write protect group size */
        volatile uint8_t  WrProtectGrEnable;    /*!< Write protect group enable */
        volatile uint8_t  ManDeflECC;           /*!< Manufacturer default ECC */
        volatile uint8_t  WrSpeedFact;          /*!< Write speed factor */
        volatile uint8_t  MaxWrBlockLen;        /*!< Max. write data block length */
        volatile uint8_t  WriteBlockPaPartial;  /*!< Partial blocks for write allowed */
        volatile uint8_t  Reserved3;            /*!< Reserded */
        volatile uint8_t  ContentProtectAppli;  /*!< Content protection application */
        volatile uint8_t  FileFormatGrouop;     /*!< File format group */
        volatile uint8_t  CopyFlag;             /*!< Copy flag (OTP) */
        volatile uint8_t  PermWrProtect;        /*!< Permanent write protection */
        volatile uint8_t  TempWrProtect;        /*!< Temporary write protection */
        volatile uint8_t  FileFormat;           /*!< File Format */
        volatile uint8_t  ECC;                  /*!< ECC code */
        volatile uint8_t  CSD_CRC;              /*!< CSD CRC */
        volatile uint8_t  Reserved4;            /*!< always 1*/
    };

    struct SdCid {
      volatile uint8_t  ManufacturerID;       /*!< ManufacturerID */
      volatile uint16_t OEM_AppliID;          /*!< OEM/Application ID */
      volatile uint32_t ProdName1;            /*!< Product Name part1 */
      volatile uint8_t  ProdName2;            /*!< Product Name part2*/
      volatile uint8_t  ProdRev;              /*!< Product Revision */
      volatile uint32_t ProdSN;               /*!< Product Serial Number */
      volatile uint8_t  Reserved1;            /*!< Reserved1 */
      volatile uint16_t ManufactDate;         /*!< Manufacturing Date */
      volatile uint8_t  CID_CRC;              /*!< CID CRC */
      volatile uint8_t  Reserved2;            /*!< always 1 */
    };

    enum SD_Error {
      SD_CMD_CRC_FAIL                    = (1), /*!< Command response received (but CRC check failed) */
      SD_DATA_CRC_FAIL                   = (2), /*!< Data bock sent/received (CRC check Failed) */
      SD_CMD_RSP_TIMEOUT                 = (3), /*!< Command response timeout */
      SD_DATA_TIMEOUT                    = (4), /*!< Data time out */
      SD_TX_UNDERRUN                     = (5), /*!< Transmit FIFO under-run */
      SD_RX_OVERRUN                      = (6), /*!< Receive FIFO over-run */
      SD_START_BIT_ERR                   = (7), /*!< Start bit not detected on all data signals in widE bus mode */
      SD_CMD_OUT_OF_RANGE                = (8), /*!< CMD's argument was out of range.*/
      SD_ADDR_MISALIGNED                 = (9), /*!< Misaligned address */
      SD_BLOCK_LEN_ERR                   = (10), /*!< Transferred block length is not allowed for the card or the number of transferred bytes does not match the block length */
      SD_ERASE_SEQ_ERR                   = (11), /*!< An error in the sequence of erase command occurs.*/
      SD_BAD_ERASE_PARAM                 = (12), /*!< An Invalid selection for erase groups */
      SD_WRITE_PROT_VIOLATION            = (13), /*!< Attempt to program a write protect block */
      SD_LOCK_UNLOCK_FAILED              = (14), /*!< Sequence or password error has been detected in unlock command or if there was an attempt to access a locked card */
      SD_COM_CRC_FAILED                  = (15), /*!< CRC check of the previous command failed */
      SD_ILLEGAL_CMD                     = (16), /*!< Command is not legal for the card state */
      SD_CARD_ECC_FAILED                 = (17), /*!< Card internal ECC was applied but failed to correct the data */
      SD_CC_ERROR                        = (18), /*!< Internal card controller error */
      SD_GENERAL_UNKNOWN_ERROR           = (19), /*!< General or Unknown error */
      SD_STREAM_READ_UNDERRUN            = (20), /*!< The card could not sustain data transfer in stream read operation. */
      SD_STREAM_WRITE_OVERRUN            = (21), /*!< The card could not sustain data programming in stream mode */
      SD_CID_CSD_OVERWRITE               = (22), /*!< CID/CSD overwrite error */
      SD_WP_ERASE_SKIP                   = (23), /*!< only partial address space was erased */
      SD_CARD_ECC_DISABLED               = (24), /*!< Command has been executed without using internal ECC */
      SD_ERASE_RESET                     = (25), /*!< Erase sequence was cleared before executing because an out of erase sequence command was received */
      SD_AKE_SEQ_ERROR                   = (26), /*!< Error in sequence of authentication. */
      SD_INVALID_VOLTRANGE               = (27),
      SD_ADDR_OUT_OF_RANGE               = (28),
      SD_SWITCH_ERROR                    = (29),
      SD_SDIO_DISABLED                   = (30),
      SD_SDIO_FUNCTION_BUSY              = (31),
      SD_SDIO_FUNCTION_FAILED            = (32),
      SD_SDIO_UNKNOWN_FUNCTION           = (33),

    /**
      * @brief  Standard error defines
      */

      SD_INTERNAL_ERROR,
      SD_NOT_CONFIGURED,
      SD_REQUEST_PENDING,
      SD_REQUEST_NOT_APPLICABLE,
      SD_INVALID_PARAMETER,
      SD_UNSUPPORTED_FEATURE,
      SD_UNSUPPORTED_HW,
      SD_ERROR,
      SD_OK = 0
    };

    enum SDTransferState {
      SD_TRANSFER_OK  = 0,
      SD_TRANSFER_BUSY = 1,
      SD_TRANSFER_ERROR
    };

    enum SDCardState {
      SD_CARD_READY                  = ((uint32_t)0x00000001),
      SD_CARD_IDENTIFICATION         = ((uint32_t)0x00000002),
      SD_CARD_STANDBY                = ((uint32_t)0x00000003),
      SD_CARD_TRANSFER               = ((uint32_t)0x00000004),
      SD_CARD_SENDING                = ((uint32_t)0x00000005),
      SD_CARD_RECEIVING              = ((uint32_t)0x00000006),
      SD_CARD_PROGRAMMING            = ((uint32_t)0x00000007),
      SD_CARD_DISCONNECTED           = ((uint32_t)0x00000008),
      SD_CARD_ERROR                  = ((uint32_t)0x000000FF)
    };

    enum {
      SD_CMD_GO_IDLE_STATE                       =0,
      SD_CMD_SEND_OP_COND                        =1,
      SD_CMD_ALL_SEND_CID                        =2,
      SD_CMD_SET_REL_ADDR                        =3, /*!< SDIO_SEND_REL_ADDR for SD Card */
      SD_CMD_SET_DSR                             =4,
      SD_CMD_SDIO_SEN_OP_COND                    =5,
      SD_CMD_HS_SWITCH                           =6,
      SD_CMD_SEL_DESEL_CARD                      =7,
      SD_CMD_HS_SEND_EXT_CSD                     =8,
      SD_CMD_SEND_CSD                            =9,
      SD_CMD_SEND_CID                            =10,
      SD_CMD_READ_DAT_UNTIL_STOP                 =11, /*!< SD Card doesn't support it */
      SD_CMD_STOP_TRANSMISSION                   =12,
      SD_CMD_SEND_STATUS                         =13,
      SD_CMD_HS_BUSTEST_READ                     =14,
      SD_CMD_GO_INACTIVE_STATE                   =15,
      SD_CMD_SET_BLOCKLEN                        =16,
      SD_CMD_READ_SINGLE_BLOCK                   =17,
      SD_CMD_READ_MULT_BLOCK                     =18,
      SD_CMD_HS_BUSTEST_WRITE                    =19,
      SD_CMD_WRITE_DAT_UNTIL_STOP                =20, /*!< SD Card doesn't support it */
      SD_CMD_SET_BLOCK_COUNT                     =23, /*!< SD Card doesn't support it */
      SD_CMD_WRITE_SINGLE_BLOCK                  =24,
      SD_CMD_WRITE_MULT_BLOCK                    =25,
      SD_CMD_PROG_CID                            =26, /*!< reserved for manufacturers */
      SD_CMD_PROG_CSD                            =27,
      SD_CMD_SET_WRITE_PROT                      =28,
      SD_CMD_CLR_WRITE_PROT                      =29,
      SD_CMD_SEND_WRITE_PROT                     =30,
      SD_CMD_SD_ERASE_GRP_START                  =32, /*!< To set the address of the first write
                                                                  block to be erased. (For SD card only, */
      SD_CMD_SD_ERASE_GRP_END                    =33, /*!< To set the address of the last write block of the
                                                                  continuous range to be erased. (For SD card only, */
      SD_CMD_ERASE_GRP_START                     =35, /*!< To set the address of the first write block to be erased.
                                                                  (For MMC card only spec 3.31, */

      SD_CMD_ERASE_GRP_END                       =36, /*!< To set the address of the last write block of the
                                                                  continuous range to be erased. (For MMC card only spec 3.31, */

      SD_CMD_ERASE                               =38,
      SD_CMD_FAST_IO                             =39, /*!< SD Card doesn't support it */
      SD_CMD_GO_IRQ_STATE                        =40, /*!< SD Card doesn't support it */
      SD_CMD_LOCK_UNLOCK                         =42,
      SD_CMD_APP_CMD                             =55,
      SD_CMD_GEN_CMD                             =56,
      SD_CMD_NO_CMD                              =64,

      /**
       * @brief Following commands are SD Card Specific commands.
       *        SDIO_APP_CMD should be sent before sending these commands.
       */
      SD_CMD_APP_SD_SET_BUSWIDTH                 =6,  /*!< For SD Card only */
      SD_CMD_SD_APP_STAUS                        =13, /*!< For SD Card only */
      SD_CMD_SD_APP_SEND_NUM_WRITE_BLOCKS        =22, /*!< For SD Card only */
      SD_CMD_SD_APP_OP_COND                      =41, /*!< For SD Card only */
      SD_CMD_SD_APP_SET_CLR_CARD_DETECT          =42, /*!< For SD Card only */
      SD_CMD_SD_APP_SEND_SCR                     =51, /*!< For SD Card only */
      SD_CMD_SDIO_RW_DIRECT                      =52, /*!< For SD I/O Card only */
      SD_CMD_SDIO_RW_EXTENDED                    =53, /*!< For SD I/O Card only */

      /**
       * @brief Following commands are SD Card Specific security commands.
       *        SDIO_APP_CMD should be sent before sending these commands.
       */
      SD_CMD_SD_APP_GET_MKB                      =43, /*!< For SD Card only */
      SD_CMD_SD_APP_GET_MID                      =44, /*!< For SD Card only */
      SD_CMD_SD_APP_SET_CER_RN1                  =45, /*!< For SD Card only */
      SD_CMD_SD_APP_GET_CER_RN2                  =46, /*!< For SD Card only */
      SD_CMD_SD_APP_SET_CER_RES2                 =47, /*!< For SD Card only */
      SD_CMD_SD_APP_GET_CER_RES1                 =48, /*!< For SD Card only */
      SD_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCK   =18, /*!< For SD Card only */
      SD_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCK  =25, /*!< For SD Card only */
      SD_CMD_SD_APP_SECURE_ERASE                 =38, /*!< For SD Card only */
      SD_CMD_SD_APP_CHANGE_SECURE_AREA           =49, /*!< For SD Card only */
      SD_CMD_SD_APP_SECURE_WRITE_MKB             =48 /*!< For SD Card only */
    };

    enum {
      SDIO_STD_CAPACITY_SD_CARD_V1_1             =((uint32_t)0x00000000),
      SDIO_STD_CAPACITY_SD_CARD_V2_0             =((uint32_t)0x00000001),
      SDIO_HIGH_CAPACITY_SD_CARD                 =((uint32_t)0x00000002),
      SDIO_MULTIMEDIA_CARD                       =((uint32_t)0x00000003),
      SDIO_SECURE_DIGITAL_IO_CARD                =((uint32_t)0x00000004),
      SDIO_HIGH_SPEED_MULTIMEDIA_CARD            =((uint32_t)0x00000005),
      SDIO_SECURE_DIGITAL_IO_COMBO_CARD          =((uint32_t)0x00000006),
      SDIO_HIGH_CAPACITY_MMC_CARD                =((uint32_t)0x00000007)
    };

    protected:
      SdCardIoFeature(SdCardBase& sdcard)
        : SdCardFeatureBase(sdcard) {
      }
  };
}
// END FILE: ../lib/include/sdcard/features/SdCardIoFeature.h
// START FILE: ../lib/include/sdcard/features/SdCardSdioFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base Implementation of the SD card for SDIO. Provides SDIO initialisation functionality.
   *
   * The code here is nearly all adapted from the driver sample code provided by ST. The rights of the original
   * authors are preserved under the following license statement provided by ST:
   *
   * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
   *
   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
   * You may not use this file except in compliance with the License.
   * You may obtain a copy of the License at:
   *
   *        http://www.st.com/software_license_agreement_liberty_v2
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   */

  class SdCardSdioFeature : public SdCardIoFeature {

    public:

      struct CardInfo {
        SdCsd SD_csd;
        SdCid SD_cid;
        uint64_t CardCapacity;  /*!< Card Capacity */
        uint32_t CardBlockSize; /*!< Card Block Size */
        uint16_t RCA;
        uint8_t CardType;
      } _cardInfo;

    protected:
      uint8_t _initDivider;
      uint8_t _transferDivider;
      uint32_t _cardType;
      uint32_t _csdTab[4];
      uint32_t _cidTab[4];
      uint32_t _rca;

      enum {
        E_SDIO_ERROR = 1,
        E_CRC_FAIL,
        E_TIMEOUT,
        E_RXOVERRUN,
        E_TXOVERRUN,
        E_STARTBITERROR,
        E_DMA_TRANSFER_ERROR
      };

      enum {
        SD_STD_CAPACITY = 0,
        SD_HIGH_CAPACITY = 0x40000000,
        SD_CHECK_PATTERN = 0x000001AA,
        SD_MAX_VOLT_TRIAL = 0x0000FFFF,
        SD_VOLTAGE_WINDOW_SD = 0x80100000,
        SDIO_CMD0TIMEOUT = 0x00010000,
        SD_DATATIMEOUT = 0xFFFFFFFF,
        SDIO_STATIC_FLAGS = 0x000005FF,
        SDIO_SEND_IF_COND = 0x00000008,
        SD_ALLZERO = 0,
        SD_CARD_LOCKED = 0x02000000,
        SD_WIDE_BUS_SUPPORT = 0x00040000,
        SD_SINGLE_BUS_SUPPORT = 0x00010000,
        SD_0TO7BITS = 0x000000FF,
        SD_8TO15BITS = 0x0000FF00,
        SD_16TO23BITS = 0x00FF0000,
        SD_24TO31BITS = 0xFF000000
      };

      enum {
        SD_OCR_ADDR_OUT_OF_RANGE        =0x80000000,
        SD_OCR_ADDR_MISALIGNED          =0x40000000,
        SD_OCR_BLOCK_LEN_ERR            =0x20000000,
        SD_OCR_ERASE_SEQ_ERR            =0x10000000,
        SD_OCR_BAD_ERASE_PARAM          =0x08000000,
        SD_OCR_WRITE_PROT_VIOLATION     =0x04000000,
        SD_OCR_LOCK_UNLOCK_FAILED       =0x01000000,
        SD_OCR_COM_CRC_FAILED           =0x00800000,
        SD_OCR_ILLEGAL_CMD              =0x00400000,
        SD_OCR_CARD_ECC_FAILED          =0x00200000,
        SD_OCR_CC_ERROR                 =0x00100000,
        SD_OCR_GENERAL_UNKNOWN_ERROR    =0x00080000,
        SD_OCR_STREAM_READ_UNDERRUN     =0x00040000,
        SD_OCR_STREAM_WRITE_OVERRUN     =0x00020000,
        SD_OCR_CID_CSD_OVERWRIETE       =0x00010000,
        SD_OCR_WP_ERASE_SKIP            =0x00008000,
        SD_OCR_CARD_ECC_DISABLED        =0x00004000,
        SD_OCR_ERASE_RESET              =0x00002000,
        SD_OCR_AKE_SEQ_ERROR            =0x00000008,
        SD_OCR_ERRORBITS                =0xFDFFE008
      };

      enum {
        SD_R6_GENERAL_UNKNOWN_ERROR =0x00002000,
        SD_R6_ILLEGAL_CMD           =0x00004000,
        SD_R6_COM_CRC_FAILED        =0x00008000
      };

      enum {
        SD_CCCC_LOCK_UNLOCK = (uint32_t)0x00000080,
        SD_CCCC_WRITE_PROT  = (uint32_t)0x00000040,
        SD_CCCC_ERASE       = (uint32_t)0x00000020
      };

    protected:
      SD_Error enableWideBus(FunctionalState NewState);
      SD_Error findSCR(uint32_t *pscr);

      SD_Error cmdError();
      SD_Error cmdResp1Error(uint8_t cmd) const;
      SD_Error cmdResp2Error();
      SD_Error cmdResp3Error();
      SD_Error cmdResp6Error(uint8_t cmd,uint16_t *prca);
      SD_Error cmdResp7Error();

      SD_Error sendStatus(uint32_t& pcardstatus) const;
      SD_Error isCardProgramming(uint8_t& pstatus) const;

      bool stopTransfer() const;
      uint32_t waitStatusFlags() const;

    public:
      SdCardSdioFeature(SdCardBase& sdcard);

      void detectDividers();

      bool powerOn();
      void powerOff();

      bool initialiseCard();
      bool detectCardInfo();
      bool selectDeselect(uint32_t addr);
      bool enableWideBusOperation(uint32_t WideMode);

      bool readBlockCommand(uint32_t blockIndex,uint16_t blockSize);
      bool readBlocksCommand(uint32_t blockIndex,uint16_t blockSize,uint32_t numberOfBlocks);

      bool writeBlockCommand(uint32_t blockIndex,uint16_t blockSize);
      bool writeBlocksCommand(uint32_t blockIndex,uint16_t blockSize,uint32_t numberOfBlocks);
      bool eraseBlocks(uint32_t firstBlock,uint32_t lastBlock);

      bool waitForReceiveComplete();
      bool waitForTransmitComplete();
      void clearAllFlags() const;

      void setInitDivider(uint8_t divider);
      void setTransferDivider(uint8_t divider);

      const CardInfo& getCardInfo() const;
      uint32_t getCardType() const;

      SDCardState getCardState() const;
      SDTransferState getStatus() const;
  };


  /**
   * Set the initialisation clock divider
   * @param divider
   */

  inline void SdCardSdioFeature::setInitDivider(uint8_t divider) {
    _initDivider=divider;
  }


  /**
   * Set the initialisation clock divider
   * @param divider
   */

  inline void SdCardSdioFeature::setTransferDivider(uint8_t divider) {
    _transferDivider=divider;
  }


  /**
   * Clear all flags
   */

  inline void SdCardSdioFeature::clearAllFlags() const {
    SDIO_ClearFlag(SDIO_STATIC_FLAGS);
  }


  /**
   * Return the card information structure
   * @return the reference
   */

  inline const SdCardSdioFeature::CardInfo& SdCardSdioFeature::getCardInfo() const {
    return _cardInfo;
  }


  /**
   * Get the card type
   * @return
   */

  inline uint32_t SdCardSdioFeature::getCardType() const {
    return _cardType;
  }
}
// END FILE: ../lib/include/sdcard/features/SdCardSdioFeature.h
// START FILE: ../lib/include/sdcard/features/SdioDmaTransferFeature.h
// END FILE: ../lib/include/sdcard/features/SdioDmaTransferFeature.h
// START FILE: ../lib/include/exti/f4/ExtiPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * @brief Template implementation for the EXTI lines
   * @tparam Index The index (0..15) of the EXTI line.
   * @tparam Line The EXTI line e.g. EXTI_Line0
   * @tparam Irq The corresponding IRQ for the EXTI line.
   *
   * Exti 0..15 configuration differs only slightly so we define as a template with integral
   * parameters and then declare typedefs for the user usage.
   *
   * The ExtiInterruptEventSender member can be used to subscribe to the
   * interrupts. See the 'exti' example for details of how to do this.
   */

  template<uint32_t Line>
  class ExtiPeripheral : public ExtiPeripheralBase {

    public:
      static ExtiPeripheral *_extiInstance;

    public:
      ExtiPeripheral(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger);

      void generateSoftwareInterrupt() const;
      bool isSet() const;
  };


  /**
   * Constructor
   *
   * @param[in] mode EXTI_Mode_Event or EXTI_Mode_Interrupt
   * @param[in] trigger EXTI_Trigger_Falling / EXTI_Trigger_Rising / EXTI_Trigger_Rising_Falling
   * @param[in] pin The GPIO pin to use.
   */

  template<uint32_t Line>
  inline ExtiPeripheral<Line>::ExtiPeripheral(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger) {
    _extiInstance=this;
    initialisePeripheral(Line,mode,trigger);
  }


  /**
   * Generate a software interrupt on this line
   */

  template<uint32_t Line>
  inline void ExtiPeripheral<Line>::generateSoftwareInterrupt() const {
    EXTI_GenerateSWInterrupt(Line);
  }

  /**
   * Test if this line is set or not
   * @return true if it is set
   */

  template<uint32_t Line>
  inline bool ExtiPeripheral<Line>::isSet() const {
    return EXTI_GetFlagStatus(Line)==SET;
  }


  /**
   * Specialisations for all the exti lines
   */

  struct Exti0 : public ExtiPeripheral<EXTI_Line0> {
    Exti0(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line0>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<0>::enable();
    }
  };

  struct Exti1 : public ExtiPeripheral<EXTI_Line1> {
    Exti1(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line1>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<1>::enable();
    }
  };

  struct Exti2 : public ExtiPeripheral<EXTI_Line2> {
    Exti2(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line2>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<2>::enable();
    }
  };

  struct Exti3 : public ExtiPeripheral<EXTI_Line3> {
    Exti3(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line3>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<3>::enable();
    }
  };

  struct Exti4 : public ExtiPeripheral<EXTI_Line4> {
    Exti4(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line4>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<4>::enable();
    }
  };

  struct Exti5 : public ExtiPeripheral<EXTI_Line5> {
    Exti5(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line5>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<5>::enable();
    }
  };

  struct Exti6 : public ExtiPeripheral<EXTI_Line6> {
    Exti6(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line6>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<5>::enable();
    }
  };

  struct Exti7 : public ExtiPeripheral<EXTI_Line7> {
    Exti7(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line7>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<5>::enable();
    }
  };

  struct Exti8 : public ExtiPeripheral<EXTI_Line8> {
    Exti8(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line8>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<5>::enable();
    }
  };

  struct Exti9 : public ExtiPeripheral<EXTI_Line9> {
    Exti9(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line9>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<5>::enable();
    }
  };

  struct Exti10 : public ExtiPeripheral<EXTI_Line10> {
    Exti10(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line10>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<10>::enable();     // shared interrupt 10..15
    }
  };

  struct Exti11 : public ExtiPeripheral<EXTI_Line11> {
    Exti11(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line11>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<10>::enable();     // shared interrupt 10..15
    }
  };

  struct Exti12 : public ExtiPeripheral<EXTI_Line12> {
    Exti12(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line12>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<10>::enable();     // shared interrupt 10..15
    }
  };

  struct Exti13 : public ExtiPeripheral<EXTI_Line13> {
    Exti13(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line13>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<10>::enable();     // shared interrupt 10..15
    }
  };

  struct Exti14 : public ExtiPeripheral<EXTI_Line14> {
    Exti14(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line14>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<10>::enable();     // shared interrupt 10..15
    }
  };

  struct Exti15 : public ExtiPeripheral<EXTI_Line15> {
    Exti15(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger,const Gpio& pin)
      : ExtiPeripheral<EXTI_Line15>(mode,trigger) {

      pin.enableExti();

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<10>::enable();     // shared interrupt 10..15
    }
  };

  struct ExtiPvd : public ExtiPeripheral<EXTI_Line16> {
    ExtiPvd(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger)
      : ExtiPeripheral<EXTI_Line16>(mode,trigger) {

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<16>::enable();
    }
  };

  struct ExtiRtcAlarm : public ExtiPeripheral<EXTI_Line17> {
    ExtiRtcAlarm(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger)
      : ExtiPeripheral<EXTI_Line17>(mode,trigger) {

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<17>::enable();
    }
  };

  struct ExtiUsbFsWakeup : public ExtiPeripheral<EXTI_Line18> {
    ExtiUsbFsWakeup(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger)
      : ExtiPeripheral<EXTI_Line18>(mode,trigger) {

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<18>::enable();
    }
  };

  struct ExtiEthernetWakeup : public ExtiPeripheral<EXTI_Line19> {
    ExtiEthernetWakeup(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger)
      : ExtiPeripheral<EXTI_Line19>(mode,trigger) {

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<19>::enable();
    }
  };

  struct ExtiUsbHsWakeup : public ExtiPeripheral<EXTI_Line20> {
    ExtiUsbHsWakeup(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger)
      : ExtiPeripheral<EXTI_Line20>(mode,trigger) {

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<20>::enable();
    }
  };

  struct ExtiTamperTimestamp : public ExtiPeripheral<EXTI_Line21> {
    ExtiTamperTimestamp(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger)
      : ExtiPeripheral<EXTI_Line21>(mode,trigger) {

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<21>::enable();
    }
  };

  struct ExtiRtcWakeup : public ExtiPeripheral<EXTI_Line22> {
    ExtiRtcWakeup(EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger)
      : ExtiPeripheral<EXTI_Line22>(mode,trigger) {

      if(mode==EXTI_Mode_Interrupt)
        ExtiInterruptEnabler<22>::enable();
    }
  };
}
// END FILE: ../lib/include/exti/f4/ExtiPeripheral.h
// START FILE: ../lib/include/exti/f4/ExtiInterruptEnabler.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /*
   * Forward declare the IRQ handler names
   */

  extern "C" void EXTI0_IRQHandler();
  extern "C" void EXTI1_IRQHandler();
  extern "C" void EXTI2_IRQHandler();
  extern "C" void EXTI3_IRQHandler();
  extern "C" void EXTI4_IRQHandler();
  extern "C" void EXTI9_5_IRQHandler();
  extern "C" void EXTI15_10_IRQHandler();
  extern "C" void PVD_IRQHandler();
  extern "C" void RTCAlarm_IRQHandler();
  extern "C" void OTG_FS_WKUP_IRQHandler();
  extern "C" void ETH_WKUP_IRQHandler();
  extern "C" void OTG_HS_WKUP_IRQHandler();
  extern "C" void TAMP_STAMP_IRQHandler();
  extern "C" void RTC_WKUP_IRQHandler();


  /**
   * Helper class to enable only the desired interrupts in the NVIC. This will
   * be fully specialised for each EXTI peripheral
   * @tparam TExtiNumber The number of the Exti peripheral (0..19 | 22)
   */

  template<uint8_t TExtiNumber>
  class ExtiInterruptEnabler {

    private:
      typedef void (*FPTR)();         // this trick will force the linker to include the ISR
      static FPTR _forceLinkage;

    public:
      static void enable();
      static void disable();
  };

  template<uint8_t TExtiNumber>
  typename ExtiInterruptEnabler<TExtiNumber>::FPTR ExtiInterruptEnabler<TExtiNumber>::_forceLinkage=nullptr;


  /**
   * Enabler specialisations for the F4
   */

  template<>
  inline void ExtiInterruptEnabler<0>::enable() {
    _forceLinkage=&EXTI0_IRQHandler;
    Nvic::configureIrq(EXTI0_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<0>::disable() {
    Nvic::configureIrq(EXTI0_IRQn,DISABLE);
  }


  template<>
  inline void ExtiInterruptEnabler<1>::enable() {
    _forceLinkage=&EXTI1_IRQHandler;
    Nvic::configureIrq(EXTI1_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<1>::disable() {
    Nvic::configureIrq(EXTI1_IRQn,DISABLE);
  }


  template<>
  inline void ExtiInterruptEnabler<2>::enable() {
    _forceLinkage=&EXTI2_IRQHandler;
    Nvic::configureIrq(EXTI2_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<2>::disable() {
    Nvic::configureIrq(EXTI2_IRQn,DISABLE);
  }


  template<>
  inline void ExtiInterruptEnabler<3>::enable() {
    _forceLinkage=&EXTI3_IRQHandler;
    Nvic::configureIrq(EXTI3_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<3>::disable() {
    Nvic::configureIrq(EXTI3_IRQn,DISABLE);
  }


  template<>
  inline void ExtiInterruptEnabler<4>::enable() {
    _forceLinkage=&EXTI4_IRQHandler;
    Nvic::configureIrq(EXTI4_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<4>::disable() {
    Nvic::configureIrq(EXTI4_IRQn,DISABLE);
  }


  /**
   * 5 through 9 are on a shared IRQ
   */

  template<>
  inline void ExtiInterruptEnabler<5>::enable() {
    _forceLinkage=&EXTI9_5_IRQHandler;
    Nvic::configureIrq(EXTI9_5_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<5>::disable() {
    Nvic::configureIrq(EXTI9_5_IRQn,DISABLE);
  }


  /**
   * 10 through 15 are on a shared IRQ
   */

  template<>
  inline void ExtiInterruptEnabler<10>::enable() {
    _forceLinkage=&EXTI15_10_IRQHandler;
    Nvic::configureIrq(EXTI15_10_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<10>::disable() {
    Nvic::configureIrq(EXTI15_10_IRQn,DISABLE);
  }


  /**
   * Non-GPIO EXTI lines
   */

  template<>
  inline void ExtiInterruptEnabler<16>::enable() {
    _forceLinkage=&PVD_IRQHandler;
    Nvic::configureIrq(PVD_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<16>::disable() {
    Nvic::configureIrq(PVD_IRQn,DISABLE);
  }


  template<>
  inline void ExtiInterruptEnabler<17>::enable() {
    _forceLinkage=&RTCAlarm_IRQHandler;
    Nvic::configureIrq(RTC_Alarm_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<17>::disable() {
    Nvic::configureIrq(RTC_Alarm_IRQn,DISABLE);
  }


  template<>
  inline void ExtiInterruptEnabler<18>::enable() {
    _forceLinkage=&OTG_FS_WKUP_IRQHandler;
    Nvic::configureIrq(OTG_FS_WKUP_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<18>::disable() {
    Nvic::configureIrq(OTG_FS_WKUP_IRQn,DISABLE);
  }


#if defined(STM32PLUS_F4_HAS_MAC)

  /**
   * Ethernet EXTI is available
   */


  template<>
  inline void ExtiInterruptEnabler<19>::enable() {
    _forceLinkage=&ETH_WKUP_IRQHandler;
    Nvic::configureIrq(ETH_WKUP_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<19>::disable() {
    Nvic::configureIrq(ETH_WKUP_IRQn,DISABLE);
  }

#endif


  /**
   * Additional EXTI lines on many F4 devices
   */

#if defined(STM32PLUS_F4_HAS_OTG_HS)

  template<>
  inline void ExtiInterruptEnabler<20>::enable() {
    _forceLinkage=&OTG_HS_WKUP_IRQHandler;
    Nvic::configureIrq(OTG_HS_WKUP_IRQn);
  }


  template<>
  inline void ExtiInterruptEnabler<20>::disable() {
    Nvic::configureIrq(OTG_HS_WKUP_IRQn,DISABLE);
  }

#endif


  template<>
  inline void ExtiInterruptEnabler<21>::enable() {
    _forceLinkage=&TAMP_STAMP_IRQHandler;
    Nvic::configureIrq(TAMP_STAMP_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<21>::disable() {
    Nvic::configureIrq(TAMP_STAMP_IRQn,DISABLE);
  }


  template<>
  inline void ExtiInterruptEnabler<22>::enable() {
    _forceLinkage=&RTC_WKUP_IRQHandler;
    Nvic::configureIrq(RTC_WKUP_IRQn);
  }

  template<>
  inline void ExtiInterruptEnabler<22>::disable() {
    Nvic::configureIrq(RTC_WKUP_IRQn,DISABLE);
  }
}
// END FILE: ../lib/include/exti/f4/ExtiInterruptEnabler.h
// START FILE: ../lib/include/exti/ExtiPeripheralBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief EXTI base class. This holds the instance address of the IRQ handler class and
   * handles the peripheral initialisation (non-template code)
   */

  DECLARE_EVENT_SIGNATURE(ExtiInterrupt,void(uint8_t));

  class ExtiPeripheralBase {

    protected:
      uint32_t _line;

    protected:
      void initialisePeripheral(uint32_t line,EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger);

    public:
      DECLARE_EVENT_SOURCE(ExtiInterrupt);

    public:
      void clearPendingInterrupt() const;
  };


  /**
   * Initialise the peripheral
   *
   * @param[in] index exti number (0..n)
   * @param[in] mode EXTI_Mode_Event or EXTI_Mode_Interrupt
   * @param[in] trigger EXTI_Trigger_Falling / EXTI_Trigger_Rising / EXTI_Trigger_Rising_Falling
   * @param[in] pin The GPIO pin to use.
   */

  inline void ExtiPeripheralBase::initialisePeripheral(uint32_t line,EXTIMode_TypeDef mode,EXTITrigger_TypeDef trigger) {

    EXTI_InitTypeDef init;

    _line=line;

    init.EXTI_Line=line;
    init.EXTI_Mode=mode;
    init.EXTI_Trigger=trigger;
    init.EXTI_LineCmd=ENABLE;

    EXTI_Init(&init);
  }


  /**
   * Clear any pending interrupt flag
   */

  inline void ExtiPeripheralBase::clearPendingInterrupt() const {
    EXTI_ClearITPendingBit(_line);
  }
}
// END FILE: ../lib/include/exti/ExtiPeripheralBase.h
// START FILE: ../lib/include/flash/internal/f4/InternalFlashSectorMap.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Size map declaration for the F40x and F41x devices. 12 sectors.
   */

  struct InternalFlashSectorMapF40xF41x {
    static const uint8_t SizeMap[12];
  };


  /**
   * Size map declaration for the F42x and F43x devices. 24 sectors.
   */

  struct InternalFlashSectorMapF42xF43x {
    static const uint8_t SizeMap[24];
  };
}
// END FILE: ../lib/include/flash/internal/f4/InternalFlashSectorMap.h
// START FILE: ../lib/include/flash/internal/f4/InternalFlashVoltageRange.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Program/erase operations on the F4 need a voltage range parameter from this enumeration.
   */

  enum class InternalFlashVoltageRange : uint8_t {
    VR_1_8_TO_2_1 = VoltageRange_1,         ///< operating range: 1.8V to 2.1V
    VR_2_1_TO_2_7 = VoltageRange_2,         ///< operating range: 2.1V to 2.7V
    VR_2_7_TO_3_6 = VoltageRange_3,         ///< operating range: 2.7V to 3.6V
    VR_2_7_TO_3_6_EXT_VPP = VoltageRange_4  ///< operating range: 2.7V to 3.6V with ext Vpp
  };
}

// END FILE: ../lib/include/flash/internal/f4/InternalFlashVoltageRange.h
// START FILE: ../lib/include/flash/internal/f4/InternalFlashPeripheral.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * Basic features for the internal flash peripheral
   */

  class InternalFlashPeripheral {

    protected:
      const uint8_t *_sizeMap;

    public:
      InternalFlashPeripheral(const uint8_t *sizeMap);

      uint8_t getPageFromAddress(uint32_t flashAddress) const;
      uint32_t getPageSize(uint32_t flashAddress) const;
      uint32_t getFlashSizeInBytes() const;
      bool isStartOfPage(uint32_t address) const;
  };


  /**
   * Constructor
   * @param sizeMap pointer to the sector size map
   */

  inline InternalFlashPeripheral::InternalFlashPeripheral(const uint8_t *sizeMap)
    : _sizeMap(sizeMap) {
  }


  /**
   * Get the page size of this device
   * @return The page size
   */

  inline uint32_t InternalFlashPeripheral::getPageSize(uint32_t flashAddress) const {
    return _sizeMap[getPageFromAddress(flashAddress)]*1024;
  }


  /**
   * Get the page number from the flash address
   * @param flashAddress
   * @return the zero-based page number
   */

  inline uint8_t InternalFlashPeripheral::getPageFromAddress(uint32_t flashAddress) const {

    uint8_t pageNumber;
    uint32_t address,pageSize;

    address=FLASH_BASE;
    pageNumber=0;

    for(;;) {

      pageSize=_sizeMap[pageNumber]*1024;

      if(flashAddress<address+pageSize)
        return pageNumber;

      pageNumber++;
      address+=pageSize;
    }
  }


  /**
   * Check if this address is at the start of a page
   * @param address The address to check
   * @return true if it's at the start of a page
   */

  inline bool InternalFlashPeripheral::isStartOfPage(uint32_t addressToCheck) const {

    uint32_t address;

    address=FLASH_BASE;

    while(addressToCheck>address)
      address+=getPageSize(address);

    return address==addressToCheck;
  }


  /**
   * Read the total flash size in bytes
   * @return The total flash size
   */

  inline uint32_t InternalFlashPeripheral::getFlashSizeInBytes() const {
    return *reinterpret_cast<volatile uint16_t *>(0x1FFF7A22)*1024;
  }
}
// END FILE: ../lib/include/flash/internal/f4/InternalFlashPeripheral.h
// START FILE: ../lib/include/flash/internal/f4/features/InternalFlashWriteFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Implementation of the basic flash operations. Note that the flash must be write enabled
   * for any of these methods to work.
   *
   * @tparam TVoltageRange a value from the VoltageRange
   */

  template<InternalFlashVoltageRange TVoltageRange>
  class InternalFlashWriteFeature  : public InternalFlashFeatureBase {

    public:
      enum {
        E_ERASE_FAILED = 1,          ///< erase operation failed: see extended code for reason
        E_PROGRAM_FAILED = 2         ///< program operation failed: see extended code for reason
      };

    public:
      InternalFlashWriteFeature(InternalFlashPeripheral& flashPeripheral);

      bool chipErase() const;
      bool pageErase(uint32_t flashAddress) const;

      bool wordProgram(uint32_t flashAddress,uint32_t data) const;
      bool halfWordProgram(uint32_t flashAddress,uint16_t data) const;
  };


  /*
   * Some typedefs for common MCU configurations
   */

  typedef InternalFlashWriteFeature<InternalFlashVoltageRange::VR_2_7_TO_3_6> DefaultF407InternalFlashWriteFeature;


  /**
   * Constructor
   * @param flashPeripheral reference to the peripheral class
   */

  template<InternalFlashVoltageRange TVoltageRange>
  inline InternalFlashWriteFeature<TVoltageRange>::InternalFlashWriteFeature(InternalFlashPeripheral& flashPeripheral)
    : InternalFlashFeatureBase(flashPeripheral) {
  }


  /**
   * Erase the entire device - not clever if you're running from flash
   * @return true if it worked and the operation has completed.
   */

  template<InternalFlashVoltageRange TVoltageRange>
  inline bool InternalFlashWriteFeature<TVoltageRange>::chipErase() const {

    uint32_t err;

    // erase everything

    if((err=FLASH_EraseAllSectors(static_cast<uint8_t>(TVoltageRange)))==FLASH_COMPLETE)
      return true;

    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_INTERNAL_FLASH,E_ERASE_FAILED,err);
  }


  /**
   * Erase a page.
   * @param flashAddress. The address to erase - must be a page multiple.
   * @return true if it worked and the operation has completed.
   */

  template<InternalFlashVoltageRange TVoltageRange>
  inline bool InternalFlashWriteFeature<TVoltageRange>::pageErase(uint32_t flashAddress) const {

    uint32_t err;
    uint8_t pageNumber;

    // FLASH_EraseSector takes a coded sector number

    pageNumber=_flashPeripheral.getPageFromAddress(flashAddress);
    if(pageNumber<12)
      pageNumber*=8;                        // the low range (1Mb devices)
    else
      pageNumber=0x80+((pageNumber-12)*8);  // the high rage (2Mb devices)

    if((err=FLASH_EraseSector(pageNumber,static_cast<uint8_t>(TVoltageRange)))==FLASH_COMPLETE)
      return true;

    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_INTERNAL_FLASH,E_ERASE_FAILED,err);
  }


  /**
   * Program a 32-bit word
   * @param flashAddress The address to program. Must be a 4-byte boundary.
   * @param data The 32-bit word to program
   * @return true if it worked and the operation has completed.
   */

  template<InternalFlashVoltageRange TVoltageRange>
  inline bool InternalFlashWriteFeature<TVoltageRange>::wordProgram(uint32_t flashAddress,uint32_t data) const {

    uint32_t err;

    if((err=FLASH_ProgramWord(flashAddress,data))==FLASH_COMPLETE)
      return true;

    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_INTERNAL_FLASH,E_PROGRAM_FAILED,err);
  }


  /**
   * Program a 16-bit half word
   * @param flashAddress The address to program. Must be a 2-byte boundary.
   * @param data The 16-bit half-word to program
   * @return true if it worked and the operation has completed.
   */

  template<InternalFlashVoltageRange TVoltageRange>
  inline bool InternalFlashWriteFeature<TVoltageRange>::halfWordProgram(uint32_t flashAddress,uint16_t data) const {

    uint32_t err;

    if((err=FLASH_ProgramHalfWord(flashAddress,data))==FLASH_COMPLETE)
      return true;

    return errorProvider.set(ErrorProvider::ERROR_PROVIDER_INTERNAL_FLASH,E_PROGRAM_FAILED,err);
  }
}
// END FILE: ../lib/include/flash/internal/f4/features/InternalFlashWriteFeature.h
// START FILE: ../lib/include/flash/internal/f4/InternalFlashDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Internal flash device features class. This is the class that user
   * code should instantiate
   */

  template<class TSectorMap,class... Features>
  struct InternalFlashDevice : InternalFlashPeripheral,Features... {

    /**
     * Constructor
     */

    InternalFlashDevice()
      : InternalFlashPeripheral(TSectorMap::SizeMap),Features(static_cast<InternalFlashPeripheral&>(*this))... {
    }
  };
}
// END FILE: ../lib/include/flash/internal/f4/InternalFlashDevice.h
// START FILE: ../lib/include/flash/internal/InternalFlashSettingsStorage.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * High-level class to manage the storage of program settings (configuration) in flash memory. Configuration data
   * is stored in the upper-most flash pages in your device. At least two pages are required for a system to be
   * resiliant in the face of unexpected power loss. Wear levelling is achieved by using up as much of the page as
   * possible before rolling over to the next page and eventually back to the first, and so on. There is an overhead
   * of 8 bytes on top of your settings class size (the template TSettings parameter) and the size is rounded up to
   * the nearest power of 2.
   *
   * For example, your settings class is 12 bytes long. The 8-byte overhead makes that 20 bytes. That is rounded up
   * to a storage size of 32 bytes. Your device has 1K pages and you have allocated 2 pages to the settings. To fill
   * up both pages requires 2048/32 = 64 writes before wrapping back to the first page. ST guarantee a minimum of 10K
   * erase/program cycles per page. Therefore you are safe to write settings 10000*64 = 640000 times before the flash
   * is in danger of wearing out.
   *
   * The size of your settings class must be a multiple of 4 bytes. This is automatically done for you by the compiler
   * unless you apply an attribute that prevents it. There is a static_assert in this class's constructor to catch
   * the case where a settings class is not a multiple of 4 bytes.
   *
   * The memory layout is:
   *   0     : 0xBE
   *   1-3   : version number
   *   4-n   : your settings structure
   *   a+1-b : random byte padding up to nearest power of 2 less one 32-bit word
   *   b-b+3 : CRC of all preceding data
   *
   * Your settings class must be a POD type (simple types only). We store it prefixed by a version number and
   * postfixed by its 32-bit CRC. The 24-bit version number is incremented each time the settings are written giving
   * you a maximum number of 16m versions.
   */

  template<class TSettings,class TFlash>
  class InternalFlashSettingsStorage {

    public:

      /**
       * Parameters class: must be set up by the user
       */

      struct Parameters {

        uint32_t firstLocation;   ///< The first location to use in flash. Must be on a page boundary.
        uint32_t memorySize;      ///< The amount of memory to use. Must be a multiple of the page sizes you want to use.

        /**
         * Constructor
         * @param location The first location in flash (must be a multiple of the page size)
         * @param size The total amount of flash memory that you want to use
         */

        Parameters(uint32_t location,uint32_t size)
          : firstLocation(location),
            memorySize(size) {
        }


        /**
         * Default constructor. Parameters must be set later.
         */

        Parameters() {
        }
      };


      /**
       * Error codes
       */

      enum {
        E_NOT_FOUND = 1     ///< No settings found in flash
      };

    protected:
      const TFlash& _flashPeripheral;
      const Parameters& _parameters;

      uint32_t _lastLocation;
      uint32_t _lastVersion;

    protected:
      bool findSettings();
      uint32_t getSettingsSize() const;

    public:
      InternalFlashSettingsStorage(const TFlash& flashPeripheral,const Parameters& params);

      bool read(TSettings& settings);
      bool write(const TSettings& settings);

      bool erase() const;
      void reset();
  };


  /**
   * Constructor
   */

  template<class TSettings,class TFlash>
  inline InternalFlashSettingsStorage<TSettings,TFlash>::InternalFlashSettingsStorage(const TFlash& flashPeripheral,const Parameters& params)
    : _flashPeripheral(flashPeripheral),
      _parameters(params) {

    static_assert(sizeof(TSettings) % 4==0,"Settings class must be multiple of 4 bytes. Please pad it out with some dummy fields to make it so");

    ClockControl<PERIPHERAL_CRC>::On();
    reset();
  }


  /**
   * Reset internal state
   */

  template<class TSettings,class TFlash>
  inline void InternalFlashSettingsStorage<TSettings,TFlash>::reset() {
    _lastLocation=0xFFFFFFFF;
    _lastVersion=0xFFFFFFFF;
  }


  /**
   * Read settings
   * @param settings The settings class
   * @return true if it worked
   */

  template<class TSettings,class TFlash>
  inline bool InternalFlashSettingsStorage<TSettings,TFlash>::read(TSettings& settings) {

    uint32_t i,*src,*dest;

    // if this is the first time then the settings need to be found

    if(_lastLocation==0xFFFFFFFF && !findSettings())
      return errorProvider.set(ErrorProvider::ERROR_PROVIDER_INTERNAL_FLASH_SETTINGS,E_NOT_FOUND);

    // copy out the settings. these need to come out as words to maintain the endian-ness of
    // the data that programmed word-by-word. In short, don't memcpy them out because it
    // won't work

    src=reinterpret_cast<uint32_t *>(_lastLocation)+1;
    dest=reinterpret_cast<uint32_t *>(&settings);

    for(i=0;i<sizeof(TSettings)/4;i++)
      *dest++=*src++;

    return true;
  }


  /**
   * Write settings
   * @param settings The settings class to write
   * @return true if it worked
   */

  template<class TSettings,class TFlash>
  inline bool InternalFlashSettingsStorage<TSettings,TFlash>::write(const TSettings& settings) {

    uint32_t newVersion,newLocation,settingsWords,i,r,randomWords;
    const uint32_t *srcPtr;

    // if this is the first time then the settings need to be found

    settingsWords=getSettingsSize()/4;

    if(_lastLocation==0xFFFFFFFF && !findSettings()) {

      // if this is the first time then try to find the last version

      _lastLocation=newLocation=_parameters.firstLocation;
      _lastVersion=0;     // invalid version, will be incremented in next instruction
    }
    else
      newLocation=_lastLocation+settingsWords*4;

    // get the new location and new version

    newVersion=_lastVersion+1;

    // if reached the end of all pages then wrap back to the start

    if(newLocation>=_parameters.firstLocation+_parameters.memorySize)
      newLocation=_parameters.firstLocation;

    // declare a lock manager to keep the flash write-enabled while we work on it

    InternalFlashLockFeature::LockManager lm;

    // is this new location the beginning of a page?

    if(_flashPeripheral.isStartOfPage(newLocation)) {

      // erase the page that we are about to occupy

      if(!_flashPeripheral.pageErase(newLocation))
        return false;
    }

    InternalFlashWordWriter<TFlash> writer(_flashPeripheral,newLocation);
    CRC_ResetDR();

    // write the version number

    *writer++=newVersion | 0xBE000000;
    CRC_CalcCRC(newVersion | 0xBE000000);

    srcPtr=reinterpret_cast<const uint32_t *>(&settings);

    // write the settings

    for(i=0;i<sizeof(TSettings)/4;i++) {

      // program the word

      *writer++=*srcPtr;

      // update CRC, src and dest

      CRC_CalcCRC(*srcPtr);
      srcPtr++;
    }

    // write random words from the end of the settings to where the CRC will be

    randomWords=settingsWords-(sizeof(TSettings)/4)-2;

    for(i=0;i<randomWords;i++) {

      // get a new random word

      r=rand();

      // program it

      *writer++=r;

      // update CRC and position

      CRC_CalcCRC(r);
    }

    // write the CRC into the last location - only after this is this settings block valid

    *writer=CRC_GetCRC();

    if(writer.hasError())
      return false;

    // update internal state

    _lastLocation=newLocation;
    _lastVersion=newVersion;

    return true;
  }


  /**
   * Search for the settings in flash
   * @return true if found, false if not
   */

  template<class TSettings,class TFlash>
  inline bool InternalFlashSettingsStorage<TSettings,TFlash>::findSettings() {

    uint32_t crc,maxVersion,thisVersion,settingsSize,i,entryCount;
    uint32_t *location,*maxLocation;

    maxVersion=0;
    maxLocation=nullptr;
    location=reinterpret_cast<uint32_t *>(_parameters.firstLocation);
    settingsSize=getSettingsSize();
    entryCount=_parameters.memorySize/settingsSize;
    settingsSize/=4;

    // all possible locations must be checked

    for(i=0;i<entryCount;i++) {

      // the top 8 bits have a magic number: BE

      thisVersion=*location;
      if((thisVersion & 0xFF000000)==0xBE000000) {

        if((thisVersion & 0x00FFFFFF)>maxVersion) {

          // possible match, run the CRC check

          CRC_ResetDR();
          crc=CRC_CalcBlockCRC(location,settingsSize-1);    // don't include the CRC itself

          if(crc==location[settingsSize-1]) {

            // CRC matches, we have a new high version

            maxVersion=thisVersion & 0x00FFFFFF;
            maxLocation=location;
          }
        }
      }

      location+=settingsSize;
    }

    if(maxVersion>0) {

      // found it

      _lastVersion=maxVersion;
      _lastLocation=reinterpret_cast<uint32_t>(maxLocation);

      return true;
    }

    // not found

    return false;
  }


  /**
   * Erase all pages defined as belonging to these settings
   * @return true if it worked
   */

  template<class TSettings,class TFlash>
  inline bool InternalFlashSettingsStorage<TSettings,TFlash>::erase() const {

    uint32_t address;

    // the flash device needs to be unlocked

    InternalFlashLockFeature::LockManager lm;

    for(address=_parameters.firstLocation;address<_parameters.firstLocation+_parameters.memorySize;address+=_flashPeripheral.getPageSize(address)) {

      // erase this page

      if(!_flashPeripheral.pageErase(address))
        return false;
    }

    return true;
  }


  /**
   * Bit twiddling hack to get the nearest power of 2 above the settings size
   * @return The settings size
   */

  template<class TSettings,class TFlash>
  inline uint32_t InternalFlashSettingsStorage<TSettings,TFlash>::getSettingsSize() const {

    uint32_t size;

    size=sizeof(TSettings)+8;

    size--;
    size |= size >> 1;
    size |= size >> 2;
    size |= size >> 4;
    size |= size >> 8;
    size |= size >> 16;
    size++;

    return size;
  }
}
// END FILE: ../lib/include/flash/internal/InternalFlashSettingsStorage.h
// START FILE: ../lib/include/flash/internal/InternalFlashWordWriter.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /*
   * Helper "smart pointer" class to permit writing words to the flash using
   * pointer-like semantics. Lock/unlock commands are not done here.
   */

  template<class TFlash>
  class InternalFlashWordWriter {

    protected:
      const TFlash& _flash;
      uint32_t _address;
      bool _errorFlag;

    public:
      InternalFlashWordWriter(const TFlash& flash,const uint32_t address);
      InternalFlashWordWriter(const InternalFlashWordWriter<TFlash>& src);

      bool hasError() const;

      InternalFlashWordWriter<TFlash>& operator*();
      InternalFlashWordWriter<TFlash> operator[](uint32_t idx);
      const InternalFlashWordWriter<TFlash> operator[](uint32_t idx) const;

      InternalFlashWordWriter<TFlash>& operator++();
      InternalFlashWordWriter<TFlash>& operator--();
      InternalFlashWordWriter<TFlash> operator++(int);
      InternalFlashWordWriter<TFlash> operator--(int);
      InternalFlashWordWriter<TFlash>& operator+=(const uint32_t words);
      InternalFlashWordWriter<TFlash>& operator-=(const uint32_t words);
      InternalFlashWordWriter<TFlash>& operator=(const InternalFlashWordWriter<TFlash>& src);
      InternalFlashWordWriter<TFlash>& operator=(uint32_t value);
  };


  /**
   * Constructor
   * @param flash The flash peripheral
   * @param address The flash address
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash>::InternalFlashWordWriter(const TFlash& flash,const uint32_t address)
    : _flash(flash),
      _address(address),
      _errorFlag(false) {
  }


  /**
   * Copy constructor
   * @param src The class to copy from
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash>::InternalFlashWordWriter(const InternalFlashWordWriter<TFlash>& src)
    : _flash(src._flash),
      _address(src._address),
      _errorFlag(src._errorFlag) {
  }


  /**
   * Return reference to self
   * @return *this
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash>& InternalFlashWordWriter<TFlash>::operator*() {
    return *this;
  }


  /*
   * Return a temporary, offset by the index
   * @param idx array index
   * @return a temporary, offset by the index
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash> InternalFlashWordWriter<TFlash>::operator[](uint32_t idx) {

    InternalFlashWordWriter<TFlash> t(*this);

    t+=idx;
    return t;
  }


  /**
   * Const version of the above
   * @param idx array index
   * @return a temporary, offset by the index
   */

  template<class TFlash>
  inline const InternalFlashWordWriter<TFlash> InternalFlashWordWriter<TFlash>::operator[](uint32_t idx) const {

    InternalFlashWordWriter<TFlash> t(*this);

    t+=idx;
    return t;
  }


  /**
   * pre-increment operator
   * @return ourselves offset by a word
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash>& InternalFlashWordWriter<TFlash>::operator++() {
    _address+=4;
    return *this;
  }


  /**
   * Post increment operator
   * @param dummy
   * @return Ourselves, before the update
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash> InternalFlashWordWriter<TFlash>::operator++(int) {
    InternalFlashWordWriter<TFlash> t(*this);
    _address+=4;
    return t;
  }


  /**
   * Pre-decrement operator
   * @return ourselves, decremented by a word
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash>& InternalFlashWordWriter<TFlash>::operator--() {
    _address-=4;
    return *this;
  }


  /**
   * Post-decrement operator
   * @param dummy
   * @return Ourselves, before the update
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash> InternalFlashWordWriter<TFlash>::operator--(int) {
    InternalFlashWordWriter<TFlash> t(*this);
    _address-=4;
    return t;
  }


  /**
   * Increment and assign operator
   * @param words number of words to increment by
   * @return *this
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash>& InternalFlashWordWriter<TFlash>::operator+=(const uint32_t words) {
    _address+=words*4;
    return *this;
  }


  /**
   * Decrement and assign operator
   * @param words number of words to decrement by
   * @return *this
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash>& InternalFlashWordWriter<TFlash>::operator-=(const uint32_t words) {
    _address-=words*4;
    return *this;
  }


  /**
   * Assign another instance of this pointer to ourselves.
   * @param src The pointer to copy from
   * @return *this;
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash>& InternalFlashWordWriter<TFlash>::operator=(const InternalFlashWordWriter<TFlash>& src) {
    _address=src._address;
    return *this;
  }


  /**
   * Write a word to the address pointed to by this pointer. Success/fail is stored in a member variable
   * @param value The word to write
   * @return *this
   */

  template<class TFlash>
  inline InternalFlashWordWriter<TFlash>& InternalFlashWordWriter<TFlash>::operator=(uint32_t value) {
    _errorFlag=!_flash.wordProgram(_address,value);
    return *this;
  }


  /**
   * Get the value of the error flag
   * @return true if there has been an error
   */

  template<class TFlash>
  inline bool InternalFlashWordWriter<TFlash>::hasError() const {
    return _errorFlag;
  }
}
// END FILE: ../lib/include/flash/internal/InternalFlashWordWriter.h
// START FILE: ../lib/include/flash/internal/features/InternalFlashFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for all feature classes
   */

  class InternalFlashFeatureBase {

    protected:
      InternalFlashPeripheral& _flashPeripheral;

    public:
      InternalFlashFeatureBase(InternalFlashPeripheral& peripheral);
  };


  /**
   * Constructor
   * @param peripheral reference to the internal flash peripheral
   */

  inline InternalFlashFeatureBase::InternalFlashFeatureBase(InternalFlashPeripheral& peripheral)
    : _flashPeripheral(peripheral) {
  }
}
// END FILE: ../lib/include/flash/internal/features/InternalFlashFeatureBase.h
// START FILE: ../lib/include/flash/internal/features/InternalFlashLockFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /*
   * Feature class to provide lock/unlock capability
   */

  class InternalFlashLockFeature : public InternalFlashFeatureBase {

    public:

      /**
       * LockManager class can be declared on the stack to guard an area of code
       * where the flash is to be written and to ensure that it gets locked regardless
       * of the exit point of the guarded code.
       */

      struct LockManager {

        LockManager() {
          FLASH_Unlock();
        }

        ~LockManager() {
          FLASH_Lock();
        }
      };

    public:
      InternalFlashLockFeature(InternalFlashPeripheral& flashPeripheral);

    public:
      void lock() const;
      void unlock() const;
  };


  /**
   * Constructor
   * @param flashPeripheral reference to the peripheral class
   */

  inline InternalFlashLockFeature::InternalFlashLockFeature(InternalFlashPeripheral& flashPeripheral)
    : InternalFlashFeatureBase(flashPeripheral) {
  }


  /**
   * Lock the flash memory
   */

  inline void InternalFlashLockFeature::lock() const {
    FLASH_Lock();
  }


  /**
   * Unlock the flash memory
   */

  inline void InternalFlashLockFeature::unlock() const {
    FLASH_Unlock();
  }
}
// END FILE: ../lib/include/flash/internal/features/InternalFlashLockFeature.h
// START FILE: ../lib/include/flash/spi/devices/w25q16dw/EraseSuspend.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {
    namespace w25q16dw {


      /**
       * Erase suspend command implementation
       */

      template<class TSpi>
      struct EraseSuspend : Command<TSpi> {

        /**
         * Provide a eraseSuspend() function for the derived class
         */

        bool eraseSuspend() const {
          return this->writeCommand(CMD_ERASE_SUSPEND);
        }
      };
    }
  }
}
// END FILE: ../lib/include/flash/spi/devices/w25q16dw/EraseSuspend.h
// START FILE: ../lib/include/flash/spi/devices/w25q16dw/EraseResume.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {
    namespace w25q16dw {


      /**
       * Erase suspend command implementation
       */

      template<class TSpi>
      struct EraseResume : Command<TSpi> {

        /**
         * Provide a eraseSuspend() function for the derived class
         */

        bool eraseResume() const {
          return this->writeCommand(CMD_ERASE_RESUME);
        }
      };
    }
  }
}
// END FILE: ../lib/include/flash/spi/devices/w25q16dw/EraseResume.h
// START FILE: ../lib/include/flash/spi/devices/w25q16dw/Commands.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {
    namespace w25q16dw {


      /**
       * Commands specific to the Winbond w25q16dw
       */

      enum {
        CMD_ERASE_SUSPEND = 0x75,//!< CMD_ERASE_SUSPEND
        CMD_ERASE_RESUME = 0x7a  //!< CMD_ERASE_RESUME
      };
    }
  }
}
// END FILE: ../lib/include/flash/spi/devices/w25q16dw/Commands.h
// START FILE: ../lib/include/flash/spi/devices/w25q16dw/W25Q16DW.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Winbond W25Q16DW 1.8V 16Mbit Serial Flash Memory with Dual/Quad SPI & QPI
     *
     */

    template<class TSpi>
    struct W25Q16DW : SpiFlashDevice<W25Q16DW<TSpi>>,

                      WriteStatusRegister <TSpi>,   // standard commands
                      WriteDisable        <TSpi>,
                      ReadStatusRegister  <TSpi>,
                      WriteEnable         <TSpi>,
                      PageProgram         <TSpi>,
                      Read                <TSpi>,
                      FastRead            <TSpi>,
                      SectorErase         <TSpi>,
                      BlockErase          <TSpi>,
                      ChipErase           <TSpi>,
                      DeepPowerDown       <TSpi>,
                      ReleaseDeepPowerDown<TSpi>,
                      w25q16dw::EraseResume<TSpi>,        // custom commands
                      w25q16dw::EraseSuspend<TSpi> {

      /**
       * Various constants required by the base class
       */

      enum {
        STATUS_BUSY_BIT_MASK = 0x1,   // bitmask to get the BUSY bit from SR
        PAGE_SIZE = 256               // 256 byte pages
      };


      /**
       * Constructor
       * @param spi Reference to the SPI object
       */

      W25Q16DW(TSpi& spi) {
        this->_spi=&spi;
      }


      /**
       * Get the size of the device in bytes (2 megabytes)
       * @return 2097152
       */

      constexpr uint32_t getSize() const {
        return 1024*1024*2;
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/devices/w25q16dw/W25Q16DW.h
// START FILE: ../lib/include/flash/spi/devices/s25fl208k/Commands.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {
    namespace s25fl208k {


      /**
       * Commands for the S25FL208K that are either different to, or extend
       * the standard set.
       */

      enum {
        CMD_BLOCK_ERASE = 0xd8        // different to the usual command id
      };
    }
  }
}
// END FILE: ../lib/include/flash/spi/devices/s25fl208k/Commands.h
// START FILE: ../lib/include/flash/spi/devices/s25fl208k/S25FL208K.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Spansion S25FL208K 8Mbit Serial Flash Memory with Dual SPI
     *
     */

    template<class TSpi>
    struct S25FL208K : SpiFlashDevice<S25FL208K<TSpi>>,

                      WriteStatusRegister <TSpi>,   // standard commands
                      WriteDisable        <TSpi>,
                      ReadStatusRegister  <TSpi>,
                      WriteEnable         <TSpi>,
                      PageProgram         <TSpi>,
                      Read                <TSpi>,
                      FastRead            <TSpi>,
                      SectorErase         <TSpi>,
                      BlockErase          <TSpi,s25fl208k::CMD_BLOCK_ERASE>,
                      ChipErase           <TSpi>,
                      DeepPowerDown       <TSpi>,
                      ReleaseDeepPowerDown<TSpi>,
                      ReadJedecId         <TSpi> {

      /**
       * Various constants required by the base class
       */

      enum {
        STATUS_BUSY_BIT_MASK = 0x1,   // bitmask to get the BUSY bit from SR
        PAGE_SIZE = 256               // 256 byte pages
      };


      /**
       * Constructor
       * @param spi Reference to the SPI object
       */

      S25FL208K(TSpi& spi) {
        this->_spi=&spi;
      }


      /**
       * Get the size of the device in bytes (1 megabyte)
       * @return 1048576
       */

      constexpr uint32_t getSize() const {
        return 1024*1024*1;
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/devices/s25fl208k/S25FL208K.h
// START FILE: ../lib/include/flash/spi/devices/StandardSpiFlashDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * A standard SPI flash device implements only the commands that are known to
     * be common across (nearly) all SPI flash devices.
     */

    template<class TSpi>
    struct StandardSpiFlashDevice : SpiFlashDevice<StandardSpiFlashDevice<TSpi>>,

                                    WriteStatusRegister <TSpi>,   // standard commands
                                    WriteDisable        <TSpi>,
                                    ReadStatusRegister  <TSpi>,
                                    WriteEnable         <TSpi>,
                                    PageProgram         <TSpi>,
                                    Read                <TSpi>,
                                    FastRead            <TSpi>,
                                    SectorErase         <TSpi>,
                                    BlockErase          <TSpi>,
                                    ChipErase           <TSpi>,
                                    DeepPowerDown       <TSpi>,
                                    ReleaseDeepPowerDown<TSpi>,
                                    ReadJedecId         <TSpi> {

      /**
       * Various constants required by the base class
       */

      enum {
        STATUS_BUSY_BIT_MASK = 0x1,   // bitmask to get the BUSY bit from SR
        PAGE_SIZE = 256               // 256 byte pages
      };


      /**
       * Constructor
       */

      StandardSpiFlashDevice(TSpi& spi) {
        this->_spi=&spi;
      }


      /**
       * This is a generic implementation, the size of the device is unknown
       * @return 0
       */

      constexpr uint32_t getSize() const {
        return 0;
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/devices/StandardSpiFlashDevice.h
// START FILE: ../lib/include/flash/spi/Command.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Base template for SPI commands. Provides the actual functionality to execute
     * the command
     */

    template<class TSpi>
    class Command : public virtual Base<TSpi> {

      protected:
        bool writeCommand(uint8_t command) const;
        bool writeCommand(uint8_t command,uint32_t address,uint8_t addressBytes,uint8_t dummyBytes,const void *data,uint32_t dataSize) const;
        bool readCommand(uint8_t command,uint32_t address,uint8_t addressBytes,uint8_t dummyBytes,void *data,uint32_t dataSize) const;

        bool doWriteCommand(uint8_t command,uint32_t address,uint8_t addressBytes,uint8_t dummyBytes,const void *data,uint32_t dataSize) const;
        bool doWriteCommandStart(uint8_t command,uint32_t address,uint8_t addressBytes,uint8_t dummyBytes) const;
        bool doReadCommand(uint8_t command,uint32_t address,uint8_t addressBytes,uint8_t dummyBytes,void *data,uint32_t dataSize) const;
    };


    /**
     * Write a command. No address or data
     * @param command The command byte to write
     * @return true if it worked
     */

    template<class TSpi>
    inline bool Command<TSpi>::writeCommand(uint8_t command) const {

      bool retval;

      // CS=low, write data, CS=high

      this->_spi->setNss(false);
      retval=this->_spi->send(&command,1);
      this->_spi->setNss(true);

      return retval;
    }


    /**
     * Write a command, with all options
     * @param command The command byte to write
     * @param address The address to write at
     * @param addressBytes The number of bytes that make up the address
     * @param dummyBytes The number of dummy (zero) bytes to write before the data
     * @param data Pointer to the data to send
     * @param dataSize The number of bytes to send
     * @return true if it worked
     */

    template<class TSpi>
    inline bool Command<TSpi>::writeCommand(uint8_t command,
                                            uint32_t address,
                                            uint8_t addressBytes,
                                            uint8_t dummyBytes,
                                            const void *data,
                                            uint32_t dataSize) const {

      bool retval;

      this->_spi->setNss(false);
      retval=doWriteCommand(command,address,addressBytes,dummyBytes,data,dataSize);
      this->_spi->setNss(true);

      return retval;
    }


    /*
     * Actually do a write while CS is low
     */

    template<class TSpi>
    inline bool Command<TSpi>::doWriteCommand(uint8_t command,
                                              uint32_t address,
                                              uint8_t addressBytes,
                                              uint8_t dummyBytes,
                                              const void *data,
                                              uint32_t dataSize) const {

      // write out the common starting sequence

      if(!doWriteCommandStart(command,address,addressBytes,dummyBytes))
        return false;

      // write out the data block

      if(dataSize)
        return this->_spi->send(reinterpret_cast<const uint8_t *>(data),dataSize);

      return true;
    }


    /*
     * Write out the common command,address,dummy starting sequence
     */

    template<class TSpi>
    inline bool Command<TSpi>::doWriteCommandStart(uint8_t command,
                                                   uint32_t address,
                                                   uint8_t addressBytes,
                                                   uint8_t dummyBytes) const {

      int i;
      uint8_t c;

      // write the command

      if(!this->_spi->send(&command,1))
        return false;

      // write the address bytes, MSB first

      if(addressBytes) {
        for(i=addressBytes-1;i>=0;i--) {
          c=address >> (8*i);
          if(!this->_spi->send(&c,1))
            return false;
        }
      }

      // if any dummy bytes, write them

      if(dummyBytes) {

        c=0;
        while(dummyBytes--) {
          if(!this->_spi->send(&c,1))
            return false;
        }
      }

      // done

      return true;
    }


    /**
     * Send a command to read data, with all options
     * @param command The command byte to write
     * @param address The address to read from
     * @param addressBytes The number of bytes that make up the address
     * @param dummyBytes The number of dummy (zero) bytes to write before the data
     * @param data Pointer to the data to receive
     * @param dataSize The number of bytes to receive
     * @return true if it worked
     */

    template<class TSpi>
    inline bool Command<TSpi>::readCommand(uint8_t command,
                                           uint32_t address,
                                           uint8_t addressBytes,
                                           uint8_t dummyBytes,
                                           void *data,
                                           uint32_t dataSize) const {

      bool retval;

      this->_spi->setNss(false);
      retval=doReadCommand(command,address,addressBytes,dummyBytes,data,dataSize);
      this->_spi->setNss(true);

      return retval;
    }


    /*
     * Actually do a read while CS is low
     */

    template<class TSpi>
    inline bool Command<TSpi>::doReadCommand(uint8_t command,
                                             uint32_t address,
                                             uint8_t addressBytes,
                                             uint8_t dummyBytes,
                                             void *data,
                                             uint32_t dataSize) const {

      // write out the common starting sequence

      if(!doWriteCommandStart(command,address,addressBytes,dummyBytes))
        return false;

      // read using the dummy write method

      return this->_spi->receive(reinterpret_cast<uint8_t *>(data),dataSize);
    }
  }
}
// END FILE: ../lib/include/flash/spi/Command.h
// START FILE: ../lib/include/flash/spi/SpiFlashInputStream.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * @brief Implementation of an input stream for SPI flash devices. The SPI flash device is modelled as
     * a very large sequence of bytes on to which you can map an input stream of a defined length. This
     * class accepts an initial offset and a size parameter which together define the segment of the flash
     * device that you want to read from.
     * @tparam TSpiFlash An object that implements fastRead()
     */

    template<class TSpiFlash>
    class SpiFlashInputStream : public InputStream {

      public:

        /**
         * Error codes
         */

        enum {
          E_INVALID_SKIP_POSITION = 1       //!< attempt to skip() past the end
        };

      protected:
        const TSpiFlash& _spiFlash;
        uint32_t _initialOffset;
        uint32_t _offset;
        uint32_t _size;

      public:
        SpiFlashInputStream(const TSpiFlash& spiFlash,uint32_t initialOffset,uint32_t size);
        virtual ~SpiFlashInputStream() {}

        uint32_t remaining() const;

        // overrides from InputStream

        virtual int16_t read() override;
        virtual bool read(void *buffer,uint32_t size,uint32_t& actuallyRead) override;
        virtual bool skip(uint32_t howMuch) override;
        virtual bool available() override;
        virtual bool close() override;
        virtual bool reset() override;
    };


    /**
     * Constructor
     */

    template<class TSpiFlash>
    inline SpiFlashInputStream<TSpiFlash>::SpiFlashInputStream(const TSpiFlash& spiFlash,uint32_t initialOffset,uint32_t size)
      : _spiFlash(spiFlash),
        _initialOffset(initialOffset),
        _offset(initialOffset),
        _size(size) {
    }


    /**
     * Doesn't do anything.
     * @return always true
     */

    template<class TSpiFlash>
    inline bool SpiFlashInputStream<TSpiFlash>::close() {
      return true;
    }


    /**
     * Reset the stream pointer to the beginning
     * @return true
     */

    template<class TSpiFlash>
    inline bool SpiFlashInputStream<TSpiFlash>::reset() {
      _offset=_initialOffset;
      return true;
    }


    /**
     * Read a single byte
     * @return The byte in the lower 8 bits or E_END_OF_STREAM / E_STREAM ERROR (negative numbers)
     */

    template<class TSpiFlash>
    inline int16_t SpiFlashInputStream<TSpiFlash>::read() {

      uint8_t c;
      uint32_t actuallyRead;

      // must have at least a byte available

      if(!available())
        return E_END_OF_STREAM;

      // try to read a byte

      if(!read(&c,1,actuallyRead))
        return E_STREAM_ERROR;

      // return the byte in the lower bits

      return c;
    }


    /**
     * Read a chunk of bytes up to the amount requested.
     * @param buffer Where to read out the bytes to
     * @param size The maximum number of bytes to read
     * @param actuallyRead The actual number of bytes read, which may be less than requested if the end of stream is hit.
     * @return false if there was an error. end of stream is not an error.
     */

    template<class TSpiFlash>
    inline bool SpiFlashInputStream<TSpiFlash>::read(void *buffer,uint32_t size,uint32_t& actuallyRead) {

      // trim the requested size if not enough remains

      actuallyRead=remaining() < size ? remaining() : size;

      // return now if we're at the EOF

      if(actuallyRead==0)
        return true;

      // attempt to read the bytes

      if(!_spiFlash.fastRead(_offset,buffer,actuallyRead))
        return false;

      // update the read pointer

      _offset+=actuallyRead;
      return true;
    }


    /**
     * Skip a number of bytes forward
     * @param howMuch Amount to skip - can go to EOF but not beyond
     * @return true if OK
     */

    template<class TSpiFlash>
    inline bool SpiFlashInputStream<TSpiFlash>::skip(uint32_t howMuch) {

      if(howMuch>remaining())
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_SPI_FLASH_INPUT_STREAM,E_INVALID_SKIP_POSITION);

      _offset+=howMuch;
      return true;
    }


    /**
     * Return true if at least one byte can be read
     * @return true if reading is possible
     */

    template<class TSpiFlash>
    inline bool SpiFlashInputStream<TSpiFlash>::available() {
      return remaining()>0;
    }


    /**
     * Return the amount of bytes remaining to read
     * @return The number of bytes remaining
     */

    template<class TSpiFlash>
    inline uint32_t SpiFlashInputStream<TSpiFlash>::remaining() const {
      return _size-(_offset-_initialOffset);
    }
  }
}
// END FILE: ../lib/include/flash/spi/SpiFlashInputStream.h
// START FILE: ../lib/include/flash/spi/SpiFlashDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * This template contains generic operations
     */

    template<class TImpl>
    class SpiFlashDevice {

      public:

        /**
         * Error codes
         */

        enum {
          E_TIMED_OUT = 1     //!< Timed out while performing an operation
        };

      public:
        bool waitForIdle(uint32_t timeoutMillis=0) const;
    };


    /**
     * Wait for the status register to clear the BUSY bit
     * @param timeoutMillis Maximum time to wait, or zero to wait forever
     * @return true if it worked
     */

    template<class TImpl>
    inline bool SpiFlashDevice<TImpl>::waitForIdle(uint32_t timeoutMillis) const {

      uint8_t sr;
      uint32_t start;

      if(timeoutMillis)
        start=MillisecondTimer::millis();

      for(;;) {

        if(!static_cast<const TImpl *>(this)->readStatusRegister(sr))
          return false;

        if((sr & TImpl::STATUS_BUSY_BIT_MASK)==0)
          return true;

        if(timeoutMillis && MillisecondTimer::hasTimedOut(start,timeoutMillis))
          return errorProvider.set(ErrorProvider::ERROR_PROVIDER_SPI_FLASH,E_TIMED_OUT);
      }
    }
  }
}

// END FILE: ../lib/include/flash/spi/SpiFlashDevice.h
// START FILE: ../lib/include/flash/spi/commands/SectorErase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Sector erase command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_SECTOR_ERASE,uint8_t TAddressBytes=3>
    struct SectorErase : Command<TSpi> {

      /**
       * Provide a sectorErase() function for the derived class
       */

      bool sectorErase(uint32_t address) const {
        return this->writeCommand(TOpCode,address,TAddressBytes,0,nullptr,0);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/SectorErase.h
// START FILE: ../lib/include/flash/spi/commands/WriteDisable.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Write disable command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_WRITE_DISABLE>
    struct WriteDisable : Command<TSpi> {

      /**
       * Provide a writeDisable() function for the derived class
       */

      bool writeDisable() const {
        return this->writeCommand(TOpCode);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/WriteDisable.h
// START FILE: ../lib/include/flash/spi/commands/WriteEnable.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Write enable command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_WRITE_ENABLE>
    struct WriteEnable : Command<TSpi> {

      /**
       * Provide a writeEnable() function for the derived class
       */

      bool writeEnable() const {
        return this->writeCommand(TOpCode);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/WriteEnable.h
// START FILE: ../lib/include/flash/spi/commands/ChipErase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Bulk chip erase command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_CHIP_ERASE>
    struct ChipErase : Command<TSpi> {

      /**
       * Provide a chipErase() function for the derived class
       */

      bool chipErase() const {
        return this->writeCommand(TOpCode);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/ChipErase.h
// START FILE: ../lib/include/flash/spi/commands/PageProgram.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Page program command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_PAGE_PROGRAM,uint8_t TAddressBytes=3>
    struct PageProgram : Command<TSpi> {

      /**
       * Provide a pageProgram() function for the derived class
       */

      bool pageProgram(uint32_t address,const void *data,uint32_t dataSize) const {
        return this->writeCommand(TOpCode,address,TAddressBytes,0,data,dataSize);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/PageProgram.h
// START FILE: ../lib/include/flash/spi/commands/Commands.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * "Standard" command list
     */

    enum {
      CMD_WRITE_REGISTERS         = 0x01,         ///< write status or write status & configuration
      CMD_PAGE_PROGRAM            = 0x02,         ///< program a page
      CMD_READ                    = 0x03,         ///< read, 1-bit mode
      CMD_WRITE_DISABLE           = 0x04,         ///< disable writing
      CMD_READ_STATUS_REGISTER    = 0x05,         ///< read the status register
      CMD_WRITE_ENABLE            = 0x06,         ///< enable writing
      CMD_FAST_READ               = 0x0b,         ///< fast frequency read out of data
      CMD_SECTOR_ERASE            = 0x20,         ///< erase a sector
      CMD_BLOCK_ERASE             = 0x52,         ///< erase a block of sectors
      CMD_CHIP_ERASE              = 0xc7,         ///< erase the whole thing
      CMD_READ_JEDEC_ID           = 0x9f,         ///< read the manufacturer and device information
      CMD_DEEP_POWER_DOWN         = 0xb9,         ///< power down mode
      CMD_RELEASE_DEEP_POWER_DOWN = 0xab          ///< release from deep power down
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/Commands.h
// START FILE: ../lib/include/flash/spi/commands/WriteStatusRegister.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Write status and write status/configuration implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_WRITE_REGISTERS>
    struct WriteStatusRegister : Command<TSpi> {

      /**
       * Provide writeStatusRegister()
       */

      bool writeStatusRegister(uint8_t status) const {
        return this->writeCommand(TOpCode,0,0,0,&status,1);
      }


      /**
       * Provide writeStatusAndConfigurationRegisters()
       */

      bool writeStatusAndConfigurationRegisters(uint8_t status,uint8_t configuration) const {

        uint8_t data[2];

        data[0]=status;
        data[1]=configuration;

        return this->writeCommand(TOpCode,0,0,0,data,2);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/WriteStatusRegister.h
// START FILE: ../lib/include/flash/spi/commands/BlockErase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Block erase command implementation. Sometimes this is described as a sector erase and
     * generally it's the command that erases the largest 'unit' of sectors on the device in
     * a single call.
     */

    template<class TSpi,uint8_t TOpCode=CMD_BLOCK_ERASE,uint8_t TAddressBytes=3>
    struct BlockErase : Command<TSpi> {

      /**
       * Provide a blockErase() function for the derived class
       */

      bool blockErase(uint32_t address) const {
        return this->writeCommand(TOpCode,address,TAddressBytes,0,nullptr,0);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/BlockErase.h
// START FILE: ../lib/include/flash/spi/commands/DeepPowerDown.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Deep power down command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_DEEP_POWER_DOWN>
    struct DeepPowerDown : Command<TSpi> {

      /**
       * Provide a deepPowerDown() function for the derived class
       */

      bool deepPowerDown() const {
        return this->writeCommand(TOpCode);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/DeepPowerDown.h
// START FILE: ../lib/include/flash/spi/commands/Read.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Read command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_READ,uint8_t TAddressBytes=3>
    struct Read : Command<TSpi> {

      /**
       * Provide a read() function for the derived class
       */

      bool read(uint32_t address,void *data,uint32_t dataSize) const {
        return this->readCommand(TOpCode,address,TAddressBytes,0,data,dataSize);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/Read.h
// START FILE: ../lib/include/flash/spi/commands/ReadJedecId.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Read JEDEC id command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_READ_JEDEC_ID>
    struct ReadJedecId : Command<TSpi> {

      /**
       * Provide a readJedecId() function for the derived class
       */

      bool readJedecId(uint8_t *data,uint32_t dataSize) const {
        return this->readCommand(TOpCode,0,0,0,data,dataSize);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/ReadJedecId.h
// START FILE: ../lib/include/flash/spi/commands/FastRead.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Fast Read command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_FAST_READ,uint8_t TAddressBytes=3,uint8_t TDummyBytes=1>
    struct FastRead : Command<TSpi> {

      /**
       * Provide a fastRead() function for the derived class
       */

      bool fastRead(uint32_t address,void *data,uint32_t dataSize) const {
        return this->readCommand(TOpCode,address,TAddressBytes,TDummyBytes,data,dataSize);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/FastRead.h
// START FILE: ../lib/include/flash/spi/commands/ReleaseDeepPowerDown.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Release deep power down command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_RELEASE_DEEP_POWER_DOWN>
    struct ReleaseDeepPowerDown : Command<TSpi> {

      /**
       * Provide a releaseDeepPowerDown() function for the derived class
       */

      bool releaseDeepPowerDown() const {
        return this->writeCommand(TOpCode);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/ReleaseDeepPowerDown.h
// START FILE: ../lib/include/flash/spi/commands/ReadStatusRegister.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {


    /**
     * Read status register command implementation
     */

    template<class TSpi,uint8_t TOpCode=CMD_READ_STATUS_REGISTER>
    struct ReadStatusRegister : Command<TSpi> {

      /**
       * Provide a readStatusRegister() function for the derived class
       */

      bool readStatusRegister(uint8_t& sr) const {
        return this->readCommand(TOpCode,0,0,0,&sr,1);
      }
    };
  }
}
// END FILE: ../lib/include/flash/spi/commands/ReadStatusRegister.h
// START FILE: ../lib/include/flash/spi/Base.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace spiflash {

    /**
     * Base template for SPI commands. TSpi is a template parameter instead of an instance
     * of "Spi" so that a wrapper can be used to emulate SPI over GPIO or defer to a DMA
     * channel that's connected to the SPI peripheral.
     */

    template<class TSpi>
    class Base {

      protected:
        TSpi *_spi;     // not an owned pointer and not a reference to avoid ugly virtual inheritance ctor requirements
    };
  }
}
// END FILE: ../lib/include/flash/spi/Base.h
// START FILE: ../lib/include/rtc/f4/RtcBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Specialisation of the RtcPeripheral for the F4
   */

  class RtcBase {
    enum {
      BKP_ALWAYS_RESET = 0,           // Old stm32plus behavior
      NOT_SURVIVED_FLAG = 0x1000000,  // Stored in _hourFormat
      HOUR_FORMAT_MASK = 0x0000ffff   // Hour format values are 0 and 64
    };

    protected:
      uint32_t _hourFormat;

    public:
      RtcBase(uint32_t hourFormat=RTC_HourFormat_24,uint32_t backupValue=BKP_ALWAYS_RESET);

      void setTime(uint8_t hours,uint8_t minutes,uint8_t seconds,uint8_t am_pm=RTC_H12_AM) const;
      void getTime(uint8_t& hours,uint8_t& minutes,uint8_t& seconds,uint8_t& am_pm) const;

      void setDate(uint8_t year,uint8_t month,uint8_t dayOfMonth,uint8_t dayOfWeek) const;
      void getDate(uint8_t& year,uint8_t& month,uint8_t& dayOfMonth,uint8_t& dayOfWeek) const;

      uint32_t getTick() const;
      void setTick(uint32_t tick) const;

      uint32_t getHourFormat() const;
      bool survived() const;  // true if RTC configuration survived reboot
  };

  /**
   * Constructor
   */

  inline RtcBase::RtcBase(uint32_t hourFormat,uint32_t backupValue)
    : _hourFormat(hourFormat) {

    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,ENABLE);
    PWR_BackupAccessCmd(ENABLE);          // allow backup domain access

    // Derived class should set the backup value after configuring the LSE
    if (backupValue == BKP_ALWAYS_RESET || RTC_ReadBackupRegister(RTC_BKP_DR0) != backupValue) {
      // reset the backup domain
      RCC_BackupResetCmd(ENABLE);
      RCC_BackupResetCmd(DISABLE);

      _hourFormat |= NOT_SURVIVED_FLAG;
    }
  }


  /**
   * Set the time
   * @param hours
   * @param minutes
   * @param seconds
   * @param am_pm not relevant if in 24 hour format
   */

  inline void RtcBase::setTime(uint8_t hours,uint8_t minutes,uint8_t seconds,uint8_t am_pm) const {

    RTC_TimeTypeDef tset;

    tset.RTC_H12=am_pm;
    tset.RTC_Hours=hours;
    tset.RTC_Minutes=minutes;
    tset.RTC_Seconds=seconds;

    RTC_SetTime(RTC_Format_BIN,&tset);
  }


  /**
   * Get the current time
   * @param hours
   * @param minutes
   * @param seconds
   * @param am_pm
   * @return
   */

  inline void RtcBase::getTime(uint8_t& hours,uint8_t& minutes,uint8_t& seconds,uint8_t& am_pm) const {

    RTC_TimeTypeDef tget;

    RTC_GetTime(RTC_Format_BIN,&tget);

    am_pm=tget.RTC_H12;
    hours=tget.RTC_Hours;
    minutes=tget.RTC_Minutes;
    seconds=tget.RTC_Seconds;
  }


  /**
   * Set the date
   * @param year (0..99)
   * @param month (1..12)
   * @param dayOfMonth (1..31)
   * @param dayOfWeek (1..7) where 1=Monday
   */

  inline void RtcBase::setDate(uint8_t year,uint8_t month,uint8_t dayOfMonth,uint8_t dayOfWeek) const {

    RTC_DateTypeDef sdate;

    sdate.RTC_Year=year;
    sdate.RTC_Month=month;
    sdate.RTC_Date=dayOfMonth;
    sdate.RTC_WeekDay=dayOfWeek;

    RTC_SetDate(RTC_Format_BIN,&sdate);
  }


  /**
   * Get the date
   * @param year
   * @param month (1..12)
   * @param dayOfMonth (1..31)
   * @param dayOfWeek (1..7) where 1=Monday
   */

  inline void RtcBase::getDate(uint8_t& year,uint8_t& month,uint8_t& dayOfMonth,uint8_t& dayOfWeek) const {

    RTC_DateTypeDef sdate;

    RTC_GetDate(RTC_Format_BIN,&sdate);

    year=sdate.RTC_Year;
    month=sdate.RTC_Month;
    dayOfMonth=sdate.RTC_Date;
    dayOfWeek=sdate.RTC_WeekDay;
  }


  /**
   * Get the hour format
   * @return RTC_HourFormat_24 / RTC_HourFormat_12
   */

  inline uint32_t RtcBase::getHourFormat() const {
    return _hourFormat;
  }


  /**
   * Return whether the RTC configuration survived reset, indicating
   * whether the backup domain was reset or not.
   * @return true if the RTC retained its configuration from a prior boot
   */

  inline bool RtcBase::survived() const {
    return !(_hourFormat & NOT_SURVIVED_FLAG);
  }


  /**
   * Get the tick value from the RTC. ticks == time_t value. Assumes that 00 year = 2000.
   * Is IRQ-safe.
   * @return The number of ticks (time_t)
   */

  inline uint32_t RtcBase::getTick() const {

    RTC_DateTypeDef rdate;
    RTC_TimeTypeDef rtime;
    struct tm tstruct;

    // get time and date

    RTC_GetTime(RTC_Format_BIN,&rtime);
    RTC_GetDate(RTC_Format_BIN,&rdate);

    // if in 24 hour clock or hour is less than 12 then believe the hours

    if(_hourFormat==RTC_HourFormat_24 || rtime.RTC_H12==RTC_H12_AM)
      tstruct.tm_hour=rtime.RTC_Hours;
    else
      tstruct.tm_hour=12+rtime.RTC_Hours;     // adjust hours + 12 for PM

    tstruct.tm_min=rtime.RTC_Minutes;
    tstruct.tm_sec=rtime.RTC_Seconds;

    tstruct.tm_year=rdate.RTC_Year+100;       // years since 1900. 00+100=2000
    tstruct.tm_mon=rdate.RTC_Month-1;
    tstruct.tm_mday=rdate.RTC_Date;

    return mktime(&tstruct)-946684800;        // subtract our base
  }


  /**
   * Set the timer from the tick value. Assumes that 00 year = 2000
   * Not IRQ safe due to use of gmtime()
   * @param tick The time_t value
   */

  inline void RtcBase::setTick(uint32_t tick) const {

    struct tm *tstruct;

    tick+=946684800;            // tick zero = 1/1/2000 00:00:00
    tstruct=gmtime(reinterpret_cast<time_t *>(&tick));

    // date is straightforward

    setDate(tstruct->tm_year-100,tstruct->tm_mon+1,tstruct->tm_mday,tstruct->tm_wday==0 ? 7 : tstruct->tm_wday);

    // if in 24 hours then easy else the hour must be mod 12 and am/pm set

    if(_hourFormat==RTC_HourFormat_24)
      setTime(tstruct->tm_hour,tstruct->tm_min,tstruct->tm_sec,0);
    else
      setTime(tstruct->tm_hour % 12,tstruct->tm_min,tstruct->tm_sec,tstruct->tm_hour>=12 ? RTC_H12_PM : RTC_H12_AM);
  }
}
// END FILE: ../lib/include/rtc/f4/RtcBase.h
// START FILE: ../lib/include/rtc/DS1307/DS1307.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


namespace stm32plus {


  /**
   * The DS1307 is a real time clock from Maxim IC. The interface to it is I2C. 12 and 24 hour
   * clock modes are supported as are all the 'non-RTC' functions that the DS1307 gives us
   * as a sort of bonus:
   *
   *   square wave output: 1Hz, 4kHz, 8kHz or 32kHz
   *   56 bytes of battery backed up RAM
   *
   * This class is parameterised by the I2CPeripheral instance that you want to use to talk to
   * the device. For example, "DS1307<I2C1_Default> i2c(params)" would configure the DS1307
   * to use I2C peripheral #1.
   *
   * The DS1307 talks BCD. Humans don't. We talk numbers, and these are the valid ranges for
   * the date components:
   *
   *   seconds:      0-59
   *   minutes:      0-59
   *   hours:        1-12am/pm or 0-23
   *   day-of-week:  1-7 where 1=Sunday, 2=Monday
   *   day-of-month: 1-31
   *   month:        1-12
   *   year:         0-99 (interpret the century as you will)
   */

  template<class TI2CPeripheral>
  class DS1307 : public TI2CPeripheral {

    public:

      /**
       * Parameters class that inherits from the I2C parameters
       * and adds any custom parameters for the DS1307. At present
       * there are none.
       */

      struct Parameters : public TI2CPeripheral::Parameters {
      };


      /**
       * The I2C bus address for the peripheral
       */

      enum {
        I2C_BUS_ADDRESS = 0xD0    //!< 11010000
      };


      /**
       * The possible square wave output frequencies
       */

      enum SquareWaveFrequency {
        SQW_1HZ     = 0,  //!< SQW_1HZ
        SQW_4096HZ  = 1,  //!< SQW_4096HZ
        SQW_8192HZ  = 2,  //!< SQW_8192HZ
        SQW_32768HZ = 3   //!< SQW_32768HZ
      };


      /**
       * The command set for the DS1307
       */

      enum Command {
        REG_SECOND  = 0,    //!< REG_SECOND
        REG_MINUTE  = 1,    //!< REG_MINUTE
        REG_HOUR    = 2,    //!< REG_HOUR
        REG_DAY     = 3,    //!< REG_DAY
        REG_DATE    = 4,    //!< REG_DATE
        REG_MONTH   = 5,    //!< REG_MONTH
        REG_YEAR    = 6,    //!< REG_YEAR
        REG_CONTROL = 7,    //!< REG_CONTROL
        REG_RAM_0   = 8     //!< REG_RAM_0
      };

    protected:
      uint8_t toBcd(uint8_t binary) const;
      uint8_t fromBcd(uint8_t bcd) const;

    public:

      DS1307(const Parameters& params);

      bool enableSquareWaveOutput() const;
      bool disableSquareWaveOutput() const;

      bool setSquareWaveFrequency(SquareWaveFrequency frequency) const;
      bool setDisabledSquareWavePinOutputLevel(bool level) const;

      bool set24HourMode() const;
      bool set12HourMode() const;

      bool getHourMode(bool& hourMode12) const;

      bool startClock() const;
      bool stopClock() const;

      bool setDateTime(time_t dateTime) const;
      bool setDateTime(uint8_t year,uint8_t month,uint8_t monthDay,uint8_t weekDay,uint8_t hour,uint8_t minute,uint8_t second) const;

      bool setYear(uint8_t y) const;
      bool setMonth(uint8_t m) const;
      bool setMonthDay(uint8_t md) const;
      bool setWeekDay(uint8_t wd) const;

      bool setHour(uint8_t h) const;
      bool setMinute(uint8_t m) const;
      bool setSecond(uint8_t s) const;

      bool getDateTime(time_t& t) const;
      bool getDateTime(uint8_t& year,uint8_t& month,uint8_t& monthDay,uint8_t& weekDay,uint8_t& hour,uint8_t& minute,uint8_t& second) const;

      bool writeRamAddress(uint8_t address,uint8_t value) const;
      bool readRamAddress(uint8_t address,uint8_t& value) const;
  };


  /**
   * Constructor
   * @param params The parameters class used to initialise
   */

  template<class TI2CPeripheral>
  inline DS1307<TI2CPeripheral>::DS1307(const Parameters& params)
    : TI2CPeripheral(params) {

    // set our slave address. we're always a slave so there has to be an I/O feature
    // somewhere in the feature hierarchy that has this method

    this->setSlaveAddress(I2C_BUS_ADDRESS);
  }


  /**
   * Enable the square wave output. Set control bit 4 to 1
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::enableSquareWaveOutput() const {
    return this->setBits(REG_CONTROL,0x16);
  }


  /**
   * Disable the square wave output. Set control bit 4 to 0
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::disableSquareWaveOutput() const {
    return this->resetBits(REG_CONTROL,0x16);
  }


  /**
   * Set the frequency of the square wave output
   * @param frequency from the SquareWaveFrequency enumeration.
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setSquareWaveFrequency(SquareWaveFrequency frequency) const {
    return this->setMask(REG_CONTROL,frequency,0x3);
  }


  /**
   * Set the output level for the SQW/OUT when the square wave is not used
   * @param level false=LOW, true=HIGH
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setDisabledSquareWavePinOutputLevel(bool level) const {
    return level ? this->setBits(REG_CONTROL,0x80) : this->resetBits(REG_CONTROL,0x80);
  }


  /**
   * Set the device into 24 hour mode. Clear bit 6 of the hours register.
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::set24HourMode() const {
    return this->resetBits(REG_HOUR,0x40);
  }


  /**
   * Set the device into 12 hour mode. Set bit 6 of the hours register.
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::set12HourMode() const {
    return this->setBits(REG_HOUR,0x40);
  }


  /**
   * Start the clock ticker. Clear bit 7 (CH) of the seconds register.
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::startClock() const {
    return this->resetBits(REG_SECOND,0x80);
  }


  /**
   * Stop the clock ticker. Set bit 7 (CH) of the seconds register.
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::stopClock() const {
    return this->setBits(REG_SECOND,0x80);
  }


  /**
   * Write to the battery-backed RAM onboard the DS1307. There's 56 bytes of it (woohoo!) to
   * do with as you please.
   * @param address The RAM address index (0..55)
   * @param value The value to write
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::writeRamAddress(uint8_t address,uint8_t value) const {
    return this->writeByte(REG_RAM_0+address,value);
  }


  /**
   * Read from the battery-backed RAM onboard the DS1307.
   * @param address The RAM address index (0..55)
   * @param value The value successfully read (or undefined if it fails)
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::readRamAddress(uint8_t address,uint8_t& value) const {
    return this->readByte(REG_RAM_0+address,value);
  }


  /**
   * Set the date and time from a libc time_t 32-bit number of seconds.
   * See http://www.cplusplus.com/reference/ctime/time_t. The two digit limitation on the clock year
   * means that the century component is lost. There is no consideration given to timezones.
   * @param dateTime The date and time from which to set the clock
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setDateTime(time_t dateTime) const {

    struct tm *tt;
    // get the time components

    tt=::gmtime(&dateTime);

    return
      setSecond(tt->tm_sec) &&        // do this first so we have 1-second to write the others
      setYear(tt->tm_year % 100) &&
      setMonth(tt->tm_mon+1) &&
      setMonthDay(tt->tm_mday) &&
      setWeekDay(tt->tm_wday+1) &&
      setHour(tt->tm_hour) &&
      setMinute(tt->tm_min);
  }


  /**
   * Convenience function to set all the date components in one go
   * @param year
   * @param month
   * @param monthDay
   * @param weekDay
   * @param hour
   * @param minute
   * @param second
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setDateTime(uint8_t year,uint8_t month,uint8_t monthDay,uint8_t weekDay,uint8_t hour,uint8_t minute,uint8_t second) const {

    return
      setYear(year) &&
      setMonth(month) &&
      setMonthDay(monthDay) &&
      setWeekDay(weekDay) &&
      setHour(hour) &&
      setMinute(minute) &&
      setSecond(second);
  }


  /**
   * Set the year component
   * @param y The year (0..99)
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setYear(uint8_t y) const {
    return this->writeByte(REG_YEAR,toBcd(y));
  }


  /**
   * Set the month component
   * @param m The month (1..12)
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setMonth(uint8_t m) const {
    return this->writeByte(REG_MONTH,toBcd(m));
  }

  /**
   * Set the day of month component
   * @param m The month date (1..31)
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setMonthDay(uint8_t md) const {
    return this->writeByte(REG_DATE,toBcd(md));
  }

  /**
   * Set the day of week component
   * @param m The day of week (1..7 where 1=Sunday)
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setWeekDay(uint8_t wd) const {
    return this->writeByte(REG_DAY,toBcd(wd));
  }


  /**
   * Get the 12/24 running mode
   * @param hourMode12 Set to true if 12 hour mode, false if 24 mode
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::getHourMode(bool& hourMode12) const {

    uint8_t value;

    if(!this->readByte(REG_HOUR,value))
      return false;

    hourMode12=(value & 0x40)!=0;
    return true;
  }


  /**
   * Set the hour component. The 12/24 hour mode of the peripheral is handled correctly.
   * @param h The hour (0..23)
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setHour(uint8_t h) const {

    bool hourMode12;

    // get the 12/24 selector

    if(!getHourMode(hourMode12))
      return false;

    if(hourMode12) {

      // convert 0..23 to 1..12

      if((h=h % 12)==0)
        h=12;

      // write the new value

      if(!this->setMask(REG_HOUR,toBcd(h),0x1f))
        return false;
    }
    else {

      // just write out

      if(!this->setMask(REG_HOUR,toBcd(h),0x3f))
        return false;
    }

    return true;
  }


  /**
   * Set the minute component
   * @param m The minute (0..59)
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setMinute(uint8_t m) const {
    return this->writeByte(REG_MINUTE,m);
  }


  /**
   * Set the second component
   * @param m The second (0..59)
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::setSecond(uint8_t s) const {
    return this->setMask(REG_SECOND,s,0x7f);
  }


  /**
   * Get the date/time as a time_t component. See See http://www.cplusplus.com/reference/ctime/time_t.
   * The 00..99 DS1307 year is assumed to be in the range 2000..2099
   * @param t Where to store the converted time
   * @return false if it fails
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::getDateTime(time_t& t) const {

    uint8_t year,month,monthDay,weekDay,hour,minute,second;
    struct tm tt;

    // get the components

    if(!getDateTime(year,month,monthDay,weekDay,hour,minute,second))
      return false;

    // do the conversion

    tt.tm_year=year+2000;
    tt.tm_mon=month-1;
    tt.tm_mday=month;
    tt.tm_wday=weekDay-1;
    tt.tm_hour=hour;
    tt.tm_min=minute;
    tt.tm_sec=second;

    t=mktime(&tt);
    return true;
  }


  /**
   * Get the date/time components
   * @param year (0..99)
   * @param month (1..12)
   * @param monthDay (1..31)
   * @param weekDay (1..7 where Sunday=1)
   * @param hour (0..23)
   * @param minute (0..59)
   * @param second (0..59)
   * @return false if it fails, and the return values are undefined.
   */

  template<class TI2CPeripheral>
  inline bool DS1307<TI2CPeripheral>::getDateTime(uint8_t& year,uint8_t& month,uint8_t& monthDay,uint8_t& weekDay,uint8_t& hour,uint8_t& minute,uint8_t& second) const {

    uint8_t values[7];

    // get them all in one read

    if(!this->readBytes(REG_SECOND,values,7))
      return false;

    // conversion

    year=fromBcd(values[REG_YEAR] & 0x7f);
    month=fromBcd(values[REG_YEAR] & 0x1f);
    monthDay=fromBcd(values[REG_DATE] & 0x3f);
    weekDay=fromBcd(values[REG_DAY] & 0x7);

    if((values[REG_HOUR] & 0x40)!=0) {

      // get the 1..12 value

      hour=fromBcd(values[REG_HOUR] & 0x1f);

      if((values[REG_HOUR] & 0x20)!=0)
        hour+=12;             // is PM
      else {
        if(hour==12)          // is AM where 12am == 00 hours
          hour=0;
      }
    }
    else
      hour=fromBcd(values[REG_HOUR] & 0x3f);

    minute=fromBcd(values[REG_MINUTE] & 0x7f);
    second=fromBcd(values[REG_SECOND] & 0x7f);

    return true;
  }


  /**
   * Convert value to 4-bit BCD
   * @param binary the binary value
   * @return The BCD value
   */

  template<class TI2CPeripheral>
  inline uint8_t DS1307<TI2CPeripheral>::toBcd(uint8_t binary) const {

    uint8_t bcd=0;

    while(binary!=0) {
      bcd<<=4;
      bcd|=binary % 10;
      binary/=10;
    }

    return bcd;
  }


  /**
   * Convert 4-bit BCD to binary
   * @param bcd The BCD value
   * @return The binary value
   */

  template<class TI2CPeripheral>
  inline uint8_t DS1307<TI2CPeripheral>::fromBcd(uint8_t bcd) const {

    uint8_t binary=0;

    while(bcd!=0) {
      binary*=10;
      binary|=bcd & 0xf;
      bcd>>=4;
    }

    return binary;
  }
}
// END FILE: ../lib/include/rtc/DS1307/DS1307.h
// START FILE: ../lib/include/rtc/Rtc.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * RTC template definition
   */

  template<class... Features>
  class Rtc : public RtcBase,
              public Features... {

    public:
      Rtc(uint32_t hourFormat=0,uint32_t backupValue=0) :
        RtcBase(hourFormat, backupValue),
        Features(static_cast<RtcBase&>(*this))... {

        // remember successful RTC initialization after features have run
        // only useful with LSE which is part of the backup domain

        if(backupValue) {
#if defined(STM32PLUS_F1)
          BKP_WriteBackupRegister(BKP_DR1,backupValue);
#else
          RTC_WriteBackupRegister(RTC_BKP_DR0,backupValue);
#endif
        }
      }
    };
}
// END FILE: ../lib/include/rtc/Rtc.h
// START FILE: ../lib/include/rtc/features/f4/RtcMeasuredLsiFrequencyProvider.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * Class to measure the frequency of the LSI using its output into channel 4
   * of Timer5. Of course this method fundamentally relies on the accuracy of the
   * oscillator (probably HSE) being better than that of the LSI itself.
   *
   * As an observation, the LSI on my STM32F4DISCOVERY board was measured at about 37.4kHz,
   * way off the target of 32.768kHz. This led to the clock running about 5 seconds fast per
   * minute. Using this class as the provider of the LSI frequency successfully calibrated
   * the LSI and got me an accurate RTC 1Hz tick.
   */

  class RtcMeasuredLsiFrequencyProvider {

    /**
     * Compute the LSI frequency
     * @return The measured frequency
     */

    public:
      static uint32_t getLsiFrequency();
  };
}
// END FILE: ../lib/include/rtc/features/f4/RtcMeasuredLsiFrequencyProvider.h
// START FILE: ../lib/include/rtc/features/f4/RtcLsiClockFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif



namespace stm32plus {

  /**
   * RTC feature to source the RTC from the LSI clock. ST attempt to measure the LSI clock
   * in their examples so we optionally provide that functionality as well.
   */

  template<class TLsiFrequencyProvider>
  class RtcLsiClockFeature : public RtcFeatureBase {

    public:
      RtcLsiClockFeature(RtcBase& rtc);
  };


  /**
   * Constructor
   * @param rtc The base RTC class
   */

  template<class TLsiFrequencyProvider>
  inline RtcLsiClockFeature<TLsiFrequencyProvider>::RtcLsiClockFeature(RtcBase& rtc)
    : RtcFeatureBase(rtc) {

    RTC_InitTypeDef init;

    // on with the LSI

    RCC_LSICmd(ENABLE);

    // wait till LSI is ready

    while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY)==RESET);
    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);

    RCC_RTCCLKCmd(ENABLE);
    RTC_WaitForSynchro();

    // Configure the RTC hour format and prescaler for whatever the LSI is running at

    init.RTC_AsynchPrediv=0x7F;     // max value
    init.RTC_SynchPrediv=(TLsiFrequencyProvider::getLsiFrequency()/128)-1;
    init.RTC_HourFormat=_rtc.getHourFormat();

    RTC_Init(&init);
  }
}
// END FILE: ../lib/include/rtc/features/f4/RtcLsiClockFeature.h
// START FILE: ../lib/include/rtc/features/f4/RtcAlarmInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * RTC feature to enable access to the alarm functionality. The F4 has two independent alarms
   * that can be configured to trigger on any or all of the time components and optionally the date/weekday.
   */

  template<uint32_t TAlarmIndex>
  class RtcAlarmInterruptFeature : public RtcFeatureBase,
                                   public ExtiRtcAlarm {

    public:
      RtcAlarmInterruptFeature(RtcBase& rtc);

      void setAlarm(uint32_t mask,uint32_t dateOrWeekdaySelector,uint8_t dateOrWeekDayValue,uint8_t hour,uint8_t minute,uint8_t second,uint8_t am_pm=RTC_H12_AM) const;
      void cancelAlarm() const;
  };


  /**
   * Typedefs for both the possible alarms
   */

  typedef RtcAlarmInterruptFeature<RTC_Alarm_A> RtcAlarmAInterruptFeature;
  typedef RtcAlarmInterruptFeature<RTC_Alarm_B> RtcAlarmBInterruptFeature;


  /**
   * Constructor
   * @param rtc The base RTC class
   */

  template<uint32_t TAlarmIndex>
  inline RtcAlarmInterruptFeature<TAlarmIndex>::RtcAlarmInterruptFeature(RtcBase& rtc)
    : RtcFeatureBase(rtc),
      ExtiRtcAlarm(EXTI_Mode_Interrupt,EXTI_Trigger_Rising) {
  }


  /**
   * Set the alarm
   * @param mask one of RTC_AlarmMask_Definitions, e.g. RTC_AlarmMask_All
   * @param dateOrWeekdaySelector one of RTC_AlarmDateWeekDay_Definitions. e.g. RTC_AlarmDateWeekDaySel_Date (don't care if date is masked off)
   * @param hour The hour, if not masked off
   * @param minute The minute, if not masked off
   * @param second The second, if not masked off
   * @param dateOrWeekDayValue The date (1..31) or day (1..7) where Monday = 1, if not masked off.
   */

  template<uint32_t TAlarmIndex>
  inline void RtcAlarmInterruptFeature<TAlarmIndex>::setAlarm(uint32_t mask,
                                                              uint32_t dateOrWeekdaySelector,
                                                              uint8_t dateOrWeekDayValue,
                                                              uint8_t hour,
                                                              uint8_t minute,
                                                              uint8_t second,
                                                              uint8_t am_pm) const {

    RTC_AlarmTypeDef alarm;

    // alarm register is RO while enabled

    RTC_AlarmCmd(TAlarmIndex,DISABLE);

    // set up the time component

    alarm.RTC_AlarmTime.RTC_Hours=hour;
    alarm.RTC_AlarmTime.RTC_Minutes=minute;
    alarm.RTC_AlarmTime.RTC_Seconds=second;
    alarm.RTC_AlarmTime.RTC_H12=am_pm;

    // set up the alarm configuration component

    alarm.RTC_AlarmMask=mask;
    alarm.RTC_AlarmDateWeekDaySel=dateOrWeekdaySelector;
    alarm.RTC_AlarmDateWeekDay=dateOrWeekDayValue;

    // set the alarm and enable the interrupt

    RTC_SetAlarm(RTC_Format_BIN,TAlarmIndex,&alarm);
    RTC_ITConfig(TAlarmIndex==RTC_Alarm_A ? RTC_IT_ALRA : RTC_IT_ALRB,ENABLE);

    // enable the alarm

    RTC_AlarmCmd(TAlarmIndex,ENABLE);
  }


  /**
   * Cancel the alarm interupts
   */

  template<uint32_t TAlarmIndex>
  inline void RtcAlarmInterruptFeature<TAlarmIndex>::cancelAlarm() const {
    RTC_AlarmCmd(TAlarmIndex,DISABLE);
    RTC_ITConfig(TAlarmIndex==RTC_Alarm_A ? RTC_IT_ALRA : RTC_IT_ALRB,DISABLE);
  }
}
// END FILE: ../lib/include/rtc/features/f4/RtcAlarmInterruptFeature.h
// START FILE: ../lib/include/rtc/features/f4/RtcLseClockFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif



namespace stm32plus {

  /**
   * RTC feature to source the RTC from the LSE clock (32.768 kHz)
   */

  class RtcLseClockFeature : public RtcFeatureBase {

    public:
      RtcLseClockFeature(RtcBase& rtc);
  };


  /**
   * Constructor
   * @param rtc The base RTC class
   */

  inline RtcLseClockFeature::RtcLseClockFeature(RtcBase& rtc)
    : RtcFeatureBase(rtc) {

    RTC_InitTypeDef init;

    if(rtc.survived())
      return;             // already configured from earlier boot

    // on with the LSE

    RCC_LSEConfig(RCC_LSE_ON);

    // wait till LSE is ready. can hang if LSE is not working

    while(RCC_GetFlagStatus(RCC_FLAG_LSERDY)==RESET);
    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);

    RCC_RTCCLKCmd(ENABLE);
    RTC_WaitForSynchro();

    // Configure the RTC hour format and prescaler for a 32.768kHz clock

    init.RTC_AsynchPrediv=0x7F;
    init.RTC_SynchPrediv=0xFF;        // LSI freq (Hz / 128)-1 = (32768 / 128 ) -1 = 255
    init.RTC_HourFormat=_rtc.getHourFormat();

    RTC_Init(&init);
  }
}
// END FILE: ../lib/include/rtc/features/f4/RtcLseClockFeature.h
// START FILE: ../lib/include/rtc/features/f4/RtcSecondInterruptFeature.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {


  /**
   * RTC feature to enable access to the second
   * interrupt functionality. We do this on the F4 by using the wakeup facility
   */

  class RtcSecondInterruptFeature : public RtcFeatureBase,
                                    public ExtiRtcWakeup {

    public:
      RtcSecondInterruptFeature(RtcBase& rtc);

      void enableSecondInterrupt() const;
      void disableSecondInterrupt() const;
  };


  /**
   * Constructor
   * @param rtc The base RTC class
   */

  inline RtcSecondInterruptFeature::RtcSecondInterruptFeature(RtcBase& rtc)
    : RtcFeatureBase(rtc),
      ExtiRtcWakeup(EXTI_Mode_Interrupt,EXTI_Trigger_Rising) {

    // set the clock source to the 1Hz SPRE and reset the counter

    RTC_WakeUpClockConfig(RTC_WakeUpClock_CK_SPRE_16bits);
    RTC_SetWakeUpCounter(0);
  }


  /**
   * Set the second interrupt
   */

  inline void RtcSecondInterruptFeature::enableSecondInterrupt() const {
    RTC_ITConfig(RTC_IT_WUT,ENABLE);
    RTC_WakeUpCmd(ENABLE);
  }


  /**
   * Cancel the second interupt
   */

  inline void RtcSecondInterruptFeature::disableSecondInterrupt() const {
    RTC_ITConfig(RTC_IT_WUT,DISABLE);
    RTC_WakeUpCmd(DISABLE);
  }
}
// END FILE: ../lib/include/rtc/features/f4/RtcSecondInterruptFeature.h
// START FILE: ../lib/include/rtc/features/RtcConstantLsiFrequencyProvider.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {

  /**
   * @brief class to return a hard-coded frequency for the LSI. No measuring is done
   *
   * The optimiser will reduce this to a simple load of a constant into a register.
   */

  template<uint32_t TConstantFrequency>
  class RtcConstantLsiFrequencyProvider {

    public:

      static uint32_t getLsiFrequency() {
        return TConstantFrequency;
      }
  };

  /*
   * Since the LSI is supposed to always be 32kHz, provide that as a type
   */

  typedef RtcConstantLsiFrequencyProvider<32768> Rtc32kHzLsiFrequencyProvider;
}
// END FILE: ../lib/include/rtc/features/RtcConstantLsiFrequencyProvider.h
// START FILE: ../lib/include/rtc/features/RtcFeatureBase.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {


  /**
   * Base class for RTC features
   */

  class RtcFeatureBase {
    protected:
      RtcBase& _rtc;

    public:
      RtcFeatureBase(RtcBase& rtc);
      operator RtcBase&();
  };


  /**
   * Constructor
   * @param rtc
   */

  inline RtcFeatureBase::RtcFeatureBase(RtcBase& rtc)
    : _rtc(rtc) {
  }


  /**
   * Cast to RtcBase reference
   */

  inline RtcFeatureBase::operator RtcBase&() {
    return _rtc;
  }
}
// END FILE: ../lib/include/rtc/features/RtcFeatureBase.h
// START FILE: ../lib/include/traits/f4/traits.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// ensure the MCU series is correct
#ifndef STM32PLUS_F4
#error This class can only be used with the STM32F4 series
#endif


namespace stm32plus {

  /**
   * The traits templates give us a type as a container for the various constants
   * that we need to operate a peripheral. See config/custom_traits.h for the
   * mechanism that you can use to override these defaults, for example to change
   * the GPIO speed to something other than the default.
   */

  template<PeripheralName TPeripheralName>
  struct PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_ADC1> {
    enum {
      PERIPHERAL_BASE = ADC1_BASE
    };
  };
  typedef PeripheralTraits<PERIPHERAL_ADC1> Adc1PeripheralTraits;

#if defined(STM32PLUS_F4_HAS_ADC2_3)
  template<>
  struct PeripheralTraits<PERIPHERAL_ADC2> {
    enum {
      PERIPHERAL_BASE = ADC2_BASE
    };
  };
  typedef PeripheralTraits<PERIPHERAL_ADC2> Adc2PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_ADC3> {
    enum {
      PERIPHERAL_BASE = ADC3_BASE
    };
  };
  typedef PeripheralTraits<PERIPHERAL_ADC3> Adc3PeripheralTraits;
#endif

  template<>
  struct PeripheralTraits<PERIPHERAL_CAN1> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = CAN1_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_CAN1> Can1PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_CAN2> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = CAN2_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_CAN2> Can2PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_DAC1> {
    enum {
      CHANNEL_NUMBER = DAC_Channel_1
    };
  };
  typedef PeripheralTraits<PERIPHERAL_DAC1> Dac1PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_DAC2> {
    enum {
      CHANNEL_NUMBER = DAC_Channel_2
    };
  };
  typedef PeripheralTraits<PERIPHERAL_DAC1> Dac1PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_GPIO> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz
    };
  };
  typedef PeripheralTraits<PERIPHERAL_GPIO> GpioPeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_FSMC> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_FSMC> FsmcPeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_SDIO> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_SDIO> SdioPeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_I2C1> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = I2C1_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_I2C1> I2C1PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_I2C2> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = I2C2_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_I2C2> I2C2PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_I2C3> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = I2C3_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_I2C3> I2C3PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_I2S2> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = SPI2_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_I2S2> I2S2PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_I2S3> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = SPI3_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_I2S3> I2S3PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_SPI1> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = SPI1_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_SPI1> Spi1PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_SPI2> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = SPI2_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_SPI2> Spi2PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_SPI3> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = SPI3_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_SPI3> Spi3PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER1> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM1_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER1> Timer1PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER2> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM2_BASE,
      COUNTER_MAX = 0xFFFFFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER2> Timer2PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER3> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM3_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER3> Timer3PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER4> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM4_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER4> Timer4PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER5> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM5_BASE,
      COUNTER_MAX = 0xFFFFFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER5> Timer5PeripheralTraits;

#if defined(STM32PLUS_F4_HAS_TIM6_7_8_12_13_14)

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER6> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM6_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER6> Timer6PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER7> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM7_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER7> Timer7PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER8> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM8_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER8> Timer8PeripheralTraits;

#endif

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER9> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM9_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER9> Timer9PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER10> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM10_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER10> Timer10PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER11> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM11_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER11> Timer11PeripheralTraits;

#if defined(STM32PLUS_F4_HAS_TIM6_7_8_12_13_14)

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER12> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM12_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER12> Timer12PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER13> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM13_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER13> Timer13PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_TIMER14> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = TIM14_BASE,
      COUNTER_MAX = 0xFFFF
    };
  };
  typedef PeripheralTraits<PERIPHERAL_TIMER14> Timer14PeripheralTraits;

#endif
  
  template<>
  struct PeripheralTraits<PERIPHERAL_USART1> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = USART1_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_USART1> Usart1PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_USART2> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = USART2_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_USART2> Usart2PeripheralTraits;

#if defined(STM32PLUS_F4_HAS_USART3_4_5)

  template<>
  struct PeripheralTraits<PERIPHERAL_USART3> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = USART3_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_USART3> Usart3PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_UART4> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = UART4_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_UART4> Uart4PeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_UART5> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = UART5_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_UART5> Uart5PeripheralTraits;
#endif

#if defined(STM32PLUS_F4_HAS_MAC)

  template<>
  struct PeripheralTraits<PERIPHERAL_MAC> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = ETH_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_MAC> MacPeripheralTraits;
#endif

  template<>
  struct PeripheralTraits<PERIPHERAL_OTG_FS> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz
    };
  };
  typedef PeripheralTraits<PERIPHERAL_OTG_FS> OtgFsPeripheralTraits;

  template<>
  struct PeripheralTraits<PERIPHERAL_USART6> {
    enum {
      GPIO_SPEED = GPIO_Speed_50MHz,
      PERIPHERAL_BASE = USART6_BASE,
    };
  };
  typedef PeripheralTraits<PERIPHERAL_USART6> Usart6PeripheralTraits;
}
// END FILE: ../lib/include/traits/f4/traits.h
// START FILE: ../LICENSE.md
License
=======
Copyright (c) 2011-2015 [Andrew Brown](http://www.andybrown.me.uk)
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

* Neither the name of stm32plus nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL ANDREW BROWN BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// END FILE: ../LICENSE.md
// START FILE: ../cmake/example/blink.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/gpio.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * This is the most basic example that uses GPIO and the
 * Systick timer to blink a LED on PC8 at 1Hz. PC8 is wired
 * to the blue onboard LED on the F1VL and F0 discovery boards.
 *
 * If the STM32F4DISCOVERY board is your target then
 * change the GPIO declation to...
 *
 *  GpioD<DefaultDigitalOutputFeature<13> > pd
 *
 * ... and change 2 of "pc[8]" to "pd[13]" to blink the
 * orange led on the discovery board.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 *   STM32F107VCT6
 */

class Blink {

  public:

    void run() {

      // initialise the pin for output

      GpioE<DefaultDigitalOutputFeature<2> > pc;

      // loop forever switching it on and off with a 1 second
      // delay in between each cycle

      for(;;) {

        pc[2].set();
        MillisecondTimer::delay(1000);

        pc[2].reset();
        MillisecondTimer::delay(1000);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  Blink blink;
  blink.run();

  // not reached
  return 0;
}
// END FILE: ../cmake/example/blink.cpp
// START FILE: ../cmake/example/README.md
CMake Example
=============

This folder shows a bare-bones example of compiling an external firmware
against stm32plus, using CMake. To compile the example, create a folder
for the out-of-source build tree, configure, and make the firmware binary:

    mkdir build && cd build
    cmake ..
    make blink.bin

The CMakeLists.txt file contains two main things which you might want or
need to change:

  - First, the location of the stm32plus install. If you placed
    it somewhere other than the default, you may need to edit
    CMAKE_PREFIX_PATH.
  - Second, the stm32plus system prefix string, stored in the
    STM32PLUS_CONFIGURATION. The default is for an 8MHz F407
    discovery kit. You will need to change this if you have other
    hardware (and, of course, build/install the appropriate 
    configuration of stm32plus itself). 
// END FILE: ../cmake/example/README.md
// START FILE: ../cmake/example/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../cmake/example/system/LibraryHacks.cpp
// START FILE: ../examples/adc_single_interrupts/adc_single_interrupts.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"
#include "config/adc.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * This example illustrates the use of interrupts to signal the end of a conversion. Using an interrupt
 * can be a more efficient way to manage the flow of converted data if your MCU has other things to do
 * such as being responsive to the actions going on in a user interface.
 *
 * On the F0:
 *   We use a 7.5 cycle conversion time against PCLK/2.
 *
 * On the F1:
 *   We use a 7.5 cycle conversion time against PCLK2/6 (e.g. 72 MHz / 6 = 12 MHz)
 *
 * On the F4:
 *   ADC1 is configured with 12-bit resolution, APB2 clock prescaler of 2, 56 cycle conversion time.
 *
 * We will use ADC channel 0 (PA0). USART1 is configured with 57600/8/N/1 parameters.
 *
 * To run this example you can connect PA0 (ADC123_IN0) to see a conversion value of 0 or you can
 * connect PA0 to the VREF level (probably 3.3V or 3V) to see a conversion value of 4095. The actual
 * values that you get will vary according to the noise present on the line.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 *   STM32F107VCT6
 */

class AdcSingleInterrupts {

  protected:
    volatile bool _ready;           // set by the interrupt callback when data is ready (EOC)

  public:

    void run() {

      _ready=false;

#if defined(STM32PLUS_F0)

      /*
       * Declare the ADC peripheral using PCLK with a prescaler of 2, a resolution of
       * 12 bits. We will use 55.5-cycle conversions on ADC channel 0.
       */

      Adc1<
        AdcPclk2ClockModeFeature,                 // prescaler of 2
        AdcResolutionFeature<12>,                 // 12 bit resolution
        Adc1Cycle7RegularChannelFeature<0>,       // using channel 0 on ADC1 with 7.5-cycle latency
        Adc1InterruptFeature                      // enable interrupt handling on this ADC
        > adc;

#elif defined(STM32PLUS_F1)

      /*
       * Declare the ADC peripheral with a PCLK2 clock prescaler of 6. The ADC clock cannot exceed 14MHz so
       * if PCLK2 is 72MHz then we're operating it at 12MHz here.
       */

      Adc1<
        AdcClockPrescalerFeature<6>,              // PCLK2/6
        Adc1Cycle7RegularChannelFeature<0>,       // using channel 0 (PA0) on ADC1 with 7.5-cycle latency
        Adc1InterruptFeature                      // enable interrupt handling on this ADC
        > adc;

#elif defined(STM32PLUS_F4)

      /*
       * Declare the ADC peripheral with an APB2 clock prescaler of 2, a resolution of
       * 12 bits. We will use 3-cycle conversions on ADC channel 0.
       */

      Adc1<
        AdcClockPrescalerFeature<2>,              // prescaler of 2
        AdcResolutionFeature<12>,                 // 12 bit resolution
        Adc1Cycle56RegularChannelFeature<0>,      // using channel 0 on ADC1 with 56-cycle latency
        Adc1InterruptFeature                      // enable interrupt handling on this ADC
        > adc;

#endif

      /*
       * Subscribe to the interrupts raised by the ADC
       */

      adc.AdcInterruptEventSender.insertSubscriber(
          AdcInterruptEventSourceSlot::bind(this,&AdcSingleInterrupts::onInterrupt)
        );

      /*
       * Declare an instance of USART that we'll use to write out the conversion results.
       */

      Usart1<> usart(57600);
      UsartPollingOutputStream outputStream(usart);

      /*
       * Enable the ADC interrupts
       */

      adc.enableInterrupts(Adc1InterruptFeature::END_OF_CONVERSION);

      /*
       * Go into an infinite loop converting
       */

      for(;;) {

        uint16_t value;

        // start a conversion

        adc.startRegularConversion();

        // wait for the interrupt handler to tell us that the conversion is done
        // then reset the ready flag

        while(!_ready);
        _ready=false;

        // get the result

        value=adc.getRegularConversionValue();

        // write the value to the USART

        outputStream << "Converted value is " << StringUtil::Ascii(value) << "\r\n";

        // wait for a second before converting the next value

        MillisecondTimer::delay(1000);
      }
    }


    /**
     * Interrupt callback will be fired when a value has been converted and
     * is ready for consumption. We'll just signal to the main code that it
     * can wake up and pick up the value.
     * @param eventType Which interrupt was fired, see the AdcEventType enumeration for details.
     * @param adcNumber The ADC peripheral number that raised the interrupt (1..3). Will always be 1 in this test.
     */

    void onInterrupt(AdcEventType eventType,uint8_t adcNumber) {

      if(adcNumber==1 && eventType==AdcEventType::EVENT_REGULAR_END_OF_CONVERSION)
        _ready=true;
    }
};


/*
 * Main entry point
 */

int main() {

  // we're using interrupts, initialise NVIC

  Nvic::initialise();

  MillisecondTimer::initialise();

  AdcSingleInterrupts adc;
  adc.run();

  // not reached
  return 0;
}
// END FILE: ../examples/adc_single_interrupts/adc_single_interrupts.cpp
// START FILE: ../examples/adc_single_interrupts/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/adc_single_interrupts/system/LibraryHacks.cpp
// START FILE: ../examples/dac_circular/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/dac_circular/system/LibraryHacks.cpp
// START FILE: ../examples/dac_circular/dac_circular.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dac.h"

using namespace stm32plus;


/**
 * Demonstration of DAC channel 1 playing back a sampled waveform.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices
 *   STM32F051R8T6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

// A sine wave centered around 2048

static uint16_t samples[] = { 2048, 2128, 2208, 2288, 2367, 2446, 2523,
    2599, 2674, 2748, 2820, 2890, 2958, 3023, 3087, 3148, 3206, 3261, 3314,
    3363, 3410, 3453, 3492, 3529, 3561, 3590, 3615, 3637, 3654, 3668, 3678,
    3684, 3686, 3684, 3678, 3668, 3654, 3637, 3615, 3590, 3561, 3529, 3492,
    3453, 3410, 3363, 3314, 3261, 3206, 3148, 3087, 3023, 2958, 2890, 2820,
    2748, 2674, 2599, 2523, 2446, 2367, 2288, 2208, 2128, 2048, 1967, 1887,
    1807, 1728, 1649, 1572, 1496, 1421, 1347, 1275, 1205, 1137, 1072, 1008, 947,
    889, 834, 781, 732, 685, 642, 603, 566, 534, 505, 480, 458, 441, 427, 417,
    411, 409, 411, 417, 427, 441, 458, 480, 505, 534, 566, 603, 642, 685, 732,
    781, 834, 889, 947, 1008, 1072, 1137, 1205, 1275, 1347, 1421, 1496, 1572,
    1649, 1728, 1807, 1887, 1967
};

enum {
  NUM_SAMPLES = sizeof(samples) / sizeof(samples[0])
};


#if defined(STM32PLUS_F0)

  typedef Dac1UpdateDmaChannel<Dac1UpdateDmaChannelInterruptFeature,
                               DacDmaWriterFeature<DacChannel112BitRightAlignmentFeature,
                                                   DMA_Priority_High,
                                                   DMA_Mode_Circular> > MyDma;

  typedef Dac1UpdateDmaChannelInterruptFeature InterruptFeature;

#elif defined(STM32PLUS_F1)

  typedef Dac1DmaChannel<DacChannel1DmaChannelInterruptFeature,
                         DacDmaWriterFeature<DacChannel112BitRightAlignmentFeature,
                                             DMA_Priority_High,
                                             DMA_Mode_Circular> > MyDma;

  typedef DacChannel1DmaChannelInterruptFeature InterruptFeature;

#elif defined(STM32PLUS_F4)

  typedef Dac1DmaChannel<Dac1DmaChannelInterruptFeature,
                         DacDmaWriterFeature<DacChannel112BitRightAlignmentFeature,
                                             DMA_Priority_High,
                                             DMA_FIFOMode_Disable,
                                             DMA_Mode_Circular> > MyDma;

  typedef Dac1DmaChannelInterruptFeature InterruptFeature;

#endif

class DacCircularTest {

public:
  void run() {

    Dac1<>::Parameters params;
    params.dac_trigger = DAC_Trigger_T6_TRGO; // Output only changes on trigger
    params.dac_waveGeneration = DAC_WaveGeneration_None;
    params.dac_outputBuffer = DAC_OutputBuffer_Enable;

    Dac1<DacChannel112BitLeftAlignmentFeature> dac(params);

    MyDma dma;

    dma.DmaInterruptEventSender.insertSubscriber(
        DmaInterruptEventSourceSlot::bind(this, &DacCircularTest::onComplete));

    // Must enable all desired interrupts in one call

    dma.enableInterrupts(InterruptFeature::HALF_COMPLETE | InterruptFeature::COMPLETE);

    // Samples output on every second tick of the time base

    Timer6<Timer6InternalClockFeature, TimerUpdateMasterFeature> timer;
    timer.setTimeBaseByFrequency(NUM_SAMPLES * 440 * 2, 1, TIM_CounterMode_Up);
    timer.enableMasterFeature();

    dac.enablePeripheral();
    timer.enablePeripheral();

    dma.beginWrite(samples, NUM_SAMPLES);

    // it's running in the background now

    for(;;);
  }

  /*
   * Subscriber callback is fired when the DMA transfer is (half)complete.
   * We could refresh the half that was just completed or just let it loop.s
   */

  void onComplete(DmaEventType det) {
    if (det == DmaEventType::EVENT_COMPLETE) {
      // refill second half of buffer (or just leave it alone)
    }
    if (det == DmaEventType::EVENT_HALF_COMPLETE) {
      // refill first half of buffer (or just leave it alone)
    }
  }
};


/*
 * Main entry point
 */

int main() {

  DacCircularTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/dac_circular/dac_circular.cpp
// START FILE: ../examples/timer_master_slave/timer_master_slave.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"
#include "config/dma.h"


using namespace stm32plus;


/**
 * Timer master/slave demonstration. Use one timer to switch another one on and off at
 * predefined intervals.
 *
 * Timer2 is configured as the master timer with a frequency of 2000Hz and a reload
 * value of 8000. Channel 1 is configured to generate a PWM wave with a 25% duty cycle.
 * That means 1 seconds on and 3 seconds off.
 *
 * Timer3 is configured as the slave timer with a frequency of 2000Hz and a reload value
 * of 200 with a GPIO output toggle feature so it flashes on/off 5 times per second.
 *
 * If left to run freely timer3 would flash continually at 5Hz. However, attaching it as
 * a slave to the PWM wave generated by timer2 means that it will flash for 1 second then
 * switch off for 3 seconds.
 *
 * The output is generated on PA6. You can wire that directly to a LED or a logic analyser
 * to see the results. My STM32F103ZET6 development board has a LED on PF6 so I've wired
 * PA6 to PF6 and enabled PF6 for output in this demo code.
 *
 * If you're using the F4 Discovery board then wire up PA6 to PD13. If you're using the
 * F1 VL or F0 Discovery board then wire up PA6 to PC8.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class TimerMasterSlaveTest {

  public:

    void run() {

      /*
       * Enable PF6 for output so we can see the output on the LED that's connected there.
       * Wire up PA6 to PF6 to see the output.
       */

      GpioF<DefaultDigitalOutputFeature<6> > pf;

      /*
       * Create an instance of Timer2 (master) running off the internal clock with
       * channel 1 and master features.
       */

      Timer2<
        Timer2InternalClockFeature,         // the timer bus is APB1 (APB on the F0)
        TimerChannel1Feature<>,             // we're going to use channel 1
        TimerOutputCompare1MasterFeature    // we're the master timer using OC1 as the trigger
      > masterTimer;

      /*
       * Set the frequency of Timer2 to 2000Hz with a reload value of 8000.
       */

      masterTimer.setTimeBaseByFrequency(2000,7999);

      /*
       * Initialise channel 1's comparator for use as a PWM output with an
       * initial duty cycle of 25%
       */

      masterTimer.initCompareForPwmOutput(25);

      /*
       * Create an instance of Timer3 (slave) running off the internal clock
       * with channel 1 and unremapped GPIO output features.
       */

      Timer3<
        Timer3InternalClockFeature,       // the timer bus is APB1 (APB on the F0)
        TimerChannel1Feature<>,           // we're going to use channel 1
        Timer2MasterTimer3SlaveFeature<   // timer3 is a slave to timer2 (ITR1)
          TIM_SlaveMode_Gated             // gated mode - the slave counter goes on and off with the trigger
        >,
        Timer3GpioFeature<                // we want to output something to GPIO
          TIMER_REMAP_NONE,               // the GPIO output will not be remapped
          TIM3_CH1_OUT                    // we will output channel 1 to GPIO
        >
      > slaveTimer;

      /*
       * Set an up-timer up to tick at 2000Hz with an auto-reload value of 200
       * The timer will count from 0 to 199 inclusive then reset back to 0.
       * It will do this 10 times per second
       *
       * Note that the lowest frequency you can set is 1098 for a 72Mhz timer clock source.
       * This is because the maximum prescaler value is 65536 (72Mhz/65536 = 1098Hz).
       */

      slaveTimer.setTimeBaseByFrequency(2000,199);

      /*
       * Initialise the channel 1 output compare value to 2000 with the default
       * action of toggle.
       */

      slaveTimer.initCompare(199);

      /*
       * Enable master feature and switch the timer on. Enabling of master feature must happen
       * after the rest of the timer has been set up (above)
       */

      masterTimer.enableMasterFeature();
      masterTimer.enablePeripheral();

      /*
       * Enable slave feature and switch the timer on. Enabling of slave feature must happen
       * after the rest of the timer has been set up (above)
       */

      slaveTimer.enableSlaveFeature();
      slaveTimer.enablePeripheral();

      /*
       * It's all running automatically now. The on/off duration of the flashing can be controlled
       * using the duty cycle of timer2.
       */

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  TimerMasterSlaveTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_master_slave/timer_master_slave.cpp
// START FILE: ../examples/timer_master_slave/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_master_slave/system/LibraryHacks.cpp
// START FILE: ../examples/spi_send_sync/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/spi_send_sync/system/LibraryHacks.cpp
// START FILE: ../examples/spi_send_sync/spi_send_sync.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/spi.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * This demo illustrates sending and receiving using the SPI peripherals. A block of test data
 * is sent from SPI1 to SPI2 and, if successfully received, then a LED on PF6 is flashed for
 * one second. The test repeats continuously.
 *
 * For this demo I'm going to need you to do a little wiring to hook up SPI1 to SPI2 so that we can
 * exchange data over the MOSI pin. Here are the connections that you need to make.
 *
 * If you intend to run this example on the F4 DISCOVERY board then replace PF6 with PD13 to use
 * the onboard LED.
 *
 * If you intend to run this example on the VL or F0 DISCOVERY board then replace PF6 with PC8
 * to use the onboard LED.
 *
 * 1MOSI/2MOSI: PA7  => PB15
 * NSS:         PA4 <=> PB12
 * SCLK:        PA5 <=> PB13
 * *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class SpiSendSyncTest {

  protected:

    enum { LED_PIN = 6 };

  public:

    void run() {

      const uint8_t *dataToSend=(const uint8_t *)"Hello World";
      uint8_t receiveBuffer[12];
      uint8_t i;

      // initialise the LED on PF6. It's active LOW so we set it HIGH to turn it off

      GpioF<DefaultDigitalOutputFeature<LED_PIN> > pf;
      pf[LED_PIN].set();

      /*
       * Declare our SPI objects with no extra features beyond the ability to send and
       * receive data bytes. SPI1 is going to be the master and SPI2 the slave. All the SPI
       * remap configurations are available with names such as Spi1_Remap if you need to use the
       * remapped pins.
       */

      typedef Spi1<> MySender;
      typedef Spi2<> MyReceiver;

      MySender::Parameters senderParams;
      MyReceiver::Parameters receiverParams;

      senderParams.spi_mode=SPI_Mode_Master;
      receiverParams.spi_mode=SPI_Mode_Slave;

      MySender sender(senderParams);
      MyReceiver receiver(receiverParams);

      for(;;) {

        /*
         * Clear out the receive buffer for this session
         */

        memset(receiveBuffer,0,12);

        /*
         * NSS (slave select) is active LOW. ST made such a mess of the hardware implementation of NSS
         * that we always control it through software. Here it's pulled LOW ready for transmission.
         */

        sender.setNss(false);

        for(i=0;i<12;i++) {

          /*
           * Wait for the sender to signal it's ready and then send a byte
           */

          while(!sender.readyToSend());
          sender.send(&dataToSend[i],1);

          /*
           * Wait for the receiver to signal it's ready to receive and then receive the byte
           */

          while(!receiver.readyToReceive());
          receiver.receive(receiveBuffer[i]);
        }

        /*
         * The session is complete, wait for the last transmission to complete and deactivate NSS.
         */

        sender.waitForIdle();
        sender.setNss(true);

        /*
         * Test the received buffer. If the data is incorrect then lock up
         */

        if(memcmp(receiveBuffer,dataToSend,12)!=0)
          for(;;);

        /*
         * The data is correct, flash the LED on PF6 for one second
         */

        pf[LED_PIN].reset();
        MillisecondTimer::delay(1000);
        pf[LED_PIN].set();
        MillisecondTimer::delay(1000);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  MillisecondTimer::initialise();

  SpiSendSyncTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/spi_send_sync/spi_send_sync.cpp
// START FILE: ../examples/timer_7segment/timer_7segment.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"
#include "config/timer.h"
#include "string/StringUtil.h"


using namespace stm32plus;


/**
 * This example shows how to drive a seven segment, three digit common-cathode
 * LED display using resistors and MOSFETs as the only external components.
 * Timer 1 is used to generate an interrupt at a frequency of 180Hz. Each
 * interrupt sets up the GPIOs to drive one of the digits with the other two
 * switched off. Therefore the update rate for each digit is 180/3 = 60Hz.
 * This is enough to avoid visual flickering.
 *
 * The wiring required is:
 *   68 ohm resistors between each GPIO port and the LED segment pins. Connect
 *   each digit pin to the drain of an n-channel MOSFET. Connect PB9, PB2, PB10
 *   to the corresponding MOSFET gates. Ground all 3 MOSFET source pins.
 *
 *     PA0: segment A
 *     PA3: segment B
 *     PB8: segment C
 *     PB4: segment D
 *     PB3: segment E
 *     PA1: segment F
 *     PA2: segment G
 *     PB5: decimal point segment
 *     PB9: digit 1 MOSFET gate
 *     PB2: digit 2 MOSFET gate
 *     PB10: digit 3 MOSFET gate
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */


/*
 * Abbreviated table of digits to switched on for each character. The table is
 * in ASCII order starting at 32 for space. Each bit is a segment in order ABCDEFG0.
 */

static const uint8_t AsciiTable[]= {
  0,  // SPACE
  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,  // skip
  0b11111100,  // 0
  0b01100000,  // 1
  0b11011010,  // 2
  0b11110010,  // 3
  0b01100110,  // 4
  0b10110110,  // 5
  0b10111110,  // 6
  0b11100000,  // 7
  0b11111110,  // 8
  0b11110110   // 9
};


class Timer7SegmentTest  {

  protected:

    enum {
      SEGA = 0,   // PA0
      SEGB = 3,   // PA3
      SEGC = 8,   // PB8
      SEGD = 4,   // PB4
      SEGE = 3,   // PB3
      SEGF = 1,   // PA1
      SEGG = 2,   // PA2
      SEGP = 5,   // PB5
      DIG1 = 9,   // PB9
      DIG2 = 2,   // PB2
      DIG3 = 10   // PB10
    };

    /*
     * Segments A-G, DP in that order
     */

    GpioPinRef _segments[8];

    /*
     * Digits 1,2,3
     */

    GpioPinRef _digits[3];

    /*
     * State variables. Copy the ASCII string to display to _display
     * and it will show up immediately.
     */

    volatile char _display[7];   // 3 digits, each can be followed by '.'
    volatile uint8_t _currentDigit;
    volatile char *_currentDigitPtr;

  public:

    void run() {

      /*
       * Initialise the GPIO pins. The SEGx pins will drive HIGH to light a
       * segment and on the other side of the LED DIGx will be set HIGH to
       * switch on the MOSFET that permits the digit to light up.
       */

      GpioA<DefaultDigitalOutputFeature<SEGA,SEGB,SEGF,SEGG>> pa;
      GpioB<DefaultDigitalOutputFeature<DIG1,DIG2,DIG3,SEGC,SEGD,SEGE,SEGP>> pb;

      // set up the state variables

      _segments[0]=pa[SEGA];
      _segments[1]=pa[SEGB];
      _segments[2]=pb[SEGC];
      _segments[3]=pb[SEGD];
      _segments[4]=pb[SEGE];
      _segments[5]=pa[SEGF];
      _segments[6]=pa[SEGG];
      _segments[7]=pb[SEGP];

      _digits[0]=pb[DIG1];
      _digits[1]=pb[DIG2];
      _digits[2]=pb[DIG3];

      /*
       * Turn all the LEDs off by setting everything to low
       */

      for(uint8_t i=0;i<sizeof(_segments)/sizeof(_segments[0]);i++)
        _segments[0].reset();

      for(uint8_t i=0;i<sizeof(_digits)/sizeof(_digits[0]);i++)
        _digits[0].reset();

      /*
       * Initialise the state variables
       */

      _display[0]=_display[1]=_display[2]=0;
      _currentDigit=0;
      _currentDigitPtr=_display;

      /*
       * Initialise timer1 running from the high speed internal APB2 (APB on the F0)
       * clock with an interrupt feature
       */

      Timer1<
        Timer1InternalClockFeature,       // the timer clock source is APB2 (APB on the F0)
        Timer1InterruptFeature            // gain access to interrupt functionality
      > timer;

      /*
       * Set ourselves up as a subscriber for interrupts raised by the timer class.
       */

      timer.TimerInterruptEventSender.insertSubscriber(
          TimerInterruptEventSourceSlot::bind(this,&Timer7SegmentTest::onInterrupt)
        );


      /*
       * Set an up-down-timer up to tick at 80kHz with an auto-reload value of 444
       * The timer will count from 0 to 444 inclusive, raise an Update interrupt and
       * then go backwards back down to 0 where it'll raise another Update interrupt
       * and start again. Each journey from one end to the other takes 1/180 second.
       */

      timer.setTimeBaseByFrequency(80000,444,TIM_CounterMode_CenterAligned3);

      /*
       * Enable just the Update interrupt, clearing any spurious pending flag first
       */

      timer.clearPendingInterruptsFlag(TIM_IT_Update);
      timer.enableInterrupts(TIM_IT_Update);

      /*
       * Start the timer
       */

      timer.enablePeripheral();

      /*
       * We'll display an upward counter that wraps at 999 and shows each number
       * for 100ms
       */

      int value = -1;

      for(;;) {

        value++;

        if(value>999)
          value = 0;

        // translate value to ascii, left justified

        _display[0]=_display[1]=_display[2]=0;
        StringUtil::itoa(value, const_cast<char *>( _display), 10);

        // wait for 100ms

        MillisecondTimer::delay(100);
      }
    }

    /*
     * Subscriber callback function. This is called when the update interrupt that we've
     * enabled is fired.
     */

    void onInterrupt(TimerEventType tet,uint8_t /* timerNumber */) {

      // verify our expectation

      if(tet!=TimerEventType::EVENT_UPDATE)
        return;

      // turn off the last digit we displayed. This needs to be done first to avoid
      // switched off segments becoming faintly visible during multiplexing

      _digits[_currentDigit].reset();

      // advance to the digit we just set up

      if(_currentDigit>=2) {
        _currentDigit=0;
        _currentDigitPtr=_display;
      }
      else
        _currentDigit++;

      // get the character to display at this position

      uint8_t c=*_currentDigitPtr++;

      // check the bottom end of the range

      if(c<=' ')
        c=' ';

      // get the segment state bitmap from the table

      uint8_t bits=AsciiTable[c-' '];

      // for each bit in the map, set/reset the correct state in the segments

      for(uint8_t j=0;j<7;j++) {
        bool state=(bits & 0x80)!=0;
        _segments[j].setState(state);
        bits <<= 1;
      }

      // process the decimal point if there is one

      if(*_currentDigitPtr=='.') {
        _segments[7].set();
        _currentDigitPtr++;
      }
      else
        _segments[7].reset();

      // switch on the digit we have set up

      _digits[_currentDigit].set();

      // we'll be back in 1/180s which means we are displaying each digit at 60Hz
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution

  MillisecondTimer::initialise();

  // we're using interrupts, initialise NVIC

  Nvic::initialise();

  Timer7SegmentTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_7segment/timer_7segment.cpp
// START FILE: ../examples/timer_7segment/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_7segment/system/LibraryHacks.cpp
// START FILE: ../examples/st7783/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/st7783/system/LibraryHacks.cpp
// START FILE: ../examples/st7783/st7783.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * ST7783 LCD test, show a looping graphics demo
 *
 * It's a 16-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring that
 * you need to do is as follows:
 *
 * PE1  => RESET
 * PE3  => RS (D/CX) (note different to usual demos)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0    PE11 => D8
 * PD15 => D1    PE12 => D9
 * PD0  => D2    PE13 => D10
 * PD1  => D3    PE14 => D11
 * PE7  => D4    PE15 => D12
 * PE8  => D5    PD8  => D13
 * PE9  => D6    PD9  => D14
 * PE10 => D7    PD10 => D15
 * PD13 => Backlight PWM (if variable backlight)
 *
 * The code works without structural change on both the
 * F1 and F4.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class ST7783Test {

  protected:
    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef ST7783_Portrait_64K<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PE3

      GpioE<DefaultDigitalOutputFeature<1>,
            DefaultFsmcAlternateFunctionFeature<3> > pe;

      // set up the FSMC timing. these numbers (particularly the data setup time) are dependent on
      // both the FSMC bus speed and the panel timing parameters.

      Fsmc8080LcdTiming fsmcTiming(2,4);

      // set up the FSMC with RS=A19 (PE3)

      _accessMode=new LcdAccessMode(fsmcTiming,19,pe[1]);
      _gl=new LcdPanel(*_accessMode);

      // apply gamma settings

      ST7783Gamma gamma(0,0x0107,0,0x0203,0x0402,0,0x0207,0,0x0203,0x0403);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      _gl->setForeground(ColourNames::RED);
      _gl->fillRectangle(Rectangle(10,20,30,40));

      for(;;) {
        jpegTest();
        lzgTest();
        basicColoursTest();
        textTest();
        ellipseTest();
        gradientTest();
        rectTest();
        lineTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      if(_gl->getHeight()==320 && _gl->getWidth()==240) {

        prompt("JPEG bitmap test");

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle(0,0,240,320),compressedData);

        MillisecondTimer::delay(3000);
      }
    }

    void lzgTest() {

      prompt("LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,false,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,true,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,false,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,true,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,false,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t start,before,elapsed,chars;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();
      chars=0;

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);

        chars+=19;
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << (chars*1000/elapsed)  << " characters/sec";

      MillisecondTimer::delay(3000);
    }


    void clearTest() {

      uint32_t start;

      prompt("Clear screen test");

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {
        _gl->setBackground(rand());
        _gl->clearScreen();
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      uint32_t start;

      prompt("Line test");

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {
        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }
    }

    void rectTest() {

      Rectangle rc;
      uint32_t start;

      prompt("Rectangle test");

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        if(rc.Width>0 && rc.Height>0) {
          _gl->setForeground(rand());
          _gl->fillRectangle(rc);
        }
      }

      _gl->clearScreen();

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;
      uint32_t start;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 1000==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  ST7783Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/st7783/st7783.cpp
// START FILE: ../examples/adc_multi_dma_multichan/adc_multi_dma_multichan.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"
#include "config/adc.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * This example shows how to use two ADC peripherals simultaneously. ADC1 and ADC2 are used
 * to convert channels 0,1 (ADC1) and 2,3 (ADC2) simultaneously. That is, channels 0 and 2
 * are converted at the same time followed by channels 1 and 3. The order of the values in
 * the 4-value output buffer will be channel [0,2,1,3].
 *
 * USART3 remap1 is configured with protocol settings of 57600/8/N/1. The ADC channels are read
 * from PA[0], PA[1], PA[2], PA[3]. You will need to connect these GPIO inputs to valid levels
 * between GND and VREF to see conversion values.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103ZET6
 *   STM32F407VGT6
 */


class AdcMultiDmaMultiChan {

  private:
    volatile bool _ready;

  public:

    void run() {

      uint16_t dmaTransfers;

      _ready=false;

      /*
       * We're converting 4 channels in circular buffer mode so we need exactly 4 16-bit words
       * for that circular buffer
       */

      volatile uint16_t readBuffer[4];

      /*
       * Unfortunately the ADC is quite different across the MCU series so we have to
       * be MCU-specific when declaring this instance
       */

#if defined(STM32PLUS_F1)

      /*
       * Declare the ADC DMA channel. The default is circular mode for the MultiAdcDmaMode1Feature
       * which means that it wil automatically refill our buffer on each conversion because
       * one conversion exactly matches the size of the memory buffer that we will give
       * to the DMA peripheral.
       */

      Adc1DmaChannel<AdcMultiDmaFeature<Adc1PeripheralTraits>,Adc1DmaChannelInterruptFeature> dma;

      Adc1<
        AdcClockPrescalerFeature<6>,                    // PCLK2/6
        Adc1Cycle55RegularChannelFeature<0,1>,          // using channels 0,1 on ADC1 with 55.5-cycle latency
        AdcScanModeFeature,                             // scan mode
        AdcContinuousModeFeature,
        AdcDualRegularSimultaneousFeature<              // regular simultaneous multi mode
          Adc2<                                         // the second ADC
            Adc2Cycle55RegularChannelFeature<2,3>,      // using channels 2,3 on ADC2 with 55.5-cycle latency
            AdcScanModeFeature,                         // scan mode
            AdcContinuousModeFeature                    // continuous mode
          >
        >
      > adc;

      // word transfers

      dmaTransfers=2;

#elif defined(STM32PLUS_F4)

      /*
       * Declare the ADC DMA channel. The default is circular mode for the MultiAdcDmaMode1Feature
       * which means that it wil automatically refill our buffer on each conversion because
       * one conversion exactly matches the size of the memory buffer that we will give
       * to the DMA peripheral.
       */

      Adc1DmaChannel<AdcMultiDmaMode1Feature<Adc1PeripheralTraits>,Adc1DmaChannelInterruptFeature> dma;

      /*
       * Declare the ADC1 peripheral with an APB2 clock prescaler of 2, a resolution of 12 bits.
       * We will use 144-cycle conversions on ADC channels 0,1. Scan mode is used with the default
       * template parameter that causes EOC to be raised at the end of a complete conversion group.
       * ADC1 is the master so it must be the one that declares multi-mode. We're using
       * 'regular-simultaneous' multi-mode with DMA mode 1 and a 5-cycle min delay between 2 conversions.
       * The slave ADC (ADC2) is given as a type parameter to the dual ADC feature. This feature will
       * take care of instantiating it as a slave at the appropriate time.
       */

      Adc1<
        AdcClockPrescalerFeature<2>,                    // prescaler of 2
        AdcResolutionFeature<12>,                       // 12 bit resolution
        Adc1Cycle144RegularChannelFeature<0,1>,         // using channels 0,1 on ADC1 with 144-cycle latency
        AdcScanModeFeature<>,                           // scan mode with EOC after each group
        AdcDualRegularSimultaneousDmaMode1Feature<      // regular simultaneous multi mode
          Adc2<                                         // the second ADC
            AdcClockPrescalerFeature<2>,                // prescaler of 2
            AdcResolutionFeature<12>,                   // 12 bit resolution
            Adc2Cycle144RegularChannelFeature<2,3>,     // using channels 2,3 on ADC2 with 144-cycle latency
            AdcScanModeFeature<>,                       // scan mode with EOC after each group
            AdcContinuousModeFeature                    // continuous mode
          >,
          5                                             // 5 cycle min delay
        >
      > adc;

      // half-word transfers

      dmaTransfers=4;

#endif

      /*
       * Subscribe to the DMA complete interrupt
       */

      dma.DmaInterruptEventSender.insertSubscriber(
          DmaInterruptEventSourceSlot::bind(this,&AdcMultiDmaMultiChan::onComplete)
      );

      /*
       * Enable the DMA interrupt
       */

      dma.enableInterrupts(Adc1DmaChannelInterruptFeature::COMPLETE);

      /*
       * Declare an instance of USART that we'll use to write out the conversion results.
       */

      Usart3_Remap1<> usart(57600);
      UsartPollingOutputStream outputStream(usart);

      /**
       * start the DMA (i.e. make it ready to receive requests from the ADC peripheral)
       */

      dma.beginRead(readBuffer,dmaTransfers);

      /*
       * Go into an infinite loop converting
       */

      /*
       * Start a conversion and wait until the interrupt handler tells us
       * that it's finished.
       */

      adc.startRegularConversion();

      for(;;) {

        /*
         * For this test code we set the 4 16-bit words to a known pattern so we can tell if they
         * get properly overwritten by the DMA during conversion
         */

        readBuffer[0]=readBuffer[1]=readBuffer[2]=readBuffer[3]=0xAAAA;

        while(!_ready);
        _ready=false;

        /*
         * write the values to the USART
         */

        outputStream << "Converted values are "
                     << StringUtil::Ascii(readBuffer[0]) << ", "
                     << StringUtil::Ascii(readBuffer[1]) << ", "
                     << StringUtil::Ascii(readBuffer[2]) << ", "
                     << StringUtil::Ascii(readBuffer[3]) << "\r\n";

        // wait for a second before converting the next set of values

        MillisecondTimer::delay(1000);
      }
    }


    /**
     * Interrupt handler for the DMA complete event. Set the ready flag
     * when it's received.
     */

    void onComplete(DmaEventType det) {
      if(det==DmaEventType::EVENT_COMPLETE)
        _ready=true;
    }
};

int main() {

  // we're using interrupts, initialise NVIC

  Nvic::initialise();

  MillisecondTimer::initialise();

  AdcMultiDmaMultiChan adc;
  adc.run();

  // not reached
  return 0;
}
// END FILE: ../examples/adc_multi_dma_multichan/adc_multi_dma_multichan.cpp
// START FILE: ../examples/adc_multi_dma_multichan/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/adc_multi_dma_multichan/system/LibraryHacks.cpp
// START FILE: ../examples/flash_internal_settings/flash_internal_settings.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/gpio.h"
#include "config/timing.h"
#include "config/flash/internal.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * This example demonstrates saving your application configuration settings to the internal
 * flash pages of the MCU with a wear levelling strategy to ensure that your flash memory
 * does not wear out prematurely. See the comments in the InternalFlashSettingsStorage
 * template for a detailed explanation of how this works.
 *
 * Unfortunately ST have chosen to implement the internal flash with differing page sizes
 * even within the same MCU family so this example will contain preprocessor ugliness to select
 * the correct page size and flash location for each device.
 *
 * IMPORTANT: CHECK THAT THE FLASH START ADDRESS IS CORRECT FOR YOUR MCU. THE INTENTION IS
 * TO USE THE LAST PAGES IN THE DEVICES MEMORY.
 *
 * This example will exercise the code by writing the settings enough times that it will
 * wrap around back to the first page. If it works then the LED on PC8 will light solid. If there's
 * a problem then the LED will flash a number of times to indicate a numeric error code that
 * you can cross reference with the code.
 *
 * Compatible MCU (without modifying this example):
 *   STM32F051 (64Kb)
 *   STM32F407 (1Mb)
 *   STM32F415 (1Mb)
 *   STM32F417 (1Mb)
 *   STM32F103 (512Kb)
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F407VGT6
 *   STM32F103ZET6
 */

class InternalFlashSettings {

  protected:

    /*
     * The default LED pin is PC8. Change this and the port declaration in error() if your board has
     * it somewhere else
     */

    enum {
      LED_PIN = 8
    };


  public:

    /*
     * Example settings class. We'll store a string and an integer (total 14 bytes). The storage
     * required will be 14+8 rounded up to power of 2 = 32 bytes.
     */

    struct Settings {
      char stringValue[10];
      uint32_t intValue;
    };

    // set up the types needed for the storage

#if defined(STM32PLUS_F0) || defined(STM32PLUS_F1)
    typedef InternalFlashDevice<InternalFlashWriteFeature> MyFlash;
#elif defined(STM32PLUS_F4)
    typedef InternalFlashDevice<InternalFlashSectorMapF40xF41x,DefaultF407InternalFlashWriteFeature> MyFlash;
#endif

    typedef InternalFlashSettingsStorage<Settings,MyFlash> MySettingsStorage;


    /*
     * Get the first location based on the device
     */

    void getFlashParameters(uint32_t& firstLocation,uint32_t& memorySize) const {

#if defined(STM32PLUS_F0_51) || defined(STM32PLUS_F0_30)

      firstLocation=FLASH_BASE+65536-2048;           // 2Kb at the top of the 64Kb flash
      memorySize=2048;

#elif defined(STM32PLUS_F0_42)

      firstLocation=FLASH_BASE+32768-2048;           // 2Kb at the top of the 32Kb flash
      memorySize=2048;

#elif defined(STM32PLUS_F407) || defined(STM32PLUS_F415) || defined(STM32PLUS_F417)

      firstLocation=FLASH_BASE+1048576-(128*1024);   // 128Kb (last page) at the top of the 1Mb flash
      memorySize=128*1024;

#elif defined(STM32PLUS_F1_HD)

      firstLocation=FLASH_BASE+524288-4096;          // 4Kb (2x2Kb pages) at the top of 512Kb flash
      memorySize=4096;

#else
#error Unsupported MCU
#endif
    }


    /*
     * Run the test
     */

    void run() {

      // create the objects. We'll use 2 pages for the settings storage

      MySettingsStorage::Parameters params;
      getFlashParameters(params.firstLocation,params.memorySize);

      MyFlash flash;
      MySettingsStorage storage(flash,params);
      Settings settingsOut,settingsIn;
      uint8_t i;

      // erase the settings pages

      if(!storage.erase())
        error(1);

      // start the setting integer counter

      settingsOut.intValue=12345678;

      // 130 writes will cause a wrap-around on the F0 and F1.

      for(i=0;i<130;i++) {

        // increment the setting

        settingsOut.intValue++;

        // convert the integer counter to string

        StringUtil::modp_uitoa10(settingsOut.intValue,settingsOut.stringValue);

        // attempt to write to flash

        if(!storage.write(settingsOut))
          error(2);

        // attempt to read back

        if(!storage.read(settingsIn))
          error(3);

        // check that the values match

        if(settingsOut.intValue!=settingsIn.intValue || strcmp(settingsOut.stringValue,settingsIn.stringValue))
          error(4);
      }

      // reset the internal state of the storage so it has to go looking for the settings again

      storage.reset();

      // read back

      memset(&settingsIn,'\0',sizeof(settingsIn));
      if(!storage.read(settingsIn))
        error(5);

      // check values

      if(settingsOut.intValue!=settingsIn.intValue || strcmp(settingsOut.stringValue,settingsIn.stringValue))
        error(6);

      // finished OK

      error(0);
    }


    /*
     * An error occurred, light the LED constantly
     */

    void error(uint8_t flashes) {

      GpioC<DefaultDigitalOutputFeature<LED_PIN> > led;
      uint8_t i;

      if(flashes==0) {

        // success case: just light solid

        led[LED_PIN].set();
        for(;;);
      }

      for(;;) {

        for(i=0;i<flashes;i++) {

          led[LED_PIN].set();
          MillisecondTimer::delay(250);
          led[LED_PIN].reset();
          MillisecondTimer::delay(250);
        }

        // 3 second delay after the last flash

        MillisecondTimer::delay(2750);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  InternalFlashSettings ifs;
  ifs.run();

  // not reached
  return 0;
}
// END FILE: ../examples/flash_internal_settings/flash_internal_settings.cpp
// START FILE: ../examples/flash_internal_settings/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/flash_internal_settings/system/LibraryHacks.cpp
// START FILE: ../examples/spi_send_dma/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/spi_send_dma/system/LibraryHacks.cpp
// START FILE: ../examples/spi_send_dma/spi_send_dma.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/spi.h"
#include "config/dma.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * This demo illustrates sending and receiving using the SPI peripherals. A block
 * of test data is sent from SPI1 to SPI2 and, if successfully received, then a LED
 * on PF6 is flashed for 1 second. The test repeats continuously.
 *
 * The DMA channels assigned to SPI1 and SPI2 are used to perform the transfer.
 *
 * If you intend to run this example on the F4 DISCOVERY board then replace PF6
 * with PD13 to use the onboard LED.
 *
 * If you intend to run this example on the VL or F0 DISCOVERY board then replace
 * PF6 with PC8 to use the onboard LED.
 *
 * For this demo I'm going to need you to do a little wiring to hook up SPI1 to SPI2
 * so that we can exchange data over the MOSI pin. Here are the connections that
 * you need to make.
 *
 * 1MOSI/2MOSI: PA7  => PB15
 * NSS:         PA4 <=> PB12
 * SCLK:        PA5 <=> PB13
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class SpiSendDmaTest {

  protected:

    enum { LED_PIN = 6 };

  public:

    void run() {

      const uint8_t *dataToSend=(const uint8_t *)"Hello World";
      uint8_t receiveBuffer[12];

      // initialise the LED on PF6. It's active LOW so we set it HIGH to turn it off

      GpioF<DefaultDigitalOutputFeature<LED_PIN> > pf;
      pf[LED_PIN].set();

      /*
       * Declare our SPI objects with no extra features beyond the ability to send and
       * receive data bytes. SPI1 is going to be the master and SPI2 the slave. All the SPI
       * remap configurations are available with names such as Spi1_Remap if you need to use the
       * remapped pins.
       */

      typedef Spi1<> MySender;
      typedef Spi2<> MyReceiver;

      MySender::Parameters senderParams;
      MyReceiver::Parameters receiverParams;

      senderParams.spi_mode=SPI_Mode_Master;
      receiverParams.spi_mode=SPI_Mode_Slave;

      MySender sender(senderParams);
      MyReceiver receiver(receiverParams);

      /*
       * Declare the transmit and receive DMA channels assigned to the two peripherals.
       * We'll give reception a higher priority than transmit since we are both the
       * sender and the receiver.
       *
       * On the F4 the DMA FIFO is enabled by default. If you want to disable the FIFO then
       * you can do that with an additional template parameter to SpiDmaWriterFeature and
       * SpiDmaReaderFeature.
       */

      Spi1TxDmaChannel<SpiDmaWriterFeature<Spi1PeripheralTraits,DMA_Priority_Medium> > dmaSender;
      Spi2RxDmaChannel<SpiDmaReaderFeature<Spi2PeripheralTraits,DMA_Priority_High> > dmaReceiver;

      for(;;) {

        /*
         * Clear out the receive buffer for this session
         */

        memset(receiveBuffer,0,12);

        /*
         * Start the DMA receiver ready for the data
         */

        dmaReceiver.beginRead(receiveBuffer,12);

        /*
         * NSS (slave select) is active LOW. ST made such a mess of the hardware implementation of NSS
         * that we always control it through software. Here it's pulled LOW ready for transmission.
         */

        sender.setNss(false);

        /*
         * Start the DMA sender and let those bytes flow. The receiver has already been started and is
         * stalled waiting for this
         */

        dmaSender.beginWrite(dataToSend,12);

        /*
         * Wait until the receiver gets all the bytes
         */

        if(!dmaReceiver.waitUntilComplete()) {
          // handle error properly

          for(;;);
        }

        /*
         * Wait until the sender has signalled that it's finished
         */

        if(!dmaSender.waitUntilComplete()) {
          // handle error properly

          for(;;);
        }

        /*
         * The session is complete, wait for the last transmission then deactivate NSS.
         */

        sender.waitForIdle();
        sender.setNss(true);

        /*
         * Test the received buffer. If the data is incorrect then lock up
         */

        if(memcmp(receiveBuffer,dataToSend,12)!=0)
          for(;;);

        /*
         * The data is correct, flash the LED on PF6 for one second
         */

        pf[LED_PIN].reset();
        MillisecondTimer::delay(1000);
        pf[LED_PIN].set();
        MillisecondTimer::delay(1000);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  MillisecondTimer::initialise();

  SpiSendDmaTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/spi_send_dma/spi_send_dma.cpp
// START FILE: ../examples/net_udp_receive_async/net_udp_receive_async.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/timing.h"
#include "config/usart.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This example demonstrates how to receive UDP packets from a remote host. After obtaining an IP
 * address via DHCP this example will wait for UDP datagrams to arrive on port 12345. When a
 * datagram arrives it will print the first 10 bytes to USART #3. The reception is done
 * asynchronously via a subscription to an event provided by the network stack's UDP module.
 *
 * For testing I recommend the Linux NPING utility that allows you to create hand-crafted
 * network packets to send to your device. For example, here's how to send a byte sequence of
 * 1..10 to your device on 192.168.1.5 using nping:
 *
 * nping --udp 192.168.1.5 -p 12345 --data 0102030405060708090a
 *
 * If there are any errors then they are output to a USART which for me is
 * USART3 57600/8/N/1
 *
 * DHCP lease renewal is not considered here - see the DHCP example for the
 * correct procedure.
 *
 * Here's how the network stack for this example is configured:
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient                 |
 *              +----------------------------+
 * TRANSPORT:   | Udp                        |
 *              +-----+----------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +-----------------------------
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 */

class NetUdpReceiveAsyncTest {

  public:

    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    TextOutputStream *_outputStream;


    /*
     * State variables to manage the incoming datagram
     */

    volatile bool _datagramArrived;
    volatile uint16_t _datagramDataSize;
    volatile uint8_t _datagramData[10];
    volatile IpAddress _remoteAddress;


    /*
     * Run the test
     */

    void run() {

      // nothing arrived yet

      _datagramArrived=false;

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      UsartPollingOutputStream usartStream(*_usart);
      _outputStream=new TextOutputStream(usartStream);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetUdpReceiveAsyncTest::onError));

      // subscribe to incoming datagrams from the UDP module

      _net->UdpReceiveEventSender.insertSubscriber(UdpReceiveEventSourceSlot::bind(this,&NetUdpReceiveAsyncTest::onReceive));

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      for(;;) {

        char buffer[20];

        if(_datagramArrived) {

          // a datagram has been received, print the address of the sender

          const_cast<IpAddress&>(_remoteAddress).toString(buffer);

          *(_outputStream) << "From: " << buffer << ": ";

          // now print out the first 10 bytes

          for(uint16_t i=0;i<_datagramDataSize;i++)
            (*_outputStream) << (uint16_t) _datagramData[i] << " ";

          (*_outputStream) << "\r\n";

          // ready for another

          _datagramArrived=false;
        }
      }
    }


    /**
     * A datagram has arrived. Since we are going to see every datagram sent
     * to this host we'll quickly check that the port is ours (12345) and if
     * it is then we'll copy out some data and set the flag that indicates
     * we have data. This is IRQ code so no messing around, do what you have
     * to do and get out.
     * @param event The UDP datagram event
     */

    void onReceive(UdpDatagramEvent& event) {

      // the datagram structure in the event it straight off the network so
      // the multibyte numbers are all in big-endian order

      if(event.udpDatagram.udp_destinationPort!=NetUtil::htons(12345))
        return;

      // it's for us, set the handled flag - if this is not done then an ICMP port
      // unreachable message may be sent back to the sender (depending on your configuration)

      event.handled=true;

      // get the remote address of the sender

      _remoteAddress=event.ipPacket.header->ip_sourceAddress;

      // the datagram length includes the UDP network header (8 bytes)

      _datagramDataSize=NetUtil::ntohs(event.udpDatagram.udp_length)-UdpDatagram::getHeaderSize();

      // cut it down to a max of 10 bytes

      _datagramDataSize=_datagramDataSize<=10 ? _datagramDataSize : 10;

      // copy out the data and notify it's here

      memcpy((void *)_datagramData,event.udpDatagram.udp_data,_datagramDataSize);
      _datagramArrived=true;
    }


    /**
     * Network error event received, report it
     * @param ned The error event
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetUdpReceiveAsyncTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_udp_receive_async/net_udp_receive_async.cpp
// START FILE: ../examples/net_udp_receive_async/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_udp_receive_async/system/LibraryHacks.cpp
// START FILE: ../examples/net_web_client/net_web_client.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/net_http.h"
#include "config/timing.h"
#include "config/usart.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This example shows how to use the HttpClientConnection to retrieve an HTTP resource. In this example
 * we will connect to http://www.st.com and ask for the root document. We will write the response to
 * the USART.
 *
 * I use USART3, remap-2 with settings 57000/8/N/1.
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient | Dns           |
 *              +------+---------------------+
 * TRANSPORT:   | Tcp | Udp                  |
 *              +-----++---------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +----------------------------+
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 */

class NetHttpClientTest {

  public:

    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp,Tcp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient,Dns> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    UsartPollingOutputStream *_outputStream;


    /*
     * Run the test
     */

    void run() {

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      _outputStream=new UsartPollingOutputStream(*_usart);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetHttpClientTest::onError));

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      // look up the IP address for www.st.com

      *_outputStream << "Looking up the DNS address for www.st.com\r\n";

      IpAddress address;
      if(!_net->dnsHostnameQuery("www.st.com",address)) {
        *_outputStream << "Failed to look up www.st.com\r\n";
        error();
      }

      *_outputStream << "Connecting to www.st.com:80\r\n";

      // create the connection

      TcpClientConnection *ptr;

      if(!_net->tcpConnect<TcpClientConnection>(address,80,ptr)) {
        *_outputStream << "Failed to connect to www.st.com\r\n";
        error();
      }

      {
        // manage the connection pointer in a scoped_ptr so it's automatically deleted (and closed)
        // when it goes out of scope

        scoped_ptr<TcpClientConnection> conn(ptr);
        HttpClient httpClient(*conn);

        // set the parameters for the HTTP GET

        httpClient.setUri("/");             // get the root document
        httpClient.setHost("www.st.com");   // host header is mandatory for HTTP/1.1

        // send it

        *_outputStream << "Sending request to server\r\n";

        if(!httpClient.sendRequest()) {
          *_outputStream << "Failed to send the request to the server\r\n";
          error();
        }

        // must have a content-length for this test call

        int32_t contentLength;

        if((contentLength=httpClient.getResponseContentLength())==-1) {
          *_outputStream << "Server did not send a Content-Length header\r\n";
          error();
        }

        // read back the response in 100 byte chunks with a 60 second timeout

        uint8_t buffer[100];
        uint32_t actuallyRead;

        *_outputStream << "Reading response body from the server\r\n";

        while(contentLength) {

          // read a chunk

          if(!conn->receive(buffer,std::min(contentLength,100L),actuallyRead,60000)) {
            *_outputStream << "Timed out waiting for data from the server\r\n";
            error();
          }

          if(actuallyRead==0) {
            *_outputStream << "The remote end has closed the connection\r\n";
            error();
          }

          // push out to the USART

          _outputStream->write(buffer,actuallyRead);

          // decrease amount remaining

          contentLength-=actuallyRead;
        }

        *_outputStream << "Finished reading response body\r\n";
      }

      // finished, reset the board to try again

      for(;;);
    }


    /**
     * Network error event received, report it
     * @param ned
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetHttpClientTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_web_client/net_web_client.cpp
// START FILE: ../examples/net_web_client/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_web_client/system/LibraryHacks.cpp
// START FILE: ../examples/net_dns/net_dns.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/timing.h"
#include "config/usart.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This examples demonstrates the use of the DNS client to look up a host name on the internet.
 * In this example we will look up "www.google.co.uk". After obtaining an IP address and our DNS
 * servers via DHCP this example will perform the DNS lookup.
 *
 * The results of the DNS query and any errors are sent to USART3 configured as 57600/8/N/1.
 *
 * DHCP lease renewal is not considered here - see the DHCP example for the correct procedure.
 *
 * Here's how the network stack for this example is configured:
 *
 *              +-------------+--------------+
 * APPLICATION: | DhcpClient  | Dns          |
 *              +-------------+--------------+
 * TRANSPORT:   | Udp                        |
 *              +-----+----------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +-----------------------------
 *
 * This example is also tested using the KSZ8051MLL in MII mode instead of the DP83848C/RMII.
 * The KSZ8051MLL test was performed on the STM32F107. The DP83848C was tested on the STM32F407.
 * To reconfigure this demo for the F107 using remapped MAC pins connected to the KSZ8051MLL change
 * the physical and datalink layers thus:
 *
 * typedef PhysicalLayer<KSZ8051MLL> MyPhysicalLayer;
 * typedef DatalinkLayer<MyPhysicalLayer,RemapMiiInterface,Mac> MyDatalinkLayer;
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 *   STM32F407ZGT6
 */


class NetDnsTest {

  public:

    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient,Dns> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    UsartPollingOutputStream *_outputStream;

    /*
     * Run the test
     */

    void run() {

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      _outputStream=new UsartPollingOutputStream(*_usart);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference.  Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // spy on the DHCP announcements for DNS servers
      // by subscribing to the notification events passed around the network stack

      _net->NetworkNotificationEventSender.insertSubscriber(
          NetworkNotificationEventSourceSlot::bind(this,&NetDnsTest::onNotification)
        );

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(
          NetworkErrorEventSourceSlot::bind(this,&NetDnsTest::onError)
        );

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      // now query for google UK's host name (the default timeout is 5000ms,
      // configurable with 'dns_timeout' in the stack's parameters

      IpAddress ipAddress;
      char buf[30];

      if(!_net->dnsHostnameQuery("www.google.co.uk",ipAddress))
        error();

      // write out the results

      ipAddress.toString(buf);
      *_outputStream << "www.google.co.uk = " << buf << "\r\n";

      for(;;);
    }


    /**
     * A notification event was received from the stack
     * @param ned
     */

    void onNotification(NetEventDescriptor& ned) {

      char buf[30];
      uint8_t i;

      // write out the DNS servers obtained via DHCP

      if(ned.eventType==NetEventDescriptor::NetEventType::DNS_SERVERS_ANNOUNCEMENT) {

        IpDnsServersAnnouncementEvent& dnsevent(static_cast<IpDnsServersAnnouncementEvent&>(ned));

        for(i=0;i<3;i++) {
          if(dnsevent.ipDnsServers[i].isValid()) {
            dnsevent.ipDnsServers[i].toString(buf);
            *_outputStream << "DNS server: " << buf << "\r\n";
          }
        }
      }
    }


    /**
     * Network error event received, report it
     * @param ned
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetDnsTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_dns/net_dns.cpp
// START FILE: ../examples/net_dns/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_dns/system/LibraryHacks.cpp
// START FILE: ../examples/usart_receive_dma/usart_receive_dma.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


using namespace stm32plus;


/**
 * USART test: synchronous receiving data
 *
 * This example will receive 5 characters from the PC over USART1 using the DMA channel and then
 * immediately echo them back, also using the DMA channel.
 *
 * Connect an RS232 cable from USART1 to your PC and run a terminal program (there are many free
 * terminal programs) and type 5 characters into it. Those 5 characters will be echo'd back
 * to the terminal.
 *
 * Note that if you are using the STM32F4DISCOVERY board then you cannot use USART1 since the pins
 * clash with onboard peripherals. I have tested this code on that board using USART2.
 *
 * The protocol is 57600/8/N/1
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class UsartReceiveDmaTest {

  public:

    void run() {

      /*
       * Declare a USART1 object. Note that an alternative Usart1_Remap object is available
       * if your application demands that you use the alternate pins for USART1
       */

      Usart1<> usart(57600);

      Usart1TxDmaChannel<UsartDmaWriterFeature<Usart1PeripheralTraits> > dmaWriter;
      Usart1RxDmaChannel<UsartDmaReaderFeature<Usart1PeripheralTraits> > dmaReader;

      /*
       * Go into a loop reading 5 characters at a time and then writing them
       * right back again.
       */

      for(;;) {

        uint8_t buffer[5];

        dmaReader.beginRead(buffer,sizeof(buffer));
        dmaReader.waitUntilComplete();

        dmaWriter.beginWrite(buffer,sizeof(buffer));
        dmaWriter.waitUntilComplete();
      }
    }
};


/*
 * Main entry point
 */

int main() {

  UsartReceiveDmaTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usart_receive_dma/usart_receive_dma.cpp
// START FILE: ../examples/usart_receive_dma/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usart_receive_dma/system/LibraryHacks.cpp
// START FILE: ../examples/can_master_send_receive/can_master_send_receive.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"
#include "config/can.h"


using namespace stm32plus;


/**
 * This example initialize the CAN peripheral at 500 kBits/s with 87.5% sampling point.
 * To get incoming messages needed to bypass the CAN filtering.
 * With the bypassing we get all messages to FIFO 0, so we need to enable the FMP0
 * interrupt.
 *
 * After the peripheral is initialised we go into an infinite loop sending and receiving
 * 8-byte frames and checking the data content after each reception. If it works then
 * a LED on PF6 will be flashed at 1Hz. If something goes wrong then the PF6 will be set
 * high and the firmware will lock up.
 *
 * If your board does not have a LED on PF6 then you will need to adjust LED_PIN and the
 * GpioF declarations accordingly.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103C8T6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */


class CanMasterSendReceive {

  private:

    // declare the CAN1 master instance

    Can1<
      Can1InterruptFeature,           // interrupt driven reception
      CanLoopbackModeFeature,         // running in loopback mode
      Can1FilterBypassFeature
    > _can;

    volatile bool _ready;
    volatile uint8_t _receiveData[8];

    enum { LED_PIN = 6 };

  public:

    CanMasterSendReceive() : _can( { 500000,875 } ) {
    }

    void run() {

      uint32_t now;
      bool ledState;
      uint8_t nextByte,i;
      uint8_t sendData[8];

      /*
       * subscribe to receive interrupts and enable FMP0
       */

      _can.CanInterruptEventSender.insertSubscriber(CanInterruptEventSourceSlot::bind(this,&CanMasterSendReceive::onCanInterrupt));
      _can.enableInterrupts(CAN_IT_FMP0);

      /*
       * set up the LED on PF6
       */

      GpioF<DefaultDigitalOutputFeature<LED_PIN>> pf;

      /*
       * Go into an infinite loop sending a message per second
       */

      nextByte=0;
      ledState=false;

      for(;;) {

        // create an 8-byte message

        for(i=0;i<sizeof(sendData);sendData[i++]=nextByte++);

        // prepare the receive state

        _ready=false;
        for(i=0;i<sizeof(_receiveData);_receiveData[i++]='\0');

        // send the message

        _can.send(0x100,sizeof(sendData),sendData);

        // wait for it to arrive for a maximum of 5 seconds

        now=MillisecondTimer::millis();

        while(!_ready)
          if(MillisecondTimer::hasTimedOut(now,5000))
            error(pf[LED_PIN]);

        // check the data content

        for(i=0;i<sizeof(sendData);i++)
          if(sendData[i]!=_receiveData[i])
            error(pf[LED_PIN]);

        // wait for a second and toggle the LED to indicate we're working

        ledState^=true;
        pf[LED_PIN].setState(ledState);

        MillisecondTimer::delay(1000);
      }
    }


    /*
     * receive IRQ callback
     */

    void onCanInterrupt(CanEventType cet) {

    	CanRxMsg msg;
    	uint8_t i;

    	if(cet == CanEventType::EVENT_FIFO0_MESSAGE_PENDING) {

    	  _can.receive(CAN_FIFO0, &msg);

    	  for(i=0;i<sizeof(_receiveData);i++)
    	    _receiveData[i]=msg.Data[i];

    	  _ready=true;
      }
    }


    /*
     * An error occurred, lock up with the LED on
     */

    void error(const GpioPinRef& led) {
      led.set();
      for(;;);
    }
};


int main() {

  // we're using interrupts, initialise NVIC
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  CanMasterSendReceive test;
  test.run();

  // not reached
  return 0;
}





// END FILE: ../examples/can_master_send_receive/can_master_send_receive.cpp
// START FILE: ../examples/can_master_send_receive/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/can_master_send_receive/system/LibraryHacks.cpp
// START FILE: ../examples/fatfs_writer/fatfs_writer.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/nvic.h"
#include "config/sdcard.h"
#include "config/filesystem.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * FAT file system writer demo.
 *
 * This example will create a file called "test.txt" in a
 * directory called "output" on the SD card. If the
 * directory does not exist then it will be created. If
 * the file does exist then it will be deleted before we
 * open it for writing.
 *
 * When we're done writing to it we will re-open the
 * file and write the content to USART1.
 *
 * Note that if you are using the STM32F4DISCOVERY board
 * then you cannot use Usart1 since the pins clash with
 * onboard peripherals. I have tested this code on that
 * board using Usart2.
 *
 * The SD card must be inserted and ready when this
 * application runs. This demo was tested on a 4Gb
 * class 10 SDHC microSD card.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class FatFsWriterTest  {

  protected:

    // SD card and file system objects

    SdioDmaSdCard *_sdcard;
    FileSystem *_fs;
    NullTimeProvider _timeProvider;

    // USART objects

    typedef Usart1<> MyUsart;
    MyUsart *_usart;

  public:

    /*
     * Run the demo
     */

    void run() {

      // initialisation for the card and LCD

      initUsart();
      initSdcard();

      // now do the work

      ensureDirectoryExists();
      ensureFileDoesNotExist();
      writeToFile();
      sendFile();

      // we're done - lock up

      for(;;);
    }


    /*
     * Ensure that /output exists. If it does not then it will be created. If it
     * does exist then we check that it is a directory and not a file.
     */

    void ensureDirectoryExists() {

      FileInformation *info;

      // get a FileInformation for the directory

      if(_fs->getFileInformation("/output",info)) {

        // it exists - but if it's a file then it's an error

        if((info->getAttributes() & FileInformation::ATTR_DIRECTORY)==0)
          error();

        // it's a directory, that's OK

        delete info;
        return;
      }

      // it does not exist, create it

      if(!_fs->createDirectory("/output"))
        error();
    }


    /*
     * Ensure that the file does not exist. If it does exist then
     * it will be deleted.
     */

    void ensureFileDoesNotExist() {

      FileInformation *info;

      // get a FileInformation for the file

      if(_fs->getFileInformation("/output/test.txt",info)) {

        // it exists - make sure it's not a directory

        if((info->getAttributes() & FileInformation::ATTR_DIRECTORY)!=0)
          error();

        // clean up

        delete info;

        // we know it's a file, delete it

        if(!_fs->deleteFile("/output/test.txt"))
          error();

        return;
      }
    }


    /*
     * Write the text "Hello World" to /output/test.txt. It is not necessary to delete/create
     * the file - it could be re-opened and overwritten either from the beginning or by seeking
     * to the end and appending to it.
     */

    void writeToFile() {

      File *file;

      // any previous file has been erased, open this file. there is no concept of file mode
      // here - any file can be read or written to.

      if(!_fs->createFile("/output/test.txt"))
        error();

      // open the 0 byte file

      if(!_fs->openFile("/output/test.txt",file))
        error();

      // write some test data

      if(!file->write("Hello World",11))
        error();

      // finished with the file - close it

      delete file;
    }


    /*
     * open the file and send the contents to the USART
     */

    void sendFile() {

      File *file;

      // open the file - we own the file pointer that comes back upon success and
      // we must remember to delete it when we're finished

      if(!_fs->openFile("/output/test.txt",file))
        error();

      // attach an input stream to the file for easy sequential reading and an output
      // stream to the usart for writing

      FileInputStream input(*file);
      UsartPollingOutputStream output(*_usart);

      // the ConnectedInputOutputStream is a piece of plumbing that will copy one
      // stream to another either as a whole or in chunks

      ConnectedInputOutputStream connector(input,output);

      // copy the entire file to the USART

      if(!connector.readWrite())
        error();

      // finished with the file

      delete file;
    }


    /*
     * Initialise the USART in 57600-8-N-1 mode with no hardware flow control
     */

    void initUsart() {

      // configure the USART peripheral

      _usart=new MyUsart(57600);
    }


    /*
     * Initialise the SD card and get a reference to a file system object. FAT16 and FAT32
     * are both supported.
     */

    void initSdcard() {

      // create the SDIO object and let it auto-initialise

      _sdcard=new SdioDmaSdCard;

      if(errorProvider.hasError())
        error();

      // initialise a file system from that found on the card

      if(!FileSystem::getInstance(*_sdcard,_timeProvider,_fs))
        error();
    }


    /*
     * Print an error code if something goes wrong and lock up
     */

    void error() {

      char *ptr,errorCode[30];

      // print the error code

      StringUtil::modp_uitoa10(errorProvider.getLast(),errorCode);

      for(ptr=errorCode;*ptr;ptr++)
        _usart->send(*ptr);

      // lock up

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // set up the NVIC priority groups and subgroups
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  FatFsWriterTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/fatfs_writer/fatfs_writer.cpp
// START FILE: ../examples/fatfs_writer/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/fatfs_writer/system/LibraryHacks.cpp
// START FILE: ../examples/net_tcp_server/net_tcp_server.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/timing.h"
#include "config/usart.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This example demonstrates a TCP 'echo' server. Telnet to this server and type lines of text at it
 * to see them echo'd back. Maximum 100 characters per line, please. Multiple simultaneous connections
 * are supported up to the configured maximum per server. The 'TcpConnectionArray' class takes care of
 * the connection multiplexing for you. All you need to do to run a server is subclass TcpConnection
 * and implement the handleRead(), handleWrite() and handleClose() methods as demonstrated below.
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient                 |
 *              +------+---------------------+
 * TRANSPORT:   | Tcp | Udp                  |
 *              +-----++---------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +----------------------------+
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 */

class NetTcpServerTest {

  public:

    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp,Tcp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /**
     * Our connection class. The TCP server is templated to return instances of this class when
     * remote clients connect. Each instance of this class independently handles an incoming
     * connection. This model allows you to easily service multiple connections without having
     * to worry about doing the multiplexing yourself. When you're done with a connection just
     * delete it and the event system will take care of all necessary close and cleanup.
     *
     * This example server will read lines of text from the connection and echo them back as you
     * type them. The idea is that you telnet to the server and type lines into it.
     */

    class MyTcpConnection : public TcpConnection {

      protected:

        uint32_t pos;
        uint32_t length;
        bool reading;
        char buffer[101];

      public:

        /**
         * Default constructor. Make sure to call up to base class constructor
         * with the parameters class instance as a reference.
         */

        MyTcpConnection(const Parameters& params)
          : TcpConnection(params) {

          pos=0;
          reading=true;
        }


        /**
         * Read data from the remote end up to a linefeed
         * @return true
         */

        bool handleRead() {

          uint32_t actuallyRead;

          // must be reading state

          if(!reading)
            return true;

          // read up to a \n or we run out of data

          for(;;) {

            if(!receive(&buffer[pos],1,actuallyRead,1) || actuallyRead!=1)
              return true;

            if(buffer[pos++]=='\n') {
              reading=false;
              length=pos;
              pos=0;
              return true;
            }
          }
        }


        /**
         * Echo back the data from the remote end
         * @return true
         */

        bool handleWrite() {

          uint32_t actuallySent;

          // must be writing

          if(reading)
            return true;

          // try to send all remaining

          if(!send(buffer+pos,length,actuallySent,0))
            return true;

          // update counters

          pos+=actuallySent;
          length-=actuallySent;

          // if all gone then flip back to reading

          if(length==0) {
            pos=0;
            reading=true;
          }

          return true;
        }


        /**
         * Callback for when the connection is detected to be closed. We will self-destruct which will
         * cause the connection-released event to be fired and the connection state will be transferred
         * back to the network stack where the TCP closing sequence is managed. The connection itself
         * will be automatically removed from the connections array.
         * @return true - no need to abort the connection round robin.
         */

        bool handleClosed() {
          delete this;
          return true;
        }


        /**
         * Round-robin opportunity to do some processing. We're not interested.
         * @return true
         */

        bool handleCallback() {
          return true;
        }
    };


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    UsartPollingOutputStream *_outputStream;


    /*
     * Run the test
     */

    void run() {

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      _outputStream=new UsartPollingOutputStream(*_usart);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetTcpServerTest::onError));

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      // create a TCP server on port 12345

      TcpServer<MyTcpConnection> *tcpServer(nullptr);

      if(!_net->tcpCreateServer(12345,tcpServer))
        error();

      // create an array to hold the active connections and configure it to
      // automatically receive connections as they arrive. It will also
      // automatically remove connections as they are closed.

      TcpConnectionArray<MyTcpConnection> connections(*tcpServer);

      // now all the plumbing is in place, open up the server to start
      // accepting connection requests

      tcpServer->start();
      *_outputStream << "TCP server started\r\n";

      // loop forever servicing connections via their handleXXX() methods

      connections.wait(TcpWaitState::READ | TcpWaitState::WRITE | TcpWaitState::CLOSED,0);
    }


    /**
     * Network error event received, report it
     * @param ned
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetTcpServerTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_tcp_server/net_tcp_server.cpp
// START FILE: ../examples/net_tcp_server/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_tcp_server/system/LibraryHacks.cpp
// START FILE: ../examples/sdio/sdio.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/sdcard.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * SD card demonstration using the onboard SDIO peripheral in high-speed 4-bit mode.
 * This example will erase 100 blocks from 20000 to 20099, then write a bit-pattern to
 * each of these blocks and finally read back each block to verify the bit-pattern.
 * Blocks are always 512 bytes in size, even if your card is a non-SDHC card that has
 * physical block sizes that are not 512 bytes.
 *
 * If all is OK then a LED on PF[6] will be flashed for 1-second at the end of each of
 * the erase, write, read sequences. If anything goes wrong then the LED will flash
 * rapidly at 5Hz.
 *
 * The SdioDmaSdCard class encapsulates access to the SDIO peripheral classes and uses
 * DMA and interrupts to transfer data. The default constructor will automatically detect
 * appropriate SDIO initialisation and transfer frequencies based on targets of 400kHz and
 * 24MHz, respectively. You can tune these dividers by using an SdioDmaSdCard constructor
 * parameter of 'false' (see the code comments below).
 *
 * Please note that this demo is destructive to any files that happen to be on your SD card
 * and are unfortunate enough to be located on the blocks we target. You should reformat the
 * card after you're done.
 *
 * Wiring:
 *   PC12 => SDIO_CLK
 *   PC8  => SDIO_D0
 *   PC9  => SDIO_D1
 *   PC10 => SDIO_D2
 *   PC11 => SDIO_D3
 *   PD2  => SDIO_CMD
 *
 * stm32plus enables the internal pullups on the data and command lines so you do not need
 * to connect external pullup resistors.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6
 *   STM32F103VET6
 *   STM32F103ZET6
 */

class SdioTest {

  protected:

    GpioF<DefaultDigitalOutputFeature<6> > _pf;
    SdioDmaSdCard *_sdcard;

  public:

      void run() {

        /*
         * Clear the LED. Our LED on PF[6] is active LOW.
         */

        _pf[6].set();


        /*
         * Initialise the sdcard with the SDIO interface feature. The constructor will attempt
         * to detect the initialisation and transfer clock dividers automatically for target frequencies
         * of 200kHz and 24MHz, respectively. You can override these by calling setInitDivider() and
         * setTransferDivider() and use 'false' as the constructor parameter so that the auto-init
         * does not happen. In this case you will need to call powerOn() and initialiseCard() yourself.
         */

        _sdcard=new SdioDmaSdCard;

        /*
         * Check for any errors raised in the constructor
         */

        if(errorProvider.hasError())
          error();

        for(;;) {

          eraseBlocks();

          writeSingleBlocks();
          readSingleBlocks();

          writeMultiBlocks();
          readMultiBlocks();

          // wait 5 seconds and do it again. it's not a good idea to go into a tight
          // program/erase loop with flash memory because it can wear out

          MillisecondTimer::delay(5000);
        }
      }



      /*
       * Erase blocks 20000 to 20099
       */

      void eraseBlocks() {

        // erase the blocks

        if(!_sdcard->eraseBlocks(20000,20099))
          error();

        // it worked

        signalOK();
      }


      /*
       * Write blocks 20000 to 20099 using the single block write command
       */

      void writeSingleBlocks() {

        int i;
        uint8_t block[512];

        // init the block

        for(i=0;i<512;i++)
          block[i]=i & 0xff;

        for(i=20000;i<20099;i++)
          if(!_sdcard->writeBlock(block,i))
            error();

        // it worked

        signalOK();
      }


      /*
       * Write blocks 20000 to 20099 using the multi-block write command
       * to write 20 blocks at a time
       */

      void writeMultiBlocks() {

        uint32_t i;
        uint8_t block[512*20];

        // init the blocks

        for(i=0;i<512*20;i++)
          block[i]=i & 0xff;

        for(i=20000;i<20099;i+=20)
          if(!_sdcard->writeBlocks(block,i,20))
            error();

        // it worked

        signalOK();
      }


      /*
       * Read blocks 20000 to 20099 using the single block read command
       */

      void readSingleBlocks() {

        int i,j;
        uint8_t block[512];

        // read each block

        for(i=20000;i<20099;i++) {

          // read this block

          if(!_sdcard->readBlock(block,i))
            error();

          // verify the content

          for(j=0;j<512;j++)
            if(block[j]!=(j & 0xff))
              error();
        }

        // it worked

        signalOK();
      }


      /*
       * Read blocks 20000 to 20099 using the multi-block read command
       * to read 20 blocks at a time
       */

      void readMultiBlocks() {

        uint32_t i,j;
        uint8_t blocks[512*20];

        for(i=20000;i<20099;i+=20) {

          // read these blocks

          if(!_sdcard->readBlocks(blocks,i,20))
            error();

          // verify the content

          for(j=0;j<512*20;j++)
            if(blocks[j]!=(j & 0xff))
              error();
        }

        // it worked

        signalOK();
      }


      /*
       * Signal that we completed an operation OK
       */

      void signalOK() {
        _pf[6].reset();                     // on
        MillisecondTimer::delay(1000);      // wait a second
        _pf[6].set();                       // off
        MillisecondTimer::delay(1000);      // wait a second
      }


      /*
       * There's been an error. Lock up and flash the LED on PF6 rapidly
       */

      void error() {

        for(;;) {

          _pf[6].set();
          MillisecondTimer::delay(200);
          _pf[6].reset();
          MillisecondTimer::delay(200);
        }
      }
  };


/*
 * Main entry point
 */

int main() {

  // we're using timing

  MillisecondTimer::initialise();

  // configure Nvic

  Nvic::initialise();

  SdioTest sdio;
  sdio.run();

  // not reached
  return 0;
}
// END FILE: ../examples/sdio/sdio.cpp
// START FILE: ../examples/sdio/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/sdio/system/LibraryHacks.cpp
// START FILE: ../examples/power/power.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/exti.h"
#include "config/power.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * Low power modes test. This example requires a pushbutton wired to PA8 and an
 * indicator LED wired to PF6.
 *
 * The LED will continually flash as 250ms intervals until the button is pressed
 * at which point the MCU will go into STOP mode pending an interrupt to wake
 * it up. Press the button again will cause the EXTI interrupt that will wake it up.
 *
 * The commented out line _lpm.standby() can be substituted for the stopInterruptWakeup()
 * call to cause the MCU to enter STANDBY mode. STANDBY can be exited by WAKEUP,
 * IWDG, RTC alarm and of course external reset. STANDBY mode clears SRAM therefore
 * execution after wakeup is back at the start of your program (the reset handler).
 *
 * To run this example on the STM32F4DISCOVERY board change the LED pin to PD13 to use
 * the onboard LED and change the button pin to PA0 to use the onboard user button.
 * Also change Exti8 to Exti0 to match the button pin number.
 *
 * To run this example on the STM32VLDISCOVERY board change the LED pin to PC8 to
 * use the onboard LED and change the button pin to PA0 to use the onboard
 * user button. Also change Exti8 to Exti0 to match
 * the button pin number.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class PowerTest {

  protected:

    enum {
      BUTTON_PIN = 8,
      LED_PIN = 6
    };

    LowPowerModes _lpm;
    bool _triggered;

  public:

    void run() {

      // initialise the LED and button pins

      GpioF<DefaultDigitalOutputFeature<LED_PIN> > pf;
      GpioA<DefaultDigitalInputFeature<BUTTON_PIN> > pa;

      // subscribe to interrupts from the button

      Exti8 exti(EXTI_Mode_Interrupt,EXTI_Trigger_Falling,pa[BUTTON_PIN]);

      exti.ExtiInterruptEventSender.insertSubscriber(
          ExtiInterruptEventSourceSlot::bind(this,&PowerTest::onInterrupt)
        );

      // if we're here because of a previous standby then flash quickly 3 times

      if(LowPowerModes::wasInStandby())
        flashLed(pf[LED_PIN],3);

      // if we're here because of a wakeup then flash quickly 6 times

      if(LowPowerModes::wasWokenUp())
        flashLed(pf[LED_PIN],6);

      // enable the WAKEUP pin

      _lpm.enableWakeup();

      _triggered=false;

      for(;;) {

        // flash the LED

        pf[LED_PIN].set();
        MillisecondTimer::delay(250);
        pf[LED_PIN].reset();
        MillisecondTimer::delay(250);

        // if the interrupt set the trigger, do our stuff

        if(_triggered) {

          // wakeup following STOP will continue after here
          _lpm.stopInterruptWakeup();

          // wakeup following STANDBY will reset the device
          //_lpm.standby();

          _triggered=false;
        }
      }
    }

    /*
     * Observer notification callback for the EXTI interrupt that's wired to the falling
     * edge of the button GPIO line.
     */

    void onInterrupt(uint8_t /* extiLine */) {
      _triggered=true;
    }


    /**
     * Flash the LED for the number times then wait 3 seconds
     * @param count number of times to flash
     */

    void flashLed(const GpioPinRef& gpio,int count) {

      for(int i=0;i<count;i++) {
        gpio.reset();
        MillisecondTimer::delay(100);
        gpio.set();
        MillisecondTimer::delay(100);
      }

      MillisecondTimer::delay(3000);
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  PowerTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/power/power.cpp
// START FILE: ../examples/power/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/power/system/LibraryHacks.cpp
// START FILE: ../examples/timer_encoder/timer_encoder.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"
#include "config/timer.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * This timer example demonstrates the use of the encoder feature. The STM32's timers understand
 * the phase relationship between two signals output by a rotary encoder and can translate those
 * rising and falling edges into up/down movements of a counter. All you need to do is to connect
 * up the two encoder output pins to channels 1 and 2 of a timer and then configure the timer to
 * operate in encoder mode. The timer's counter will then tick up and down as the encoder is operated.
 *
 * We will use timer 1 to receive the encoder inputs. We will subscribe to capture/compare interrupts
 * so that we get notified when the encoder is moved rather than having to poll for it. We will light
 * different LEDs depending on the direction that the encoder is turned and we will output the value
 * of the counter to the USART.
 *
 * We will also cater for the optional "index pin" that resets the counter to a known value when
 * its triggered. This should be connected to PA0. If you're simulating the encoder then you can
 * press the blue USER button on the F4 discovery board to trigger this.
 *
 * Some wiring is obviously required.
 *
 * If you have an encoder then wire the outputs to PA8, PA9 and remove the call to simulateSignals()
 * in the code. simulateSignals() allows you to validate your code before attaching your hardware.
 * To run in simulation mode you must wire PA2 => PA8 and PA3 => PA9. The simulator will pretend to
 * be an encoder and stimulate the encoder TI1 and TI2 inputs according to a known pattern. See the
 * file simulation_waveform.png for a logic-analyser capture of the simulation waveform.
 *
 * F4 Discovery board:
 *   This example will work out-of-the-box on the F4 discovery board. LEDs are on PD12, PD13. The
 *   USART TX/RX is on PB6/PB7 except on the F4 when it's on PD8/PD9 due to pin availability on
 *   the F4 discovery board.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class TimerEncoderTest {

  protected:

    /*
     * LED pins on port D
     */

    enum {
      LED1_PIN = 12,
      LED2_PIN = 13
    };

    /*
     * Set up the two LEDs that will show the direction of the counter (up/down)
     */

    GpioD<DefaultDigitalOutputFeature<LED1_PIN,LED2_PIN>> _leds;

    /*
     * Set up the timer that will be used to receive input from the encoder
     */

    Timer1<
       Timer1GpioFeature<               // TI1/TI2 are CH1_IN and CH2_IN, set them up
         TIMER_REMAP_NONE,              // the GPIO input will not be remapped
         TIM1_CH1_IN,                   // channel 1 = TI1
         TIM1_CH2_IN                    // channel 2 = TI2
       >,
       TimerEncoderFeature<             // we're using the quadrature encoder feature
         EncoderCounterEdge::Input1,    // count on TI1 edges with direction according to TI2
         EncoderPolarity::Rising,       // TI1 polarity
         EncoderPolarity::Rising        // TI2 polarity
       >,
       TimerChannel1Feature<>,          // we'll use channel 1 for CC interrupts
       Timer1InterruptFeature           // that means we need the interrupt feature
    > _timer;

    /*
     * Declare a USART to write out the counter value. TX/RX = PD8/PD9 for Usart3_Remap1 and
     * PB6/PB7 for Usart1_Remap1. The differences are down to which pins are available on the
     * F4 and F0 discovery boards.
     */

#if defined(STM32PLUS_F4)
    Usart3_Remap1<> _usart;
#else
    Usart1_Remap1<> _usart;
#endif

    UsartPollingOutputStream _outputStream;

    /*
     * Declare the EXTI input (PA0) that should be connected to the encoder's index
     * pin if it has one. A rising edge on this pin resets the counter to a known value
     */

    GpioA<DefaultDigitalInputFeature<0> > _indexPin;
    Exti0 _exti;

    /*
     * The last value received from the counter
     */

    uint16_t _lastValue;

  public:

    /*
     * Constructor, call the member variable constructors where needed
     */

    TimerEncoderTest() :
      _usart(57600),
      _outputStream(_usart),
      _exti(EXTI_Mode_Interrupt,EXTI_Trigger_Rising,_indexPin[0]) {
    }

    /*
     * Run the test
     */

    void run() {

      /*
       * Set ourselves up as a subscriber for interrupts raised by the timer class.
       */

      _timer.TimerInterruptEventSender.insertSubscriber(
          TimerInterruptEventSourceSlot::bind(this,&TimerEncoderTest::onInterrupt)
        );

      /*
       * Initialise the counter for the encoder to have a range of 0..65535 and arrange
       * for automatic management of the index pin (resets to 30000)
       */

      _timer.initialiseEncoderCounter(65535);
      _timer.manageEncoderReset(_exti,30000);

      /*
       * Initialise the capture and subscribe to the interrupts
       */

      _timer.initCapture();
      _timer.enableInterrupts(TIM_IT_CC1);

      /*
       * Initialise the starting value for the counter to 30000
       */

      _timer.setCounter(_lastValue=30000);

      /*
       * Enable the timer
       */

      _timer.enablePeripheral();

      /*
       * Go into an infinite loop simulating the encoder signals. If you've got a real
       * encoder then delete the simulateSignals() and delay() calls and just go into
       * an infinite loop.
       */

      for(;;) {
        simulateSignals();
        MillisecondTimer::delay(1000);
      }
    }


    /*
     * Simulate the signals that an encoder might make. This requires you to make the following
     * wiring: PA2 => PA8. PA3 => PA9. TI1 and TI2 will be generated on PA0/PA1 following the
     * pattern in AN4013 Figure 8. This will simulate 4 up counts and then 4 down counts.
     */

    void simulateSignals() {

      static const bool ti[][2]={
          { false, false },
          { true,  false },         // +1
          { true,  true },
          { false, true },          // +1
          { false, false },
          { true,  false },         // +1
          { true,  true },
          { false, true },          // +1
          { false, false },
          { true,  false },         // reversal
          { false, false },
          { true,  false },
          { false, false },         // -1
          { false, true },
          { true,  true },          // -1
          { true,  false },
          { false, false },         // -1
          { false, true },
          { true,  true },          // -1
          { true,  false },
          { false, false },
          { false, true },          // reversal
          { false, false },
          { false, true },
          { false, false },
          { false, true },
          { false, false }
      };

      enum { TI1 = 2, TI2 = 3 };
      GpioA<DefaultDigitalOutputFeature<TI1,TI2> > simpins;

      uint8_t i;

      // run through the steps allowing 10ms between each one

      for(i=0;i<sizeof(ti)/sizeof(ti[0]);i++) {

        simpins[TI1].setState(ti[i][0]);
        simpins[TI2].setState(ti[i][1]);

        MillisecondTimer::delay(10);
      }
    }


    /*
     * Subscriber callback function. This is called when the CC1 interrupt that we've
     * enabled is fired. Don't do much in here and be aware of re-entrancy issues.
     */

    void onInterrupt(TimerEventType tet,uint8_t /* timerNumber */) {

      uint16_t currentValue;

      /*
       * Not likely to be anything else but anyway...
       */

      if(tet!=TimerEventType::EVENT_COMPARE1)
        return;

      /*
       * A positive change will light LED1, a negative change will light LED2
       */

      currentValue=_timer.getCounter();
      if(currentValue>_lastValue || _lastValue-currentValue>30000) {

        // current > last or there's been a wrap (i.e. silly difference between last and current)

        _leds[LED1_PIN].set();
        _leds[LED2_PIN].reset();
      }
      else {
        _leds[LED1_PIN].reset();
        _leds[LED2_PIN].set();
      }

      /*
       * Write out the current value to the USART if it's connected
       */

      _outputStream << StringUtil::Ascii(currentValue) << "\r\n";
      _lastValue=currentValue;
    }
};


/*
 * Main entry point
 */

int main() {

  MillisecondTimer::initialise();

  TimerEncoderTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_encoder/timer_encoder.cpp
// START FILE: ../examples/timer_encoder/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_encoder/system/LibraryHacks.cpp
// START FILE: ../examples/timer_pwm_gpio_out/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_pwm_gpio_out/system/LibraryHacks.cpp
// START FILE: ../examples/timer_pwm_gpio_out/timer_pwm_gpio_out.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * Timer demonstration: Use timer 2 to output a 1MHz PWM wave on channel 1 (PA0). The demo
 * will repeatedly increment the duty cycle from 0 to 100% and back down to 0 over 800ms.
 *
 * Connect up PA0 to a LED pin on your development board to see the output.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F107VCT6
 *   STM32F407VGT6
 */

class TimerPwmGpioOutTest {

  public:

    void run() {

      /*
       * Initialise timer2 running from the internal APB2 clock with channel-1 and GPIO output features.
       * The GPIO output feature is itself configured with a channel-1 output feature.
       */

      Timer2<
        Timer2InternalClockFeature,       // the timer clock source is APB1
        TimerChannel1Feature<>,           // we're going to use channel 1
        Timer2GpioFeature<                // we want to output something to GPIO
          TIMER_REMAP_NONE,               // the GPIO output will not be remapped
          TIM2_CH1_OUT                    // we will output channel 1 to GPIO
        >
      > timer;

      /*
       * Set an up-timer up to tick at 10MHz with an auto-reload value of 1999
       * The timer will count from 0 to 1999 inclusive then reset back to 0.
       *
       * Note that the lowest frequency you can set on the F1 is 1098 for a 72MHz
       * timer clock source. This is because the maximum prescaler value is 65536
       * (72Mhz/65536 = 1098Hz).
       */

      timer.setTimeBaseByFrequency(10000000,1999);

      /*
       * Initialise channel 1 as a PWM channel in edge-aligned mode (TIM_OCMode_PWM1).
       * The default starting duty cycle is zero.
       */

      timer.initCompareForPwmOutput();

      /*
       * Enable the timer. The PWM output is on PA0.
       */

      timer.enablePeripheral();

      /*
       * It's all running automatically now, use the main CPU to vary the duty cycle up
       * to 100% and back down again
       */

      for(;;) {

        // fade up to 100% in 4ms steps

        for(int8_t i=0;i<=100;i++) {
          timer.setDutyCycle(i);
          MillisecondTimer::delay(4);
        }

        // fade down to 0% in 4ms steps

        for(int8_t i=100;i>=0;i--) {
          timer.setDutyCycle(i);
          MillisecondTimer::delay(4);
        }
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // we need the SysTick timer

  MillisecondTimer::initialise();

  TimerPwmGpioOutTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_pwm_gpio_out/timer_pwm_gpio_out.cpp
// START FILE: ../examples/usart_receive_sync/usart_receive_sync.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


using namespace stm32plus;


/**
 * USART test: synchronous receiving data
 *
 * This example will receive 5 characters from the PC over USART1 and then immediately echo them back.
 * Connect an RS232 cable from USART1 to your PC and run a terminal program (there are many free terminal
 * programs) and type 5 characters into it. Those 5 characters will be echo'd back to the terminal.
 *
 * Note that if you are using the STM32F4DISCOVERY board then you cannot use USART1 since the pins
 * clash with onboard peripherals. I have tested this code on that board using USART2 and UART4.
 *
 * The protocol is 57600/8/N/1
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class UsartReceiveSyncTest {

  public:

    void run() {

      /*
       * Declare a USART1 object. Note that an alternative Usart1_Remap object is available
       * if your application demands that you use the alternate pins for USART1
       */

      Usart1<> usart(57600);

      /*
       * We'll use streams to send and receive the data.
       */

      UsartPollingOutputStream outputStream(usart);
      UsartPollingInputStream inputStream(usart);

      /*
       * Go into a loop reading 5 characters at a time and then writing them
       * right back again.
       */

      for(;;) {

        uint8_t buffer[5];
        uint32_t actuallyRead;

        if(!inputStream.read(buffer,sizeof(buffer),actuallyRead) || actuallyRead!=sizeof(buffer)) {
          // read error: handle it here
        }

        if(!outputStream.write(buffer,sizeof(buffer))) {
          // write error: handle it here
        }

      }
    }
};


/*
 * Main entry point
 */

int main() {

  UsartReceiveSyncTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usart_receive_sync/usart_receive_sync.cpp
// START FILE: ../examples/usart_receive_sync/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usart_receive_sync/system/LibraryHacks.cpp
// START FILE: ../examples/ili9327/ili9327.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * ILI9327 LCD test, show a looping graphics demo
 *
 * It's a 16-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring
 * that you need to do is as follows:
 *
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0    PE11 => D8
 * PD15 => D1    PE12 => D9
 * PD0  => D2    PE13 => D10
 * PD1  => D3    PE14 => D11
 * PE7  => D4    PE15 => D12
 * PE8  => D5    PD8  => D13
 * PE9  => D6    PD9  => D14
 * PE10 => D7    PD10 => D15
 * PD13 => Backlight PWM (if variable backlight)
 *
 * The code works without structural change on both
 * the F1 and F4. You will most likely have to change
 * the timing configuration to suit your panel and FSMC
 * bus speed. I include working timings for the F1 and
 * F4 for the ILI9327 development board that I own.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class ILI9327Test {

  protected:
    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef ILI9327_400x240_Portrait_262K<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11>> pd;

      // set up the FSMC with RS=A16 (PD11)

#if defined(STM32PLUS_F1)
      Fsmc8080LcdTiming fsmcTiming(0,2);
#elif defined(STM32PLUS_F4)
      Fsmc8080LcdTiming fsmcTiming(4,10);
#endif
      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);

      // declare a panel

      _gl=new LcdPanel(*_accessMode);

      // apply gamma settings

      ILI9327Gamma gamma(0,0x10,0,0,3,0,0,1,7,5,5,0x25,0,0,0);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        rectTest();
        jpegTest();
        lzgTest();
        basicColoursTest();
        textTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        lineTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      // only draw in portrait mode and if it can fit on screen

      if(_gl->getHeight()>_gl->getWidth() && _gl->getHeight()>=320 && _gl->getWidth()>=240) {

        prompt("JPEG bitmap test");

        // draw it centered

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle((_gl->getWidth()-240)/2,(_gl->getHeight()-320)/2,240,320),compressedData);

        MillisecondTimer::delay(3000);
      }
    }

    void lzgTest() {

      prompt("LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,true,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,false,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,true,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,false,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,true,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t before,elapsed;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();

      for(i=0;i<15000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << "Elapsed: " << (int32_t)elapsed << "ms";

      MillisecondTimer::delay(3000);
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      int i;

      prompt("Line test");

      for(i=0;i<25000;i++) {
        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }
    }

    void rectTest() {

      int i;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0;i<8000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0;i<80000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0;i<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0;i<8000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  ILI9327Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/ili9327/ili9327.cpp
// START FILE: ../examples/ili9327/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/ili9327/system/LibraryHacks.cpp
// START FILE: ../examples/usb_device_msc_internal/usb_device_msc_internal.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usb/device/msc.h"


using namespace stm32plus;
using namespace stm32plus::usb;


extern uint32_t FloppyImageSize;
extern uint32_t FloppyImage;


/**
 * This is a self-contained example of the 'mass storage' USB device class. In this mode your
 * device appears as an external disk and can present a file system to the computer without actually
 * having to implement the file system. All the device needs to do is to be able to read and write
 * blocks as well as present some basic meta data and live status information about itself.
 *
 * The stm32plus driver implemnts the popular Bulk Only Transport (BOT) standard that provides
 * one IN and one OUT bulk endpoint. A SCSI command set is used to transfer data, commands, and
 * responses from and to the host.
 *
 * This example compiles in a 360Kb floppy disk image into the MCU flash and makes it available
 * as a read-only USB mass storage device. To use, simply compile and flash this example to the
 * F4 discovery board and then hook up the micro USB port to a computer. The 'flash disk' should
 * be automatically discovered and the files made available for browsing.
 *
 * Compatible MCU:
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6 / Windows 8.1 x64 host
 */

class UsbDeviceMscInternalTest {

  public:

    /*
     * declare a type for the the USB stack
     */

    typedef BotMscDevice<
      InternalFsPhy<>,                    // use the internal full speed PHY with no features
      ManufacturerTextFeature,            // we'll supply a manufacturer name
      ProductTextFeature,                 // ... and a product name
      SerialNumberTextFeature,            // ... and a serial number
      ConfigurationTextFeature            // ... and a config text string
    > MyUsb;


    /*
     * Run the example
     */

    void run() {

      /*
       * set up the parameters for the USB mass storage device. The default MscScsi template
       * constructor sets up a media packet size of 8192 bytes. This is the the largest size
       * that the host will send/receive in read/write operations.
       */

      MyUsb::Parameters usbParams;

      usbParams.device_vid=0xDEAD;           // demo vendor ID
      usbParams.device_pid=0x0020;           // demo product ID

      usbParams.device_manufacturer_text="Andy's Workshop";   // see params.device_language_[ids/count] to change the languages
      usbParams.device_product_text="stm32plus flash drive";
      usbParams.device_configuration_text="My configuration";

      /*
       * The serial number length and format matters for the mass storage device class. Search online
       * for the rules that you have to follow.
       */

      usbParams.device_serial_text="002020141222";

      /*
       * Declare the USB object - this will initialise internal variables but will not
       * start the peripheral
       */

      MyUsb usb;

      /*
       * Subscribe to errors
       */

      usb.UsbErrorEventSender.insertSubscriber(UsbErrorEventSourceSlot::bind(this,&UsbDeviceMscInternalTest::onError));

      /*
       * Subscribe to USB events
       */

      usb.UsbEventSender.insertSubscriber(UsbEventSourceSlot::bind(this,&UsbDeviceMscInternalTest::onEvent));

      /*
       * Start the USB peripheral. It will run asynchronously. There is no requirement
       * for the parameters to remain in scope after the initialise call
       */

      if(!usb.initialise(usbParams))
        for(;;);      // onError() has already locked up

      // loop forever, or until an error interrupts us

      for(;;) {
      }
    }


    /**
     * Event callback from the USB stack. Lots of stuff will come through here but
     * we're only interested in the events that allow us to provide our device data
     * and information.
     */

    void onEvent(UsbEventDescriptor& ued) {

      switch(ued.eventType) {

        /*
         * MSC_BOT_IS_READY is used to test if the device is ready for IO. The Windows host
         * tends to poll this at least once per second.
         */

        case UsbEventDescriptor::EventType::MSC_BOT_IS_READY:
          onIsReady(static_cast<MscBotIsReadyEvent&>(ued));
          break;

        /*
         * MSC_BOT_GET_ENQUIRY_PAGE returns some basic control and metadata about the whole
         * device.
         */

        case UsbEventDescriptor::EventType::MSC_BOT_GET_ENQUIRY_PAGE:
          onGetEnquiryPage(static_cast<MscBotGetEnquiryPageEvent&>(ued));
          break;

        /*
         * MSC_BOT_GET_CAPACITY is used to return the number of blocks on your device and
         * the size of each block
         */

        case UsbEventDescriptor::EventType::MSC_BOT_GET_CAPACITY:
          onGetCapacity(static_cast<MscBotGetCapacityEvent&>(ued));
          break;

        /*
         * BOT_READ is the read operation. A block address and block count is provided.
         */

        case UsbEventDescriptor::EventType::MSC_BOT_READ:
          onRead(static_cast<MscBotReadEvent&>(ued));
          break;

        /*
         * BOT_IS_WRITE_PROTECTED tests if the media is write protected. This example is
         * always write protected
         */

        case UsbEventDescriptor::EventType::MSC_BOT_IS_WRITE_PROTECTED:
          onIsWriteProtected(static_cast<MscBotIsWriteProtectedEvent&>(ued));
          break;

        default:   // warning suppression
          break;
      }
    }


    /**
     * Read a number of blocks from the disk
     * @param event The read event parameters.
     */

    void onRead(MscBotReadEvent& event) {

      uint8_t *start;

      // copy the data to the buffer. assumes that the caller won't ask us to overrun

      start=reinterpret_cast<uint8_t *>(&FloppyImage)+(event.blockAddress*512);
      memcpy(event.buffer,start,static_cast<uint32_t>(event.blockCount)*512);
      event.success=true;
    }


    /**
     * Handle the onReady event: this device is always ready
     * @param event The event structure
     */

    void onIsReady(MscBotIsReadyEvent& event) {
      event.isReady=true;
    }


    /**
     * Handle the is-write-protected event: this device is always write protected because
     * the data is a virtual disk stored in flash.
     * @param event The event structure
     */

    void onIsWriteProtected(MscBotIsWriteProtectedEvent& event) {
      event.isWriteProtected=true;
    }


    /**
     * Get the capacity for this disk. The LUN index is in the event which will be zero
     * for us. We need to set the block size and count as well as the ready flag that says
     * we have a disk online.
     * @param event event data
     */

    void onGetCapacity(MscBotGetCapacityEvent& event) {

      // fill in this disks parameters

      event.blockSize=512;
      event.blockCount=reinterpret_cast<uint32_t >(&FloppyImageSize)/512;
      event.ready=true;
    }


    /**
     * Get the enquiry page for a LUN. Returns some basic stuff about the manufacturer, product
     * and version.
     * @see MscBotGetEnquiryPageEvent
     * @param event event data
     */

    void onGetEnquiryPage(MscBotGetEnquiryPageEvent& event) {

      // we only support a single LUN

      static const uint8_t data[0x24]={
        0,0x80,2,2,0x24-5,0,0,0,
       'A', 'n', 'd', 'y', 'W', 'k', 's', 'p',    // 8 byte manufacturer
       's', 't', 'm', '3', '2', 'p', 'l', 'u','s', ' ', 'U', 'S', 'B', ' ', ' ', ' ',   // 16 byte product
       '4', '.', '0','0',                         // 4 byte version
      };

      event.enquiryPage=data;
    }


    /**
     * USB error event received
     * @param uee the event descriptor
     */

    void onError(UsbErrorEvent& uee) {

      // ignore unconfigured errors from the HID device

      if(uee.provider==ErrorProvider::ERROR_PROVIDER_USB_DEVICE && uee.code==MyUsb::E_UNCONFIGURED)
        return;

      // flash the RED led on PD5 at 1Hz

      GpioD<DefaultDigitalOutputFeature<5>> pd;

      for(;;) {
        pd[5].reset();
        MillisecondTimer::delay(500);
        pd[5].set();
        MillisecondTimer::delay(500);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // initialise the interrupt controller

  Nvic::initialise();

  // initialise the millisecond timer

  MillisecondTimer::initialise();

  // run the test

  UsbDeviceMscInternalTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usb_device_msc_internal/usb_device_msc_internal.cpp
// START FILE: ../examples/usb_device_msc_internal/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usb_device_msc_internal/system/LibraryHacks.cpp
// START FILE: ../examples/ads7843/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/ads7843/system/LibraryHacks.cpp
// START FILE: ../examples/ads7843/ads7843.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"
#include "config/display/touch.h"


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * ADS7843 touch screen test, implements a basic drawing
 * application using an ILI9325 LCD.
 *
 * Compatible MCU:
 *   STM32F1 HD
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 */

class ADS7843Test : public ThreePointTouchScreenCalibrator::GuiCallback {

  protected:

    // declare a type for the LCD that we're using

    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;   // my access mode
    typedef ILI9325_Landscape_64K<LcdAccessMode> LcdPanel;          // the panel

    // LCD-related objects

    LcdAccessMode *_accessMode;             // access mode for the LCD
    LcdPanel *_lcd;                         // 64K colour interface to the ILI9325
    DefaultBacklight *_backlight;           // backlight PWM output
    Font *_font;                            // font that we'll use

    // touch screen related objects

    ADS7843AsyncTouchScreen *_touchScreen;  // the touch screen object
    Spi *_spi;                              // The SPI peripheral
    ExtiPeripheralBase *_exti;              // An EXTI interrupt line for the pen IRQ
    GpioPinRef _penIrqPin;                  // The GPIO pin that receives the pin IRQ

    // calibrator and error-correction post-processors

    PassThroughTouchScreenCalibration *_passThroughCalibration;
    AveragingTouchScreenPostProcessor *_averagingPostProcessor;
    PassThroughTouchScreenPostProcessor *_passThroughPostProcessor;

    // the observer implementation will set this when the interrupt fires

    volatile bool _clicked;

    // these are the variables that the graphical demo will use

    bool _fgSelected;
    bool _accurate;
    TouchScreenCalibration* _calibrationResults;
    Size _boxSize;
    LcdPanel::tCOLOUR _fg,_bg,_colours[8];
    Rectangle _selectionBoxes[7];
    Point _lastPoint;
    uint16_t _backlightPercentage;

  public:

    /*
     * Demo setup and preparation
     */

    void run() {

      // set up the LCD
      initLcd();

      // set up the touch screen
      initTouchScreen();

      // set up variables for the demo
      _fgSelected=true;
      _accurate=false;
      _calibrationResults=NULL;
      _boxSize.Width=_boxSize.Height=0;
      _backlightPercentage=100;

      _colours[0]=ColourNames::RED;
      _colours[1]=ColourNames::GREEN;
      _colours[2]=ColourNames::BLUE;
      _colours[3]=ColourNames::BLACK;
      _colours[4]=ColourNames::WHITE;
      _colours[5]=ColourNames::CYAN;
      _colours[6]=ColourNames::MAGENTA;
      _colours[7]=ColourNames::YELLOW;

      // run the demo and don't come back
      doDemo();
    }


    /*
     * initialise the LCD panel
     */

    void initLcd() {

      // we've got RESET on PE1, backlight on PD13 and RS (D/CX) on PD11

      GpioE<DefaultDigitalOutputFeature<1>> pe;
      GpioD<DefaultDigitalOutputFeature<13>,DefaultFsmcAlternateFunctionFeature<11>> pd;

      // set up the FSMC timing for this panel
      Fsmc8080LcdTiming fsmcTiming(2,5);

      // set up the FSMC on bank 1 with A16 as the RS line (this is compatible with 100 pin devices)
      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);

      // create the LCD interface in landscape mode
      // this will power it up and do the reset sequence
      _lcd=new LcdPanel(*_accessMode);

      // set up some gamma values for this panel
      ILI9325Gamma gamma(0x0006,0x0101,0x0003,0x0106,0x0b02,0x0302,0x0707,0x0007,0x0600,0x020b);
      _lcd->applyGamma(gamma);

      // create a font and select it for stream operations
      _font=new Font_KYROU_9_REGULAR8();
      *_lcd << *_font;
      _lcd->setFontFilledBackground(false);

      // turn on the backlight at 100%

      _backlight=new DefaultBacklight;

      _backlightPercentage=100;
      _backlight->fadeTo(_backlightPercentage,4);
    }


    /*
     * initialise the touch screen
     */

    void initTouchScreen() {

      // create the initial pass through calibration object that allows us to create
      // the touch screen object ready for calibrating for real

      _passThroughCalibration=new PassThroughTouchScreenCalibration;

      // create an averaging post-processor for use in accurate mode that
      // does 4x oversampling on the incoming data

      _averagingPostProcessor=new AveragingTouchScreenPostProcessor(4);

      // create the do-nothing post-processor that is used in non-accurate mode

      _passThroughPostProcessor=new PassThroughTouchScreenPostProcessor;

      // we've got the PENIRQ attached to GPIOB, port 6. Attach an EXTI line to it and since
      // it's active low we want to be called back via our Observer implementation when the
      // signal falls from high to low.

      GpioB<DefaultDigitalInputFeature<6> > pb;
      _penIrqPin=pb[6];

      _exti=new Exti6(EXTI_Mode_Interrupt,EXTI_Trigger_Falling,pb[6]);

      // we've got the SPI interface to the touchscreen wired to SPI1, and since SPI1 is the fast one on the
      // STM32 we'll divide the 72Mhz clock by the maximum of 256 instead of 128 which we'd use on SPI2.

      Spi1<>::Parameters params;
      params.spi_baudRatePrescaler=SPI_BaudRatePrescaler_256;
      params.spi_cpol=SPI_CPOL_Low;
      params.spi_cpha=SPI_CPHA_1Edge;

      _spi=new Spi1<>(params);

      // now create the touch screen, initially in non-accurate mode with some dummy calibration data because the first thing
      // we're going to do in the demo is calibrate it with the 3-point routine.

      _touchScreen=new ADS7843AsyncTouchScreen(
          *_passThroughCalibration,
          *_passThroughPostProcessor,
          *_spi,
          _penIrqPin,
          *_exti
        );
    }


    /*
     * Calibrate the touch screen using the accurate 3-point method
     */

    void calibrate() {

      ThreePointTouchScreenCalibrator calibrator(*_touchScreen,*this);
      TouchScreenCalibration* newResults;

      // important preparation for calibration: we must set the screen to pass through mode
      // so that the calibrator sees raw co-ordinates and not calibrated!

      _touchScreen->setCalibration(*_passThroughCalibration);

      // calibrate the screen and get the new results. A real application can use the serialise
      // and deserialise methods of the TouchScreenCalibration base class to read/write the
      // calibration data to a persistent stream

      if(!calibrator.calibrate(newResults))
        return;

      // store the new results

      if(_calibrationResults!=NULL)
        delete _calibrationResults;

      _calibrationResults=newResults;

      // re-initialise the touch screen with the calibration data

      _touchScreen->setCalibration(*_calibrationResults);
    }


    /*
     * Get the size of one of the menu boxes on the screen
     */

    void calcBoxSize(const char **boxTexts,int numBoxes) {

      Size s;
      int i;

      for(i=0;i<numBoxes;i++) {
        s=_lcd->measureString(*_font,boxTexts[i]);

        if(s.Width>_boxSize.Width)
          _boxSize.Width=s.Width;

        if(s.Height>_boxSize.Height)
          _boxSize.Height=s.Height;
      }

      // add on 4px for the left selection bar, 2px all around for space and 1px all around for the border
      // ignoring that the border is shared between vertical boxes :)

      _boxSize.Width+=1+4+2+2+1;
      _boxSize.Height+=1+2+2+1;
    }


    /*
     * Draw the tools menu at the edge of the screen
     */

    void drawTools() {

      int16_t y;
      uint16_t i;
      Point p;

      const char *boxTexts[]= {
        "","fore","back","clear","recal","accurate", ""
      };

      if(_boxSize.Width==0)
        calcBoxSize(boxTexts,sizeof(boxTexts)/sizeof(boxTexts[0]));

      // clear down

      _lcd->setForeground(ColourNames::BLACK);
      _lcd->fillRectangle(Rectangle(0,0,_boxSize.Width,(_boxSize.Height+2)*sizeof(boxTexts)/sizeof(boxTexts[0])));

      _lcd->setForeground(ColourNames::WHITE);

      y=0;
      p.X=1+4+2;

      for(i=0;i<sizeof(boxTexts)/sizeof(boxTexts[0]);i++) {

        _selectionBoxes[i].X=0;
        _selectionBoxes[i].Y=y;
        _selectionBoxes[i].Width=_boxSize.Width;
        _selectionBoxes[i].Height=_boxSize.Height;

        _lcd->drawRectangle(_selectionBoxes[i]);

        p.Y=y+1+2;
        *_lcd << p << boxTexts[i];

        y+=_boxSize.Height+2;
      }

      drawSelection(_fg,1);
      drawSelection(_bg,2);

      if(_accurate)
        drawSelection(ColourNames::GREEN,5);

      drawColours();
      drawBacklight();

      // don't return until the pen is up

      while(!_penIrqPin.read());
    }


    /*
     * Draw a selection (green bar) indicator in the menu box
     */

    void drawSelection(LcdPanel::tCOLOUR barColour,int boxIndex) {
      _lcd->setForeground(barColour);
      _lcd->fillRectangle(Rectangle(1,(_boxSize.Height+2)*boxIndex+1,4,_boxSize.Height-2));
    }


    /*
     * Draw the backlight percentage box
     */

    void drawBacklight() {
      int width,y;

      y=(_boxSize.Height+2)*6+1;
      width=((_boxSize.Width-2)*_backlightPercentage)/100;

      _lcd->setForeground(ColourNames::BLUE);
      _lcd->fillRectangle(Rectangle(1,y,width,_boxSize.Height-2));

      if(_backlightPercentage<100) {
        _lcd->setForeground(ColourNames::BLACK);
        _lcd->fillRectangle(Rectangle(1+width,y,_boxSize.Width-2-(1+width),_boxSize.Height-2));
      }

      _lcd->setForeground(ColourNames::WHITE);
      *_lcd << Point(1+4+2,y+1+2) << "LED: " << _backlightPercentage;
      _lcd->setForeground(_fg);
    }


    /*
     * Draw the colour stripe boxes
     */

    void drawColours() {

      int i,numColours,width;
      Rectangle rc;

      numColours=sizeof(_colours)/sizeof(_colours[0]);
      width=(_boxSize.Width-2)/numColours;

      rc.X=1;
      rc.Y=1;
      rc.Height=_boxSize.Height-2;
      rc.Width=width;

      for(i=0;i<numColours;i++) {
        _lcd->setForeground(_colours[i]);
        _lcd->fillRectangle(rc);
        rc.X+=width;
      }
    }


    /*
     * Go into a loop running the demo
     */

    void doDemo() {

      Point p;
      int index;
      uint16_t newpercent;

      // clear down
      _lcd->setBackground(ColourNames::BLACK);
      _lcd->clearScreen();

      // calibrate the screen for first use
      calibrate();

      // clear down the screen

      _fg=ColourNames::WHITE;
      _bg=ColourNames::BLACK;

      _lcd->setBackground(_bg);
      _lcd->clearScreen();

      // draw the tools
      drawTools();

      // register as an observer for interrupts on the EXTI line

      _touchScreen->TouchScreenReadyEventSender.insertSubscriber(
          TouchScreenReadyEventSourceSlot::bind(this,&ADS7843Test::onTouchScreenReady)
        );

      for(;;) {

        // wait for a click

        _lastPoint.X=-1;
        for(_clicked=false;!_clicked;);

        do {

          // get click-coordinates from the panel

          if(_touchScreen->getCoordinates(p)) {

            // check if the click is in any of the menu boxes

            if(_selectionBoxes[0].containsPoint(p)) {
              index=(p.X-1)/8;
              if(index>=0 && index<=7) {
                if(_fgSelected) {
                  _fg=_colours[index];
                  _lcd->setForeground(_fg);
                }
                else {
                  _bg=_colours[index];
                  _lcd->setBackground(_bg);
                  _lcd->clearScreen();
                }
                drawTools();
              }
            }
            else if(_selectionBoxes[1].containsPoint(p)) {
              _fgSelected=true;
            }
            else if(_selectionBoxes[2].containsPoint(p)) {
              _fgSelected=false;
            }
            else if(_selectionBoxes[3].containsPoint(p)) {
              _lcd->clearScreen();
              drawTools();
            }
            else if(_selectionBoxes[4].containsPoint(p)) {
              while(!_penIrqPin.read());
              calibrate();
              _lcd->setBackground(_bg);
              _lcd->clearScreen();
              drawTools();
            }
            else if(_selectionBoxes[5].containsPoint(p)) {
              if(_accurate^=true)
                _touchScreen->setPostProcessor(*_averagingPostProcessor);
              else
                _touchScreen->setPostProcessor(*_passThroughPostProcessor);
              drawTools();
            }
            else if(_selectionBoxes[6].containsPoint(p)) {
              newpercent=(100*p.X-1)/(_boxSize.Width-2);
              if(newpercent!=_backlightPercentage && newpercent<=100) {
                _backlightPercentage=newpercent;
                _backlight->setDutyCycle(_backlightPercentage);
                drawBacklight();
              }
            }
            else {

              // if the click is on screen, plot it. This bounds check is necessary because
              // the touch screen can and does extend past the LCD edges.

              if(p.X>=0 && p.X<=_lcd->getXmax() && p.Y>=0 && p.Y<=_lcd->getYmax()) {

                  if(_lastPoint.X!=-1)
                    _lcd->drawLine(p,_lastPoint);
                else
                  _lcd->plotPoint(p);

                _lastPoint=p;
              }
            }
          }

        // carry on while the pen is still down

        } while(!_penIrqPin.read());
      }
    }


    /*
     * This will be called back when the EXTI interrupt fires.
     */

    void onTouchScreenReady() {
      _clicked=true;
    }


    /*
     * Display the prompt "Please tap the stylus on each red point"
     */

    virtual void displayPrompt(const char *text) {

      Size size;

      _lcd->setBackground(ColourNames::BLACK);
      _lcd->setForeground(ColourNames::WHITE);

      _lcd->clearScreen();

      // show the prompt at the top center

      size=_lcd->measureString(*_font,text);

      *_lcd << Point((_lcd->getWidth()/2)-(size.Width/2),0) << text;
    }


    /*
     * Display a hit point for the user to aim at
     */

    virtual void displayHitPoint(const Point& pt) {

      int16_t i,j,x,y;

      x=pt.X-1;
      y=pt.Y-1;

      _lcd->setForeground(ColourNames::RED);

      for(i=0;i<3;i++)
        for(j=0;j<3;j++)
          _lcd->plotPoint(Point(x+j,y+i));
    }


    /*
     * Get the size of the panel
     */

    virtual Size getPanelSize() {
      return Size(_lcd->getWidth(),_lcd->getHeight());
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  ADS7843Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/ads7843/ads7843.cpp
// START FILE: ../examples/usb_device_hid_custom_adc/hidreader/hidreader.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Application class
 */

class CHidReaderApp : public CWinApp
{
public:
	virtual BOOL InitInstance();

	DECLARE_MESSAGE_MAP()
};
// END FILE: ../examples/usb_device_hid_custom_adc/hidreader/hidreader.h
// START FILE: ../examples/usb_device_hid_custom_adc/hidreader/stdafx.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#ifndef VC_EXTRALEAN
#define VC_EXTRALEAN            // Exclude rarely-used stuff from Windows headers
#endif

#include "targetver.h"

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS      // some CString constructors will be explicit

// turns off MFC's hiding of some common and often safely ignored warning messages
#define _AFX_ALL_WARNINGS

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcontrolbars.h>
#include <setupapi.h>
#include <stdint.h>

// need this for the device enumeration

#pragma comment(lib,"setupapi")
// END FILE: ../examples/usb_device_hid_custom_adc/hidreader/stdafx.h
// START FILE: ../examples/usb_device_hid_custom_adc/hidreader/hidReaderDlg.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"
#include "hidreader.h"
#include "hidReaderDlg.h"
#include "afxdialogex.h"
#include "UsbEnumerate.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#endif


/*
 * Constructor
 */

CHidReaderDlg::CHidReaderDlg()
  : CDialogEx(CHidReaderDlg::IDD,NULL),
    _dataEvent(FALSE,TRUE),
    _exitEvent(FALSE,TRUE) {
  
  _deviceHandle=INVALID_HANDLE_VALUE;
  _pThread=NULL;
}


/*
 * Destructor
 */

CHidReaderDlg::~CHidReaderDlg() {

  if(_deviceHandle!=INVALID_HANDLE_VALUE)
    CloseHandle(_deviceHandle);
}


/*
 * Message map
 */

BEGIN_MESSAGE_MAP(CHidReaderDlg,CDialogEx)
  ON_WM_SYSCOMMAND()
  ON_WM_PAINT()
  ON_WM_QUERYDRAGICON()
  ON_WM_CLOSE()
  ON_WM_NCRBUTTONDBLCLK()
  ON_MESSAGE(WM_USER_REPORT,OnReport)
  ON_MESSAGE(WM_USER_ERROR,OnError)
END_MESSAGE_MAP()


/*
 * Callback used to jump into the class
 */

UINT __cdecl stubThreadProc(LPVOID lpParameter) {
  ((CHidReaderDlg *)lpParameter)->threadProc();
  return 0;
}


/*
 * Dialog init 
 */

BOOL CHidReaderDlg::OnInitDialog() {

  CDialogEx::OnInitDialog();

  // find the connected device

  UsbEnumerate usb(0xDEAD,0x0004);

  if(usb.getPath().IsEmpty())
    MessageBox(_T("Cannot find USB device. Please ensure that it's switched on and connected to the PC"));
  else {
  
    // open the device

	  if((_deviceHandle=CreateFile(usb.getPath(),GENERIC_WRITE | GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_FLAG_OVERLAPPED,NULL))==INVALID_HANDLE_VALUE)
      MessageBox(_T("The USB device has been located but we failed to open it for reading"));
    else {

      // start the monitoring thread

      _pThread=AfxBeginThread(&stubThreadProc,this,0,0,CREATE_SUSPENDED);
      _pThread->m_bAutoDelete=FALSE;
      _pThread->ResumeThread();
    }
  }

  return TRUE;
}


/*
 * This thread will continually monitor the handle
 */

void CHidReaderDlg::threadProc() {
  
  HANDLE h[2];
  DWORD retval;

  ZeroMemory(&_overlapped,sizeof(_overlapped));
  _overlapped.hEvent=_dataEvent;

  h[0]=_dataEvent;
  h[1]=_exitEvent;

  for(;;) {
  
    // quick check if need to exit

    if(WaitForSingleObject(_exitEvent,0)==WAIT_OBJECT_0)
      break;

    if(!ReadFile(_deviceHandle,_report,sizeof(_report),NULL,&_overlapped)) {

      if(GetLastError()==ERROR_IO_PENDING) {

        if((retval=WaitForMultipleObjects(sizeof(h)/sizeof(h[0]),h,FALSE,INFINITE))==WAIT_OBJECT_0)
          postResult();
        else if(retval==WAIT_OBJECT_0+1)
          break;
      }
      else {
        postError(GetLastError());
        break;
      }
    }
    else
      postResult();
  }

  CancelIo(_deviceHandle);
}


/*
 * Post message synchronously to show the result
 */

void CHidReaderDlg::postResult() {
  SendMessage(WM_USER_REPORT);
}


/*
 * Post message synchronously to show an error
 */

void CHidReaderDlg::postError(DWORD code) {
  SendMessage(WM_USER_ERROR,0,code);
}


/*
 * Closing
 */

void CHidReaderDlg::OnClose() {

  if(_pThread) {
  
    // set the exit event

    _exitEvent.SetEvent();

    // wait for a reasonable time

    if(WaitForSingleObject(_pThread,5000)==WAIT_TIMEOUT)
      MessageBox(_T("Failed to terminate monitoring thread"));

    delete _pThread;
  }

  // call the base class

  CDialogEx::OnClose();
}


/*
 * A new report is available
 */

LRESULT CHidReaderDlg::OnReport(WPARAM wParam,LPARAM lParam) {

  TCHAR buffer[100];
  uint16_t ch1,ch2,ch3,*ptr;

  // prepare a text report

  ptr=reinterpret_cast<uint16_t *>(&_report[1]);
  ch1=*ptr++;
  ch2=*ptr++;
  ch3=*ptr;

  wsprintf(buffer,_T("%d: ch1=%03X ch2=%03X ch3=%03X"),_report[0],ch1,ch2,ch3);

  // set to the control

  SetDlgItemText(IDC_VALUE,buffer);

  // set the time

  setTime();
  return 0;
}


/*
 * A new error occurred
 */

LRESULT CHidReaderDlg::OnError(WPARAM wParam,LPARAM lParam) {
  
  TCHAR buffer[100];

  wsprintf(buffer,_T("Error: %08lX"),lParam);
  SetDlgItemText(IDC_VALUE,buffer);

  return 0;
}


/*
 * Set the time to the control
 */

void CHidReaderDlg::setTime() {

  TCHAR buffer[100];
  SYSTEMTIME st;

  // prepare the time

  GetSystemTime(&st);
  GetTimeFormatEx(LOCALE_NAME_USER_DEFAULT,0,&st,NULL,buffer,sizeof(buffer)/sizeof(buffer[0]));

  SetDlgItemText(IDC_TIME,buffer);
}
// END FILE: ../examples/usb_device_hid_custom_adc/hidreader/hidReaderDlg.cpp
// START FILE: ../examples/usb_device_hid_custom_adc/hidreader/hidReaderDlg.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#include "resource.h"


/*
 * MFC dialog class
 */

class CHidReaderDlg : public CDialogEx {

  protected:
    HANDLE _deviceHandle;
    CWinThread *_pThread;
    CEvent _dataEvent;
    CEvent _exitEvent;

    OVERLAPPED _overlapped;
    uint8_t _report[7];

    virtual BOOL OnInitDialog();
    DECLARE_MESSAGE_MAP()

  protected:
   
    enum {
      WM_USER_REPORT = WM_USER+1,
      WM_USER_ERROR  = WM_USER+2
    };

    void postResult();
    void postError(DWORD code);
    void setTime();

    afx_msg LRESULT OnReport(WPARAM wParam,LPARAM lParam);
    afx_msg LRESULT OnError(WPARAM wParam,LPARAM lParam);

  public:
	  CHidReaderDlg();
    ~CHidReaderDlg();

    void threadProc();

	  enum { IDD = IDD_HIDREADER_DIALOG };
    afx_msg void OnClose();
};
// END FILE: ../examples/usb_device_hid_custom_adc/hidreader/hidReaderDlg.h
// START FILE: ../examples/usb_device_hid_custom_adc/hidreader/UsbEnumerate.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Class to search for our device and get its path
 */

class UsbEnumerate {

public:
  CString _path;

public:
  UsbEnumerate(uint16_t vid,uint16_t pid);

  const CString& getPath() const;
};


/*
 * Get the path to the device or empty string if not found
 */

inline const CString& UsbEnumerate::getPath() const {
  return _path;
}


/*
 * Search for the device and set the path
 */

inline UsbEnumerate::UsbEnumerate(uint16_t vid,uint16_t pid) {

  HDEVINFO                         hDevInfo;
  SP_DEVICE_INTERFACE_DATA         DevIntfData;
  PSP_DEVICE_INTERFACE_DETAIL_DATA DevIntfDetailData;
  SP_DEVINFO_DATA                  DevData;
  DWORD dwSize,dwMemberIdx;
  TCHAR devid[100];
  GUID InterfaceClassGuid = {0x4d1e55b2, 0xf16f, 0x11cf, {0x88, 0xcb, 0x00, 0x11, 0x11, 0x00, 0x00, 0x30} };

  wsprintf(devid,_T("vid_%04hx&pid_%04hx"),vid,pid);

  // We will try to get device information set for all USB devices that have a
  // device interface and are currently present on the system (plugged in).

  hDevInfo=SetupDiGetClassDevs(&InterfaceClassGuid,NULL,0,DIGCF_DEVICEINTERFACE|DIGCF_PRESENT);

  if(hDevInfo!=INVALID_HANDLE_VALUE) {

    // Prepare to enumerate all device interfaces for the device information
    // set that we retrieved with SetupDiGetClassDevs(..)
    DevIntfData.cbSize=sizeof(SP_DEVICE_INTERFACE_DATA);
    dwMemberIdx=0;

    // Next, we will keep calling this SetupDiEnumDeviceInterfaces(..) until this
    // function causes GetLastError() to return  ERROR_NO_MORE_ITEMS. With each
    // call the dwMemberIdx value needs to be incremented to retrieve the next
    // device interface information.

    SetupDiEnumDeviceInterfaces(hDevInfo,NULL,&InterfaceClassGuid,dwMemberIdx,&DevIntfData);

    while(GetLastError()!=ERROR_NO_MORE_ITEMS) {

      // As a last step we will need to get some more details for each
      // of device interface information we are able to retrieve. This
      // device interface detail gives us the information we need to identify
      // the device (VID/PID), and decide if it's useful to us. It will also
      // provide a DEVINFO_DATA structure which we can use to know the serial
      // port name for a virtual com port.

      DevData.cbSize=sizeof(DevData);

      // Get the required buffer size. Call SetupDiGetDeviceInterfaceDetail with
      // a NULL DevIntfDetailData pointer, a DevIntfDetailDataSize
      // of zero, and a valid RequiredSize variable. In response to such a call,
      // this function returns the required buffer size at dwSize.

      SetupDiGetDeviceInterfaceDetail(hDevInfo,&DevIntfData,NULL,0,&dwSize,NULL);

      // Allocate memory for the DeviceInterfaceDetail struct

      DevIntfDetailData=(PSP_DEVICE_INTERFACE_DETAIL_DATA)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,dwSize);
      DevIntfDetailData->cbSize=sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

      if(SetupDiGetDeviceInterfaceDetail(hDevInfo,&DevIntfData,DevIntfDetailData,dwSize,&dwSize,&DevData)) {
        // Finally we can start checking if we've found a useable device,
        // by inspecting the DevIntfDetailData->DevicePath variable.
        // The DevicePath looks something like this:
        //
        // \\?\usb#vid_04d8&pid_0033#5&19f2438f&0&2#{a5dcbf10-6530-11d2-901f-00c04fb951ed}
        //
        // As you can see it contains the VID/PID for the device, so we can check
        // for the right VID/PID with string handling routines.

        if(_tcsstr((TCHAR*)DevIntfDetailData->DevicePath,devid)!=NULL) {

          _path=DevIntfDetailData->DevicePath;
          HeapFree(GetProcessHeap(),0,DevIntfDetailData);
          break;
        }
      }

      HeapFree(GetProcessHeap(),0,DevIntfDetailData);

      // Continue looping
      SetupDiEnumDeviceInterfaces(hDevInfo,NULL,&InterfaceClassGuid,++dwMemberIdx,&DevIntfData);
    }

    SetupDiDestroyDeviceInfoList(hDevInfo);
  }
}
// END FILE: ../examples/usb_device_hid_custom_adc/hidreader/UsbEnumerate.h
// START FILE: ../examples/usb_device_hid_custom_adc/hidreader/resource.h
/ / { { N O _ D E P E N D E N C I E S } }  
 / /   M i c r o s o f t   V i s u a l   C + +   g e n e r a t e d   i n c l u d e   f i l e .  
 / /   U s e d   b y   h i d r e a d e r . r c  
 / /  
 # d e f i n e   I D M _ A B O U T B O X                                         0 x 0 0 1 0  
 # d e f i n e   I D S _ A B O U T B O X                                         1 0 1  
 # d e f i n e   I D D _ H I D R E A D E R _ D I A L O G                         1 0 2  
 # d e f i n e   I D R _ M A I N F R A M E                                       1 2 8  
 # d e f i n e   I D C _ T I M E                                                 1 0 0 3  
 # d e f i n e   I D C _ V A L U E                                               1 0 0 4  
  
 / /   N e x t   d e f a u l t   v a l u e s   f o r   n e w   o b j e c t s  
 / /    
 # i f d e f   A P S T U D I O _ I N V O K E D  
 # i f n d e f   A P S T U D I O _ R E A D O N L Y _ S Y M B O L S  
 # d e f i n e   _ A P S _ N E X T _ R E S O U R C E _ V A L U E                 1 2 9  
 # d e f i n e   _ A P S _ N E X T _ C O M M A N D _ V A L U E                   3 2 7 7 1  
 # d e f i n e   _ A P S _ N E X T _ C O N T R O L _ V A L U E                   1 0 0 5  
 # d e f i n e   _ A P S _ N E X T _ S Y M E D _ V A L U E                       1 0 1  
 # e n d i f  
 # e n d i f  
 // END FILE: ../examples/usb_device_hid_custom_adc/hidreader/resource.h
// START FILE: ../examples/usb_device_hid_custom_adc/hidreader/stdafx.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"
// END FILE: ../examples/usb_device_hid_custom_adc/hidreader/stdafx.cpp
// START FILE: ../examples/usb_device_hid_custom_adc/hidreader/targetver.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.
// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>
// END FILE: ../examples/usb_device_hid_custom_adc/hidreader/targetver.h
// START FILE: ../examples/usb_device_hid_custom_adc/hidreader/hidreader.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"
#include "hidreader.h"
#include "hidReaderDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif


/*
 * Message map
 */

BEGIN_MESSAGE_MAP(CHidReaderApp, CWinApp)
END_MESSAGE_MAP()

// The one and only CHidReaderApp object

CHidReaderApp theApp;


/*
 * Init instance
 */

BOOL CHidReaderApp::InitInstance() {

	CWinApp::InitInstance();

	CHidReaderDlg dlg;
	m_pMainWnd=&dlg;
  dlg.DoModal();

  return FALSE;
}

// END FILE: ../examples/usb_device_hid_custom_adc/hidreader/hidreader.cpp
// START FILE: ../examples/usb_device_hid_custom_adc/CustomAdcHidDevice.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


// The HID report descriptor is defined in usb_device_hid_custom_adc.cpp

extern const uint8_t CustomAdcHidReportDescriptor[22];


namespace stm32plus {
  namespace usb {

    /**
     * Endpoint used by this device: a single IN endpoint to send data inbound to the host
     */

    template<class TDevice> using CustomAdcHidDeviceEndpoint=InterruptInEndpointFeature<1,TDevice>;

    /**
     * Declare the structure that gets sent back when the host asks for the whole
     * configuration descriptor
     */

    struct CustomAdcHidConfigurationDescriptor {
      ConfigurationDescriptor configuration;
      InterfaceDescriptor interface;
      HidClassDescriptor hid;
      EndpointDescriptor endpoint;
    } __attribute__((packed));

    /**
     * Derivation of HidDevice to handle a custom HID device that sends 3 ADC conversions to the
     * host every 1 second. ADC-1 channels 1,2,3 (PA1,PA2,PA3) are the channels used. Each conversion
     * takes 2-bytes so we are sending 6-byte reports.
     *
     * This HID device declares the following configuration structure:
     *
     *   1x Configuration descriptor
     *   1x Interface
     *   1x Inbound interrupt endpoint
     */

    template<class TPhy,template <class> class... Features>
    class CustomAdcHidDevice : public HidDevice<TPhy,
                                                CustomAdcHidConfigurationDescriptor,
                                                CustomAdcHidDeviceEndpoint,
                                                Features...> {

      protected:

        typedef HidDevice<TPhy,
                          CustomAdcHidConfigurationDescriptor,
                          CustomAdcHidDeviceEndpoint,
                          Features...> HidDeviceBase;

        /**
         * Constants
         */

        enum {
          CUSTOM_ADC_HID_REPORT_SIZE = 7    // 1-byte report ID
        };

      public:

        /**
         * Customisable parameters for this HID device
         */

        struct Parameters : HidDeviceBase::Parameters {

          uint8_t custom_hid_poll_interval;      // default is 100

          Parameters() {
            custom_hid_poll_interval=100;
          }
        };

      protected:
        void onEvent(UsbEventDescriptor& event);

        // event processing for the events that we'll need to take action upon

        void onHidInit();
        void onHidDeInit();
        void onHidGetConfigurationDescriptor(DeviceClassSdkGetConfigurationDescriptorEvent& event);

      public:
        CustomAdcHidDevice();
        ~CustomAdcHidDevice();

        bool initialise(Parameters& params);

        bool sendAdcReport(uint16_t channel1,uint16_t channel2,uint16_t channel3);
    };


    /**
     * Constructor
     */

    template<class TPhy,template <class> class... Features>
    inline CustomAdcHidDevice<TPhy,Features...>::CustomAdcHidDevice()
      : HidDeviceBase(CustomAdcHidReportDescriptor,sizeof(CustomAdcHidReportDescriptor)) {

      // subscribe to USB events

      this->UsbEventSender.insertSubscriber(
          UsbEventSourceSlot::bind(this,&CustomAdcHidDevice<TPhy,Features...>::onEvent)
        );
    }


    /**
     * Destructor
     */

    template<class TPhy,template <class> class... Features>
    inline CustomAdcHidDevice<TPhy,Features...>::~CustomAdcHidDevice() {

      // unsubscribe from USB events

      this->UsbEventSender.removeSubscriber(
          UsbEventSourceSlot::bind(this,&CustomAdcHidDevice<TPhy,Features...>::onEvent)
        );
    }


    /**
     * Initialise the class
     * @param param The parameters structure
     * @return true if it worked
     */

    template<class TPhy,template <class> class... Features>
    inline bool CustomAdcHidDevice<TPhy,Features...>::initialise(Parameters& params) {

      USBD_StatusTypeDef status;

      // initialise upwards

      if(!HidDeviceBase::initialise(params))
        return false;

      // set up the configuration descriptor (see constructor for defaults)

      this->_configurationDescriptor.configuration.wTotalLength=sizeof(this->_configurationDescriptor);
      this->_configurationDescriptor.configuration.bNumInterfaces=1;
      this->_configurationDescriptor.configuration.bmAttributes=0x80 | ConfigurationDescriptor::SELF_POWERED;

      // if ConfigurationTextFeature is in the hierarchy then we've got a configuration string (compile-time check)

      if(std::is_base_of<ConfigurationTextFeature<Device<TPhy>>,CustomAdcHidDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.configuration.iConfiguration=USBD_IDX_CONFIG_STR;

      // set up the interface descriptor (see constructor for defaults)

      this->_configurationDescriptor.interface.bInterfaceNumber=0;
      this->_configurationDescriptor.interface.bNumEndpoints=1;
      this->_configurationDescriptor.interface.bInterfaceClass=static_cast<uint8_t>(DeviceClass::HID);
      this->_configurationDescriptor.interface.bInterfaceSubClass=static_cast<uint8_t>(HidSubClass::NONE);    // custom HID
      this->_configurationDescriptor.interface.bInterfaceProtocol=static_cast<uint8_t>(HidProtocol::NONE);

      // if InterfaceTextFeature is in the hierarchy then we've got an interface string (compile-time check)

      if(std::is_base_of<InterfaceTextFeature<Device<TPhy>>,CustomAdcHidDevice<TPhy,Features...>>::value)
        this->_configurationDescriptor.interface.iInterface=USBD_IDX_INTERFACE_STR;

      // set up the hid class descriptor (see constructor for defaults)

      this->_configurationDescriptor.hid.bNumDescriptors=1;
      this->_configurationDescriptor.hid.wItemLength=sizeof(CustomAdcHidReportDescriptor);

      // set up the endpoint descriptor. we'll configure a max packet size of 64 though the
      // actual number of bytes per report will be 1+6=7

      this->_configurationDescriptor.endpoint.bEndpointAddress=EndpointDescriptor::IN | 1;
      this->_configurationDescriptor.endpoint.bmAttributes=EndpointDescriptor::INTERRUPT;
      this->_configurationDescriptor.endpoint.wMaxPacketSize=USB_FS_MAX_PACKET_SIZE;
      this->_configurationDescriptor.endpoint.bInterval=params.custom_hid_poll_interval;  // default is 1000ms

      // set up the qualifier descriptor (see constructor for defaults)

      this->_qualifierDescriptor.bMaxPacketSize0=0x40;
      this->_qualifierDescriptor.bNumConfigurations=1;

      // start the device

      if((status=USBD_Start(&this->_deviceHandle))!=USBD_OK)
        return errorProvider.set(ErrorProvider::ERROR_PROVIDER_USB_DEVICE,this->E_START,status);

      // OK

      return true;
    }


    /**
     * Event handler for device events
     * @param event The event descriptor
     */

    template<class TPhy,template <class> class... Features>
    inline void CustomAdcHidDevice<TPhy,Features...>::onEvent(UsbEventDescriptor& event) {

      switch(event.eventType) {

        case UsbEventDescriptor::EventType::CLASS_INIT:
          onHidInit();
          break;

        case UsbEventDescriptor::EventType::CLASS_DEINIT:
          onHidDeInit();
          break;

        case UsbEventDescriptor::EventType::CLASS_GET_CONFIGURATION_DESCRIPTOR:
          onHidGetConfigurationDescriptor(static_cast<DeviceClassSdkGetConfigurationDescriptorEvent&>(event));
          break;

        default:
          break;
      }
    }


    /**
     * HID initialisation
     */

    template<class TPhy,template <class> class... Features>
    inline void CustomAdcHidDevice<TPhy,Features...>::onHidInit() {

      // open an interrupt IN endpoint

      USBD_LL_OpenEP(&this->_deviceHandle,
                     EndpointDescriptor::IN | 1,
                     EndpointDescriptor::INTERRUPT,
                     CUSTOM_ADC_HID_REPORT_SIZE);
    }


    /**
     * De-initialise the HID device
     */

    template<class TPhy,template <class> class... Features>
    inline void CustomAdcHidDevice<TPhy,Features...>::onHidDeInit() {

      // close the endpoint

      USBD_LL_CloseEP(&this->_deviceHandle,EndpointDescriptor::IN | 1);
    }


    /**
     * Get the configuration descriptor
     * @param event The event class to receive the descriptor and provide type of descriptor being requested
     */

    template<class TPhy,template <class> class... Features>
    inline void CustomAdcHidDevice<TPhy,Features...>::onHidGetConfigurationDescriptor(DeviceClassSdkGetConfigurationDescriptorEvent& event) {

      if(event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::HIGH_SPEED ||
         event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::FULL_SPEED ||
         event.type==DeviceClassSdkGetConfigurationDescriptorEvent::Type::OTHER_SPEED) {

        // set up the values in the event

        event.length=sizeof(this->_configurationDescriptor);
        event.descriptor=reinterpret_cast<uint8_t *>(&this->_configurationDescriptor);
      }
    }


    /**
     * Send a 3-byte HID report to the host
     * @param data The data to send
     * @return true if it worked
     */

    template<class TPhy,template <class> class... Features>
    inline bool CustomAdcHidDevice<TPhy,Features...>::sendAdcReport(uint16_t channel1,uint16_t channel2,uint16_t channel3) {

      CustomAdcHidDeviceEndpoint<Device<TPhy>>& endpoint=static_cast<CustomAdcHidDeviceEndpoint<Device<TPhy>>&>(*this);

      // data must remain in scope until IRQ indicates transmission complete

      static uint8_t report[7];
      uint16_t *ptr;

      // serialized report has 1-byte id at the front, followed by actual data;

      ptr=reinterpret_cast<uint16_t *>(&report[1]);

      report[0]=1;
      *ptr++=channel1;
      *ptr++=channel2;
      *ptr=channel3;

      // wait for previous send to complete by IRQ notification

      while(endpoint.isTransmitting());

      // send the report

      return endpoint.transmit(report,CUSTOM_ADC_HID_REPORT_SIZE);
    }
  }
}
// END FILE: ../examples/usb_device_hid_custom_adc/CustomAdcHidDevice.h
// START FILE: ../examples/usb_device_hid_custom_adc/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usb_device_hid_custom_adc/system/LibraryHacks.cpp
// START FILE: ../examples/usb_device_hid_custom_adc/usb_device_hid_custom_adc.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usb/device/hid.h"
#include "config/adc.h"
#include "CustomAdcHidDevice.h"


using namespace stm32plus;
using namespace stm32plus::usb;


/*
 * This example defines a custom HID that we will use to send ADC conversion results from the
 * STM32 to the PC USB host. We configure ADC1, channels 0,1,2 to convert once per second using
 * DMA to tell us when the data is ready to send. Channels 0,1,2 are mapped to PA0, PA1, PA2.
 * This custom HID has a single interrupt IN endpoint, the minimum required by the HID standard.
 *
 * The key to a custom HID is its report descriptor which is used to define the format of the
 * data sent back to the host. We declare a single host input report with an ID of 1 and a
 * following sequence of 6 bytes that represent the converted values.
 *
 * To use, compile and flash the example to your STM32F4DISCOVERY board. Connect the USB device
 * to a PC host and it will be automtically recognised. Unlike mice and keyboards, custom devices
 * will be suspended by the host until an application opens the device for use. In this state
 * you will see the red LED on the discovery board flash briefly once per second.
 *
 * A sample Windows application can be found in the "hidreader" subdirectory that will connect
 * to the running device and log the incoming reports. Full source code is supplied and I've also
 * included a compiled exe if you don't happen to have Visual Studio 2013 or better.
 *
 * Compatible MCU:
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6 / Windows 8.1 x64 host
 */


/**
 * Declare the HID report descriptor. This descriptor tells the host how we expect to communicate
 * with it. Once defined, these descriptors can be hard-coded into embedded devices. Search the
 * internet for "HID Descriptor Tool" for a free tool that helps define these structures.
 *
 * This descriptor tells the host that we will send reports with an ID of #1 followed by a sequence
 * of 6 (REPORT_COUNT) 8-bit (REPORT_SIZE) data items. Therefore the actual packet sent to the host
 * will be 7 bytes long. It would be more true to the data to declare 3x12 bit data items and 4-bits
 * of padding to round it up but keeping it all byte-oriented makes it easier to pack and unpack.
 */

const uint8_t CustomAdcHidReportDescriptor[22] = {
  0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
  0x09, 0x00,                    // USAGE (Undefined)
  0xa1, 0x01,                    // COLLECTION (Application)
  0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
  0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
  0x85, 0x01,                    //   REPORT_ID (1)
  0x75, 0x08,                    //   REPORT_SIZE (8)
  0x95, 0x06,                    //   REPORT_COUNT (6)
  0x09, 0x00,                    //   USAGE (Undefined)
  0x81, 0x82,                    //   INPUT (Data,Var,Abs,Vol)
  0xc0                           // END_COLLECTION
};


/**
 * Main program class
 */

class UsbDeviceCustomAdcTest {

  public:

    /*
     * declare a type for the the USB stack
     */

    typedef CustomAdcHidDevice<
      InternalFsPhy<>,                    // use the internal full speed PHY with no features
      ManufacturerTextFeature,            // we'll supply a manufacturer name
      ProductTextFeature,                 // ... and a product name
      SerialNumberTextFeature,            // ... and a serial number
      ConfigurationTextFeature,           // ... and a config text string
      InterfaceTextFeature                // ... and an interface text string
    > MyUsb;

    /*
     * Declare the ADC peripheral with an APB2 clock prescaler of 2, a resolution of
     * 12 bits. We will use 144-cycle conversions on ADC channels 0,1 and 2. Scan mode is used
     * with the default template parameter that causes EOC to be raised at the end of a complete
     * conversion group.
     */

    typedef Adc1<
      AdcClockPrescalerFeature<2>,                // prescaler of 2
      AdcResolutionFeature<12>,                   // 12 bit resolution
      Adc1Cycle144RegularChannelFeature<0,1,2>,   // using channels 0,1,2 on ADC1 with 144-cycle latency
      AdcScanModeFeature<>                        // scan mode with EOC after each group
    > MyAdc;

    /*
     * Declare the ADC1 DMA channel. The default is circular mode for the AdcDmaFeature
     * which means that it wil automatically refill our buffer on each conversion because
     * one conversion exactly matches the size of the memory buffer that we will give
     * to the DMA peripheral.
     */

    typedef Adc1DmaChannel<AdcDmaFeature<Adc1PeripheralTraits>,Adc1DmaChannelInterruptFeature> MyDma;

    /*
     * Declare the ADC conversion buffer and the flag that tells us when data is ready
     */

    uint16_t _values[3];
    volatile bool _ready;


    /*
     * Run the example
     */

    void run() {

      /*
       * set up the parameters for the USB hid device. Do not attempt to reuse vid/pid combinations unless
       * you know how to flush your PC's USB driver cache because Windows caches the characteristics of each
       * device and will suspend your device if it suddenly re-appears as a different device type.
       */

      MyUsb::Parameters usbParams;

      usbParams.device_vid=0xDEAD;           // demo vendor ID
      usbParams.device_pid=0x0004;           // demo product ID

      usbParams.device_manufacturer_text="Andy's Workshop";   // see params.device_language_[ids/count] to change the languages
      usbParams.device_product_text="ADC input device";
      usbParams.device_serial_text="0123456789";
      usbParams.device_configuration_text="My configuration";
      usbParams.device_interface_text="My interface";

      /*
       * Declare the USB object - this will initialise internal variables but will not
       * start the peripheral
       */

      MyUsb usb;

      /*
       * Start the USB peripheral. It will run asynchronously. There is no requirement
       * for the parameters to remain in scope after the initialise call
       */

      if(!usb.initialise(usbParams))
        for(;;);      // onError has already locked up

      /*
       * Subscribe to USB errors
       */

      usb.UsbErrorEventSender.insertSubscriber(
          UsbErrorEventSourceSlot::bind(this,&UsbDeviceCustomAdcTest::onError)
      );

      /*
       * Declare the DMA and ADC instances
       */

      MyDma dma;
      MyAdc adc;

      _ready=false;

      /*
       * Subscribe to the DMA complete interrupt
       */

      dma.DmaInterruptEventSender.insertSubscriber(
          DmaInterruptEventSourceSlot::bind(this,&UsbDeviceCustomAdcTest::onComplete)
      );

      /*
       * Enable the DMA interrupt
       */

      dma.enableInterrupts(Adc1DmaChannelInterruptFeature::COMPLETE);

      /*
       * start the DMA (i.e. make it ready to receive requests from the ADC peripheral)
       */

      dma.beginRead(_values,3);

      /*
       * Go into an infinite loop converting
       */

      for(;;) {

        // wait a second

        MillisecondTimer::delay(1000);

        /*
         * Start a conversion and wait until the interrupt handler tells us that it's finished.
         */

        adc.startRegularConversion();

        while(!_ready);
        _ready=false;

        /*
         * Send the converted values as a report to the USB host
         */

        usb.sendAdcReport(_values[0],_values[1],_values[2]);
      }
    }


    /**
     * Interrupt handler for the DMA complete event. Set the ready flag when it's received
     */

    void onComplete(DmaEventType det) {
      if(det==DmaEventType::EVENT_COMPLETE)
        _ready=true;
    }


    /**
     * USB error event received
     * @param uee the event descriptor
     */

    void onError(UsbErrorEvent& uee) {

      // flash the RED led on PD5 at 1Hz

      GpioD<DefaultDigitalOutputFeature<5>> pd;

      // flash on

      if(uee.provider==ErrorProvider::ERROR_PROVIDER_USB_DEVICE) {

        if(uee.code==MyUsb::E_UNCONFIGURED) {

          // unconfigured - pulse for 50ms

          pd[5].reset();
          MillisecondTimer::delay(50);
          pd[5].set();
          MillisecondTimer::delay(50);

          return;
        }
        else if(uee.code==MyUsb::E_BUSY) {

          // unconfigured - pulse twice for 100ms

          for(int i=0;i<2;i++) {
            pd[5].reset();
            MillisecondTimer::delay(50);
            pd[5].set();
            MillisecondTimer::delay(50);
          }

          return;
        }
      }

      for(;;) {
        pd[5].reset();
        MillisecondTimer::delay(500);
        pd[5].set();
        MillisecondTimer::delay(500);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // initialise the interrupt controller

  Nvic::initialise();

  // initialise the millisecond timer

  MillisecondTimer::initialise();

  // run the test

  UsbDeviceCustomAdcTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usb_device_hid_custom_adc/usb_device_hid_custom_adc.cpp
// START FILE: ../examples/fatfs_reader/fatfs_reader.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/nvic.h"
#include "config/sdcard.h"
#include "config/filesystem.h"
#include "config/usart.h"
#include "config/string.h"
#include "config/smartptr.h"


using namespace stm32plus;


/**
 * FAT file system reader demo.
 *
 * This example will open a text file from a subdirectory of the SD card and write
 * the contents to USART1. The filename is /files/test.txt. To run this demo you must
 * have USART1 wired to a terminal program on the PC that is set up to receive at
 * 57600-8-N-1 mode. I recommend the free "RealTerm" program.
 *
 * Note that if you are using the STM32F4DISCOVERY board then you cannot use Usart1
 * since the pins clash with onboard peripherals. I have tested this code on that
 * board using Usart2.
 *
 * The SD card must be inserted and ready when this application runs. This demo was
 * tested on a 4Gb class 10 SDHC microSD card.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class FatFsReaderTest  {

  protected:

    // SD card and file system objects

    SdioDmaSdCard *_sdcard;
    FileSystem *_fs;
    NullTimeProvider _timeProvider;

    // USART objects

    typedef Usart1<> MyUsart;
    MyUsart *_usart;

  public:

    /*
     * Run the demo
     */

    void run() {

      // initialisation for the card and LCD

      initUsart();
      initSdcard();

      // now send the file

      sendFile("/files/test.txt");

      // we're done - lock up

      for(;;);
    }


    /*
     * open the file and send the contents to the USART
     */

    void sendFile(const char *filename) {

      scoped_ptr<File> file;
      char buffer[256];

      // open the file - we own the file pointer that comes back upon success and
      // we must remember to delete it when we're finished

      if(!_fs->openFile(filename,file.address()))
        error();

      // declare a file reader to read lines from the file and also a
      // UsartPollingOutputStream for convenient output to the USART

      FileReader reader(*file);
      UsartPollingOutputStream output(*_usart);

      while(reader.available()) {

        // read the next line and send to the USART

        if(!reader.readLine(buffer,sizeof(buffer)))
          error();

        output << buffer << "\r\n";
      }
    }


    /*
     * Initialise the USART in 57600-8-N-1 mode with no hardware flow control
     */

    void initUsart() {

      // configure the USART peripheral

      _usart=new MyUsart(57600);
    }


    /*
     * Initialise the SD card and get a reference to a file system object. FAT16 and FAT32
     * are both supported.
     */

    void initSdcard() {

      // create the SDIO object and let it auto-initialise

      _sdcard=new SdioDmaSdCard;

      if(errorProvider.hasError())
        error();

      // initialise a file system from that found on the card

      if(!FileSystem::getInstance(*_sdcard,_timeProvider,_fs))
        error();
    }


    /*
     * Print an error code if something goes wrong and lock up
     */

    void error() {

      char *ptr,errorCode[30];

      // print the error code

      StringUtil::modp_uitoa10(errorProvider.getLast(),errorCode);

      for(ptr=errorCode;*ptr;ptr++)
        _usart->send(*ptr);

      // lock up

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // set up the NVIC priority groups and subgroups
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  FatFsReaderTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/fatfs_reader/fatfs_reader.cpp
// START FILE: ../examples/fatfs_reader/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/fatfs_reader/system/LibraryHacks.cpp
// START FILE: ../examples/pframe/stdafx.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once

#include "config/stm32plus.h"
#include "config/display/tft.h"
#include "config/display/touch.h"
#include "config/fx.h"
#include "config/sdcard.h"
#include "config/filesystem.h"

using namespace stm32plus;
using namespace stm32plus::display;
using namespace stm32plus::fx;

#include "LcdManager.h"
#include "Initialiser.h"
#include "FileSystemManager.h"
#include "BitmapManager.h"
#include "TouchManager.h"
#include "ImageTransitionAnimator.h"
#include "ImageManager.h"
#include "ThumbManager.h"
#include "PictureFrame.h"
// END FILE: ../examples/pframe/stdafx.h
// START FILE: ../examples/pframe/ImageManager.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Image manager class
 */

class ImageManager : public Initialiser {

  protected:
    BitmapManager& _bmManager;
    BlockDevice& _blockDevice;
    uint32_t _currentImage;
    ImageTransitionAnimator _imageTransition;

  protected:
    bool drawFullImage();

  public:
    ImageManager(LcdManager& lcdManager,BitmapManager& bmManager,BlockDevice& blockDevice);
    virtual ~ImageManager() {}

    ImageTransitionAnimator& getAnimator();

    LcdManager& getLcdManager() {
      return _lcdManager;
    }

    void setCurrentImage(uint32_t imageIndex) {
      _currentImage=imageIndex;
    }

    void nextImage();
    void showImage();

    // overrides from Initialiser

    bool initialise();
};
// END FILE: ../examples/pframe/ImageManager.h
// START FILE: ../examples/pframe/TouchManager.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Touch screen manager
 */

class TouchManager : public Initialiser,
                     public ThreePointTouchScreenCalibrator::GuiCallback {

  protected:
    FileSystemManager& _fsManager;

    TouchScreen *_touchScreen;
    Spi *_spi;
    ExtiPeripheralBase *_exti;
    GpioPinRef _penIrqPin;
    PassThroughTouchScreenPostProcessor _passThroughPostProcessor;
    PassThroughTouchScreenCalibration _passThroughCalibration;
    TouchScreenCalibration *_calibration;
    bool _needsCalibration;

    volatile bool _clicked;

  protected:
    bool loadCalibration();
    bool saveCalibration();

  public:
    TouchManager(LcdManager& lcdManager,FileSystemManager& fsManager);
    virtual ~TouchManager() {}

    TouchScreen& getTouchScreen() const {
      return *_touchScreen;
    }

    bool needsCalibration() const {
      return _needsCalibration;
    }

    void waitForPenUp() {
      while(isPenDown());
      MillisecondTimer::delay(100);
      _clicked=false;
    }

    bool isPenDown() const {
      return !_penIrqPin.read();
    }

    bool clicked() const {
      return _clicked;
    }

    bool calibrate();

    // overrides from Initialiser

    virtual bool initialise();

    // overrides from ThreePointTouchScreenCalibrator::GuiCallback

    virtual void displayPrompt(const char *text);
    virtual void displayHitPoint(const Point& pt);
    virtual Size getPanelSize();

    // touch screen ready event

    void onTouchScreenReady();
};
// END FILE: ../examples/pframe/TouchManager.h
// START FILE: ../examples/pframe/LcdManager.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"


/*
 * Initialiser, create the LCD object. Gamma and fsmc objects need to be in scope but
 * can be lost on the heap as they'll never be referenced again externally.
 */

bool LcdManager::initialise() {

  // reset is on PE1 and RS (D/CX) is on PD11

  GpioE<DefaultDigitalOutputFeature<1> > pe;
  GpioD<DefaultFsmcAlternateFunctionFeature<11> > pd;

  // set up the FSMC on bank 0 with A16 as the RS line

  Fsmc8080LcdTiming fsmcTiming(2,5);
  _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);

  // create the LCD and object

  _lcd=new LcdAccess(*_accessMode);

  // create and select the font

  _font=new Font_APPLE8();
  *_lcd << *_font;

  // create the terminal object using the selected font

  _terminal=new TerminalAccess(*_lcd);

  // apply gamma settings

  ILI9325Gamma gamma(0x0006,0x0101,0x0003,0x0106,0x0b02,0x0302,0x0707,0x0007,0x0600,0x020b);
  _lcd->applyGamma(gamma);

  // clear down to black

  _lcd->setBackground(ColourNames::BLACK);
  _lcd->setForeground(ColourNames::WHITE);

  _terminal->clearScreen();

  // lights on at 100% in 4ms steps from zero.

  _backlight=new DefaultBacklight;
  _backlight->fadeTo(100,4);

  return true;
}
// END FILE: ../examples/pframe/LcdManager.cpp
// START FILE: ../examples/pframe/ImageTransitionAnimator.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"


/*
 * Constructor
 */

ImageTransitionAnimator::ImageTransitionAnimator(LcdManager::LcdAccess& lcd,BlockDevice& bd)
  : _lcd(lcd),
    _blockDevice(bd) {

  // set a 100Khz timer to tick at 2ms intervals

  _timer.setTimeBaseByFrequency(100000,199);
  _timer.enableInterrupts(TIM_IT_Update);
  _timer.TimerInterruptEventSender.insertSubscriber(
      TimerInterruptEventSourceSlot::bind(this,&ImageTransitionAnimator::onTimerInterrupt)
    );

  // initialise the easing function

  _ease.setDuration(TRANSITION_TIME);
  _ease.setTotalChangeInPosition(320);

  // preset for no previous image

  _blockIndex=0;
}


/**
 * Set the position of the new image block index
 * @param blockIndex where the new image starts
 */

void ImageTransitionAnimator::setNewImageBlockIndex(uint32_t blockIndex) {
  _lastBlockIndex=_blockIndex;
  _blockIndex=blockIndex;
}


/*
 * Start the transition and wait until it's done. The transition is synchronised to the tick of
 * the UPDATE event of the timer. Each update event moves the animation onwards by one position.
 */

void ImageTransitionAnimator::start() {

  int16_t newPosition,count;
  uint32_t currentTime,i,lastBlock,firstBlock;
  uint16_t blocks[512];
  int16_t currentScrollPosition;

  _ticker=0;
  _timer.enablePeripheral();

  currentScrollPosition=0;
  currentTime=0;

  while(currentTime<TRANSITION_TIME) {

    currentTime=_ticker<=TRANSITION_TIME ? _ticker : TRANSITION_TIME;

    // scroll the display

    newPosition=_ease.easeOut(currentTime);
    count=newPosition-currentScrollPosition;

    if(count!=0) {

      _lcd.setScrollPosition(newPosition);

      // blit in the new data

      _lcd.moveToPoint(Point(0,currentScrollPosition));

      firstBlock=_blockIndex+(currentScrollPosition*2);
      lastBlock=_blockIndex+(currentScrollPosition*2)+(count*2);

      currentScrollPosition=newPosition;

      _lcd.beginWriting();

      for(i=firstBlock;i<lastBlock;i+=2) {

        // read the 2 blocks (one scan)

        if(!_blockDevice.readBlocks(blocks,i,2))
          return;

        // write to the device

        _lcd.rawTransfer(blocks,120);                       // first 120 pixels (480 bytes) are here
        _lcd.rawTransfer(&blocks[256],120);                 // next 120 pixels are in the next sector
      }
    }
  }
}


/*
 * Interrupt callback function. This is called when the update interrupt that we've
 * enabled is fired.
 */

void ImageTransitionAnimator::onTimerInterrupt(TimerEventType tet,uint8_t /* timerNumber */) {

  if(tet==TimerEventType::EVENT_UPDATE)
    _ticker++;
}

// END FILE: ../examples/pframe/ImageTransitionAnimator.cpp
// START FILE: ../examples/pframe/FileSystemManager.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Class to manage the file system
 */

class FileSystemManager : public Initialiser {

  protected:
    FileSystem *_fs;
    SdioDmaSdCard *_sdcard;
    CachedBlockDevice *_cachedBlockDevice;
    uint32_t _firstCacheBlock;
    bool _imagesAreCached;

  protected:
    void readImageCacheStatus();

  public:
    FileSystemManager(LcdManager& lcdManager);

    bool allocateBlocks(uint32_t imageCount);

    FileSystem& getFileSystem() const {
      return *_fs;
    }

    BlockDevice& getSdCard() const {
      return *_sdcard;
    }

    uint32_t getFirstCacheBlock() const {
      return _firstCacheBlock;
    }

    bool imagesAreCached() const {
      return _imagesAreCached;
    }

    // overrides from Initialiser

    virtual bool initialise();
};
// END FILE: ../examples/pframe/FileSystemManager.h
// START FILE: ../examples/pframe/TouchManager.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"


/*
 * Constructor
 */

TouchManager::TouchManager(LcdManager& lcdManager,FileSystemManager& fsManager)
  : Initialiser(lcdManager),
    _fsManager(fsManager) {
}


/*
 * Initialise the touch screen
 */

bool TouchManager::initialise() {

  int16_t i,j;

  _term.writeString("Initialising touch screen.\n");

  // initialise hardware: the pen IRQ is on PB6

  GpioB<DefaultDigitalInputFeature<6> > pb;
  _penIrqPin=pb[6];

  _exti=new Exti6(EXTI_Mode_Interrupt,EXTI_Trigger_Falling,pb[6]);

  Spi1<>::Parameters params;
  params.spi_baudRatePrescaler=SPI_BaudRatePrescaler_256;
  params.spi_cpol=SPI_CPOL_Low;
  params.spi_cpha=SPI_CPHA_1Edge;

  _spi=new Spi1<>(params);

  // get calibration data if there is any

  if(loadCalibration())
    _needsCalibration=false;
  else {
    _calibration=new PassThroughTouchScreenCalibration;
    _needsCalibration=true;
  }

  // create the touch screen API

  _touchScreen=new ADS7843AsyncTouchScreen(
      *_calibration,
      _passThroughPostProcessor,
      *_spi,
      _penIrqPin,
      *_exti);

  // do the 5 second countdown for recalibration

  _clicked=false;

  _touchScreen->TouchScreenReadyEventSender.insertSubscriber(
      TouchScreenReadyEventSourceSlot::bind(this,&TouchManager::onTouchScreenReady)
    );

  if(!_needsCalibration) {
    for(i=5;i>=0;i--) {

      _term.clearLine();
      _term << "Tap screen to recalibrate: " << i;

      for(j=0;j<100;j++) {
        MillisecondTimer::delay(10);

        if(_clicked) {
          calibrate();
          return true;
        }
      }
    }
    _term << '\n';
  }

  return true;
}


/*
 * Calibrate the screen
 */

bool TouchManager::calibrate() {

  TouchScreenCalibration* newResults;

  // wait for the pen to come up

  while(_touchScreen->isTouched());

  // create the calibrator

  ThreePointTouchScreenCalibrator calibrator(*_touchScreen,*this);

  // important preparation for calibration: we must set the screen to pass through mode
  // so that the calibrator sees raw co-ordinates and not calibrated!

  _touchScreen->setCalibration(_passThroughCalibration);

  // calibrate the screen and get the new results

  if(!calibrator.calibrate(newResults))
    return false;

  _term.clearScreen();

  // set the new results

  if(_calibration!=NULL)
    delete _calibration;

  _calibration=newResults;

  // re-initialise the touch screen with the calibration data

  _touchScreen->setCalibration(*_calibration);
  _needsCalibration=false;

  // save the new results to the file system as /pframe/touchcal.bin

  return saveCalibration();
}


/*
 * Save the calibration data
 */

bool TouchManager::saveCalibration() {

  File *file;
  bool retval;

  _term.writeString("Saving calibration data.\n");

  // delete old file

  _fsManager.getFileSystem().deleteFile("/pframe/touchcal.bin");

  // open the file

  if(!_fsManager.getFileSystem().createFile("/pframe/touchcal.bin")) {
    _term.writeString("Unable to create calibration file.\n");
    return false;
  }
  if(!_fsManager.getFileSystem().openFile("/pframe/touchcal.bin",file)) {
    _term.writeString("Unable to open calibration file.\n");
    return false;
  }

  // attach the file to a stream and serialize the data into the file

  FileOutputStream ostream(*file);
  retval=_calibration->serialise(ostream);

  delete file;
  return retval;
}


/*
 * Load calibration data from /pframe/touchcal.bin
 */

bool TouchManager::loadCalibration() {

  File *file;
  bool retval;

  _term.writeString("Loading calibration data.\n");

  // open the file

  if(!_fsManager.getFileSystem().openFile("/pframe/touchcal.bin",file)) {
    _term.writeString("Calibration data not found.\n");
    return false;
  }

  // attach the file to a stream and deserialize the data into the class

  FileInputStream istream(*file);

  _calibration=new ThreePointTouchScreenCalibration;
  retval=_calibration->deserialise(istream);

  delete file;
  return retval;
}


/*
 * Display prompt for calibrator
 */

void TouchManager::displayPrompt(const char *text) {

  Size size;
  LcdManager::LcdAccess lcd=_lcdManager.getLcd();

  lcd.setBackground(ColourNames::BLACK);
  lcd.setForeground(ColourNames::WHITE);

  lcd.clearScreen();

  // show the prompt at the top center

  size=lcd.measureString(*(lcd.getStreamSelectedFont()),text);

  lcd << Point((lcd.getWidth()/2)-(size.Width/2),0) << text;
}


/*
 * Display a hit point
 */

void TouchManager::displayHitPoint(const Point& pt) {

  int16_t i,j,x,y;

  x=pt.X-1;
  y=pt.Y-1;

  _lcdManager.getLcd().setForeground(ColourNames::RED);

  for(i=0;i<3;i++)
    for(j=0;j<3;j++)
      _lcdManager.getLcd().plotPoint(Point(x+j,y+i));
}


/*
 * Get the panel dimensions
 */

Size TouchManager::getPanelSize() {

  return Size(_lcdManager.getLcd().getWidth(),_lcdManager.getLcd().getHeight());
}


/*
 * Screen clicked
 */

void TouchManager::onTouchScreenReady() {
  _clicked=true;
}
// END FILE: ../examples/pframe/TouchManager.cpp
// START FILE: ../examples/pframe/Initialiser.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Base class for classes that need to perform startup tasks
 */

class Initialiser {

  protected:
    LcdManager& _lcdManager;
    LcdManager::TerminalAccess& _term;

  public:
    virtual ~Initialiser() {}

  protected:
    bool error(const char *message);

    Initialiser(LcdManager& lcdManager);

    virtual bool initialise()=0;
};
// END FILE: ../examples/pframe/Initialiser.h
// START FILE: ../examples/pframe/PictureFrame.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


/*
 * Main application class
 */

class PictureFrame {

  protected:
    LcdManager *_lcdManager;
    FileSystemManager *_fsManager;
    TouchManager *_touchManager;
    BitmapManager *_bitmapManager;
    ImageManager *_imageManager;
    ThumbManager *_thumbManager;
    uint32_t _autoScrollMillis;
    bool _autoScrollEnabled;

  protected:
    bool initialise();
    void processEvents();
    bool processClick();

  public:
    void run();
};

// END FILE: ../examples/pframe/PictureFrame.h
// START FILE: ../examples/pframe/ImageManager.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"


/*
 * Constructor
 */

ImageManager::ImageManager(LcdManager& lcdManager,BitmapManager& bmManager,BlockDevice& bd)
  : Initialiser(lcdManager),
    _bmManager(bmManager),
    _blockDevice(bd),
    _imageTransition(_lcdManager.getLcd(),bd) {
}


/*
 * Initialise the class
 */

bool ImageManager::initialise()
{
  _currentImage=0;

  return drawFullImage();
}


/*
 * Draw the current image in full
 */

bool ImageManager::drawFullImage() {

  uint32_t blockIndex,i;
  uint16_t blocks[512];

  // get the first block. There are two blocks per scan line.

  blockIndex=_bmManager.getFirstBlockIndex(_currentImage);

  // get the display device

  LcdManager::LcdAccess& lcd=_lcdManager.getLcd();

  lcd.moveTo(lcd.getFullScreenRectangle());
  lcd.beginWriting();

  for(i=blockIndex;i<blockIndex+640;i+=2) {

    // read the 2 blocks (one scan)

    if(!_blockDevice.readBlocks(blocks,i,2))
      return false;

    // write to the device

    lcd.rawTransfer(blocks,120);               // 120 pixels are here (480 bytes in one 512b sector)
    lcd.rawTransfer(&blocks[256],120);         // and the next 120 are here
  }

  return true;
}


/*
 * Move to the next image
 */

void ImageManager::nextImage() {

  // advance and wrap if we have to

  if(_currentImage==_bmManager.getImageCount()-1)
    _currentImage=0;
  else
    _currentImage++;

  // show the current image

  showImage();
}


/*
 * Show image with animated transition
 */

void ImageManager::showImage() {

  // set the new image

  _imageTransition.setNewImageBlockIndex(_bmManager.getFirstBlockIndex(_currentImage));

  // start the timeline

  _imageTransition.start();
}


/*
 * Get the animator
 */

ImageTransitionAnimator& ImageManager::getAnimator() {
  return _imageTransition;
}
// END FILE: ../examples/pframe/ImageManager.cpp
// START FILE: ../examples/pframe/BitmapManager.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Class to manage bitmap IO
 */

class BitmapManager : public Initialiser {

  protected:
    FileSystemManager& _fsManager;
    uint32_t _imageCount;

    static const uint32_t IMAGE_BYTE_SIZE = 307200;

  protected:
    bool createBitmapBlocks();
    bool readImages();
    bool countImages();

  public:
    BitmapManager(LcdManager& lcdManager,FileSystemManager& fsManager);
    virtual ~BitmapManager() {}

    bool openImage(uint32_t imageIndex,File*& file);

    /*
     * Get the first block index for this image
     */

    uint32_t getFirstBlockIndex(uint32_t imageIndex) const {
      return _fsManager.getFirstCacheBlock()+(imageIndex*640);
    }

    /*
     * Get the count of images
     */

    uint32_t getImageCount() const {
      return _imageCount;
    }

    // overrides from Initialiser

    virtual bool initialise();
};
// END FILE: ../examples/pframe/BitmapManager.h
// START FILE: ../examples/pframe/ThumbManager.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"


/*
 * Constructor
 */

ThumbManager::ThumbManager(LcdManager::LcdAccess& gl,FileSystemManager& fsManager,TouchManager& touchManager,uint32_t imageCount)
  : _gl(gl),
    _fsManager(fsManager),
    _touchManager(touchManager) {

  int16_t x,y,i;
  char buffer[30];

  _imageCount=imageCount;

  // store the image count

  _first=0;
  _last=_imageCount>THUMBS_PER_PAGE ? THUMBS_PER_PAGE-1 : _imageCount-1;

  // create the hot spots

  x=26;
  y=64;

  for(i=0;i<THUMBS_PER_PAGE/2;i++) {
    _hotSpots[i].X=x;
    _hotSpots[i].Y=y;
    _hotSpots[i].Width=THUMB_WIDTH;
    _hotSpots[i].Height=THUMB_HEIGHT;

    x+=48;
  }

  x=26;
  y=64+62;

  for(i=THUMBS_PER_PAGE/2;i<THUMBS_PER_PAGE;i++) {
    _hotSpots[i].X=x;
    _hotSpots[i].Y=y;
    _hotSpots[i].Width=THUMB_WIDTH;
    _hotSpots[i].Height=THUMB_HEIGHT;

    x+=48;
  }

  // open the progress files

  FileSystem& fs=_fsManager.getFileSystem();
  fs.openFile("/pframe/controls/progressBar.262",_progressBarFile);
  fs.openFile("/pframe/controls/progressKnob.262",_progressKnobFile);

  // open the time icons

  _timeMap[0]=5;
  _timeMap[1]=10;
  _timeMap[2]=15;
  _timeMap[3]=20;
  _timeMap[4]=30;
  _timeMap[5]=40;
  _timeMap[6]=60;

  for(i=0;i<7;i++) {

    strcpy(buffer,"/pframe/controls/");
    StringUtil::itoa(_timeMap[i],buffer+17,10);
    strcat(buffer,".262");

    fs.openFile(buffer,_timeIcons[i]);
  }
}


/*
 * Draw all the thumbnails
 */

void ThumbManager::redraw() {

  drawBackground();
  drawThumbs();
  drawScrollbar();
  drawTime();
  drawControls();
}


/*
 * Draw the time indicator
 */

void ThumbManager::drawTime() {

  FileInputStream fis(*_timeIcons[_currentTimeIndex]);
  fis.reset();

  _gl.drawBitmap(Rectangle(26+(32+4)*3,224,32,32),fis);
}


/*
 * Draw the additional controls
 */

void ThumbManager::drawControls() {

  drawBitmapFile("/pframe/controls/stop.262",26,224,32,32);
  drawBitmapFile("/pframe/controls/play.262",26+32+4,224,32,32);
  drawBitmapFile("/pframe/controls/updown.262",26+(32+4)*4,224,15,32);
}


/*
 * Draw a bitmap file
 */

void ThumbManager::drawBitmapFile(const char *filename,int16_t x,int16_t y,int16_t w,int16_t h) const {

  File *file;

  if(!_fsManager.getFileSystem().openFile(filename,file))
    return;

  FileInputStream fis(*file);
  _gl.drawBitmap(Rectangle(x,y,w,h),fis);
}


/*
 * Draw the scrollbar
 */

void ThumbManager::drawScrollbar() {

  // prepare input streams

  _progressBarFile->seek(0,File::SeekStart);
  FileInputStream progressBarStream(*_progressBarFile);

  _progressKnobFile->seek(0,File::SeekStart);
  FileInputStream progressKnobStream(*_progressKnobFile);

  // draw container

  _scrollbar.X=26;
  _scrollbar.Y=60+4+58+4+58+4;
  _scrollbar.Width=SCROLLBAR_WIDTH;
  _scrollbar.Height=SCROLLBAR_HEIGHT;

  _gl.drawBitmap(Rectangle(_scrollbar.X,_scrollbar.Y,_scrollbar.Width,_scrollbar.Height),progressBarStream);

  // use this rectangle for hit testing so move the valid x-range past the curved ends

  _scrollbar.X+=5;
  _scrollbar.Width-=10;

  // cannot scroll

  if(_imageCount<=THUMBS_PER_PAGE)
    return;

  // draw the thumb

  _thumbx=26+5+((168*_first)/(_imageCount-THUMBS_PER_PAGE));
  _gl.drawBitmap(Rectangle(_thumbx,60+4+58+4+58+4,SCROLLBAR_KNOB_WIDTH,SCROLLBAR_KNOB_HEIGHT),progressKnobStream);
}


/*
 * Draw the background
 */

void ThumbManager::drawBackground() const {

  Rectangle rc;

  rc.X=20;
  rc.Y=58;
  rc.Width=202;
  rc.Height=152;

  _gl.setForeground(0x384349);
  _gl.fillRectangle(rc);

  rc.Y=220;
  rc.Height=40;
  _gl.fillRectangle(rc);
}


/*
 * Draw all thumbs
 */

void ThumbManager::drawThumbs() const {

  int32_t i;

  for(i=_first;i<=_last;i++)
    drawThumb(i);
}


/*
 * Draw the thumbnail given by the index
 */

void ThumbManager::drawThumb(uint32_t thumbIndex) const {

  File *file;
  int16_t x,y,row,col;

  // open the thumb

  if(!openThumb(thumbIndex,file))
    return;

  // get a stream on to it

  FileInputStream istream(*file);

  // draw it

  row=thumbIndex-_first<4 ? 0 : 1;
  col=(thumbIndex-_first) & 3;

  x=(col*49)+26;
  y=(row*62)+64;

  _gl.drawBitmap(Rectangle(x,y,THUMB_WIDTH,THUMB_HEIGHT),istream);

  // done

  delete file;
}


/*
 * Open a thumb file
 */

bool ThumbManager::openThumb(uint32_t thumbIndex,File *& file) const {

  char buffer[30];

  strcpy(buffer,"/pframe/thumb/");
  StringUtil::itoa(thumbIndex,buffer+14,10);
  strcat(buffer,".262");

  return _fsManager.getFileSystem().openFile(buffer,file);
}


/*
 * Run the user interface. Return true if move to next image and nextImage will be set.
 * Return false if clicked outside interface
 */

bool ThumbManager::run(uint32_t& nextImage,uint32_t& autoScrollMillis,bool& autoScrollEnabled) {

  Point p;
  int16_t i;

  // remember where we are in the sequence

  for(i=0;i<7;i++) {
    if(_timeMap[i]==autoScrollMillis/1000) {
      _currentTimeIndex=i;
      break;
    }
  }

  // redraw all

  redraw();

  // wait for touches

  for(;;) {

    _touchManager.waitForPenUp();

    while(!_touchManager.clicked());

    // get the co-ordinates

    if(!_touchManager.getTouchScreen().getCoordinates(p))
      continue;

    if(clickedThumb(p,nextImage))
      return true;

    if(clickedKnob(p))
      continue;

    if(clickedScrollbar(p))
      continue;

    if(clickedUpDown(p)) {
      autoScrollMillis=static_cast<uint32_t>(_timeMap[_currentTimeIndex])*1000;
      continue;
    }

    if(clickedStop(p)) {
      _touchManager.waitForPenUp();
      autoScrollEnabled=false;
      return false;
    }

    if(clickedPlay(p)) {
      _touchManager.waitForPenUp();
      autoScrollEnabled=true;
      return false;
    }

    if(clickedOutside(p))
      return false;
  }
}


/*
 * Check if stop clicked
 */

bool ThumbManager::clickedStop(const Point& p) {

  return p.X>=26 && p.X<26+32 && p.Y>=224 && p.Y<=224+32;
}


/*
 * Check if play clicked
 */

bool ThumbManager::clickedPlay(const Point& p) {

  return p.X>=26+32+4 && p.X<26+32+4+32 && p.Y>=224 && p.Y<=224+32;
}


/*
 * Check if clicked up/down button
 */

bool ThumbManager::clickedUpDown(const Point& p) {

  if(p.X<26+(32+4)*4 || p.X>15+26+(32+4)*4 || p.Y<224 || p.Y>224+32)
    return false;

  if(p.Y<224+16)
    _currentTimeIndex++;
  else
    _currentTimeIndex--;

  if(_currentTimeIndex<0)
    _currentTimeIndex=0;
  else if(_currentTimeIndex>6)
    _currentTimeIndex=6;

  drawTime();
  _touchManager.waitForPenUp();

  return true;
}


/*
 * Have we clicked the knob?
 */

bool ThumbManager::clickedKnob(const Point& p) {

  int16_t xoffset,newThumbx;
  int32_t newfirst;
  Point newPoint;

  // scrolling disabled?

  if(_imageCount<THUMBS_PER_PAGE)
    return false;

  // must be in the knob

  if(p.X<_thumbx-4 || p.X>=_thumbx+SCROLLBAR_KNOB_WIDTH+4 || p.Y<_scrollbar.Y || p.Y>_scrollbar.Y+SCROLLBAR_HEIGHT)
    return false;

  // to avoid an initial jump, remember the offset from the left of the knob

  xoffset=p.X-_thumbx;

  // carry on while the pen is down

  while(_touchManager.isPenDown()) {

    // get touch co-ordinates

    if(!_touchManager.getTouchScreen().getCoordinates(newPoint))
      break;

    newThumbx=newPoint.X-xoffset;
    if(newThumbx<26+5)
      newThumbx=26+5;
    else if(newThumbx>26+5+168)
      newThumbx=26+5+168;

    // calc the new first position and validate it

    newfirst=((newThumbx-26-5)*(_imageCount-THUMBS_PER_PAGE))/168;

    if(newfirst<0)
      newfirst=0;
    else if(newfirst>_imageCount-THUMBS_PER_PAGE)
      newfirst=_imageCount-THUMBS_PER_PAGE;

    // if it's new then move

    if(newfirst!=_first) {
      _first=newfirst;
      _last=_first+THUMBS_PER_PAGE-1;

      drawScrollbar();
      drawThumbs();
    }
  }

  _touchManager.waitForPenUp();
  return true;
}


/*
 * check if clicked scrollbar and action it
 */

bool ThumbManager::clickedScrollbar(const Point& p) {

  if(_imageCount<THUMBS_PER_PAGE || !_scrollbar.containsPoint(p))
    return false;

  // left of the knob?

  if(p.X<_thumbx)
    _first-=THUMBS_PER_PAGE;
  else if(p.X>_thumbx+SCROLLBAR_KNOB_WIDTH)
    _first+=THUMBS_PER_PAGE;

  // range check

  if(_first<0)
    _first=0;
  else if(_first>_imageCount-THUMBS_PER_PAGE)
    _first=_imageCount-THUMBS_PER_PAGE;

  _last=_first+THUMBS_PER_PAGE-1;

  // redraw the thumbs and scrollbar

  drawThumbs();
  drawScrollbar();

  _touchManager.waitForPenUp();
  return true;
}


/*
 * Have we clicked outside the area
 */

bool ThumbManager::clickedOutside(const Point& p) const {

  return p.X<20 || p.X>220 || p.Y<60 || p.Y>260;
}


/*
 * Have we clicked a thumb?
 */

bool ThumbManager::clickedThumb(const Point& p,uint32_t& nextImage) const {

  int32_t i;

  for(i=_first;i<=_last;i++) {
    if(_hotSpots[i-_first].containsPoint(p)) {
      nextImage=i;
      return true;
    }
  }

  return false;
}
// END FILE: ../examples/pframe/ThumbManager.cpp
// START FILE: ../examples/pframe/BitmapManager.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"


/*
 * Constructor
 */

BitmapManager::BitmapManager(LcdManager& lcdManager,FileSystemManager& fsManager)
  : Initialiser(lcdManager),
    _fsManager(fsManager) {
}


/*
 * Initialise the class
 */

bool BitmapManager::initialise() {

  // create the bitmap blocks on the sd card

  return createBitmapBlocks();
}


/*
 * Create the contiguous blocks that hold the bitmaps for fast access
 */

bool BitmapManager::createBitmapBlocks() {

  countImages();

  if(_fsManager.imagesAreCached())
    return true;

  return readImages();
}


/*
 * Count the images
 */

bool BitmapManager::countImages() {

  char buffer[30];
  FileInformation *finfo;
  uint32_t length;
  FileSystem& fs=_fsManager.getFileSystem();

  _lcdManager.getLcd().setForeground(ColourNames::WHITE);

  // status

  _term.writeString("Counting images");

  // iterate over sequential *.262 images in /pframe/img
  // e.g. 0.262, 1.262, 2.262 etc.

  _imageCount=0;

  for(;;) {

    // check that the image exists

    strcpy(buffer,"/pframe/img/");
    StringUtil::itoa(_imageCount,buffer+12,10);
    strcat(buffer,".262");

    if(!fs.getFileInformation(buffer,finfo))
      break;

    // verify that this is a bitmap by checking the size

    length=finfo->getLength();
    delete finfo;

    if(length!=IMAGE_BYTE_SIZE)
      return error("Invalid image format");

    _imageCount++;
    _term << '.';
  }

  _term << '\n';

  // check for no images

  if(_imageCount==0)
    return error("There are no images to play");

  _term << "Found " << _imageCount << " images\n";

  return true;
}


/*
 * Read the images
 */

bool BitmapManager::readImages() {

  char buffer[30];
  uint8_t block[512];
  uint32_t blockIndex,i,j,actuallyRead;
  FileSystem& fs=_fsManager.getFileSystem();
  File *file;
  BlockDevice& sdcard=_fsManager.getSdCard();

  // allocate enough blocks from the free space to hold the image data

  if(!_fsManager.allocateBlocks(_imageCount))
    return false;

  // status

  _term << "Caching images.\n";

  blockIndex=_fsManager.getFirstCacheBlock();

  for(i=0;i<_imageCount;i++) {

    // read and cache the image

    strcpy(buffer,"/pframe/img/");
    StringUtil::itoa(i,buffer+12,10);
    strcat(buffer,".262");

    if(!fs.openFile(buffer,file))
      return error("Failed to open file");

    _term.clearLine();
    _term << "Image: " << (i+1) << '/' << _imageCount;

    // 640 blocks/image (2 per row, 320 rows / image)
    // each block contains 1 scan line (240*4 bytes)

    for(j=0;j<640;j++) {

      if(!file->read(block,480,actuallyRead) || actuallyRead!=480)
        return error("IO error reading image");

      if(!sdcard.writeBlock(block,blockIndex++))
        return error("IO error writing to card");
    }

    delete file;
  }

  _term << '\n';
  return true;
}


/*
 * Open an image file
 */

bool BitmapManager::openImage(uint32_t imageIndex,File*& file) {

  char buffer[30];

  strcpy(buffer,"/pframe/img/");
  StringUtil::itoa(imageIndex,buffer+12,10);
  strcat(buffer,".262");

  return _fsManager.getFileSystem().openFile(buffer,file);
}

// END FILE: ../examples/pframe/BitmapManager.cpp
// START FILE: ../examples/pframe/FileSystemManager.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"


/*
 * Constructor
 */

FileSystemManager::FileSystemManager(LcdManager& lcdManager)
  : Initialiser(lcdManager) {
}


/*
 * initialise
 */

bool FileSystemManager::initialise() {

  _term.writeString("Initialising SD card.\n");

  // create the SDIO block device - the constructor will attempt to deduce the optimum
  // clock dividers for initialisation and data transfer

  _sdcard=new SdioDmaSdCard;
  if(errorProvider.getLast()!=0)
    return error("Failed to init SD card");

  // attach the block device to the file system

  _term.writeString("Initialising file system.\n");

  _cachedBlockDevice=new CachedBlockDevice(*_sdcard,4);

  if(!FileSystem::getInstance(*_cachedBlockDevice,*new NullTimeProvider,_fs))
    return error("Failed to init file system");

  readImageCacheStatus();
  return true;
}


/*
 * Get the status of the image cache. /pframe/cacheloc-nnnnn encodes the first block in
 * the name. This is to keep the file zero length, i.e. does not allocate a cluster
 * and therefore cannot corrupt the cache when created.
 */

void FileSystemManager::readImageCacheStatus() {

  DirectoryIterator *it;

  // preset for not-set

  _imagesAreCached=false;

  // iterate the pframe directory

  if(!_fs->getDirectoryIterator("/pframe",it))
    return;

  while(it->next()) {

    if(!strncasecmp("cacheloc-",it->current().getFilename(),9)) {
      _firstCacheBlock=atoi(it->current().getFilename()+9);
      _imagesAreCached=true;
      break;
    }
  }

  delete it;
}


/*
 * Allocate sequential blocks for the buffer
 */

bool FileSystemManager::allocateBlocks(uint32_t imageCount) {

  uint32_t blocksRequired,blocksPerCluster,clustersRequired,firstCluster;
  char buffer[50];

  // the filesystem is required to be FATxx so this is safe

  fat::FatFileSystem& fs=(fat::FatFileSystem&)*_fs;
  fat::LinearFreeClusterFinder finder(fs);

  // status

  _term.writeString("Allocating image cache.\n");

  // get the number of clusters required for the buffer

  blocksRequired=2*320*imageCount;
  blocksPerCluster=fs.getBootSector().BPB_SecPerClus;
  clustersRequired=blocksRequired/blocksPerCluster;

  if(blocksRequired % blocksPerCluster!=0)
    clustersRequired++;

  // ask the FS for the first cluster of a sequential free block
  // long enough for our buffer

  if(!finder.findMultipleSequential(clustersRequired,firstCluster))
    return error("Not enough free space on card");

  // convert the cluster number to a block number

  _firstCacheBlock=fs.clusterToSector(firstCluster)+_fs->getFirstSector();

  // write the cache

  strcpy(buffer,"/pframe/cacheloc-");
  StringUtil::itoa(_firstCacheBlock,buffer+17,10);

  _fs->createFile(buffer);
  return true;
}
// END FILE: ../examples/pframe/FileSystemManager.cpp
// START FILE: ../examples/pframe/main.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"


/*
 * Main entry point
 */

int main() {

  PictureFrame pf;

  pf.run();

  for(;;);

  // not reached
  return 0;
}
// END FILE: ../examples/pframe/main.cpp
// START FILE: ../examples/pframe/ImageTransitionAnimator.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Class to manage the transition between images. Uses an easing function
 * and the native scrolling ability of the LCD.
 */

class ImageTransitionAnimator {

  protected:
    static const uint32_t TRANSITION_TIME=600;

    Timer3<Timer3InternalClockFeature,Timer3InterruptFeature> _timer;

    LcdManager::LcdAccess& _lcd;
    BlockDevice& _blockDevice;
    uint32_t _blockIndex;
    uint32_t _lastBlockIndex;
    BounceEase _ease;

    volatile uint32_t _ticker;

  public:
    ImageTransitionAnimator(LcdManager::LcdAccess& lcd,BlockDevice& bd);
    virtual ~ImageTransitionAnimator() {}

    void setNewImageBlockIndex(uint32_t blockIndex);
    void start();

    // overrides from timer Observer
    void onTimerInterrupt(TimerEventType tet,uint8_t timerNumber);
};
// END FILE: ../examples/pframe/ImageTransitionAnimator.h
// START FILE: ../examples/pframe/ThumbManager.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Thumbnail manager class
 */

class ThumbManager {

  protected:
    LcdManager::LcdAccess& _gl;
    FileSystemManager& _fsManager;
    TouchManager& _touchManager;
    Rectangle _hotSpots[8];
    Rectangle _scrollbar;
    File *_progressBarFile;
    File *_progressKnobFile;
    File *_timeIcons[7];
    uint8_t _timeMap[7];

    int16_t _currentTimeIndex;
    int16_t _thumbx;
    int32_t _first;
    int32_t _last;
    int32_t _imageCount;

  protected:
    void drawBackground() const;
    void drawThumb(uint32_t thumbIndex) const;
    void redraw();
    void drawThumbs() const;
    bool openThumb(uint32_t thumbIndex,File *& file) const;
    bool clickedThumb(const Point& p,uint32_t& nextImage) const;
    bool clickedScrollbar(const Point& p);
    bool clickedOutside(const Point& p) const;
    void drawScrollbar();
    bool clickedKnob(const Point& p);
    void drawBitmapFile(const char *filename,int16_t x,int16_t y,int16_t w,int16_t h) const;
    void drawControls();
    void drawTime();
    bool clickedUpDown(const Point& p);
    bool clickedStop(const Point& p);
    bool clickedPlay(const Point& p);

    static const int32_t THUMBS_PER_PAGE = 8;

    static const int16_t THUMB_WIDTH = 44;
    static const int16_t THUMB_HEIGHT = 58;

    static const int16_t SCROLLBAR_WIDTH = 188;
    static const int16_t SCROLLBAR_HEIGHT = 18;

    static const int16_t SCROLLBAR_KNOB_WIDTH = 8;
    static const int16_t SCROLLBAR_KNOB_HEIGHT = 18;

  public:
    ThumbManager(LcdManager::LcdAccess& gl,FileSystemManager& fsManager,TouchManager& touchManager,uint32_t imageCount);

    bool run(uint32_t& nextImage,uint32_t& autoScrollMillis,bool& autoScrollEnabled);
};


// END FILE: ../examples/pframe/ThumbManager.h
// START FILE: ../examples/pframe/PictureFrame.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include "stdafx.h"


/*
 * Run the app
 */

void PictureFrame::run() {

  if(!initialise())
    return;

  processEvents();
}


/*
 * Initialise
 */

bool PictureFrame::initialise() {

  // initialise Nvic priority group configuration

  Nvic::initialise();

  // initialise the millisecond timer

  MillisecondTimer::initialise();

  // default to 20 seconds

  _autoScrollMillis=20000;
  _autoScrollEnabled=true;

  // create and init the LCD manager

  _lcdManager=new LcdManager;
  if(!_lcdManager->initialise())
    return false;

  // create and init the FS manager

  _fsManager=new FileSystemManager(*_lcdManager);
  if(!_fsManager->initialise())
    return false;

  // create and init the touch manager

  _touchManager=new TouchManager(*_lcdManager,*_fsManager);
  if(!_touchManager->initialise())
    return false;

  // create and init the bitmap manager

  _bitmapManager=new BitmapManager(*_lcdManager,*_fsManager);
  if(!_bitmapManager->initialise())
    return false;

  // create the thumb manager

  _thumbManager=new ThumbManager(_lcdManager->getLcd(),*_fsManager,*_touchManager,_bitmapManager->getImageCount());

  // if the touch screen needs calibration, do it

  if(_touchManager->needsCalibration() && !_touchManager->calibrate())
    return false;

  // clear the screen

  _lcdManager->getLcd().clearScreen();

  // create the image manager

  _imageManager=new ImageManager(*_lcdManager,*_bitmapManager,_fsManager->getSdCard());
  return _imageManager->initialise();
}


/*
 * Process events
 */

void PictureFrame::processEvents() {

  Point p;
  uint32_t last,now;

  last=MillisecondTimer::millis();

  for(;;) {

    now=MillisecondTimer::millis();

    // test for a wrap on the timer

    if(last>now) {
      last=now;
      continue;
    }

    // time to scroll?

    if(_autoScrollEnabled && now-last>_autoScrollMillis) {
      _imageManager->nextImage();
      last=now;
    }

    // process clicks

    if(processClick())
      last=MillisecondTimer::millis();
  }
}


/*
 * Detect and process a click
 */

bool PictureFrame::processClick() {

  uint32_t nextImage;

  // check for click

  if(!_touchManager->clicked())
    return false;

  // last touch must come up

  _touchManager->waitForPenUp();

  // display UI and get the next image from it

  if(_thumbManager->run(nextImage,_autoScrollMillis,_autoScrollEnabled))
    _imageManager->setCurrentImage(nextImage);

  _touchManager->waitForPenUp();

  // show the image

  _imageManager->showImage();
  return true;
}
// END FILE: ../examples/pframe/PictureFrame.cpp
// START FILE: ../examples/pframe/LcdManager.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


/*
 * Manager class for the LCD display
 */

class LcdManager {

  public:

    // we'll use the ILI9325

    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef ILI9325_Portrait_262K<LcdAccessMode> LcdAccess;
    typedef ILI9325_Terminal_Portrait<LcdAccess> TerminalAccess;

  protected:

    // members

    LcdAccessMode *_accessMode;
    LcdAccess *_lcd;
    TerminalAccess *_terminal;
    DefaultBacklight *_backlight;
    Font *_font;

  public:
    bool initialise();

    LcdAccess& getLcd() const {
      return *_lcd;
    }

    Font& getFont() const {
      return *_font;
    }

    TerminalAccess& getTerminal() const {
      return *_terminal;
    }
};
// END FILE: ../examples/pframe/LcdManager.h
// START FILE: ../examples/pframe/Initialiser.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "stdafx.h"


/*
 * Constructor
 */

Initialiser::Initialiser(LcdManager& lcdManager)
  : _lcdManager(lcdManager),
    _term(_lcdManager.getTerminal()) {
}


/*
 * Return an error
 */

bool Initialiser::error(const char *message) {

  _term << message << '\n';
  return false;
}
// END FILE: ../examples/pframe/Initialiser.cpp
// START FILE: ../examples/pframe/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/pframe/system/LibraryHacks.cpp
// START FILE: ../examples/adc_single/adc_single.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"
#include "config/adc.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * This example illustrates the most basic of all uses of the ADC. A 12-bit conversion is performed
 * of a single channel. The conversion is done synchronously, on-demand and the result is written to
 * USART1.
 *
 * On the F0:
 *   ADC1 is configured to use the 14MHz dedicated internal oscillator with a latency of 28.5 cycles.
 *
 * On the F1:
 *   ADC1 is configured to use a PCLK2/6 (e.g. 72/6=12MHz) clock. The latency is 7.5 cycles.
 *
 * On the F4:
 *   ADC1 is configured with 12-bit resolution and an APB2 clock prescaler of 2 and a 3-cycle
 *   conversion time.
 *
 * We will use channel 0 which is connected to PA0. USART1 is configured with 57600/8/N/1 parameters.
 *
 * To run this example you can connect PA0 (ADC123_IN0) to see a conversion value of 0 or you can
 * connect PA0 to the VREF level (probably 3.3V or 3V) to see a conversion value of 4095. The actual
 * values that you get will vary according to the noise present on the line.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 *   STM32F107VCT6
 */

class AdcSingle {

  public:

    void run() {

      /*
       * Unfortunately the ADC is quite different across the MCU series so we have to
       * be MCU-specific when declaring this instance
       */

#if defined(STM32PLUS_F0)

      /*
       * Declare the ADC peripheral with the 14MHz dedicated clock, a resolution of
       * 12 bits. We will use 28.5-cycle conversions on ADC channel 0.
       */

      Adc1<
        AdcAsynchronousClockModeFeature,          // the free-running 14MHz HSI
        AdcResolutionFeature<12>,                 // 12 bit resolution
        Adc1Cycle28RegularChannelFeature<0>       // using channel 0 (PA0) on ADC1 with 28.5 cycle latency
        > adc;

#elif defined(STM32PLUS_F1)

      /*
       * Declare the ADC peripheral with a PCLK2 clock prescaler of 6. The ADC clock cannot exceed 14MHz so
       * if PCLK2 is 72MHz then we're operating it at 12MHz here.
       */

      Adc1<
        AdcClockPrescalerFeature<6>,              // PCLK2/6
        Adc1Cycle7RegularChannelFeature<0>        // using channel 0 (PA0) on ADC1 with 7.5-cycle latency
        > adc;

#elif defined(STM32PLUS_F4)

      /*
       * Declare the ADC peripheral with an APB2 clock prescaler of 2, a resolution of
       * 12 bits. We will use 3-cycle conversions on ADC channel 0.
       */

      Adc1<
        AdcClockPrescalerFeature<2>,              // prescaler of 2
        AdcResolutionFeature<12>,                 // 12 bit resolution
        Adc1Cycle3RegularChannelFeature<0>        // using channel 0 (PA0) on ADC1 with 3-cycle latency
        > adc;

#endif

      /*
       * Declare an instance of USART that we'll use to write out the conversion results.
       */

      Usart1<> usart(57600);
      UsartPollingOutputStream outputStream(usart);

      /*
       * Go into an infinite loop converting
       */

      for(;;) {

        uint16_t value;

        // start a conversion manually

        adc.startRegularConversion();

        // poll the EOC flag that tells us when the conversion has finished

        while(!adc.hasRegularConversionFinished());

        // get the result

        value=adc.getRegularConversionValue();

        // write the value to the USART

        outputStream << "Converted value is " << StringUtil::Ascii(value) << "\r\n";

        // wait for a second before converting the next value

        MillisecondTimer::delay(1000);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  MillisecondTimer::initialise();

  AdcSingle adc;
  adc.run();

  // not reached
  return 0;
}
// END FILE: ../examples/adc_single/adc_single.cpp
// START FILE: ../examples/adc_single/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/adc_single/system/LibraryHacks.cpp
// START FILE: ../examples/timer_dual_gpio_out/timer_dual_gpio_out.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"


using namespace stm32plus;


/**
 * Timer demonstration: Output a 1Hz toggle on/off signal on PA0 and another 1Hz
 * signal 500ms ahead of the first one, output on PA1.
 *
 * The timer is configured to tick at 4000Hz with an auto-reload value of 3999.
 * Channel 1 is configured to output an alternating signal on PA0 when the counter
 * reaches 3999. Similarly, channel 2 is configured to output an alternating signal
 * on PA1 when the counter reaches 1000.
 *
 * We configure the channel 1 compare value to be 3999 with an action of "toggle"
 * and we enable GPIO output for channel 1 on its default port of PA0.
 *
 * To see the output, connect PA0 and PA1 to LEDs. e.g. on the F0 and F1 VL discovery
 * boards you can connect PA0 => PC8 and PA1 => PC9.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class TimerDualGpioOutTest {

  public:

    void run() {

      /*
       * Initialise timer2 running from the internal APB1 (APB on the F0) clock with channel-1,
       * channel-2 and GPIO output features. The GPIO output feature is itself configured with
       * channel-1 and channel-2 output features.
       */

      Timer2<
        Timer2InternalClockFeature,       // the timer clock source is APB1 (APB on the F0)
        TimerChannel1Feature<>,           // we're going to use channel 1...
        TimerChannel2Feature<>,           // ...and we're going to use channel 2
        Timer2GpioFeature<                // we want to output something to GPIO
          TIMER_REMAP_NONE,               // the GPIO output will not be remapped
          TIM2_CH1_OUT,                   // we will output channel 1 to GPIO PA0
          TIM2_CH2_OUT                    // ...and also channel 2 to GPIO PA1
        >
      > timer;

      /*
       * Set an up-timer up to tick at 4000Hz with an auto-reload value of 3999
       * The timer will count from 0 to 3999 inclusive then reset back to 0.
       * It will take exactly 1 second to do this.
       *
       * Note that the lowest frequency you can set is 1098 for a 72Mhz timer clock source.
       * This is because the maximum prescaler value is 65536 (72Mhz/65536 = 1098Hz).
       */

      timer.setTimeBaseByFrequency(4000,3999);

      /*
       * Initialise the channel 1 output compare value to 3999 with the default
       * action of toggle. Note that we have to qualify the initCompare call because
       * we're including multiple channels in our timer class and their members have
       * the same names.
       */

      timer.TimerChannel1Feature<>::initCompare(3999);

      /*
       * Initialise the channel 2 output compare value to 2000 with the default
       * action of toggle. The toggle frequency is still 1Hz but it will be out
       * of phase with the toggling of channel 1.
       */

      timer.TimerChannel2Feature<>::initCompare(2000);

      /*
       * Start the timer. Each time it ticks up to 4000 (which will take 1 second)
       * the channel 1 compare value will be triggered and the TIM1_CH1 GPIO pin on PA0
       * will be toggled. Since we've hooked this up to a LED we should see it flashing
       * at 1Hz.
       *
       * When it hits 1000 then the same goes for TIM2_CH2 GPIO on PA1.
       */

      timer.enablePeripheral();

      /*
       * It's all running automatically now
       */

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  TimerDualGpioOutTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_dual_gpio_out/timer_dual_gpio_out.cpp
// START FILE: ../examples/timer_dual_gpio_out/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_dual_gpio_out/system/LibraryHacks.cpp
// START FILE: ../examples/timer_gpio_out/timer_gpio_out.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"


using namespace stm32plus;


/**
 * Timer demonstration: Output a 1Hz toggle on/off signal on PA0.
 *
 * To achieve the alternating 1Hz signal on PA0 (TIM2_CH1) we first
 * set up Timer2 to tick at 10kHz with its auto-reload register set to 9999.
 * It will take 2 seconds for the timer to tick up to 9999 at which point it
 * will reset back to zero.
 *
 * We configure the channel 1 compare value to be 9999 with an action of
 * "toggle" and we enable GPIO output for channel 1 on its default port of PA0.
 *
 * To see the output, connect PA0 to a LED. e.g. on the F0 and F1 VL discovery
 * boards you can connect PA0 to PC8.
 *
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class TimerGpioOutTest {

  public:

    void run() {

      /*
       * Initialise timer2 running from the internal APB2 clock with channel-1 and GPIO output features.
       * The GPIO output feature is itself configured with a channel-1 output feature.
       */

      Timer2<
        Timer2InternalClockFeature,       // the timer clock source is HCLK/2
        TimerChannel1Feature<>,           // we're going to use channel 1
        Timer2GpioFeature<                // we want to output something to GPIO
          TIMER_REMAP_NONE,               // the GPIO output will not be remapped
          TIM2_CH1_OUT                    // we will output channel 1 to GPIO
        >
      > timer;

      /*
       * Set an up-timer up to tick at 1000Hz with an auto-reload value of 9999
       * The timer will count from 0 to 9999 inclusive then reset back to 0.
       * It will take exactly 1 second to do this.
       *
       * Note that the lowest frequency on the F1 that you can set is 1098 for a
       * 72Mhz timer clock source. This is because the maximum prescaler value is
       * 65536 (72Mhz/65536 = 1098Hz).
       */

      timer.setTimeBaseByFrequency(10000,9999);

      /*
       * Initialise the channel 1 output compare value to 9999 with the default
       * action of toggle.
       */

      timer.initCompare(9999);

      /*
       * Start the timer. Each time it ticks up to 9999 (which will take 1 second)
       * the channel 1 compare value will be triggered and the TIM2_CH1 GPIO pin on PA0
       * will be toggled. Since we've hooked this up to a LED we should see it flashing
       * at 1Hz.
       */

      timer.enablePeripheral();

      /*
       * It's all running automatically now
       */

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  TimerGpioOutTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_gpio_out/timer_gpio_out.cpp
// START FILE: ../examples/timer_gpio_out/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_gpio_out/system/LibraryHacks.cpp
// START FILE: ../examples/net_tcp_client_async/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_tcp_client_async/system/LibraryHacks.cpp
// START FILE: ../examples/net_tcp_client_async/net_tcp_client_async.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/timing.h"
#include "config/usart.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This example demonstrates a TCP 'echo' client. It will attempt to connect to a server on a remote
 * computer and send it a line of text. The server will read that line of text and then send it back
 * in reverse. An example server, written in perl, is included in this example code directory.
 * It can be run directly on Linux or Linux-alike systems such as cygwin or msys on Windows. The
 * reversed string will be sent to the USART.
 *
 * I use Usart3, remap-2 with settings 57000/8/N/1.
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient                 |
 *              +------+---------------------+
 * TRANSPORT:   | Tcp | Udp                  |
 *              +-----++---------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +----------------------------+
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 */

class NetTcpClientAsyncTest {

  public:

    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp,Tcp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * The two state variables. One of these will be set when the connection succeeds
     * or fails
     */

    volatile bool _connectionSucceeded;
    volatile bool _connectionFailed;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    UsartPollingOutputStream *_outputStream;


    /*
     * Run the test
     */

    void run() {

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      _outputStream=new UsartPollingOutputStream(*_usart);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetTcpClientAsyncTest::onError));

      // subscribe to notification events from the network stack

      _net->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&NetTcpClientAsyncTest::onNotification));

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      *_outputStream << "The TCP client is ready to run\r\n";

      TcpClientConnection *ptr;
      uint32_t actuallyReceived,actuallySent;
      char buffer[100];

      for(;;) {

        if(connectToServer(ptr)) {

          // manage the connection pointer in a scoped_ptr so it's automatically deleted (and closed)
          // when it goes out of scope

          scoped_ptr<TcpClientConnection> conn(ptr);

          // send 11 bytes of text and a newline to the other end (blocking). We have to copy the data to
          // a sram buffer before sending because the STM32 Ethernet DMA peripheral cannot transmit from
          // flash memory. (string constants are compiled into flash).

          strcpy(buffer,"Hello World\n");

          if(conn->send(buffer,12,actuallySent) && actuallySent==12) {

            // receive the response line from the other end (blocking)

            if(conn->receive(buffer,100,actuallyReceived) && actuallyReceived>0) {

              // write the response to the USART stream

              _outputStream->write(buffer,actuallyReceived);
            }
          }
        }
        else
          *_outputStream << "Timed out while trying to connect, trying again...\r\n";

        // pause for 5 seconds to avoid flooding the network before doing it again

        MillisecondTimer::delay(5000);
      }
    }


    /*
     * Connect to the server asynchronously then wait for a response. If you're interested in this async
     * connect then you won't be blocking like this. This function implements full retry semantics using
     * the same method as the blocking connect calls. You don't have to go to this effort but if you do
     * need retries then this can serve as a template for how to do it.
     */

    bool connectToServer(TcpClientConnection *&conn) {

      uint16_t retry;
      uint32_t start;

      // reset states

      _connectionSucceeded=false;
      _connectionFailed=false;

      for(retry=0;retry<=_net->tcpGetParameters().tcp_connectMaxRetries;retry++) {

        if(retry==0) {

          // start connecting to the remote end using a random local ephemeral port

          if(!_net->tcpConnectAsync<TcpClientConnection>("192.168.1.3",12345,conn))
            return false;
        }
        else
          conn->sendSyn();    // timed out, get the stack to send another SYN

        // wait for success or failure

        start=MillisecondTimer::millis();

        while(!MillisecondTimer::hasTimedOut(start,_net->tcpGetParameters().tcp_connectRetryInterval)) {

          if(_connectionSucceeded)
            return true;            // moved to ESTABLISHED

          if(_connectionFailed)     // actively refused the connection
            return _net->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP,MyNetworkStack::E_CONNECT_FAILED);
        }
      }

      // failed due to timeout

      return _net->setError(ErrorProvider::ERROR_PROVIDER_NET_TCP,MyNetworkStack::E_TIMEOUT);
    }


    /**
     * Network notification event received. We're interested in the connection succeeding
     * or timing out. This will be called in an IRQ context.
     * @param ned
     */

    void onNotification(NetEventDescriptor& ned) {

      // only interested in the state of the connection changing

      if(ned.eventType!=NetEventDescriptor::NetEventType::TCP_CONNECTION_STATE_CHANGED)
        return;

      // now we know which subclass of NetEventDescriptor we have received.
      // In a system where you could be connecting to multiple servers you can use
      // the destAddress, destPort members of the event structure to match this event
      // structure to the connection that you currently have in progress. This example
      // does not need to do that.

      TcpConnectionStateChangedEvent& event=static_cast<TcpConnectionStateChangedEvent&>(ned);

      // The initial state is SYN_SENT. A move to ESTABLISHED indicates the connection
      // has been made. Any other move away from SYN_SENT is a failure state.

      if(event.oldState==TcpState::SYN_SENT) {

        if(event.newState==TcpState::ESTABLISHED)
          _connectionSucceeded=true;
        else
          _connectionFailed=true;
      }
    }


    /**
     * Network error event received, report it
     * @param ned
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetTcpClientAsyncTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_tcp_client_async/net_tcp_client_async.cpp
// START FILE: ../examples/dma_copy/dma_copy.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * Demo of the DMA peripheral used to copy a block of memory. We repeatedly copy
 * a small 256 byte buffer using the completion interrupt to signal the end of
 * each transfer. If all is well then a LED on PF6 will blink once per second.
 *
 * If this example is to be run on the STM32F4DISCOVERY board then change the LED
 * configuration from PF6 to PD13 and invert the set() / reset() logic because
 * that LED is active HIGH.
 *
 * If this example is to be run on the F1 VL or the F0 DISCOVERY board then change
 * the LED configuration from PF6 to PC8 and invert the set() / reset() logic because
 * that LED is active HIGH.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F103ZET6
 *   STM32F100RBT6
 *   STM32F407VGT6
 */

class DmaCopyTest {

  protected:

    /**
     * The LED is on PF6
     */

    enum { LED_PIN = 6 };

    /*
     * The IRQ handler sets this to true when the DMA transfer is complete
     */

    volatile bool _completed;

  public:

    void run() {

      uint8_t buffer1[256],buffer2[256];
      int i;

      // initialise the LED pin

      GpioF<DefaultDigitalOutputFeature<LED_PIN>> pf;

      // lights off (this LED is active low, i.e. PF6 is a sink)

      pf[LED_PIN].set();

      // declare a DMA channel with interrupts and memory copy features
      // F4 users note that only DMA2 can do memory-to-memory transfers.

#if defined(STM32PLUS_F1) || defined(STM32PLUS_F0)

      Dma1Channel1<
        Dma1Channel1InterruptFeature,   // interrupts on DMA1, channel 1
        DmaMemoryCopyFeature<>          // memory copy with default transfer size (bytes)
      > dma;

      // enable the completion interrupt for DMA1, channel 1.

      dma.enableInterrupts(Dma1Channel1InterruptFeature::COMPLETE);

#elif defined(STM32PLUS_F4)

      Dma2Channel1Stream0<
        Dma2Stream0InterruptFeature,    // interrupts on DMA2, stream 0
        DmaMemoryCopyFeature<>          // memory copy with default transfer size (bytes)
      > dma;

      // enable the completion interrupt for DMA2, stream 0.

      dma.enableInterrupts(Dma2Stream0InterruptFeature::COMPLETE);

#endif

      // subscribe to the completion of the DMA transfer

      dma.DmaInterruptEventSender.insertSubscriber(
          DmaInterruptEventSourceSlot::bind(this,&DmaCopyTest::onComplete)
        );

      for(;;) {

        // reset the completion flag

        _completed=false;

        // clear the target buffer, fill the source buffer with a pattern

        memset(buffer2,'\0',sizeof(buffer2));
        for(i=0;i<256;i++)
          buffer1[i]=i;

        // start the transfer of 256 bytes from buffer1 to buffer2. this executes asynchronously.

        dma.beginCopyMemory(buffer2,buffer1,sizeof(buffer1),DMA_Priority_Medium);

        // wait for transfer complete via the IRQ

        while(!_completed);

        // verify the result

        for(i=0;i<256;i++)
          if(buffer2[i]!=i)
            for(;;);          // lock up on error

        // flash the LED for a second

        pf[LED_PIN].reset();
        MillisecondTimer::delay(1000);
        pf[LED_PIN].set();
        MillisecondTimer::delay(1000);
      }
    }


    /*
     * Subscriber callback is fired when the DMA transfer is complete
     */

    void onComplete(DmaEventType det) {
      if(det==DmaEventType::EVENT_COMPLETE)
        _completed=true;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  DmaCopyTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/dma_copy/dma_copy.cpp
// START FILE: ../examples/dma_copy/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/dma_copy/system/LibraryHacks.cpp
// START FILE: ../examples/net_ftp_server/net_ftp_server.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net_ftp.h"
#include "config/timing.h"
#include "config/sdcard.h"
#include "config/hash.h"
#include "config/filesystem.h"
#include "FtpServer.h"
#include "MyFtpServerConnection.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This demo brings together a number of the stm32plus components, namely the network stack,
 * the RTC, the SD card and the FAT16/32 filesystem to build a simple ftp server that listens
 * on port 21.
 *
 * The server supports authenticated and (optionally) anonymous connections. It requires you to
 * create a top-level directory on your SD card called "ftp" and that "ftp" directory must contain
 * a text file called "server.ini". An example "server.ini" file is included in the same directory
 * as this example. Every option is explained in detail in the example server.ini, please do read it.
 *
 * Only passive mode is supported by this server. I have tested this server against cygwin/linux
 * command line clients as well as IE10, Firefox 13 and Chrome 28. The Windows 7 command line ftp
 * client is not supported due to its lack of passive mode support.
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient                 |
 *              +------+---------------------+
 * TRANSPORT:   | Tcp | Udp | Icmp           |
 *              +-----++---------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +----------------------------+
 *
 * This example is only compatible with the F4 because it requires the SDIO peripheral to communicate
 * with the SD card.
 *
 * Tested on devices:
 *   STM32F407VGT6
 */

class NetFtpServerTest {

  public:

    /*
     * The network stack, sdio and filesystem objects that we'll need for this demo
     */

    MyNetworkStack *_net;
    BlockDevice *_sdcard;
    FileSystem *_fs;
    RtcTimeProvider *_timeProvider;


    /*
     * Run the test
     */

    void run() {

      FtpParameters ftpParams;

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // create the RTC time provider for the file system. if writes are made to the card then
      // this provider will be used to timestamp them.

      _timeProvider=new RtcTimeProvider(rtc);

      // declare the SD card with a 3 block (1.5kbyte) read cache
      // and check for error. the card must be inserted at this point

      _sdcard=new CachedBlockDevice(*new SdioDmaSdCard,3);

      if(errorProvider.hasError())
        error();

      // initialise a file system for the card. FAT16 and FAT32 are supported. the card must
      // already be formatted.

      if(!FileSystem::getInstance(*_sdcard,*_timeProvider,_fs))
        error();

      // read the server parameters file

      readServerParameters(ftpParams);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      // create an FTP server on port 21.
      // Here we take advantage of the second template parameter to the TcpServer template to
      // pass in a user-defined type to the constructor of MyFtpConnection. We use it to pass
      // in a pointer to some parameters we need to pass in, such as the TCP implementation
      // and the filesystem object

      ftpParams.fs=_fs;
      ftpParams.tcpImpl=_net;

      TcpServer<MyFtpServerConnection,FtpParameters> *ftpServer;

      if(!_net->tcpCreateServer(21,ftpServer,&ftpParams))
        error();

      // create an array to hold the active connections and configure it to
      // automatically receive connections as they arrive. It will also
      // automatically remove connections as they are closed.

      TcpConnectionArray<MyFtpServerConnection> connections(*ftpServer);

      // now all the plumbing is in place, open up the server to start
      // accepting connection requests

      ftpServer->start();

      // loop forever servicing connections via their handleXXX() methods
      // handleRead()     : data is ready to read
      // handleWrite()    : connection can accept new data
      // handleClosed()   : connection was closed (either end)
      // handleCallback() : round-robin callback to do whatever you want with (we use it to service the data connection)

      connections.wait(TcpWaitState::READ | TcpWaitState::WRITE | TcpWaitState::CLOSED | TcpWaitState::CALLBACK,0);
    }


    /*
     * Read the FTP server parameters. the syntax is a simple key = value style
     * See comments in the demo ftpserver.ini (in this directory) for help.
     * @return false if it fails
     */

    bool readServerParameters(FtpParameters& params) {

      scoped_ptr<File> file;
      char buffer[200];
      uint16_t pos;
      uint32_t actuallyRead;

      // open the parameters file

      if(!_fs->openFile("/ftp/server.ini",file.address()))
        return false;

      FileInputStream fis(*file);

      for(;;) {

        // read a line

        for(pos=0;pos<sizeof(buffer)-1;pos++) {

          // check for error

          if(!fis.read(&buffer[pos],1,actuallyRead))
            return false;

          // check for EOF

          if(actuallyRead==0)
            return true;

          // check for EOL

          if(buffer[pos]=='\n')
            break;
        }

        // terminate the line

        buffer[pos]='\0';

        std::string line(buffer);
        std::string key,value;

        if(line.length()==0 || line[0]=='#' || !getKeyValue(line,key,value))
          continue;

        if(key=="greeting")
          params.serverGreeting+=value+"\r\n";
        else if(key=="goodbye")
          params.serverGoodbye+=value+"\r\n";
        else if(key=="anonymous") {
          params.anonymousPermitted=value=="on";
          params.users.push_back(FtpUser::createAnonymous());
        }
        else if(key=="root")
          params.rootDirectory=value;
        else if(key=="user")
          parseUser(params,value);
        else if(key=="idletimeout")
          params.idleTimeout=atoi(value.c_str());
      }
    }


    /**
     * Parse a user specification: user=name:password-salt:password-hash:r/w
     * See comments in ftpserver.ini for how to generate passwords with sha1sum
     * @param params The FTP parameters
     * @param userspec The user specification
     */

    void parseUser(FtpParameters& params,const std::string& userspec) {

      std::vector<std::string> words;
      FtpUser user;

      // syntax is (e.g.) user=andy:lskdjfoe:86f4d33bf6616c7df658367c69fa43712b072c88:w

      StdStringUtil::tokenise(userspec,":",words);

      if(words.size()==4) {

        user.name=words[0];
        user.passwordSalt=words[1];
        user.passwordHash=words[2];
        user.writeAccess=words[3]=="w";

        params.users.push_back(user);
      }
    }


    /**
     * Get a key and a value from the line we read in
     */

    bool getKeyValue(const std::string& line,std::string& key,std::string& value) {

      std::string::size_type pos;

      if((pos=line.find('='))==std::string::npos)
        return false;

      key=line.substr(0,pos);
      StdStringUtil::trim(key);

      value=line.substr(pos+1);
      StdStringUtil::trim(value);

      return true;
    }


    void error() {
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetFtpServerTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_ftp_server/net_ftp_server.cpp
// START FILE: ../examples/net_ftp_server/FtpServer.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * Types that define the network stack
 */

typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
typedef TransportLayer<MyNetworkLayer,Icmp,Udp,Tcp> MyTransportLayer;
typedef ApplicationLayer<MyTransportLayer,DhcpClient> MyApplicationLayer;
typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


/**
 * Structure to hold a user specification
 */

struct FtpUser {

  std::string name;
  std::string passwordHash;
  std::string passwordSalt;
  bool writeAccess;

  static FtpUser createAnonymous() {

    FtpUser user;

    user.name="anonymous";
    user.writeAccess=false;

    return user;
  }
};


/**
 * Structure to hold FTP parameters that need to be passed to the connections
 */

struct FtpParameters {

  // parameters read from the card

  std::string serverGreeting;       /// no default: you have to set one
  std::string serverGoodbye;        /// no default: you have to set one
  std::string rootDirectory;        /// the root directory for this server: default is ""
  bool anonymousPermitted;          /// default is false
  uint32_t idleTimeout;             /// default is 120 seconds, 0=never time out
  std::vector<FtpUser> users;       /// user specifications, no defaults. anonymous always gets entry zero if enabled.

  // internal references created during server startup

  FileSystem *fs;
  Tcp<MyNetworkLayer> *tcpImpl;


  /**
   * Constructor
   */

  FtpParameters() {
    anonymousPermitted=false;
    idleTimeout=120;
  }
};
// END FILE: ../examples/net_ftp_server/FtpServer.h
// START FILE: ../examples/net_ftp_server/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_ftp_server/system/LibraryHacks.cpp
// START FILE: ../examples/net_ftp_server/MyFtpServerConnection.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * Our command connection class. The FTP server is templated to return instances of this
 * class when remote clients connect. Each instance of this class independently handles an
 * incoming connection. This model allows you to easily service multiple connections without
 * having to worry about doing the multiplexing yourself. When you're done with a connection
 * just delete it and the event system will take care of all necessary close and cleanup.
 */


class MyFtpServerConnection : public FtpServerConnection<MyFtpServerConnection,Tcp<MyNetworkLayer> > {

  public:

    typedef FtpServerConnection<MyFtpServerConnection,Tcp<MyNetworkLayer> > FtpServerConnectionType;

    /**
     * Customised parameters for this ftp server
     */

    struct Parameters : FtpServerConnectionType::Parameters {

      /**
       * Constructor
       */

      Parameters() {

        // this is an interactive connection so switch off the nagle avoidance and enable PUSH

        tcp_nagleAvoidance=false;
        tcp_push=true;
      }
    };

  protected:
    FtpParameters *_ftpParameters;
    uint16_t _userIndex;
    std::string _cwd;

  protected:
    std::string appendPath(const std::string& prefix,const std::string& path) const;
    bool normalisePath(std::string& path) const;
    std::string getCurrentDirectory() const;
    bool directoryListing(void (MyFtpServerConnection::*printFunction)(const FileInformation&));
    void printFileDetails(const FileInformation& finfo);
    void printFileName(const FileInformation& finfo);
    bool getPaths(const char *dir,std::string& subdir,std::string& fullpath);

  public:
    MyFtpServerConnection(const Parameters& params,FtpParameters *ftpParameters);

    // required by the parent

    bool handleClosed();
    bool writeGreeting();
    bool writeGoodbye();
    bool isAnonymousPermitted();
    bool loginUser(const char *user,const char *password);
    bool setCwd(const char *cwd);
    bool download(const char *filename);
    const char *getCwd();
    bool simpleListing();
    bool complexListing();
    bool createDirectory(const char *dir,std::string& newdir);
    bool removeDirectory(const char *dir);
    bool removeFile(const char *filename);
    bool upload(const char *param,bool append,OutputStream*& stream);
    bool fileSize(const char *filename,uint32_t& fileSize);
    bool hasTimedOut(uint32_t idleMillis) const;
};


/**
 * Constructor. We need to supply the base class with its parameters and we stash
 * the ftp parameters object that will be used to serve the web files.
 */

inline MyFtpServerConnection::MyFtpServerConnection(const Parameters& params,FtpParameters *ftpParameters)
  : FtpServerConnectionType(params,ftpParameters->tcpImpl),
    _ftpParameters(ftpParameters) {
}


/**
 * Callback for when the connection is detected to be closed. We will self-destruct which will
 * cause the connection-released event to be fired and the connection state will be transferred
 * back to the network stack where the TCP closing sequence is managed. The connection itself
 * will be automatically removed from the connections array.
 * @return true - no need to abort the connection round robin.
 */

inline bool MyFtpServerConnection::handleClosed() {
  delete this;
  return true;
}


/**
 * Check if anonymous is permitted
 * @return true if anonymous is permitted
 */

inline bool MyFtpServerConnection::isAnonymousPermitted() {
  return _ftpParameters->anonymousPermitted;
}


/**
 * Write the greeting message to the client
 * @return true to continue, false to close
 */

inline bool MyFtpServerConnection::writeGreeting() {

  // add the greeting to the outputs. the greeting already contains the correct 220 code prefixes

  _outputStreams.addStream(new StlStringInputStream(&_ftpParameters->serverGreeting,false),true);
  return true;
}


/**
 * Write the greeting message to the client
 * @return true to continue, false to close
 */

inline bool MyFtpServerConnection::writeGoodbye() {

  // add the goodbye to the outputs. the goodbye already contains the correct 221 code prefixes

  _outputStreams.addStream(new StlStringInputStream(&_ftpParameters->serverGoodbye,false),true);
  return true;
}


/**
 * Try to login the user given the credentials
 * @param user The user name
 * @param password The password
 * @return true if the user was logged in
 */

inline bool MyFtpServerConnection::loginUser(const char *user,const char *password) {

  // find the user

  for(auto it=_ftpParameters->users.begin();it!=_ftpParameters->users.end();it++) {

    if(it->name==user) {

      SHA1HashPeripheral<> sha1;
      std::string creds;
      uint8_t hash[20];
      char hex[41];

      // hash the salt and password concatenated

      creds=it->passwordSalt+password;
      sha1.hash(creds.c_str(),creds.length(),hash);

      // convert the hash to hex

      StringUtil::toHex(hash,20,hex);
      hex[40]='\0';

      // must match

      if(it->passwordHash!=hex)
        return false;

      _userIndex=it-_ftpParameters->users.begin();
      return true;
    }
  }

  // failed to find the user

  return false;
}


/**
 * The CWD is later appended to the server root to form the full path
 *
 * @param pathname The pathname to check. It's already checked for non-null
 * @return true if it's OK
 */

inline bool MyFtpServerConnection::setCwd(const char *pathname) {

  std::string newdir,fullpath;
  scoped_ptr<FileInformation> finfo;

  if(!getPaths(pathname,newdir,fullpath))
    return false;

  // get the file/directory information

  if(!_ftpParameters->fs->getFileInformation(fullpath.c_str(),finfo.address()))
    return false;

  if((finfo->getAttributes() & FileInformation::ATTR_DIRECTORY)==0)
    return false;

  _cwd=newdir;
  return true;
}


/**
 * Get the current working directory
 * @return
 */

inline const char *MyFtpServerConnection::getCwd() {
  return _cwd.c_str();
}


/**
 * Process a path so that .. navigation parts are removed
 * @param path The path to normalise
 * @return false if the path is invalid
 */

inline bool MyFtpServerConnection::normalisePath(std::string& path) const {

  std::vector<std::string> names,normalised;

  // break out the component parts

  StdStringUtil::tokenise(path,"/\\",names);

  for(auto it=names.begin();it!=names.end();it++) {

    // skip empty parts e.g. foo//bar has an empty part at position 1.

    if(it->length() && *it!=".") {

      if(*it=="..") {

        if(normalised.size()==0)
          return false;

        // remove the last part

        normalised.pop_back();
      }
      else
        normalised.push_back(*it);
    }
  }

  // put it back together

  path.clear();

  for(auto it=normalised.begin();it!=normalised.end();it++) {
    if(it!=normalised.begin())
      path+='/';

    path+=*it;
  }

  return true;
}


/**
 * Append path to prefix to get a new path
 * @param prefix The prefix
 * @param path The path
 * @return The new path
 */

inline std::string MyFtpServerConnection::appendPath(const std::string& prefix,const std::string& path) const {

  std::string newpath(path),newprefix(prefix);

  StdStringUtil::trimRight(newprefix,"/");
  StdStringUtil::trimLeft(newpath,"/");

  return newprefix+"/"+newpath;
}


/**
 * Get the current directory
 * @return The full directory including the root, '/' and the current working directory
 */

inline std::string MyFtpServerConnection::getCurrentDirectory() const {

  // _cwd has already been sanitised

  std::string dir(_ftpParameters->rootDirectory);

  if(!_cwd.empty()) {
    dir+='/';
    dir+=_cwd;
  }

  return dir;
}


/**
 * Send a simple directory listing to the data connection
 * @return true if it worked
 */

inline bool MyFtpServerConnection::simpleListing() {
  return directoryListing(&MyFtpServerConnection::printFileName);
}


/**
 * Send a complete listing to the data connection
 * @return true if it worked
 */

inline bool MyFtpServerConnection::complexListing() {
  return directoryListing(&MyFtpServerConnection::printFileDetails);
}


/**
 * Do a directory listing
 * @return true if it worked
 */

inline bool MyFtpServerConnection::directoryListing(void (MyFtpServerConnection::*printFunction)(const FileInformation& finfo)) {

  std::string fullPath(getCurrentDirectory());
  scoped_ptr<DirectoryIterator> dit;

  // get a directory iterator

  if(!_ftpParameters->fs->getDirectoryIterator(fullPath.c_str(),dit.address()))
    return false;

  // list the names

  while(dit->next()) {

    // get a reference to the FileInformation object that describes the file/directory
    // that we're currently looking at

    const FileInformation& fileInfo(dit->current());

    // write out the filename, ignoring "." and ".."

    if(strcmp(".",fileInfo.getFilename())!=0 && strcmp("..",fileInfo.getFilename())!=0)
      (this->*printFunction)(fileInfo);
  }

  return true;
}


/**
 * Print out just the filename
 */

inline void MyFtpServerConnection::printFileName(const FileInformation& finfo) {
  _dataConnection->addString(finfo.getFilename());
}


/**
 * Print out all file information
 */

inline void MyFtpServerConnection::printFileDetails(const FileInformation& finfo) {

  std::string str;
  char buffer[20];
  uint32_t len;

  // permissions string

  if((finfo.getAttributes() & FileInformation::ATTR_DIRECTORY)==0)
    str="-";
  else
    str="d";

  if((finfo.getAttributes() & FileInformation::ATTR_READ_ONLY)==0)
    str+="r-xr-xr-x";
  else
    str+="rwxrwxrwx";

  // owner/group (n/a)

  str+="   1      owner      group ";

  // size (pad to 10)

  len=StringUtil::modp_uitoa10(finfo.getLength(),buffer);
  memset(buffer+len,' ',10-len);
  buffer[10]='\0';

  str+=buffer;

  // date (fake this)

  str+=" Jan  1  1980 ";
  str+=finfo.getFilename();

  // add to the output

  _dataConnection->addString(str.c_str());
}


/**
 * Download the requested file
 * @param filename The file (which can be a pathname)
 */

inline bool MyFtpServerConnection::download(const char *filename) {

  std::string newdir,fullpath;
  File *newFile;

  if(!getPaths(filename,newdir,fullpath))
    return false;

  // the file must not be a directory

  {
    scoped_ptr<FileInformation> finfo;

    if(!_ftpParameters->fs->getFileInformation(fullpath.c_str(),finfo.address()))
      return false;

    if((finfo->getAttributes() & FileInformation::ATTR_DIRECTORY)!=0)
      return false;
  }

  // open the file

  if(!_ftpParameters->fs->openFile(fullpath.c_str(),newFile))
    return false;

  // if the client used REST then seek accordingly

  if(_sendStartPosition!=0) {
    if(!newFile->seek(_sendStartPosition,File::SeekStart)) {
      delete newFile;
      return false;
    }
  }

  // add an input stream on to the file that will take ownership of the file pointer

  _dataConnection->addStream(new OwnedFileInputStream(newFile),true);
  return true;
}


/**
 * Start the upload process
 * @param filename The file (which can be a pathname)
 * @param append true to append, false to overwrite/create
 * @param[out] stream The stream to write data to
 */

inline bool MyFtpServerConnection::upload(const char *filename,bool append,OutputStream *&stream) {

  std::string newdir,fullpath;
  File *newFile;

  // user must have write access

  if(!_ftpParameters->users[_userIndex].writeAccess)
    return false;

  if(!getPaths(filename,newdir,fullpath))
    return false;

  if(!append) {

    // delete if exists (ignore error, will be caught in next line)

    _ftpParameters->fs->deleteFile(fullpath.c_str());

    // create the file

    if(!_ftpParameters->fs->createFile(fullpath.c_str()))
      return false;
  }

  // open the file

  if(!_ftpParameters->fs->openFile(fullpath.c_str(),newFile))
    return false;

  // if we are appending, seek to the end

  if(append && !newFile->seek(0,File::SeekEnd))
    return false;

  // add an output stream on to the file that will take ownership of the file pointer
  // it's now the caller's responsibility to look after it

  stream=new OwnedFileOutputStream(newFile);
  return true;
}


/**
 * Create a new directory
 * @param dir
 * @param newdir
 * @return true if it worked
 */

inline bool MyFtpServerConnection::createDirectory(const char *dir,std::string& newdir) {

  std::string fullpath;

  // user must have write access

  if(!_ftpParameters->users[_userIndex].writeAccess)
    return false;

  if(!getPaths(dir,newdir,fullpath))
    return false;

  // try to create the directory

  return _ftpParameters->fs->createDirectory(fullpath.c_str());
}


/**
 * Remove a directory
 * @param dir
 * @return true if it worked
 */

inline bool MyFtpServerConnection::removeDirectory(const char *dir) {

  std::string fullpath,newdir;

  // user must have write access

  if(!_ftpParameters->users[_userIndex].writeAccess)
    return false;

  if(!getPaths(dir,newdir,fullpath))
    return false;

  // try to create the directory

  return _ftpParameters->fs->deleteDirectory(fullpath.c_str());
}


/**
 * Remove a file
 * @param filename
 * @return true if it worked
 */

inline bool MyFtpServerConnection::removeFile(const char *filename) {

  std::string fullpath,newdir;

  // user must have write access

  if(!_ftpParameters->users[_userIndex].writeAccess)
    return false;

  if(!getPaths(filename,newdir,fullpath))
    return false;

  // try to remove the file

  return _ftpParameters->fs->deleteFile(fullpath.c_str());
}


/**
 * Get the size of a file
 * @param filename
 * @param[out] fileSize The size in bytes.
 * @return true if it worked
 */

inline bool MyFtpServerConnection::fileSize(const char *filename,uint32_t& fileSize) {

  std::string fullpath,newdir;
  scoped_ptr<FileInformation> finfo;

  // get the full path

  if(!getPaths(filename,newdir,fullpath))
    return false;

  // get the file/directory information

  if(!_ftpParameters->fs->getFileInformation(fullpath.c_str(),finfo.address()))
    return false;

  // return the size

  fileSize=finfo->getLength();
  return true;
}


/**
 * Given a user's input file/dir, calc the full relative subdir and the full server path
 * @param dir The user's input dir
 * @param subdir The full relative subdir
 * @param fullpath The full server path
 * @return true if all OK
 */

inline bool MyFtpServerConnection::getPaths(const char *dir,std::string& subdir,std::string& fullpath) {

  // get the full path

  if(dir[0]=='/')
    subdir=dir;
  else
    subdir=appendPath(_cwd,dir);

  // remove any path navigation stuff

  if(!normalisePath(subdir))
    return false;

  // create the full path from the root and the normalised cwd

  fullpath=_ftpParameters->rootDirectory+'/'+subdir;
  return true;
}


/**
 * Check if the connection has timed out
 * @param idleMillis Current idle time
 * @return true if timed out
 */

inline bool MyFtpServerConnection::hasTimedOut(uint32_t idleMillis) const {
  return _ftpParameters->idleTimeout && (idleMillis/1000>_ftpParameters->idleTimeout);
}

// END FILE: ../examples/net_ftp_server/MyFtpServerConnection.h
// START FILE: ../examples/hd44780/hd44780.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/character.h"


using namespace stm32plus;
using namespace stm32plus::display;


/**
 *
 * HD44780 20x4 character LCD demo. For this demonstration
 * we will attach the character LCD to the following pins:
 *
 * PC[0] => RS
 * PC[1] => ENABLE
 * PC[2] => D0
 * PC[3] => D1
 * PC[4] => D2
 * PC[5] => D3
 *
 * This demonstration attachs a text terminal class to the
 * LCD for convenient text output. We then go into an
 * infinite loop writing out the famous Lorem Ipsum
 * passage, scrolling the display each time the output
 * reaches the end of the display.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103ZET6
 *   STM32F407VGT6
 */


/**
 * The sample text
 */

static const char *sampleText[]={
  "Lorem","ipsum","dolor","sit","amet,","consectetur","adipisicing","elit,","sed","do","eiusmod","tempor","incididunt","ut","labore","et","dolore","magna","aliqua.","Ut","enim","ad","minim","veniam,","quis","nostrud","exercitation","ullamco","laboris","nisi","ut","aliquip","ex","ea","commodo","consequat.","Duis","aute","irure","dolor","in","reprehenderit","in","voluptate","velit","esse","cillum","dolore","eu","fugiat","nulla","pariatur.","Excepteur","sint","occaecat","cupidatat","non","proident,","sunt","in","culpa","qui","officia","deserunt","mollit","anim","id","est","laborum",NULL
};


class HD44780Test {

  public:

    void run() {

      int i,written,len;

      /*
       * Initialise the 6 required pins for output
       */

      GpioC<DefaultDigitalOutputFeature<0,1,2,3,4,5> > pc;

      /*
       * Initialise the 20x4 display
       */

      HD44780 lcd(pc[0],pc[1],pc[2],pc[3],pc[4],pc[5],20,4);

      /*
       * Attach a terminal to the display so we can easily demonstrate the
       * text output function
       */

      CharacterLcdTerminal<HD44780> terminal(lcd);

      /*
       * Write out the sample text
       */

      terminal.clear();

      for(i=written=0;;) {

        // if the current word plus trailing space would wrap, start a new line

        len=strlen(sampleText[i])+1;
        if(written+len>20) {
          terminal << '\n';
          written=0;
        }

        // write out the current word with the following space

        terminal << sampleText[i] << ' ';
        written+=len;

        // if there is no next word then start again

        if(sampleText[++i]==NULL)
          i=0;

        // delay for a 500ms before the next word

        MillisecondTimer::delay(500);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  HD44780Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/hd44780/hd44780.cpp
// START FILE: ../examples/hd44780/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/hd44780/system/LibraryHacks.cpp
// START FILE: ../examples/lgdp453x/lgdp453x.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"
#include "config/dma.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * LGDP453x LCD test, show a looping graphics demo
 *
 * It's a 16-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring that
 * you need to do is as follows:
 *
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0    PE11 => D8
 * PD15 => D1    PE12 => D9
 * PD0  => D2    PE13 => D10
 * PD1  => D3    PE14 => D11
 * PE7  => D4    PE15 => D12
 * PE8  => D5    PD8  => D13
 * PE9  => D6    PD9  => D14
 * PD10 => D7    PD10 => D15
 * PD13 => Backlight PWM (if variable backlight)
 *
 * The code works without structural change on both the
 * F1 and F4. You will most likely have to change the
 * timing  configuration to suit your panel and FSMC
 * bus speed.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class LGDP453xTest {

  protected:
    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef LGDP453x_Portrait_262K<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11> > pd;

      // set up the FSMC timing. these numbers (particularly the data setup time) are dependent on
      // both the FSMC bus speed and the panel timing parameters.

      Fsmc8080LcdTiming fsmcTiming(0,2);

      // set up the FSMC with RS=A16 (PD11)

      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);
      _gl=new LcdPanel(*_accessMode);

      // apply gamma settings

      LGDP453xGamma gamma(0x0006,0x0101,0x0003,0x0106,0x0b02,0x0302,0x0707,0x0007,0x0600,0x020b);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        jpegTest();
        lzgTest();
        basicColoursTest();
        textTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        rectTest();
        lineTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("stm32plus 2.0.0 Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      if(_gl->getHeight()==320 && _gl->getWidth()==240) {

        prompt("stm32plus 2.0.0 JPEG bitmap test");

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle(0,0,240,320),compressedData);

        MillisecondTimer::delay(3000);
      }
    }

    void lzgTest() {

      prompt("stm32plus 2.0.0 LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature
      // the syntax is slightly different between the F1 and F4.

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,true,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,false,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,true,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,false,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,true,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t before,elapsed;

      prompt("stm32plus 2.0.0 Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("stm32plus 2.0.0 Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();

      for(i=0;i<3000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << "Elapsed: " << (int32_t)elapsed << "ms";

      MillisecondTimer::delay(3000);
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("stm32plus 2.0.0 Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("stm32plus 2.0.0 Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("stm32plus 2.0.0 Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      int i;

      prompt("stm32plus 2.0.0 Line test");

      for(i=0;i<5000;i++) {
        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }
    }

    void rectTest() {

      int i;
      Rectangle rc;

      prompt("stm32plus 2.0.0 Rectangle test");

      for(i=0;i<1500;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0;i<10000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;

      prompt("stm32plus 2.0.0 Ellipse test");
      _gl->setBackground(0);

      for(i=0;i<1000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0;i<1500;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("stm32plus 2.0.0 Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  LGDP453xTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/lgdp453x/lgdp453x.cpp
// START FILE: ../examples/lgdp453x/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/lgdp453x/system/LibraryHacks.cpp
// START FILE: ../examples/adc_single_timer_interrupts/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/adc_single_timer_interrupts/system/LibraryHacks.cpp
// START FILE: ../examples/adc_single_timer_interrupts/adc_single_timer_interrupts.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"
#include "config/adc.h"
#include "config/timer.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * This example shows how to use a timer to trigger the ADC conversion. We set up Timer 3 to generate an
 * update event once per second. We use this update event to trigger a single channel conversion on ADC1.
 * We use the ADC1 end-of-conversion (EOC) interrupt to tell us when the conversion is ready. We then log
 * that converted value to the USART where you can see it using normal PC terminal software.
 *
 * Connect an analog input to PA0 to see the value of the conversion.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 *   STM32F107VCT6
 */


class AdcSingleTimerInterrupts {

  protected:
    bool _ready;

  public:

    void run() {

      /*
       * Reset the interrupt ready flag
       */

      _ready=false;

      /*
       * Declare Timer3
       */

      Timer3<Timer3InternalClockFeature> timer;

      /*
       * Set an up-timer up to tick at 8kHz with an auto-reload value of 7999
       * The timer will count from 0 to 7999 inclusive then reset back to 0.
       * It will take exactly 1 second to do this. The timer generates its update
       * event when it wraps around to zero.
       */

      timer.setTimeBaseByFrequency(8000,7999);

#if defined(STM32PLUS_F0)

      /*
       * Declare the ADC peripheral with the 14MHz dedicated clock and a resolution of
       * 12 bits. We will use 144-cycle conversions on ADC channel 0. We trigger the conversion
       * using the rising edge of Timer 3's trigger signal and we want the trigger to be linked
       * to the timer's update event.
       */

      Adc1<
        AdcAsynchronousClockModeFeature,                          // the free-running 14MHz HSI
        AdcResolutionFeature<12>,                                 // 12 bit resolution
        Adc1Cycle28RegularChannelFeature<0>,                      // using channel 0 (PA0) on ADC1 with 28.5 cycle latency
        AdcTimer3TriggerRisingFeature<AdcTriggerSource::Update>,  // using timer 3 trigger-on-update
        Adc1InterruptFeature
      > adc;

#elif defined(STM32PLUS_F1)

      /*
       * Declare the ADC peripheral with an APB2 clock prescaler of 2 and a resolution of
       * 12 bits. We will use 144-cycle conversions on ADC channel 0. We trigger the conversion
       * using the rising edge of Timer 3's trigger signal and we want the trigger to be linked
       * to the timer's update event.
       */

      Adc1<
        AdcClockPrescalerFeature<6>,                              // PCLK2/6
        Adc1Cycle55RegularChannelFeature<0>,                      // using channel 0 on ADC1 with 55.5-cycle latency
        AdcTimer3TriggerRisingFeature<AdcTriggerSource::Update>,  // using timer 3 trigger-on-update
        Adc1InterruptFeature
      > adc;

#elif defined(STM32PLUS_F4)

      /*
       * Declare the ADC peripheral with an APB2 clock prescaler of 2 and a resolution of
       * 12 bits. We will use 144-cycle conversions on ADC channel 0. We trigger the conversion
       * using the rising edge of Timer 3's trigger signal and we want the trigger to be linked
       * to the timer's update event.
       */

      Adc1<
        AdcClockPrescalerFeature<2>,                              // prescaler of 2
        AdcResolutionFeature<12>,                                 // 12 bit resolution
        Adc1Cycle144RegularChannelFeature<0>,                     // using channel 0 on ADC1 with 144-cycle latency
        AdcTimer3TriggerRisingFeature<AdcTriggerSource::Update>,  // using timer 3 trigger-on-update
        Adc1InterruptFeature
      > adc;

#endif

      /*
       * Subscribe to the interrupts raised by the ADC
       */

      adc.AdcInterruptEventSender.insertSubscriber(
          AdcInterruptEventSourceSlot::bind(this,&AdcSingleTimerInterrupts::onInterrupt)
        );

      /*
       * Declare an instance of USART that we'll use to write out the conversion results.
       */

      Usart1<> usart(57600);
      UsartPollingOutputStream outputStream(usart);

      /**
       * Enable the ADC interrupts
       */

      adc.enableInterrupts(Adc1InterruptFeature::END_OF_CONVERSION);

      /*
       * Start the timer
       */

      timer.enablePeripheral();

      /*
       * Wait for the interrupt handler to notify us then log the converted
       * value and the time since the last conversion
       */

      uint32_t now;
      uint16_t value;

      for(;;) {

        while(!_ready);
        _ready=false;

        value=adc.getRegularConversionValue();

        now=MillisecondTimer::millis();

        outputStream << "Converted value is " << StringUtil::Ascii(value)
                     << " at " << StringUtil::Ascii(now) << "ms.\r\n";
      }
    }


    /**
     * Interrupt handler for the DMA complete event. Set the ready flag
     * when it's received.
     */

    void onInterrupt(AdcEventType eventType,uint8_t adcNumber) {

      if(adcNumber==1 && eventType==AdcEventType::EVENT_REGULAR_END_OF_CONVERSION)
        _ready=true;
    }
};


int main() {

  // we're using interrupts, initialise NVIC and the SysTick timer

  Nvic::initialise();
  MillisecondTimer::initialise();

  AdcSingleTimerInterrupts adc;
  adc.run();

  // not reached
  return 0;
}
// END FILE: ../examples/adc_single_timer_interrupts/adc_single_timer_interrupts.cpp
// START FILE: ../examples/lds285/lds285.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * MC2PA8201 LCD test, show a looping graphics demo
 *
 * The MC2PA8201 driver is used by many of the Nokia QVGA
 * cellphone LCDs including the N95 8Gb.
 *
 * It's an 8-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring that
 * you need to do is as follows:
 *
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0
 * PD15 => D1
 * PD0  => D2
 * PD1  => D3
 * PE7  => D4
 * PE8  => D5
 * PE9  => D6
 * PE10 => D7
 * PD13 => Backlight PWM (if variable backlight)
 *
 * There are no special considerations for the F1 versus
 * the F4. The code works on both without any change.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class LDS285Test {

  protected:
    typedef Fsmc8BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef NokiaN95_8GB_Portrait_16M_TypeA<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11>> pd;

      // set up the FSMC with RS=A16 (PD11)

      Fsmc8080LcdTiming fsmcTiming(0,2);
      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);

      // declare a panel

      _gl=new LcdPanel(*_accessMode);

      // fade up to 100% in 2ms steps

      _gl->fadeBacklightTo(100,4);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        jpegTest();
        lzgTest();
        basicColoursTest();
        textTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        rectTest();
        lineTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }


    void jpegTest() {

      if(_gl->getHeight()==320 && _gl->getWidth()==240) {

        prompt("JPEG bitmap test");

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle(0,0,240,320),compressedData);

        _gl->setContentAdaptiveImageType(LcdPanel::CONTENT_ADAPTIVE_BRIGHTNESS_TYPE_STILL_IMAGE);
        MillisecondTimer::delay(3000);
        _gl->setContentAdaptiveImageType(LcdPanel::CONTENT_ADAPTIVE_BRIGHTNESS_TYPE_GUI);
      }
    }


    void lzgTest() {

      prompt("LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,true,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,false,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,true,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,false,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,true,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t before,elapsed;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();

      for(i=0;i<3000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << "Elapsed: " << (int32_t)elapsed << "ms";

      MillisecondTimer::delay(3000);
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      int i;

      prompt("Line test");

      for(i=0;i<5000;i++) {
        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }
    }

    void rectTest() {

      int i;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0;i<1500;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0;i<10000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0;i<1000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0;i<1500;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  LDS285Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/lds285/lds285.cpp
// START FILE: ../examples/lds285/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/lds285/system/LibraryHacks.cpp
// START FILE: ../examples/adc_single_injected/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/adc_single_injected/system/LibraryHacks.cpp
// START FILE: ../examples/adc_single_injected/adc_single_injected.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"
#include "config/adc.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * This example shows how "injected" channels can be combined with regular channels using
 * scan mode.
 *
 * We will use ADC1 to convert channel 1 (regular) and channel 2 (injected) in
 * scan mode using the ADC1 interrupt to tell us when all the data is ready.
 *
 * When the values have been converted the ADC1 peripheral will raise an interrupt and we will
 * write out the values to a USART. The USART is configured as 56000/8/N/1.
 *
 * If you want to see some real values then you'll need to wire PA0 (ADC123_IN0) and
 * PA1 (ADC123_IN1) to valid levels, or GND/VCC if you want to see values close to 0 and 4095.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F107VCT6
 *   STM32F407VGT6
 */


class AdcSingleInjected {

  private:
    volatile bool _ready;
    uint16_t _values[2];

    /*
     * Unfortunately the ADC is quite different across the MCU series so we have to
     * be MCU-specific when declaring this instance
     */

#if defined(STM32PLUS_F1)

      /*
       * Declare the ADC peripheral with a PCLK2 clock prescaler of 6. The ADC clock cannot exceed 14MHz so
       * if PCLK2 is 72MHz then we're operating it at 12MHz here.
       */

      Adc1<
        AdcClockPrescalerFeature<6>,              // PCLK2/6
        Adc1Cycle71RegularChannelFeature<0>,
        Adc1Cycle71InjectedChannelFeature<1>,
        Adc1InterruptFeature,
        AdcScanModeFeature
      > _adc;

#elif defined(STM32PLUS_F4)

    /*
     * Declare the ADC peripheral with an APB2 clock prescaler of 2, a resolution of
     * 12 bits. We will use 144-cycle conversions on ADC channels 0,1 and a 480-cycle
     * conversion on ADC channel 2. Scan mode is used with the default template parameter
     * that causes EOC to be raised at the end of a complete conversion group.
     */

    Adc1<
      AdcClockPrescalerFeature<2>,                // prescaler of 2
      AdcResolutionFeature<12>,                   // 12 bit resolution
      Adc1Cycle144RegularChannelFeature<0>,       // using regular channel 0 on ADC1 with 144-cycle latency
      Adc1Cycle144InjectedChannelFeature<1>,      // using injected channel 1 on ADC1 with 144-cycle latency
      Adc1InterruptFeature,                       // using interrupts to signal end of conversion
      AdcScanModeFeature<>                        // scan mode with EOC after each group
    > _adc;

#endif

  public:

    void run() {

      _ready=false;

      /*
       * Subscribe to the interrupts raised by the ADC
       */

      _adc.AdcInterruptEventSender.insertSubscriber(
          AdcInterruptEventSourceSlot::bind(this,&AdcSingleInjected::onInterrupt)
        );

      /*
       * Enable auto mode for the injected channels. Auto mode means that the injected group
       * is converted after the regular group.
       */

      _adc.enableAutoInjectedMode();

      /*
       * Declare an instance of USART that we'll use to write out the conversion results.
       */

      Usart1<> usart(57600);
      UsartPollingOutputStream outputStream(usart);

      /**
       * Enable the ADC interrupt that tells us when the injected value has been converted. Because the
       * injected channel is converted after the regular channel we know that both values will be ready
       * to read.
       */

      _adc.enableInterrupts(Adc1InterruptFeature::INJECTED_END_OF_CONVERSION);

      /*
       * Go into an infinite loop converting
       */

      for(;;) {

        // start a conversion

        _adc.startRegularConversion();

        while(!_ready);
        _ready=false;

        /*
         * write the values to the USART
         */

        outputStream << "Converted values are "
                     << StringUtil::Ascii(_values[0]) << ", "
                     << StringUtil::Ascii(_values[1]) << "\r\n";

        // wait for a second before converting the next set of values

        MillisecondTimer::delay(1000);
      }
    }


    /**
     * Interrupt callback will be fired when the injected value has been converted and
     * is ready for consumption. We'll read the regular and injected values out and signal to the
     * main context that the data is ready.
     * @param eventType Which interrupt was fired, see the AdcEventType enumeration for details.
     * @param adcNumber The ADC peripheral number that raised the interrupt (1..3). Will always be 1 in this test.
     */

    void onInterrupt(AdcEventType eventType,uint8_t adcNumber) {

      if(adcNumber==1 && eventType==AdcEventType::EVENT_INJECTED_END_OF_CONVERSION) {

        _values[0]=_adc.getRegularConversionValue();
        _values[1]=_adc.getInjectedConversionValue(0);

        _ready=true;
      }
    }
};


int main() {

  // we're using interrupts, initialise NVIC

  Nvic::initialise();

  MillisecondTimer::initialise();

  AdcSingleInjected adc;
  adc.run();

  // not reached
  return 0;
}
// END FILE: ../examples/adc_single_injected/adc_single_injected.cpp
// START FILE: ../examples/timer_dma_usart/timer_dma_usart.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"
#include "config/timer.h"
#include "config/dma.h"


using namespace stm32plus;


/**
 * This example shows how to use a timer linked to a DMA channel to transmit data
 * automatically to the USART peripheral.
 *
 * Timer1's update event is configured to fire once per second. That update event
 * is linked to a DMA channel that targets the USART1 peripheral's TX register. For
 * our demo purposes we transmit a sample text string continuously at a rate of 1
 * character per second.
 *
 * USART1 is used in default (unremapped) configuration: 4800-8-N-1
 *
 * Note that if you are using the STM32F4DISCOVERY board then you cannot use USART1
 * since the pins clash with onboard peripherals. I have tested this code on that
 * board using USART2.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class TimerDmaUsartTest {

  public:

    void run() {

      const char *dataToSend="Hello World";

      /*
       * We're using USART1 (APB2), unremapped. Configure it to run at 4800 baud, 8 bits
       * no flow control and 1 stop bit. (4800-8-N-1).
       */

      Usart1<> usart1(4800);

      /*
       * Configure Timer1 (APB2) with the internal clock source. No further features
       * are required.
       */

      Timer1<
        Timer1InternalClockFeature        // the timer bus is APB2 (APB on the F0)
      > timer;

      /*
       * Create an instance of the DMA channel that is connected to
       * Timer1's update event. Add a feature that connects the timer's update
       * event to the USART1 TX peripheral register.
       *
       * This will be a circular DMA configuration, i.e. it will automatically
       * run itself over and over again until we stop it.
       */

      Timer1UpdateDmaChannel<
        TimerUpdateDmaFeature<Usart1TxDmaPeripheralInfo,DMA_Priority_High,DMA_Mode_Circular>
      > dma;

      /*
       * Set the frequency of Timer1 to 50KHz with a reload value
       * of 50000. It will take 1 second to get from zero to 50000
       * so the attached DMA channel will get 1 update event per second.
       */

      timer.setTimeBaseByFrequency(50000,49999);

      /*
       * Start the timer
       */

      timer.enablePeripheral();

      /*
       * Attach the DMA channel to the timer and start it. The DMA
       * channel will automatically load the next character to transmit
       * into the USART register.
       */

      dma.beginWriteByTimer(timer,dataToSend,strlen(dataToSend));

      /*
       * It's all running in hardware now, the CPU is ours to do what we want with. I've run
       * out of bright ideas so I'll just do nothing.
       */

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  TimerDmaUsartTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_dma_usart/timer_dma_usart.cpp
// START FILE: ../examples/timer_dma_usart/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_dma_usart/system/LibraryHacks.cpp
// START FILE: ../examples/timer_dual_pwm_gpio_out/timer_dual_pwm_gpio_out.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * Timer demonstration: Use timer 2 to output a 1Mhz PWM wave on channel 1 (PA0) and channel 2 (PA1).
 * The demo will repeatedly increment the duty cycle on each channel from 0 to 100% and back down to
 * 0 over 800ms. Channel 1 fades up while channel 2 fades down.
 *
 * To see the output, connect PA0 and PA1 to LEDs. e.g. on the F0 and F1 VL discovery
 * boards you can connect PA0 => PC8 and PA1 => PC9.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class TimerDualPwmGpioOutTest {

  public:

    void run() {

      /*
       * Initialise timer2 running from the internal APB1 (APB on the F0) clock with
       * channel-1, channel-2 and GPIO output features. The GPIO output feature is
       * itself configured with channel-1 and channel-2 output features.
       */

      Timer2<
        Timer2InternalClockFeature,       // the timer clock source is APB1 (APB on the F0)
        TimerChannel1Feature<>,           // we're going to use channel 1...
        TimerChannel2Feature<>,           // ...and we're going to use channel 2
        Timer2GpioFeature<                // we want to output something to GPIO
          TIMER_REMAP_NONE,               // the GPIO output will not be remapped
          TIM2_CH1_OUT,                   // we will output channel 2 to GPIO...
          TIM2_CH2_OUT                    // ...and we will output channel 2 to GPIO
        >
      > timer;

      /*
       * Set an up-timer up to tick at 10MHz with an auto-reload value of 1999
       * The timer will count from 0 to 1999 inclusive then reset back to 0.
       *
       * Note that the lowest frequency you can set is 1098 for a 72Mhz timer clock source.
       * This is because the maximum prescaler value is 65536 (72Mhz/65536 = 1098Hz).
       */

      timer.setTimeBaseByFrequency(10000000,1999);

      /*
       * Initialise channel 1 as a PWM channel in edge-aligned mode (TIM_OCMode_PWM1).
       * The default starting duty cycle is zero. Note that we have to qualify the initCompare
       * call because we're including multiple channels in our timer class and their members
       * have the same names.
       */

      timer.TimerChannel1Feature<>::initCompareForPwmOutput();

      /*
       * Initialise channel 2 as a PWM channel in edge-aligned mode (TIM_OCMode_PWM1).
       * The default starting duty cycle is zero.
       */

      timer.TimerChannel2Feature<>::initCompareForPwmOutput();

      /*
       * Enable the timer. The PWM outputs are on PA0 and PA1.
       */

      timer.enablePeripheral();

      /*
       * It's all running automatically now, use the main CPU to vary the duty cycle up
       * to 100% and back down again
       */

      for(;;) {

        // fade channel 1 up to 100% in 4ms steps while channel 2 comes down to 0

        for(int8_t i=0;i<=100;i++) {
          timer.TimerChannel1Feature<>::setDutyCycle(i);
          timer.TimerChannel2Feature<>::setDutyCycle(100-i);
          MillisecondTimer::delay(4);
        }

        // fade channel 1 down to 0% in 4ms steps while channel 2 goes up to 100%

        for(int8_t i=100;i>=0;i--) {
          timer.TimerChannel1Feature<>::setDutyCycle(i);
          timer.TimerChannel2Feature<>::setDutyCycle(100-i);
          MillisecondTimer::delay(4);
        }
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // we need the SysTick timer

  MillisecondTimer::initialise();

  TimerDualPwmGpioOutTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_dual_pwm_gpio_out/timer_dual_pwm_gpio_out.cpp
// START FILE: ../examples/timer_dual_pwm_gpio_out/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_dual_pwm_gpio_out/system/LibraryHacks.cpp
// START FILE: ../examples/usart_send_dma_interrupts/usart_send_dma_interrupts.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


using namespace stm32plus;


/**
 * USART test: asynchronous sending multiple sequences of data using DMA to transfer it
 * and using DMA interrupts to move through the sequence of data items to transfer
 *
 * This example will send the first few words from the famous Lorem Ipsum quotation using
 * USART1. Connect an RS232 cable from USART1 to your PC and run a terminal program
 * (there are many free terminal programs) to see the data. The default (unremapped) USART1
 * pins are used.
 *
 * The DMA channel associated with USART1 Tx is set up and triggered. When the first transfer
 * is complete an interrupt fires and we use to initiate the next transfer. When all transfers
 * are complete we lock up.
 *
 * Note that if you are using the STM32F4DISCOVERY board then you cannot use USART1 since the
 * pins clash with onboard peripherals. I have tested this code on that board using USART2.
 *
 * The protocol is 57600/8/N/1
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103VET6
 *   STM32F407VGT6
 */

static const char *_loremIpsum[]={
  "Lorem ","ipsum ","dolor ","sit amet, ","consectetur ","adipisicing ","elit, ","sed ","do ",
  "eiusmod ","tempor ","incididunt ","ut ","labore ","et ","dolore ","magna ","aliqua."
};


class UsartSendInterruptsTest {

  protected:

    /*
     * The index of the string that we are sending
     */

    uint8_t _currentlySending;


    /*
     * The DMA peripheral appropriate for this USART, configured for transmitting
     */

    typedef Usart1TxDmaChannel<                       // use the correct channel
      UsartDmaWriterFeature<Usart1PeripheralTraits>,   // we will be writing to it
      Usart1TxDmaChannelInterruptFeature              // we want its interrupts to fire
    > MyUsartTxDmaChannel;

    MyUsartTxDmaChannel *_dma;

  public:

    /*
     * Run the test
     */

    void run()  {

      /*
       * We're using interrupts, set up the NVIC
       */

      Nvic::initialise();

      /*
       * Declare a USART1 object. Note that an alternative Usart1_Remap object is available
       * if your application demands that you use the alternate pins for USART1. Include the
       * feature class for writing to the USART over DMA.
       */

      Usart1<> usart(57600);

      // declare the DMA channel for the USART. Must come after the USART peripheral is set up.

      _dma=new MyUsartTxDmaChannel();

      // enable DMA interrupts and set ourselves up to observe them

      _dma->enableInterrupts(Usart1TxDmaChannelInterruptFeature::COMPLETE);
      _dma->DmaInterruptEventSender.insertSubscriber(
          DmaInterruptEventSourceSlot::bind(this,&UsartSendInterruptsTest::onInterrupt)
        );

      // start the first transfer

      _currentlySending=0;

      _dma->beginWrite(_loremIpsum[0],strlen(_loremIpsum[0]));

      // it's in the background from now on

      for(;;);
    }


    /*
     * DMA Interrupt callback function. This is called when the completion
     * interrupt that we've enabled is fired.
     */

    void onInterrupt(DmaEventType det) {

      if(det==DmaEventType::EVENT_COMPLETE) {

        // update to the next word

        _currentlySending++;

        // only start another if there is more to go

        if(_currentlySending<sizeof(_loremIpsum)/sizeof(_loremIpsum[0])) {

          // clear the completion flag and send the next word

          _dma->clearCompleteFlag();
          _dma->beginWrite(_loremIpsum[_currentlySending],strlen(_loremIpsum[_currentlySending]));
        }
      }
    }
};


/*
 * Main entry point
 */

int main() {

  UsartSendInterruptsTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usart_send_dma_interrupts/usart_send_dma_interrupts.cpp
// START FILE: ../examples/usart_send_dma_interrupts/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usart_send_dma_interrupts/system/LibraryHacks.cpp
// START FILE: ../examples/crc/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/crc/system/LibraryHacks.cpp
// START FILE: ../examples/crc/crc.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"
#include "config/crc.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * CRC demo. This demo will show how to calculate the 32-bit CRC of a stream of bytes
 * using the hardware CRC peripheral on the STM32. The calculated CRC will be output
 * to USART1. USART1 is configured as 57600-8-N-1. The demo CRC value is 4200624485.
 *
 * Usart1 (non-remapped) is not available on the STM32F4DISCOVERY. If this is your
 * target board then choose a remapped pin set or move to another usart, e.g. Usart2.
 *
 * The STM32 CRC peripheral operates on 32-bit words with considerations for the
 * endian-ness of the data left to the user. stm32plus provides implementations for
 * little and big endian calculations with customisable padding bytes for when your
 * data stream isn't a multiple of 32-bits long.
 *
 * Big endian mode:
 *   The words are bit-reversed before going to the CRC unit and the result is
 *   bit-reversed before returning to you.
 *
 * Little endian mode:
 *   No transformations at all are performed on the data.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class CrcTest {

  /**
   * The selected CRC mode. We'll use big-endian. Input data is bit-reversed before going in to the
   * calculation and results are bit-reversed before coming back.
   */

  typedef CrcBigEndian MyCrcMode;

  public:

    void run() {

      static const char *testString="Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua";

      /*
       * Declare USART1 to run at 57600 and attach an output stream to it
       */

      Usart1<> usart(57600);
      UsartPollingOutputStream usartOutputStream(usart);

      /*
       * Declare a big-endian CRC implementation with a default padding value
       * of zero and attach it to an output stream
       */

      MyCrcMode::Parameters p;
      MyCrcMode crc(p);

      CrcOutputStream<MyCrcMode> crcOutputStream(crc);

      /*
       * Calculate the CRC of the test string
       */

      crcOutputStream << testString;      // stream in the data to the CRC unit
      crcOutputStream.close();            // close the stream (calls finish() on the CRC)

      /*
       * Write out the CRC value to the USART
       */

      char buf[15];
      StringUtil::modp_uitoa10(crc.currentCrc(),buf);

      usartOutputStream << "CRC is " << buf;

      /*
       * Done
       */

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  CrcTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/crc/crc.cpp
// START FILE: ../examples/i2c_cs43l22/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/i2c_cs43l22/system/LibraryHacks.cpp
// START FILE: ../examples/i2c_cs43l22/i2c_cs43l22.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dac.h"


using namespace stm32plus;


/**
 * I2C / I2S demonstration using the onboard CS43L22
 * peripheral of the STM32F4Discovery board. This
 * example will play a continuous 1kHz sine wave tone
 * at 44.1kHz. The duration of the sample is 3 seconds
 * and we just go into a loop playing it continuously.
 *
 * To make it interesting we'll use I2S interrupt
 * mode to supply the data. Plug some headphones into
 * the jack on the STM32F4Discovery to hear the output
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6
 */

/*
 * The audio data is in audio_sample.cpp
 */

extern "C" const uint16_t AUDIO_SAMPLE[];


class CS43L22Test {

  public:

    /*
     * The F4 MCU packages match the pins on the F1 for equivalent peripherals but the F4 is not
     * limited to distinct sets of pins that make up a peripheral. Annoyingly the CS43L22 on the
     * F4Discovery board has I2C1 SCL and SDA split across what would be the default and remap
     * pin set on the F1 so we have to use 'custom' port/pin declarations instead of using one
     * of the I2C1_Default or I2C1_Remap pre-defined packages.
     */

    enum {
      Port_SCL=GPIOB_BASE,//!< SCL_PORT
      Port_SDA=GPIOB_BASE,//!< SDA_PORT

      Pin_SCL=GPIO_Pin_6, //!< SCL_PIN
      Pin_SDA=GPIO_Pin_9  //!< SDA_PIN
    };

    /*
     * Same goes for the I2S pins. They're using I2S3 on the F4Discovery board but the pin
     * choice for I2S3 does not match the F1.
     */

    enum {
      Port_WS   = GPIOA_BASE,
      Port_CK   = GPIOC_BASE,
      Port_SD   = GPIOC_BASE,
      Port_MCLK = GPIOC_BASE,

      Pin_WS   = GPIO_Pin_4,
      Pin_CK   = GPIO_Pin_10,
      Pin_SD   = GPIO_Pin_12,
      Pin_MCLK = GPIO_Pin_7
    };

  protected:

      enum {
        AUDIO_HEADER_SIZE = 22,     // in 16-bit words
        AUDIO_FILE_SIZE   = 132323  // in 16-bit words
      };

      /*
       * The CS43L22 has a control and a data interface. Here we define the type that will be used
       * for the control interface. It's going to be I2C.
       */

      typedef CS43L22ControlI2C<             // The I2C controller. It's templated with the I2C interface and features.
        I2C1_Custom<                         // F4 VLDiscovery pinning does not match one of the standard pinouts
          CS43L22Test,                       // get the pinning from this class
          I2CSingleByteMasterPollingFeature  // we're going to be polling in master mode
        >
      > MyDacControlInterface;

      /*
       * The data interface for this example will be I2S. Here we define a type for it.
       */

      typedef I2S3_Custom<          // F4 VLDiscovery pinning does not match one of the standard pinouts
          CS43L22Test,              // get the pinning from this class
          I2S3InterruptFeature      // we'll stream the data in the interrupt handler
        > MyDacDataInterface;

      /*
       * Now define the CS43L22 type with the control and data interface
       */

      typedef CS43L22<              // the device is parameterised with the I2C peripheral
        MyDacControlInterface,
        MyDacDataInterface
      > MyDac;

      /*
       * Declare the peripheral pointer
       */

      MyDac *_dac;

      /*
       * Data pointers used in the interrupts handler
       */

      const uint16_t *_currentAudioPointer;
      const uint16_t *_lastAudioSample;

  public:

    void run() {

      /*
       * Declare the reset pin which is on PD4 on the F4 discovery board.
       */

      GpioD<DefaultDigitalOutputFeature<4> > pd;

      /*
       * Declare an instance of the DAC with default I2C parameters of 100kHz, ACK-on, 50% duty, 7-bit
       * and default I2S parameters of 44kHz, master, phillips, 16-bit, mclk-on, cpol-low
       * Leave the master polling feature bus timeout at 5 seconds.
       */

      MyDac::Parameters params;
      params.resetPin=pd[4];

      _dac=new MyDac(params);

      // set ourselves up to observe the interrupts

      _dac->I2S3InterruptFeature::SpiInterruptEventSender.insertSubscriber(
          SpiInterruptEventSourceSlot::bind(this,&CS43L22Test::onInterrupt)
        );

      // reset the device

      _dac->reset();

      // send the I2C initialisation sequence

      if(!_dac->initialise())
        error(3);

      // check the device ID to ensure we've configured I2C correctly

      verifyId();

      // headphones on - default volume level of 200 (out of 255)

      _dac->headphonesOn();

      // set up the data pointer and enable interrupts

      _lastAudioSample=AUDIO_SAMPLE+AUDIO_FILE_SIZE-1;
      _currentAudioPointer=AUDIO_SAMPLE+AUDIO_HEADER_SIZE;

      _dac->I2S3InterruptFeature::enableInterrupts(SPI_I2S_IT_TXE);

      // finished - interrupts are now playing the wave

      for(;;) {
      }
    }

    /*
     * Interrupt callback function. This is called when the TXE interrupt that we've
     * enabled is fired.
     */

    void onInterrupt(SpiEventType set) {

      if(set==SpiEventType::EVENT_READY_TO_TRANSMIT) {

        // send the next half-word

        _dac->send(_currentAudioPointer,1);

        // advance to the next position

        if(_currentAudioPointer==_lastAudioSample)
          _currentAudioPointer=AUDIO_SAMPLE+AUDIO_HEADER_SIZE;
        else
          _currentAudioPointer++;
      }
    }


    /*
     * Read and verify the device id
     */

    void verifyId() {

      uint8_t id;

      // read the ID byte

      if(!_dac->readByte(MyDac::ID,id))
        error(1);

      // check it: the chip id is 11100xxx

      if((id & 0xf8)!=0xe0)
        error(2);
    }


    /*
     * Handle an error by flashing the LED on PD13 repeatedly
     */

    void error(uint8_t code) {

      GpioD<DefaultDigitalOutputFeature<13> > pd;

      for(;;) {

        for(uint8_t i=0;i<code;i++) {
          pd[13].set();
          MillisecondTimer::delay(250);
          pd[13].reset();
          MillisecondTimer::delay(250);
        }

        MillisecondTimer::delay(3000);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // timing is required

  MillisecondTimer::initialise();

  CS43L22Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/i2c_cs43l22/i2c_cs43l22.cpp
// START FILE: ../examples/adc_analog_watchdog/adc_analog_watchdog.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"
#include "config/adc.h"
#include "config/dac.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * This example shows how to use the analog watchdog. The analog watchdog allows you to set an acceptable voltage
 * range for one or all of your ADC channels, for example the VBat channel. If the level falls outside the acceptable
 * range then an interrupt is fired. Continuous conversion mode could be used along with interrupts in order to
 * do everything in the background although care must be taken in your code to avoid an infinite interrupt loop.
 *
 * We will set an acceptable range of 750-2500. We will configure DAC1 to output values of 0,1000,2000,3000,4000.
 * The output of DAC1 (PA4) will be connected to the input of ADC1 channel 0 (PA0).
 *
 * Connect the output of DAC1 (PA4) to the input of ADC channel 0 (PA0). Also connect PB6/PB7 to see the test
 * output on USART1.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 *   STM32F107VCT6
 */

class AdcAnalogWatchdog {

  protected:

    /*
     * Declare an instance of USART1 (TX/RX = PB6/PB7) that we'll use to write out
     * the results of the test. We're using remap1 to avoid a clash of peripherals
     * on the F4 discovery board. This remap is also OK for the F0 discovery.
     */

    Usart1_Remap1<> _usart;
    UsartPollingOutputStream _outputStream;

  public:

    /*
     * Constructor: initialise the USART
     */

    AdcAnalogWatchdog()
      : _usart(57600),_outputStream(_usart) {

    }


    /*
     * Run the test
     */

    void run() {

      /*
       * Configure DAC1 on PA4 and set the output value to 1500 so the AWD doesn't fire as
       * soon as the ADC starts up
       */

      Dac1<DacChannel112BitRightAlignmentFeature> dac;

      dac.write(1500);
      dac.enablePeripheral();

      /*
       * Unfortunately the ADC is quite different across the MCU series so we have to
       * be MCU-specific when declaring this instance
       */

#if defined(STM32PLUS_F0)

      /*
       * Declare the ADC peripheral with the 14MHz dedicated clock, a resolution of
       * 12 bits. We will use 28.5-cycle conversions on ADC channel 0.
       */

      Adc1<
        AdcAsynchronousClockModeFeature,          // the free-running 14MHz HSI
        AdcResolutionFeature<12>,                 // 12 bit resolution
        Adc1Cycle28RegularChannelFeature<0>,      // using channel 0 (PA0) on ADC1 with 28.5 cycle latency
        AdcSingleChannelAnalogWatchdogFeature<    // AWD guarding single channel
          0,                                      // and it's channel 0
          750,                                    // low threshold
          2500                                    // high threshold
        >,
        AdcInterruptFeature                       // interrupts are raised by the AWD
      > adc;

#elif defined(STM32PLUS_F1)

      /*
       * Declare the ADC peripheral with a PCLK2 clock prescaler of 6. The ADC clock cannot exceed 14MHz so
       * if PCLK2 is 72MHz then we're operating it at 12MHz here.
       */

      Adc1<
        AdcClockPrescalerFeature<6>,                // PCLK2/6
        Adc1Cycle7RegularChannelFeature<0,1>,       // using channel 0
        AdcSingleChannelAnalogWatchdogFeature<      // AWD guarding single channel
          0,                                        // and it's channel 0
          AdcChannelType::Regular,                  // it's a regular (non-injected) channel
          750,                                      // low threshold
          2500                                      // high threshold
        >,
        AdcInterruptFeature                         // interrupts are raised by the AWD
      > adc;

#elif defined(STM32PLUS_F4)

      /*
       * Declare the ADC peripheral with an APB2 clock prescaler of 2, a resolution of
       * 12 bits. We will use 144-cycle conversions on ADC channel 0
       */

      Adc1<
        AdcClockPrescalerFeature<2>,                // prescaler of 2
        AdcResolutionFeature<12>,                   // 12 bit resolution
        Adc1Cycle144RegularChannelFeature<0>,       // using channel 0 on ADC1 with 144-cycle latency
        AdcSingleChannelAnalogWatchdogFeature<      // AWD guarding single channel
          0,                                        // and it's channel 0
          AdcChannelType::Regular,                  // it's a regular (non-injected) channel
          750,                                      // low threshold
          2500                                      // high threshold
        >,
        AdcInterruptFeature                         // interrupts are raised by the AWD
      > adc;

#endif

      /*
       * Subscribe to the interrupts raised by the ADC
       */

      adc.AdcInterruptEventSender.insertSubscriber(
          AdcInterruptEventSourceSlot::bind(this,&AdcAnalogWatchdog::onInterrupt)
        );

      /*
       * Enable the ADC interrupts and the watchdog
       */

      adc.enableInterrupts(Adc1InterruptFeature::ANALOG_WATCHDOG);
      adc.enableAnalogWatchdog();

      /*
       * Go into an infinite loop
       */

      for(;;) {

        uint16_t i;

        for(i=0;i<=4000;i+=1000) {

          // write out the value to the DAC pin

          _outputStream << "Writing " << StringUtil::Ascii(i) << " to the DAC\r\n";
          dac.write(i);

          // do a conversion

          adc.startRegularConversion();

          // pause for a second. if the value written to the DAC is outside the configured AWD
          // range then the interrupt will fire and an alert will be written to the USART.

          MillisecondTimer::delay(1000);
        }
      }
    }


    /**
     * Interrupt callback will be fired when a value has been converted and
     * is ready for consumption. We'll just signal to the main code that it
     * can wake up and pick up the value.
     * @param eventType Which interrupt was fired, see the AdcEventType enumeration for details.
     * @param adcNumber The ADC peripheral number that raised the interrupt (1..3). Will always be 1 in this test.
     */

    void onInterrupt(AdcEventType eventType,uint8_t adcNumber) {

      if(adcNumber==1 && eventType==AdcEventType::EVENT_ANALOG_WATCHDOG)
        _outputStream << "Analog watchdog interrupt fired\r\n";
    }
};


/*
 * Main entry point
 */

int main() {

  // we're using interrupts, initialise NVIC

  Nvic::initialise();

  MillisecondTimer::initialise();

  AdcAnalogWatchdog adc;
  adc.run();

  // not reached
  return 0;
}
// END FILE: ../examples/adc_analog_watchdog/adc_analog_watchdog.cpp
// START FILE: ../examples/adc_analog_watchdog/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/adc_analog_watchdog/system/LibraryHacks.cpp
// START FILE: ../examples/ssd1963/ssd1963.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * SSD1963 480x272 LCD test, show a looping graphics demo
 *
 * The SSD1963_480x272PanelTraits panel traits class sets
 * up the SSD1963 PLL to run at 100Mhz with a pixel clock
 * of approximately 9MHz for the panel.
 *
 * The SSD1963 driver is configured to transfer data using
 * D0..D11. Therefore you will need to do the following
 * wiring:
 *
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0
 * PD15 => D1
 * PD0  => D2
 * PD1  => D3
 * PE7  => D4
 * PE8  => D5
 * PE9  => D6
 * PE10 => D7
 * PE11 => D8
 * PE12 => D9
 * PE13 => D10
 * PE14 => D11
 * PD13 => Backlight PWM (if variable backlight)
 *
 * Do not connect FSMC pins D12..D15.
 *
 * The code works without structural change on both
 * the F1 and F4.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 */

class SSD1963Test {

  protected:
    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef SSD1963_480x272_Landscape_16M<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11> > pd;

      // set up the FSMC with RS=A16 (PD11)

      Fsmc8080LcdTiming fsmcTiming(0,2);
      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);

      // declare a panel

      _gl=new LcdPanel(*_accessMode);

      // the reset sequence is complete but the SSD1963 is special in that the reset sequence is
      // done at a slow speed so now we have to speed up the FSMC to get optimum performance

      _accessMode->initialiseTiming(fsmcTiming,fsmcTiming);

      // apply gamma settings (zero = no curve selected)

      SSD1963Gamma gamma(0);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        jpegTest();
        lzgTest();
        basicColoursTest();
        rectTest();
        textTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        lineTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      // only draw if it can fit on screen (it's 480x272)

      if(_gl->getHeight()>=272 && _gl->getWidth()>=480) {

        prompt("JPEG bitmap test");

        // draw it centered

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle((_gl->getWidth()-480)/2,(_gl->getHeight()-272)/2,480,272),compressedData);

        MillisecondTimer::delay(5000);
      }
    }

    void lzgTest() {

      prompt("LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,false,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,true,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,false,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,true,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,false,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t start,before,elapsed,chars;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();
      chars=0;

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);

        chars+=19;
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << (chars*1000/elapsed)  << " characters/sec";

      MillisecondTimer::delay(3000);
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      uint32_t start;

      prompt("Clear screen test");

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {
        _gl->setBackground(rand());
        _gl->clearScreen();
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      uint32_t start;

      prompt("Line test");

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {
        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }
    }

    void rectTest() {

      Rectangle rc;
      uint32_t start;

      prompt("Rectangle test");

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        if(rc.Width>0 && rc.Height>0) {
          _gl->setForeground(rand());
          _gl->fillRectangle(rc);
        }
      }

      _gl->clearScreen();

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;
      uint32_t start;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 1000==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  SSD1963Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/ssd1963/ssd1963.cpp
// START FILE: ../examples/ssd1963/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/ssd1963/system/LibraryHacks.cpp
// START FILE: ../examples/usb_device_hid_keyboard/usb_device_hid_keyboard.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usb/device/hid.h"
#include "config/button.h"


using namespace stm32plus;
using namespace stm32plus::usb;


/**
 * This examples demonstrates using the STM32F4DISCOVERY board as a USB keyboard device, with the
 * slightly limiting factor of only having a single key! The USB Keyboard Boot protocol provides for
 * an 8-byte IN report that's used tell the host which of the modifier keys (ctrl/alt/shift etc) is
 * pressed and a 6-key rollover sequence. It also provides a 1-byte OUT report that the host uses
 * to communicate the current state of the keyboard LEDs (caps lock/num lock etc).
 *
 * Pressing the blue "user" key on the discovery board will send the letters 'a' through 'z' to the
 * host, one at a time before cycling back to 'a'. Pressing Caps-Lock on your real keyboard will light
 * the orange LED on the discovery board. Pressing Num-Lock will light the green LED. Finally, pressing
 * scroll-lock will light the red LED.
 *
 * To use this example, compile it and flash it to your STM32F4DISCOVERY board. Attach a USB
 * cable from the micro-USB socket on the discovery board to your PC. The USB device should be
 * recognised automatically. There's no need to detach your real keyboard from your PC - the PC USB HID
 * driver will happily recognise as many keyboards as you can plug in.
 *
 * Compatible MCU:
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6 / Windows 8.1 x64 host
 */

class UsbDeviceHidKeyboardTest {

  public:

    /*
     * declare a type for the the USB stack
     */

    typedef KeyboardHidDevice<
      InternalFsPhy<>,                    // use the internal full speed PHY with no features
      ManufacturerTextFeature,            // we'll supply a manufacturer name
      ProductTextFeature,                 // ... and a product name
      SerialNumberTextFeature,            // ... and a serial number
      ConfigurationTextFeature,           // ... and a config text string
      InterfaceTextFeature                // ... and an interface text string
    > MyUsb;


    /*
     * The three keyboard LEDs will go to these pins
     */

    GpioPinRef _numLock;                  // PD12 (green)
    GpioPinRef _capsLock;                 // PD13 (orange)
    GpioPinRef _scrollLock;               // PD14 (red)


    /*
     * Run the example
     */

    void run() {

      /*
       * Set up the keyboard LED indicators and switch them off
       */

      GpioD<DefaultDigitalOutputFeature<12,13,14>> pd;

      _numLock=pd[12];
      _capsLock=pd[13];
      _scrollLock=pd[14];

      _numLock.reset();
      _capsLock.reset();
      _scrollLock.reset();

      /*
       * Set up the auto-repeat pushbutton on PA0 with 500ms initial delay
       * then 150ms auto-repeat.
       */

      GpioA<DefaultDigitalInputFeature<0>> pa;
      AutoRepeatPushButton button(pa[0],false,500,150);

      /*
       * set up the parameters for the USB hid device. Do not attempt to reuse vid/pid combinations unless
       * you know how to flush your PC's USB driver cache because Windows caches the characteristics of each
       * device and will suspend your device if it suddenly re-appears as a different device type.
       */

      MyUsb::Parameters usbParams;

      usbParams.device_vid=0xDEAD;           // demo vendor ID
      usbParams.device_pid=0xBEED;           // demo product ID

      usbParams.device_manufacturer_text="Andy's Workshop";   // see params.device_language_[ids/count] to change the languages
      usbParams.device_product_text="stm32plus one-key keyboard";
      usbParams.device_serial_text="0123456789";
      usbParams.device_configuration_text="My configuration";
      usbParams.device_interface_text="My interface";

      /*
       * Declare the USB object - this will initialise internal variables but will not
       * start the peripheral
       */

      MyUsb usb;

      /*
       * Subscribe to errors
       */

      usb.UsbErrorEventSender.insertSubscriber(UsbErrorEventSourceSlot::bind(this,&UsbDeviceHidKeyboardTest::onError));

      /*
       * Subscribe to OUT reports from the host (keyboard LED status reports)
       */

      usb.UsbEventSender.insertSubscriber(UsbEventSourceSlot::bind(this,&UsbDeviceHidKeyboardTest::onEvent));

      /*
       * Start the USB peripheral. It will run asynchronously. There is no requirement
       * for the parameters to remain in scope after the initialise call
       */

      if(!usb.initialise(usbParams))
        for(;;);      // onError() has already locked up

      uint8_t keycode=4;      // 4 = USB keyboard 'a'

      for(;;) {

        // wait for the report interrupt delay time

        MillisecondTimer::delay(10);

        if(button.getState()==PushButton::Pressed) {

          // send the key to the host

          usb.sendKeyboardReport(keycode);

          // loop through the alphabet until code 29 is sent (code 29 = USB 'z')

          if(keycode==29)
            keycode=4;
          else
            keycode++;
        }
      }
    }


    /**
     * Event callback from the USB stack. Lots of stuff will come through here but
     * we're only interested in LED state notifications
     */

    void onEvent(UsbEventDescriptor& ued) {

      // reject all events that we don't care about

      if(ued.eventType!=UsbEventDescriptor::EventType::HID_KEYBOARD_LED_STATE)
        return;

      HidKeyboardLedStateEvent& event(static_cast<HidKeyboardLedStateEvent&>(ued));

      // light up the leds

      _numLock.setState(event.isNumLock());
      _capsLock.setState(event.isCapsLock());
      _scrollLock.setState(event.isScrollLock());
    }


    /**
     * USB error event received
     * @param uee the event descriptor
     */

    void onError(UsbErrorEvent& uee) {

      // ignore unconfigured errors from the HID device

      if(uee.provider==ErrorProvider::ERROR_PROVIDER_USB_DEVICE && uee.code==MyUsb::E_UNCONFIGURED)
        return;

      // flash the RED led on PD5 at 1Hz

      GpioD<DefaultDigitalOutputFeature<5>> pd;

      for(;;) {
        pd[5].reset();
        MillisecondTimer::delay(500);
        pd[5].set();
        MillisecondTimer::delay(500);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // initialise the interrupt controller

  Nvic::initialise();

  // initialise the millisecond timer

  MillisecondTimer::initialise();

  // run the test

  UsbDeviceHidKeyboardTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usb_device_hid_keyboard/usb_device_hid_keyboard.cpp
// START FILE: ../examples/usb_device_hid_keyboard/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usb_device_hid_keyboard/system/LibraryHacks.cpp
// START FILE: ../examples/fatfs_iterate/fatfs_iterate.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/nvic.h"
#include "config/sdcard.h"
#include "config/filesystem.h"
#include "config/display/tft.h"

// we're going to use the STL string

#include <iterator>
#include <string>


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * FAT file system iterator demo.
 *
 * This example will recursively iterate over the directories and files on a
 * FAT16/32 file system on an SD card connected via SDIO. The SD card must be inserted
 * and ready when this application runs. This demo was tested on a 4Gb class 10
 * SDHC microSD card.
 *
 * The output of the program is sent to a graphical LCD, in this case an ILI9325
 * panel connected via the FSMC. Other LCD drivers can be used by changing the device
 * driver name and ensuring that the correct access mode is selected (8 or 16 bit).
 *
 * Because I use the STL string I have added include/stl to the compile-time include path.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class FatFsIterateTest  {

  protected:

    // graphics library and terminal types and objects

    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef ILI9325_Portrait_64K<LcdAccessMode> LcdPanel;
    typedef ILI9325_Terminal_Portrait<LcdPanel> LcdTerminal;

    LcdAccessMode *_accessMode;
    LcdPanel *_graphicsLibrary;
    LcdTerminal *_terminal;
    Font *_font;
    DefaultBacklight *_backlight;

    // SD card and file system objects

    SdioDmaSdCard *_sdcard;
    FileSystem *_fs;
    NullTimeProvider _timeProvider;

  public:

    /*
     * Run the demo
     */

    void run() {

      // initialisation for the card and LCD

      initLcd();
      initSdcard();

      // now iterate the directories on the card

      iterateDirectories("");

      // we're done - lock up

      *_terminal << "Completed";
      for(;;);
    }


    /*
     * Recursively iterate over the directories and files on this card
     */

    void iterateDirectories(const std::string& directoryName) {

      DirectoryIterator *it;

      // print the name of the current directory

      *_terminal << "=> " << directoryName.c_str() << "\n";

      // get an iterator on to this directory. note that we own the returned
      // pointer and must delete it when we're finished.

      if(!_fs->getDirectoryIterator(directoryName.c_str(),it))
        error();

      // iterate over all entries in this directory

      while(it->next()) {

        // get a reference to the FileInformation object that describes the file/directory
        // that we're currently looking at

        const FileInformation& fileInfo(it->current());

        // print the name and length in bytes. other attributes such as the type and various
        // date/times are also available

        *_terminal << fileInfo.getFilename() << " = " << fileInfo.getLength() << " bytes\n";

        // if this is a directory and it's not one of the two special "." and ".." entries then
        // recursively print its contents

        if((fileInfo.getAttributes() & FileInformation::ATTR_DIRECTORY)!=0
            && strcmp(".",fileInfo.getFilename())!=0
            && strcmp("..",fileInfo.getFilename())!=0) {

          iterateDirectories(directoryName+"/"+std::string(fileInfo.getFilename()));
        }
      }

      // finished with the iterator, delete it

      delete it;
    }


    /*
     * Initialise the LCD. This demo uses the ILI9325 QVGA LCD connected to the FSMC
     * in 16 bit mode. We use a portrait-orientation terminal that will take advantage of
     * the hardware scrolling ability of the panel.
     */

    void initLcd() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11>> pd;

      // set up the FSMC with RS=A16 (PD11)

      Fsmc8080LcdTiming fsmcTiming(0,2);
      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);

      // declare an lcd driver and make a fixed font active

      _graphicsLibrary=new LcdPanel(*_accessMode);
      _font=new Font_APPLE8;
      *_graphicsLibrary << *_font;

      // declare the terminal

      _terminal=new LcdTerminal(*_graphicsLibrary);

      // clear the screen

      _graphicsLibrary->setBackground(ColourNames::BLACK);
      _graphicsLibrary->setForeground(ColourNames::WHITE);

      _terminal->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);
    }


    /*
     * Initialise the SD card and get a reference to a file system object. FAT16 and FAT32
     * are both supported.
     */

    void initSdcard() {

      // create the SDIO object and let it auto-initialise

      _sdcard=new SdioDmaSdCard;

      if(errorProvider.hasError())
        error();

      // initialise a file system from that found on the card

      if(!FileSystem::getInstance(*_sdcard,_timeProvider,_fs))
        error();
    }


    /*
     * Print an error code if something goes wrong and lock up
     */

    void error() {

      // print the error code

      *_terminal << "ERROR: " << errorProvider.getLast();

      // lock up

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // set up the NVIC priority groups and subgroups
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  FatFsIterateTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/fatfs_iterate/fatfs_iterate.cpp
// START FILE: ../examples/fatfs_iterate/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/fatfs_iterate/system/LibraryHacks.cpp
// START FILE: ../examples/usart_send_sync/usart_send_sync.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


using namespace stm32plus;


/**
 * USART test: synchronous sending data
 *
 * This example will send the string "Hello World" using USART1. Connect an RS232 cable
 * from USART1 to your PC and run a terminal program (there are many free terminal programs)
 * to see the data. The default (unremapped) USART1 pins are used.
 *
 * Note that if you are using the STM32F4DISCOVERY board then you cannot use USART1 since the
 * pins clash with onboard peripherals. I have tested this code on that board using USART2.
 *
 * The protocol is 57600/8/N/1
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class UsartSendSyncTest {

  public:

    void run() {

      const char *dataToSend="Hello World";

      /*
       * Declare a USART1 object. Note that an alternative Usart1_Remap object is available
       * if your application demands that you use the alternate pins for USART1. All the other
       * USART ports are available and types such as Usart1_Custom allow you to completely
       * customise your peripheral pinout if your MCU supports it.
       */

      Usart1<> usart(57600);

      /*
       * For kicks we'll use an output stream for sending to the port instead of using the
       * send(uint8_t) method on the usart object
       */

      UsartPollingOutputStream outputStream(usart);

      /*
       * Send the data
       */

      if(!outputStream.write(dataToSend,strlen(dataToSend))) {
        // error handling would go here
      }

      // finished

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  UsartSendSyncTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usart_send_sync/usart_send_sync.cpp
// START FILE: ../examples/usart_send_sync/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usart_send_sync/system/LibraryHacks.cpp
// START FILE: ../examples/timer_input_capture/timer_input_capture.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"
#include "config/timing.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * Timer input capture demo.
 *
 * This demonstration will calculate the frequency of a PWM signal and write it out
 * to USART1 every 3 seconds.
 *
 * Note that if you are using the STM32F4DISCOVERY board then you cannot use USART1
 * since the pins clash with onboard peripherals. I have tested this code on that
 * board using UART4.
 *
 * The USART protocol is 57600/8/N/1
 *
 * Timer2 channel 2 is used to generate a 10kHz PWM signal. This signal is fed to Timer3
 * channel 4. Each rising edge of the signal causes an interrupt to fire. When two
 * successive edges have been captured we calculate and display the result.
 *
 * You will need to wire PA1 (TIM2_CH2) to PB1 (TIM3_CH4) to test this demo.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class TimerInputCaptureTest {

  protected:

    /**
     * Declare a type for our input timer.
     */

    typedef Timer3<
        Timer3InternalClockFeature,         // we'll need this for the frequency calculation
        TimerChannel4Feature<               // we're going to use channel 4
          TimerChannelICRisingEdgeFeature,  // rising edge trigger
          TimerChannelICDirectTiFeature,    // direct connection
          TimerChannelICPreScaler1Feature,  // prescaler of 1
          TimerChannelICFilterFeature<0>    // no filter
        >,
        Timer3InterruptFeature,           // we want to use interrupts
        Timer3GpioFeature<                // we want to read something from GPIO
          TIMER_REMAP_NONE,               // the GPIO input will not be remapped
          TIM3_CH4_IN                     // we will read channel 4 from GPIO PB0
        >
      > MyInputTimer;

    /*
     * The timer needs to be a class member so we can see it from the callback
     */

    MyInputTimer *_myInputTimer;

    /*
     * State variables for reading the frequency
     */

    volatile uint16_t _captures[2];
    volatile uint8_t _captureIndex;
    volatile uint32_t _capturedFrequency;
    volatile bool _capturingNextFrequency;

  public:

    void run() {

      /*
       * Declare a USART1 object. Note that an alternative Usart1_Remap object is available
       * if your application demands that you use the alternate pins for USART1
       */

      Usart1<> usart1(57600);

      /*
       * We'll use an output stream for sending to the port instead of using the
       * send(uint8_t) method on the usart object
       */

      UsartPollingOutputStream outputStream(usart1);

      /*
       * We'll use Timer 2 to generate a PWM signal on its channel 2.
       * The signal will be output on PA1
       */

      Timer2<
        Timer2InternalClockFeature,     // clocked from the internal clock
        TimerChannel2Feature<>,         // we're going to use channel 1
        Timer2GpioFeature<              // we want to output something to GPIO
          TIMER_REMAP_NONE,             // the GPIO output will not (cannot for this timer) be remapped
          TIM2_CH2_OUT                  // we will output channel 1 to GPIO (PA1)
        >
      > outputTimer;

      /*
       * Set the output timer to 800kHz with a reload frequency of 10Khz (800kHz/80).
       */

      outputTimer.setTimeBaseByFrequency(800000,80-1);

      /*
       * Initialise the output channel for PWM output with a duty cycle of 50%. This will
       * give us a nice square wave for the input capture channel to sample.
       */

      outputTimer.initCompareForPwmOutput(50);

      /*
       * Declare a new instance of the input capture timer.
       */

      _myInputTimer=new MyInputTimer;

      /*
       * Insert our subscribtion of the capture interrupts generated by the input timer
       */

      _myInputTimer->TimerInterruptEventSender.insertSubscriber(
          TimerInterruptEventSourceSlot::bind(this,&TimerInputCaptureTest::onInterrupt)
        );

      /*
       * Reset the variables used to hold the state
       */

      _captureIndex=0;
      _capturingNextFrequency=true;

      /*
       * Enable channel 4 interrupts on Timer 3.
       */

      _myInputTimer->enableInterrupts(TIM_IT_CC4);

      /*
       * Enable both timers to start the action
       */

      outputTimer.enablePeripheral();
      _myInputTimer->enablePeripheral();

      /*
       * Loop until the next frequency has been captured
       */

      for(;;) {

        while(_capturingNextFrequency);

        /*
         * Write out the captured frequency to the USART
         */

        char buf[15];
        StringUtil::modp_uitoa10(_capturedFrequency,buf);
        outputStream << buf << "Hz\r\n";

        /*
         * Pause for 3 seconds
         */

        MillisecondTimer::delay(3000);

        /*
         * start capturing again
         */

        _capturingNextFrequency=true;
      }
    }


    /*
     * Interrupt callback function. This is called when the input capture
     * event is fired
     */

    void onInterrupt(TimerEventType tet,uint8_t /* timerNumber */) {

      if(tet==TimerEventType::EVENT_COMPARE4) {

        // store the current capture time

        _captures[_captureIndex]=_myInputTimer->getCapture();

        if(_captureIndex++==1) {

          // if the main loop is ready then calc the frequency and signal the main loop
          // note the scaling divisor because our timer clocks are scaled by a factor of
          // the APB1 prescaler.

          if(_capturingNextFrequency) {
            _capturedFrequency=_myInputTimer->calculateFrequency(_captures[0],_captures[1]);
            _capturingNextFrequency=false;
          }

          // back to storing at position zero

          _captureIndex=0;
        }
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // we're using interrupts, initialise NVIC

  Nvic::initialise();

  // initialise the SysTick timer

  MillisecondTimer::initialise();

  TimerInputCaptureTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_input_capture/timer_input_capture.cpp
// START FILE: ../examples/timer_input_capture/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_input_capture/system/LibraryHacks.cpp
// START FILE: ../examples/timer_dma_pwm/timer_dma_pwm.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"
#include "config/dma.h"


using namespace stm32plus;


/**
 * Timer demo that illustrates how to use a DMA channel to automatically reload
 * the PWM duty cycle.
 *
 * In this example timer 1 is configured to output a PWM signal on channel 2.
 * The timer's DMA channel for update events is used to automatically reload the
 * PWM duty cycle from a sequence that we supply each time the timer gets an
 * update event.
 *
 * The PWM signal is output on PA[9]. Connect this to a LED to see the fade feature.
 * On the F1VL and F4 discovery boards this means connecting PA9 to PC8
 * or PD13, respectively. The F0 discovery board is also PC8.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class TimerDmaPwmTest {

  public:

    void run() {

      uint8_t i,percents[200];

      /*
       * Create an instance of Timer1 running off the internal clock
       * with channel 1 and unremapped GPIO output features.
       */

      Timer1<
        Timer1InternalClockFeature,       // the timer bus is APB2
        TimerChannel2Feature<>,           // we're going to use channel 2
        Timer1GpioFeature<                // we want to output something to GPIO
          TIMER_REMAP_NONE,               // the GPIO output will not be remapped
          TIM1_CH2_OUT                    // we will output channel 2 to GPIO
        >
      > timer;

      /*
       * Create an instance of the DMA channel that is connected to
       * Timer1's update event and add in a PWM fader feature for
       * Timer1's channel 2. This will be a circular DMA configuration, i.e.
       * it will automatically run itself over and over again until we
       * stop it.
       */

      Timer1UpdateDmaChannel<
        Timer1Channel2UpdatePwmFadeTimerDmaFeature<DMA_Priority_High,DMA_Mode_Circular>
      > dma;

      // create a sequence of 0..100 (101 values)

      for(i=0;i<=100;i++)
        percents[i]=i;

      // follow it with a sequence of 99..1 (99 values)

      for(i=99;i>0;i--)
        percents[200-i]=i;

      /*
       * Set the frequency of Timer1 to 10Mhz with a reload value
       * of 50000. It will take 10e6/50000 = 200 ticks to get there
       * so the attached DMA channel will get 200 update events
       * per second.
       */

      timer.setTimeBaseByFrequency(10000000,49999);

      /*
       * Initialise channel 1's comparator for use as a PWM output
       */

      timer.initCompareForPwmOutput();

      /*
       * Start the timer
       */

      timer.enablePeripheral();

      /*
       * Attach the DMA channel to the timer and start it. The DMA
       * channel will automatically load each new duty cycle into
       * the CCR1 register on every update event. When it runs out
       * it will restart because it's in circular mode. The 'percents'
       * buffer does not need to remain in scope while the DMA operation
       * is running
       */

      dma.beginFadeByTimer(timer,percents,sizeof(percents));

      /*
       * It's all running automatically now - go and do something
       * cool with the CPU!
       */

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  TimerDmaPwmTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_dma_pwm/timer_dma_pwm.cpp
// START FILE: ../examples/timer_dma_pwm/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_dma_pwm/system/LibraryHacks.cpp
// START FILE: ../examples/usart_receive_interrupts/usart_receive_interrupts.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


using namespace stm32plus;


/**
 * USART test: asynchronous sending and receiving data using interrupts
 *
 * This example will receive 5 characters on USART1 and then immediately
 * echo them back. Connect an RS232 cable from USART1 to your PC and run
 * a terminal program (there are many free terminal programs) to
 * see the data. The default (unremapped) USART1 pins are used.
 *
 * We use interrupts to send and receive the data. The hardware raises a
 * TXE interrupt when it's ready to send a character and an RXNE interrupt
 * when data is ready to receive.
 *
 * Note that if you are using the STM32F4DISCOVERY board then you cannot use
 * USART1 since the pins clash with onboard peripherals. I have tested this
 * code on that board using USART2.
 *
 * The protocol is 57600/8/N/1
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class UsartReceiveInterruptsTest {

  protected:

    /*
     * We'll use this as our simple I/O buffer
     */

    uint8_t _buffer[5];
    uint8_t _index;

    /*
     * The USART1 peripheral configured with the interrupt feature
     */

    typedef Usart1InterruptFeature MyUsartInterrupt;
    Usart1<MyUsartInterrupt> _usart;

  public:

    /*
     * Use the constructor base initialiser to set up the USART at 57600
     */

    UsartReceiveInterruptsTest()
      :_usart(57600) {
    }

    /*
     * Run the test
     */

    void run()  {

      /*
       * We're using interrupts, set up the NVIC
       */

      Nvic::initialise();

      // register ourselves as an observer of the USART interrupts

      _usart.UsartInterruptEventSender.insertSubscriber(
          UsartInterruptEventSourceSlot::bind(this,&UsartReceiveInterruptsTest::onInterrupt)
        );

      // enable the receive interrupt. this will start the whole chain of events

      _index=0;
      _usart.enableInterrupts(MyUsartInterrupt::RECEIVE);

      // it's all going on in the background now. wish us luck :)

      for(;;);
    }


    /*
     * Interrupt callback function. This is called when the TXE interrupt that we've
     * enabled is fired.
     */

    void onInterrupt(UsartEventType uet) {

      if(uet==UsartEventType::EVENT_RECEIVE) {

        // receive the next character

        _buffer[_index++]=_usart.receive();

        // if we've got the 5 characters then disable receiving interrupts
        // and enable sending

        if(_index==5) {
          _index=0;
          _usart.disableInterrupts(MyUsartInterrupt::RECEIVE);
          _usart.enableInterrupts(MyUsartInterrupt::TRANSMIT);
        }
      }
      else if(uet==UsartEventType::EVENT_READY_TO_TRANSMIT) {

        // send the next character

        _usart.send(_buffer[_index++]);

        // if we've sent back all 5 then disable sending interrupts and go back
        // to receiving again

        if(_index==5) {
          _index=0;
          _usart.disableInterrupts(MyUsartInterrupt::TRANSMIT);
          _usart.enableInterrupts(MyUsartInterrupt::RECEIVE);
        }
      }
    }
};


/*
 * Main entry point
 */

int main() {

  UsartReceiveInterruptsTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usart_receive_interrupts/usart_receive_interrupts.cpp
// START FILE: ../examples/usart_receive_interrupts/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usart_receive_interrupts/system/LibraryHacks.cpp
// START FILE: ../examples/net_web_server/net_web_server.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net_http.h"
#include "config/timing.h"
#include "config/sdcard.h"
#include "config/filesystem.h"
#include "MyHttpConnection.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This demo brings together a number of the stm32plus components, namely the network stack, the RTC,
 * the SD card and the FAT16/32 filesystem to build a simple web server that listens on port 80.
 *
 * Files are served starting from the root directory on the SD card. HTTP GET is the only action
 * supported. A number of content-type mappings are supported and may be extended by amending
 * MyHttpConnection.h accordingly. The client URI must match a physical file on the card. e.g.
 * http://yourserver/foo/bar.html expects to find a file called /foo/bar.html on the SD card. The
 * server supports HTTP/1.1 persistent connections.
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient                 |
 *              +------+---------------------+
 * TRANSPORT:   | Tcp | Udp | Icmp           |
 *              +-----++---------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +----------------------------+
 *
 * This example is only compatible with the F4 because it requires the SDIO peripheral to be able
 * to talk to the SD card.
 *
 * An example website is included in the 'www' subdirectory of this card. To use, copy 'www' to the
 * root directory of your SD card, run this example and then retrieve it from your web browser at
 * "http://<your-dhcp-ip>/www/index.html"
 *
 * Tested on devices:
 *   STM32F407VGT6
 */

class NetHttpServerTest {

  public:

    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Icmp,Udp,Tcp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * The network stack, sdio and filesystem objects that we'll need for this demo
     */

    MyNetworkStack *_net;
    SdioDmaSdCard *_sdcard;
    FileSystem *_fs;
    RtcTimeProvider *_timeProvider;


    /*
     * Run the test
     */

    void run() {

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // create the RTC time provider for the file system. if writes are made to the card then
      // this provider will be used to timestamp them.

      _timeProvider=new RtcTimeProvider(rtc);

      // declare the SD card and check for error. the card must be inserted at this point

      _sdcard=new SdioDmaSdCard;

      if(errorProvider.hasError())
        error();

      // initialise a file system for the card. FAT16 and FAT32 are supported. the card must
      // already be formatted.

      if(!FileSystem::getInstance(*_sdcard,*_timeProvider,_fs))
        error();

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // increase the number of connections per server

      params.tcp_maxConnectionsPerServer=10;

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      // create an HTTP server on port 80 (our HTTP operates over TCP (the most common case))
      // Here we take advantage of the second template parameter to the TcpServer template to
      // pass in a user-defined type to the constructor of MyHttpConnection. We use it to pass
      // in a pointer to the filesystem object that holds the web documents.

      TcpServer<MyHttpConnection,FileSystem> *httpServer;

      if(!_net->tcpCreateServer(80,httpServer,_fs))
        error();

      // create an array to hold the active connections and configure it to
      // automatically receive connections as they arrive. It will also
      // automatically remove connections as they are closed.

      TcpConnectionArray<MyHttpConnection> connections(*httpServer);

      // now all the plumbing is in place, open up the server to start
      // accepting connection requests

      httpServer->start();

      // loop forever servicing connections via their handleXXX() methods

      connections.wait(TcpWaitState::WRITE | TcpWaitState::READ | TcpWaitState::CLOSED,0);
    }


    void error() {
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetHttpServerTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_web_server/net_web_server.cpp
// START FILE: ../examples/net_web_server/MyHttpConnection.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#pragma once


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * Our connection class. The HTTP server is templated to return instances of this class when
 * remote clients connect. Each instance of this class independently handles an incoming
 * connection. This model allows you to easily service multiple connections without having
 * to worry about doing the multiplexing yourself. When you're done with a connection just
 * delete it and the event system will take care of all necessary close and cleanup.
 */

class MyHttpConnection : public HttpServerConnection<MyHttpConnection> {

  public:

    /**
     * Customised parameters for this web server
     */

    struct Parameters : HttpServerConnection<MyHttpConnection>::Parameters {
      Parameters() {
        tcp_receiveBufferSize=512;            // increased receive buffer to get the request in one segment
        http_outputStreamBufferMaxSize=2048;  // increased send buffer to push out larger segments to the browser
        http_version11=true;                  // permit http/1.1 keep-alive to keep closing connection states down
      }
    };

  protected:
    FileSystem *_fs;
    File *_file;

  protected:
    void processRequest();
    void closeFile();
    FileInputStream *getErrorPageStream(const std::string& errorCode);

  public:
    MyHttpConnection(const Parameters& params,FileSystem *fs);
    ~MyHttpConnection();

    bool handleClosed();
    bool handleCallback();
    State handleStateChange(State newState);
    void handleRequestHeader(const std::string&);
};


/**
 * Constructor. We need to supply the base class with its parameters and we stash
 * the filesystem object that will be used to serve the web files.
 */

inline MyHttpConnection::MyHttpConnection(const Parameters& params,FileSystem *fs)
  : HttpServerConnection<MyHttpConnection>(params),
    _fs(fs),
    _file(nullptr) {
}


/**
 * Destructor, free resources
 */

inline MyHttpConnection::~MyHttpConnection() {
  closeFile();
}


inline void MyHttpConnection::closeFile() {
  if(_file!=nullptr) {
    delete _file;
    _file=nullptr;
  }
}


/**
 * Callback for when the connection is detected to be closed. We will self-destruct which will
 * cause the connection-released event to be fired and the connection state will be transferred
 * back to the network stack where the TCP closing sequence is managed. The connection itself
 * will be automatically removed from the connections array.
 * @return true - no need to abort the connection round robin.
 */

inline bool MyHttpConnection::handleClosed() {
  delete this;
  return true;
}


/**
 * Round-robin opportunity to do some processing. We're not interested.
 * @return true
 */

inline bool MyHttpConnection::handleCallback() {
  return true;
}


/**
 * There was a state change in the HTTP connection
 * @param newState The proposed new state
 * @return The actual new state
 */

inline HttpServerConnection<MyHttpConnection>::State MyHttpConnection::handleStateChange(State newState) {

  // a move away from the read states and on to the first write state is our trigger to
  // process the request and make the response available

  if(newState==State::READING_REQUEST_LINE)
    closeFile();                          // restarting an HTTP/1.1 connection
  if(newState==State::WRITING_RESPONSE)
    processRequest();

  return newState;
}


/**
 * We don't process headers
 * @param
 */

inline void MyHttpConnection::handleRequestHeader(const std::string&) {
}


/**
 * Process the incoming request
 */

inline void MyHttpConnection::processRequest() {

  std::string *response;
  FileInputStream *fis;

  fis=nullptr;

  if(!strcasecmp(_action.c_str(),"GET")) {

    if(_fs->openFile(_uri.c_str(),_file)) {

      response=new std::string(_version+" 200 OK\r\n");
      fis=new FileInputStream(*_file);
    }
    else {
      response=new std::string(_version+" 404 Not Found\r\n");
      fis=getErrorPageStream("404");
    }
  }
  else {
    response=new std::string(_version+" 501 Not Implemented\r\n");
    fis=getErrorPageStream("501");
  }

  // add headers

  addConnectionHeader(*response);

  if(fis) {
    addContentTypeHeader(*response);
    addContentLengthHeader(*response,_file->getLength());
  }

  (*response)+="\r\n";

  // add streams to response

  _output.addStream(new StlStringInputStream(response,true),true);

  if(fis)
    _output.addStream(fis,true);
}


/**
 * Get a new stream on to an error page. First /errors/<code>.html is checked and then /error.html
 * is checked. The URI is adjusted accordingly.
 * @return An input stream on to the file
 */

inline FileInputStream *MyHttpConnection::getErrorPageStream(const std::string& errorCode) {

  std::string filename("/errors/"+errorCode+".html");

  // first try the specific error page

  if(!_fs->openFile(filename.c_str(),_file)) {

    // now try the generic error page

    filename="/error.html";
    if(!_fs->openFile(filename.c_str(),_file))
      return nullptr;
  }

  // got it

  _uri=filename;
  return new FileInputStream(*_file);
}

// END FILE: ../examples/net_web_server/MyHttpConnection.h
// START FILE: ../examples/net_web_server/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_web_server/system/LibraryHacks.cpp
// START FILE: ../examples/ili9481/ili9481.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * ILI9481 HVGA LCD test, show a looping graphics demo
 *
 * It's a 16-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring that
 * you need to do is as follows:
 *
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0    PE11 => D8
 * PD15 => D1    PE12 => D9
 * PD0  => D2    PE13 => D10
 * PD1  => D3    PE14 => D11
 * PE7  => D4    PE15 => D12
 * PE8  => D5    PD8  => D13
 * PE9  => D6    PD9  => D14
 * PE10 => D7    PD10 => D15
 * PD13 => Backlight PWM (if variable backlight required)
 *
 * The code works without structural change on both the
 * F1 and F4. You will most likely have to change the
 * timing configuration to suit your panel and FSMC bus
 * speed. I include working timings for the F1 and F4
 * for the ILI9481 panel board that I own.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class ILI9481Test {

  protected:
    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef ILI9481_Landscape_64K<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11>> pd;

      // set up the FSMC with RS=A16 (PD11). The 60Mhz FSMC bus on the F4 needs
      // slower timings.

#if defined(STM32PLUS_F1)
      Fsmc8080LcdTiming fsmcTiming(0,2);
#else
      Fsmc8080LcdTiming fsmcTiming(2,10);
#endif

      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);

      // declare a panel

      _gl=new LcdPanel(*_accessMode);

      // apply gamma settings

      ILI9481Gamma gamma(0,0xf3,0,0xbc,0x50,0x1f,0,7,0x7f,0x7,0xf,0);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        jpegTest();
        lzgTest();
        basicColoursTest();
        textTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        rectTest();
        lineTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      prompt("JPEG bitmap test");

      // draw it centered

      LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
      _gl->drawJpeg(Rectangle((_gl->getWidth()-240)/2,(_gl->getHeight()-320)/2,240,320),compressedData);

      MillisecondTimer::delay(3000);
    }

    void lzgTest() {

      prompt("LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,true,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,false,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,true,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,false,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,true,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t before,elapsed;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();

      for(i=0;i<15000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << "Elapsed: " << (int32_t)elapsed << "ms";

      MillisecondTimer::delay(3000);
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      int i;

      prompt("Line test");

      for(i=0;i<15000;i++) {
        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }
    }

    void rectTest() {

      int i;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0;i<5000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0;i<50000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0;i<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0;i<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  ILI9481Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/ili9481/ili9481.cpp
// START FILE: ../examples/ili9481/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/ili9481/system/LibraryHacks.cpp
// START FILE: ../examples/net_udp_send/net_udp_send.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/timing.h"
#include "config/usart.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This example demonstrates how to send UDP packets to a remote host. After obtaining an IP
 * address via DHCP this example will send three 2Kb UDP packets to a remote host every 5 seconds.
 * The target IP address is hardcoded into this example code and you can change it to fit your
 * network configuration.
 *
 * I recommend either tcpdump (linux) or wireshark (windows) for observing the incoming packets.
 * The requisite wireshark filter is "udp.dstport==12345"
 *
 * If there are any errors then they are output to a USART which for me is USART3 57600/8/N/1
 *
 * DHCP lease renewal is not considered here - see the DHCP example for the correct procedure.
 *
 * Here's how the network stack for this example is configured:
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient                |
 *              +----------------------------+
 * TRANSPORT:   | Udp                       |
 *              +-----+----------------------+
 * NETWORK      | DefaultIp | Arp           |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +-----------------------------
 *
 * This example is also tested using the KSZ8051MLL in MII mode instead of the DP83848C/RMII.
 * The KSZ8051MLL test was performed on the STM32F107. The DP83848C was tested on the STM32F407.
 * To reconfigure this demo for the F107 using remapped MAC pins connected to the KSZ8051MLL change
 * the physical and datalink layers thus:
 *
 * typedef PhysicalLayer<KSZ8051MLL> MyPhysicalLayer;
 * typedef DatalinkLayer<MyPhysicalLayer,RemapMiiInterface,Mac> MyDatalinkLayer;
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 */

class NetUdpSendTest {

  public:

    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    UsartPollingOutputStream *_outputStream;


    /*
     * Run the test
     */

    void run() {

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      _outputStream=new UsartPollingOutputStream(*_usart);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetUdpSendTest::onError));

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      // This is where we will send the UDP packets. Change it to suit your requirements
      // IP multicast senders are supported so feel free to use the multicast host group
      // range if that's what you want.

      IpAddress ipAddress("192.168.1.12");

      // Set up a buffer full of a test pattern. The buffer is 50 bytes in size and as such is
      // guaranteed to easily fit within the ethernet MTU size.

      uint32_t i;
      char buffer[50];
      for(i=0;i<sizeof(buffer);i++)
        buffer[i]=0x55;

      for(;;) {

        // send 3 packets in rapid succession to port 12345 on the target host

        for(i=0;i<3;i++)
          _net->udpSend(ipAddress,12345,12345,buffer,sizeof(buffer),false,5000);

        // wait for 5 seconds

        MillisecondTimer::delay(5000);
      }
    }


    /**
     * Network error event received, report it
     * @param ned
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetUdpSendTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_udp_send/net_udp_send.cpp
// START FILE: ../examples/net_udp_send/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_udp_send/system/LibraryHacks.cpp
// START FILE: ../examples/net_tcp_client/net_tcp_client.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/timing.h"
#include "config/usart.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This example demonstrates a TCP 'echo' client. It will attempt to connect to a server on a remote
 * computer and send it a line of text. The server will read that line of text and then send it back
 * in reverse. An example server, written in perl, is included in this example code directory.
 * It can be run directly on Linux or Linux-alike systems such as cygwin or msys on Windows. The
 * reversed string will be sent to the USART.
 *
 * I use Usart3, remap-2 with settings 57000/8/N/1.
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient                 |
 *              +------+---------------------+
 * TRANSPORT:   | Tcp | Udp                  |
 *              +-----++---------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +----------------------------+
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 */

class NetTcpClientTest {

  public:

    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp,Tcp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    UsartPollingOutputStream *_outputStream;


    /*
     * Run the test
     */

    void run() {

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      _outputStream=new UsartPollingOutputStream(*_usart);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetTcpClientTest::onError));

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      *_outputStream << "The TCP client is ready to run\r\n";

      TcpClientConnection *ptr;
      uint32_t actuallyReceived,actuallySent;
      char buffer[100];

      for(;;) {

        // connect to the remote end using a random local ephemeral port

        if(_net->tcpConnect<TcpClientConnection>("192.168.1.3",12345,ptr)) {

          // manage the connection pointer in a scoped_ptr so it's automatically deleted (and closed)
          // when it goes out of scope

          scoped_ptr<TcpClientConnection> conn(ptr);

          // send 11 bytes of text and a newline to the other end (blocking). We have to copy the data to
          // a sram buffer before sending because the STM32 Ethernet DMA peripheral cannot transmit from
          // flash memory. (string constants are compiled into flash).

          strcpy(buffer,"Hello World\n");

          if(conn->send(buffer,12,actuallySent) && actuallySent==12) {

            // receive the response line from the other end (blocking)

            if(conn->receive(buffer,100,actuallyReceived) && actuallyReceived>0) {

              // write the response to the USART stream

              _outputStream->write(buffer,actuallyReceived);
            }
          }
        }
        else
          *_outputStream << "Timed out while trying to connect, trying again...\r\n";

        // pause for 5 seconds to avoid flooding the network before doing it again

        MillisecondTimer::delay(5000);
      }
    }


    /**
     * Network error event received, report it
     * @param ned
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetTcpClientTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_tcp_client/net_tcp_client.cpp
// START FILE: ../examples/net_tcp_client/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_tcp_client/system/LibraryHacks.cpp
// START FILE: ../examples/dac_noise/dac_noise.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dac.h"


using namespace stm32plus;


/**
 * Demonstration of DAC channel 1 producing a pseudo-
 * random noise sequence. The output can be seen on PA4.
 * Attach an oscilloscope to see the noise wave or take
 * a look at waveform_f1.png in the example subdirectory
 * to see how it looks on the STM32F103ZET6.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6
 *   STM32F103ZET6
 */

class DacNoiseTest {

  public:

    void run() {

      /*
       * Set up the DAC with a software trigger and noise generation. No alignment feature
       * is necessary because we'll never be writing data - it's generated for us courtesy
       * of the mask setting in the parameters class.
       */

      Dac1<>::Parameters params;
      params.dac_trigger=DAC_Trigger_Software;
      params.dac_waveGeneration=DAC_WaveGeneration_Noise;

      Dac1<> dac(params);

      // continually trigger the noise conversion as fast as possible

      for(;;)
        dac.triggerOn();
    }
};


/*
 * Main entry point
 */

int main() {

  DacNoiseTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/dac_noise/dac_noise.cpp
// START FILE: ../examples/dac_noise/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/dac_noise/system/LibraryHacks.cpp
// START FILE: ../examples/cs43l22_beep/cs43l22_beep.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dac.h"


using namespace stm32plus;


/**
 * This example will sound the CS43L22 internal beep tone
 * twice per second. From experimentation I have
 * determined that the CS43L22 needs an incoming data
 * stream in order to generate the beep - just supplying
 * MCLK is not enough.
 *
 * Therefore for this demo I stream in a continuous
 * stream of nothing (zeros) while sounding the beep.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6
 */

class CS43L22BeepTest {

  public:

    /*
     * The F4 MCU packages match the pins on the F1 for equivalent peripherals but the F4 is not
     * limited to distinct sets of pins that make up a peripheral. Annoyingly the CS43L22 on the
     * F4Discovery board has I2C1 SCL and SDA split across what would be the default and remap
     * pin set on the F1 so we have to use 'custom' port/pin declarations instead of using one
     * of the I2C1_Default or I2C1_Remap pre-defined packages.
     */

    enum {
      Port_SCL=GPIOB_BASE,//!< SCL_PORT
      Port_SDA=GPIOB_BASE,//!< SDA_PORT

      Pin_SCL=GPIO_Pin_6, //!< SCL_PIN
      Pin_SDA=GPIO_Pin_9  //!< SDA_PIN
    };

    /*
     * Same goes for the I2S pins. They're using I2S3 on the F4Discovery board but the pin
     * choice for I2S3 does not match the F1.
     */

    enum {
      Port_WS   = GPIOA_BASE,
      Port_CK   = GPIOC_BASE,
      Port_SD   = GPIOC_BASE,
      Port_MCLK = GPIOC_BASE,

      Pin_WS   = GPIO_Pin_4,
      Pin_CK   = GPIO_Pin_10,
      Pin_SD   = GPIO_Pin_12,
      Pin_MCLK = GPIO_Pin_7
    };

  protected:

      /*
       * The CS43L22 has a control and a data interface. Here we define the type that will be used
       * for the control interface. It's going to be I2C.
       */

      typedef CS43L22ControlI2C<              // The I2C controller. It's templated with the I2C interface and features.
        I2C1_Custom<                          // F4 VLDiscovery pinning does not match one of the standard pinouts
          CS43L22BeepTest,                    // get the pinning from this class
          I2CSingleByteMasterPollingFeature   // we're going to be polling in master mode
        >
      > MyDacControlInterface;

      /*
       * The data interface for this example will be I2S. Here we define a type for it.
       */

      typedef I2S3_Custom<          // F4 VLDiscovery pinning does not match one of the standard pinouts
          CS43L22BeepTest,          // get the pinning from this class
          I2S3InterruptFeature      // we'll stream the data in the interrupt handler
        > MyDacDataInterface;

      /*
       * Now define the CS43L22 type with the control and data interface
       */

      typedef CS43L22<              // the device is parameterised with the I2C peripheral
        MyDacControlInterface,
        MyDacDataInterface
      > MyDac;

      /*
       * Declare the peripheral pointer
       */

      MyDac *_dac;

  public:

    void run() {

      /*
       * Declare the reset pin which is on PD4 on the F4 discovery board.
       */

      GpioD<DefaultDigitalOutputFeature<4> > pd;

      /*
       * Declare an instance of the DAC with default I2C parameters of 100kHz, ACK-on, 50% duty, 7-bit
       * and default I2S parameters of 44kHz, master, phillips, 16-bit, mclk-on, cpol-low
       * Leave the master polling feature bus timeout at 5 seconds.
       */

      MyDac::Parameters params;
      params.resetPin=pd[4];

      _dac=new MyDac(params);

      // set ourselves up to observe the interrupts

      _dac->I2S3InterruptFeature::SpiInterruptEventSender.insertSubscriber(
          SpiInterruptEventSourceSlot::bind(this,&CS43L22BeepTest::onNotify)
        );

      // reset the device

      _dac->reset();

      // send the I2C initialisation sequence

      if(!_dac->initialise())
        error(3);

      // headphones on - default volume level of 200 (out of 255)

      _dac->headphonesOn();

      // enable the interrupts - this will start the data transfer

      _dac->I2S3InterruptFeature::enableInterrupts(SPI_I2S_IT_TXE);

      // finished - interrupts are now supplying the null data stream

      for(;;) {

        // sound the beep and then wait 500ms

        _dac->beepSingle();
        MillisecondTimer::delay(500);
      }
    }


    /*
     * callback function. This is called when the TXE interrupt that we've enabled is fired.
     */

    void onNotify(SpiEventType set) {

      static const uint16_t NULL_DATA=0;

      // send the null data

      if(set==SpiEventType::EVENT_READY_TO_TRANSMIT)
        _dac->send(&NULL_DATA,1);
    }


    /*
     * Handle an error by flashing the LED on PD13 repeatedly
     */

    void error(uint8_t code) {

      GpioD<DefaultDigitalOutputFeature<13> > pd;

      for(;;) {

        for(uint8_t i=0;i<code;i++) {
          pd[13].set();
          MillisecondTimer::delay(250);
          pd[13].reset();
          MillisecondTimer::delay(250);
        }

        MillisecondTimer::delay(3000);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // timing is required

  MillisecondTimer::initialise();

  CS43L22BeepTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/cs43l22_beep/cs43l22_beep.cpp
// START FILE: ../examples/cs43l22_beep/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/cs43l22_beep/system/LibraryHacks.cpp
// START FILE: ../examples/r61523_mdvl/r61523_mdvl.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t FlagPixelsSize,FlagPixels;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * R61523 LCD test specifically for the STM32 VL Discovery board.
 * Show a looping graphics demo. We will make use of the built-in
 * PWM generator to control the backlight. This saves us an MCU
 * output pin and a timer peripheral.
 *
 * It's a 16-bit device and we control it in this demo using the optimised
 * 64K GPIO access mode. To achieve the high speed we access the entire data
 * port (16 bits) in one instruction. You will need to get your soldering
 * iron out and make the following modifications to the VL Discovery board
 * in order to run this demo:
 *
 * Connect solder bridge SB14
 * Connect solder bridge SB15
 * Remove resistor R15 (it's an 0R rating so not really a 'resistor')
 *
 * These modifications make all of GPIO port C available for IO at the
 * expense of losing access to the 32kHz oscillator used to drive the RTC.
 *
 * The wiring that you need to do is as follows:
 *
 * PA0       => RESET
 * PA1       => WR
 * PA2       => RS
 * PC[0..15] => LCD Data [0..15]
 *
 * And for the backlight, connect together the following
 * two pins on the LCD breakout board:
 *
 * BL_PWM => EN
 *
 * Compatible MCU:
 *   STM32F100 VL
 *
 * Tested on devices:
 *   STM32F100RBT6
 */

class R61523Test {

  public:

    // declare the ports and pins that we'll use

    enum {
      Port_DATA    = GPIOC_BASE,
      Port_CONTROL = GPIOA_BASE,

      Pin_RESET    = GPIO_Pin_0,
      Pin_WR       = GPIO_Pin_1,
      Pin_RS       = GPIO_Pin_2
    };

  protected:

    // declare the access mode carefully so that we pick up the optimised implementation

    typedef Gpio16BitAccessMode<R61523Test,COLOURS_16BIT,24,80,80> LcdAccessMode;
    typedef R61523_Landscape_64K<LcdAccessMode> LcdPanel;
    typedef R61523PwmBacklight<LcdAccessMode> LcdBacklight;

    LcdPanel *_gl;
    LcdBacklight *_backlight;
    Font_PROGGYCLEAN16 _font;

  public:
    void run() {

      // declare the access mode

      LcdAccessMode accessMode;

      // declare a panel

      _gl=new LcdPanel(accessMode);

      // apply the gamma curve. Note that gammas are panel specific. This curve is appropriate
      // to a replacement (non-original) panel obtained from ebay.

      uint8_t levels[13]={ 0xe,0,1,1,0,0,0,0,0,0,3,4,0 };
      R61523Gamma gamma(levels);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight using default template parameters

      _backlight=new LcdBacklight(accessMode);

      // fade up the backlight to 100% using the hardware to do the smooth fade

      _backlight->setPercentage(100);

      // A wide range of sample fonts are available. See the "lib/include/display/graphic/fonts"
      // directory for a full list and you can always download and convert your own using the
      // FontConv utility.

      *_gl << _font;

      for(;;) {
        lzgTest();
        basicColoursTest();
        backlightTest();
        gradientTest();
        textTest();
        rectTest();
        lineTest();
        ellipseTest();
        clearTest();
        sleepTest();
      }
    }


    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }


    void lzgTest() {

      prompt("LZG bitmap test");

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      _gl->drawBitmap(
          Rectangle((_gl->getWidth()-width)/2,
              (_gl->getHeight()-height)/2,
              width,height),
              decompressor);

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t i,start;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font.getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(_font,str);

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,_font,str);
      }
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[8]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
        ColourNames::WHITE,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      uint32_t i,start;

      prompt("Line test");

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }

      _gl->setForeground(ColourNames::WHITE);
      _gl->clearScreen();
      *_gl << Point::Origin << i << " lines in 5 seconds";
      MillisecondTimer::delay(3000);
    }

    void rectTest() {

      uint32_t i,start;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getYmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getYmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      uint32_t i,start;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }


    void backlightTest() {

      prompt("Backlight test");

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[8]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
        ColourNames::BLACK,
      };

      // draw a row of solid colours

      rc.X=0;
      rc.Y=0;
      rc.Height=_gl->getHeight()/2;
      rc.Width=_gl->getWidth()/(sizeof(colours)/sizeof(colours[0]));

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        _gl->setForeground(colours[i]);
        _gl->fillRectangle(rc);

        rc.X+=rc.Width;
      }

      // draw a greyscale

      rc.X=0;
      rc.Y=rc.Height;
      rc.Height=rc.Height/4;
      rc.Width=_gl->getWidth()/256;

      for(i=0;i<256;i++) {
        _gl->setForeground(i | (i << 8) | (i << 16));
        _gl->fillRectangle(rc);
        rc.X+=rc.Width;
      }

      for(i=100;i>0;i-=5) {

        // set the level

        _backlight->setPercentage(i);

        // show the indicator

        rc.X=_gl->getWidth()/4;
        rc.Y=(_gl->getHeight()*6)/8;
        rc.Height=_gl->getHeight()/8;

        // fill

        rc.Width=(_gl->getWidth()/2*i)/100;
        _gl->gradientFillRectangle(rc,Direction::HORIZONTAL,0x008000,0x00ff00);

        // remainder

        rc.X+=rc.Width;
        rc.Width=_gl->getWidth()/2-rc.Width;
        _gl->setForeground(ColourNames::BLACK);
        _gl->fillRectangle(rc);

        // show the percentage

        _gl->setForeground(ColourNames::WHITE);
        *_gl << Point(0,_gl->getHeight()-_font.getHeight()) << "Backlight level: " << i << "%  ";

        // pause

        MillisecondTimer::delay(750);
      }

      // restore backlight

      _backlight->setPercentage(100);
    }


    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  R61523Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/r61523_mdvl/r61523_mdvl.cpp
// START FILE: ../examples/r61523_mdvl/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/r61523_mdvl/system/LibraryHacks.cpp
// START FILE: ../examples/flash_spi_program/flash_spi_program.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/flash/spi.h"
#include "config/sdcard.h"
#include "config/usart.h"
#include "config/crc.h"
#include "config/filesystem.h"
#include "memory/scoped_ptr.h"
#include <vector>
#include <string>


using namespace stm32plus;


/**
 * This example programs a SPI flash device from files stored on an SD card and outputs
 * progress messages to a USART terminal. This programmer only requires the standard SPI
 * commands so it uses the 'StandardSpiFlashDevice' template. Other templates are available
 * that mixin commands specific to those devices.
 *
 * The SD card must contain an "index.txt" file in the "/spiflash" folder. "/spiflash/index.txt"
 * contains one line per file to flash The line is of the form:
 *
 *   <filename>=<start-address-in-flash-in-decimal>
 *
 * For example:
 *
 *   /spiflash/graphic1.bin=0
 *   /spiflash/graphic2.bin=16384
 *   /spiflash/assets/line.bin=24576
 *
 * Whitespace is not permitted anywhere on the text lines. It is important that each address
 * is a multiple of the device page size (usually 256 bytes). If it's not then you will get
 * data corruption. A chip-erase command is used to wipe the device before
 * programming.
 *
 * An example "spiflash" directory is included with this example that can be copied to
 * the root of your SD card. See the related 'flash_spi_reader' example for a demo that
 * reads back the example graphic files and displays them on an LCD.
 *
 * The default peripherals for this demo are SPI2, USART1, Winbond W25Q16DW 16Mbit flash. All
 * of these are customisable by you. The device identification code reported by the W25Q16DW
 * should be "ef6015".
 *
 * The pinout for SPI2 is:
 *
 *   NSS  = PB12
 *   SCK  = PB13
 *   MISO = PB14
 *   MOSI = PB15
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class FlashSpiProgram {

  // these are the peripherals we will use

  typedef Spi2<> MySpi;
  typedef Usart1<> MyUsart;
  typedef spiflash::StandardSpiFlashDevice<MySpi> MyFlash;

  // declare the peripheral pointers

  MyUsart *_usart;
  MySpi *_spi;
  MyFlash *_flash;
  SdioDmaSdCard *_sdcard;
  FileSystem *_fs;
  UsartPollingOutputStream *_usartStream;

  // declare the program variables

  struct FlashEntry {
    char *filename;
    uint32_t length;
    uint32_t offset;
  };

  std::vector<FlashEntry> _flashEntries;

  public:

    void run() {

      // initialise the USART

      _usart=new MyUsart(57600);
      _usartStream=new UsartPollingOutputStream(*_usart);

      status("Initialising SD card.");

      // initialise the SD card

      _sdcard=new SdioDmaSdCard;

      if(errorProvider.hasError())
        error("SD card could not be initialised");

      // initialise the filesystem on the card

      NullTimeProvider timeProvider;

      if(!FileSystem::getInstance(*_sdcard,timeProvider,_fs))
        error("The file system on the SD card could not be initialised");

      // Initialise the SPI peripheral in master mode. The SPI speed is bus/4
      // Make sure that this is not too fast for your device.

      MySpi::Parameters spiParams;
      spiParams.spi_mode=SPI_Mode_Master;
      spiParams.spi_baudRatePrescaler=SPI_BaudRatePrescaler_4;
      spiParams.spi_cpol=SPI_CPOL_Low;
      spiParams.spi_cpha=SPI_CPHA_1Edge;

      _spi=new MySpi(spiParams);

      // initialise the flash device

      _flash=new MyFlash(*_spi);

      // show the device identifier

      showDeviceIdentifier();

      // read the index file

      readIndexFile();

      // erase the flash device

      eraseFlash();

      // write each file

      for(auto it=_flashEntries.begin();it!=_flashEntries.end();it++)
        writeFile(*it);

      // verify each file

      for(auto it=_flashEntries.begin();it!=_flashEntries.end();it++)
        verifyFile(*it);

      // done

      status("Success");
      for(;;);
    }


    /*
     * Show the flash device id
     */

    void showDeviceIdentifier() {

      uint8_t id[3];
      char output[7];

      if(!_flash->readJedecId(id,sizeof(id)))
        error("Unable to read the flash id code");

      StringUtil::toHex(id,sizeof(id),output);
      output[sizeof(output)-1]='\0';

      *_usartStream << "Flash id = " << output << "\r\n";
    }


    /*
     * Erase the entire device
     */

    void eraseFlash() {

      status("Erasing the entire flash device");

      if(!_flash->writeEnable())
        error("Unable to enable write access");

      if(!_flash->chipErase())
        error("Unable to execute the erase command");

      if(!_flash->waitForIdle())
        error("Failed to wait for the flash device to be idle");

      status("Erase completed");
    }


    /*
     * Write the file to the flash device
     */

    void writeFile(const FlashEntry& fe) {

      uint8_t page[MyFlash::PAGE_SIZE];
      scoped_ptr<File> file;
      uint32_t i,remaining,actuallyRead,address;
      CrcBigEndian::Parameters params;
      CrcBigEndian crc(params);

      *_usartStream << "Programming " << fe.filename << "\r\n";

      if(!_fs->openFile(fe.filename,file.address()))
        error("Failed to open file");

      address=fe.offset;

      for(remaining=fe.length;remaining;remaining-=actuallyRead) {

        // read a page from the file

        if(!file->read(page,sizeof(page),actuallyRead))
          error("Failed to read from file");

        // cannot hit EOF here

        if(!actuallyRead)
          error("Unexpected end of file");

        // wait for the device to go idle

        if(!_flash->waitForIdle())
          error("Failed to wait for the device to become idle");

        // enable writing

        if(!_flash->writeEnable())
          error("Unable to enable write access");

        if(!_flash->waitForIdle())
          error("Failed to wait for the device to become idle");

        // program the page

        if(!_flash->pageProgram(address,page,actuallyRead))
          error("Failed to program the page");

        // add to CRC

        for(i=0;i<actuallyRead;i++)
          crc.addNewData(page[i]);

        // update for next

        address+=actuallyRead;
      }

      *_usartStream << "Programmed " << fe.filename <<  " OK. CRC = " << StringUtil::Ascii(crc.finish()) << "\r\n";
    }


    /*
     * Verify the file just written to the device
     */

    void verifyFile(const FlashEntry& fe) {

      uint8_t filePage[MyFlash::PAGE_SIZE],flashPage[MyFlash::PAGE_SIZE];
      scoped_ptr<File> file;
      uint32_t i,remaining,actuallyRead,address;
      CrcBigEndian::Parameters params;
      CrcBigEndian crc(params);

      *_usartStream << "Verifying " << fe.filename << "\r\n";

      if(!_fs->openFile(fe.filename,file.address()))
        error("Failed to open file");

      address=fe.offset;

      for(remaining=fe.length;remaining;remaining-=actuallyRead) {

        // read a page from the file

        if(!file->read(filePage,sizeof(filePage),actuallyRead))
          error("Failed to read from file");

        // cannot hit EOF here

        if(!actuallyRead)
          error("Unexpected end of file");

        // read the page from the flash device

        if(!_flash->fastRead(address,flashPage,actuallyRead))
          error("Failed to read from the flash device");

        // compare it

        if(memcmp(filePage,flashPage,actuallyRead)!=0)
          error("Verify error: programming failed");

        // add to CRC

        for(i=0;i<actuallyRead;i++)
          crc.addNewData(flashPage[i]);

        // update for next

        address+=actuallyRead;
      }

      *_usartStream << "Verified " << fe.filename << " OK. CRC = " << StringUtil::Ascii(crc.finish()) << "\r\n";
    }


    /*
     * Read index.txt
     */

    void readIndexFile() {

      scoped_ptr<File> file;
      char line[200],*ptr;

      status("Reading index file.");

      // open the file

      if(!_fs->openFile("/spiflash/index.txt",file.address()))
        error("Cannot open /index.txt");

      // attach a reader and read each line

      FileReader reader(*file);

      while(reader.available()) {

        scoped_ptr<File> dataFile;

        // read line

        if(!reader.readLine(line,sizeof(line)))
          error("Failed to read line from file");

        // search for the = separator and break the text line at it

        if((ptr=strchr(line,'='))==nullptr)
          error("Badly formatted index.txt line - cannot find = symbol");

        *ptr='\0';

        // ensure this file can be opened

        if(!_fs->openFile(line,dataFile.address()))
          error("Cannot open data file");

        FlashEntry fe;
        fe.filename=strdup(line);
        fe.offset=atoi(ptr+1);
        fe.length=dataFile->getLength();

        _flashEntries.push_back(fe);

        *_usartStream << "Parsed " << fe.filename
                      << " offset " << StringUtil::Ascii(fe.offset)
                      << " length " << StringUtil::Ascii(fe.length)
                      << "\r\n";
      }

      *_usartStream << "Finished reading index, "
                    << StringUtil::Ascii(_flashEntries.size()) << ", entries read\r\n";
    }


    /*
     * Unrecoverable error
     */

    void error(const char *text) {
      status(text);
      for(;;);
    }


    /*
     * Write a status string to the usart
     */

    void status(const char *text) {
      *_usartStream << text << "\r\n";
    }
};


/*
 * Main entry point
 */

int main() {

  MillisecondTimer::initialise();

  FlashSpiProgram test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/flash_spi_program/flash_spi_program.cpp
// START FILE: ../examples/flash_spi_program/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/flash_spi_program/system/LibraryHacks.cpp
// START FILE: ../examples/r61523_f051/r61523_f051.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * R61523 LCD test specifically for the STM32 F0 Discovery board. Show a looping graphics demo.
 * We will make use of the built-in PWM generator to control the backlight. This saves us an MCU
 * output pin and a timer peripheral.
 *
 * It's a 16-bit device and we control it in this demo using the optimised 64K GPIO access mode.
 * To achieve the high speed we access the entire data port (16 bits) in one instruction.
 *
 * The wiring that you need to do is as follows:
 *
 * PA0       => RESET
 * PA1       => WR
 * PA2       => RS
 * PC[0..15] => LCD Data [0..15]
 *
 * And for the backlight, connect together the following two pins on the LCD breakout board:
 *
 * BL_PWM => EN
 *
 * Compatible MCU:
 *   STM32F0
 *
 * Tested on devices:
 *   STM32F051R8T6
 */

class R61523Test {

  public:

    // declare the ports and pins that we'll use

    enum {
      Port_DATA    = GPIOC_BASE,
      Port_CONTROL = GPIOA_BASE,

      Pin_RESET    = GPIO_Pin_0,
      Pin_WR       = GPIO_Pin_1,
      Pin_RS       = GPIO_Pin_2
    };

  protected:

    // declare the access mode carefully so that we pick up the optimised implementation

    typedef Gpio16BitAccessMode<R61523Test,COLOURS_16BIT,48,42,42> LcdAccessMode;
    typedef R61523_Landscape_64K<LcdAccessMode> LcdPanel;
    typedef R61523PwmBacklight<LcdAccessMode> LcdBacklight;

    LcdPanel *_gl;
    LcdBacklight *_backlight;
    Font_PROGGYCLEAN16 _font;

  public:
    void run() {

      // declare the access mode

      LcdAccessMode accessMode;

      // declare a panel

      _gl=new LcdPanel(accessMode);

      // apply the gamma curve. Note that gammas are panel specific. This curve is appropriate
      // to a replacement (non-original) panel obtained from ebay.

      uint8_t levels[13]={ 0xe,0,1,1,0,0,0,0,0,0,3,4,0 };
      R61523Gamma gamma(levels);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight using default template parameters

      _backlight=new LcdBacklight(accessMode);

      // fade up the backlight to 100% using the hardware to do the smooth fade

      _backlight->setPercentage(100);

      // A wide range of sample fonts are available. See the "lib/include/display/graphic/fonts"
      // directory for a full list and you can always download and convert your own using the
      // FontConv utility.

      *_gl << _font;

      for(;;) {
        textTest();
        lzgTest();
        basicColoursTest();
        backlightTest();
        gradientTest();
        rectTest();
        lineTest();
        ellipseTest();
        clearTest();
        sleepTest();
      }
    }


    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }


    void lzgTest() {

      prompt("LZG bitmap test");

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      _gl->drawBitmap(
          Rectangle((_gl->getWidth()-width)/2,
              (_gl->getHeight()-height)/2,
              width,height),
              decompressor);

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t i,start;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font.getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(_font,str);

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,_font,str);
      }
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[8]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
        ColourNames::WHITE,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      uint32_t i,start;

      prompt("Line test");

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }

      _gl->setForeground(ColourNames::WHITE);
      _gl->clearScreen();
      *_gl << Point::Origin << i << " lines in 5 seconds";
      MillisecondTimer::delay(3000);
    }

    void rectTest() {

      uint32_t i,start;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getYmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getYmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      uint32_t i,start;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }


    void backlightTest() {

      prompt("Backlight test");

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[8]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
        ColourNames::BLACK,
      };

      // draw a row of solid colours

      rc.X=0;
      rc.Y=0;
      rc.Height=_gl->getHeight()/2;
      rc.Width=_gl->getWidth()/(sizeof(colours)/sizeof(colours[0]));

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        _gl->setForeground(colours[i]);
        _gl->fillRectangle(rc);

        rc.X+=rc.Width;
      }

      // draw a greyscale

      rc.X=0;
      rc.Y=rc.Height;
      rc.Height=rc.Height/4;
      rc.Width=_gl->getWidth()/256;

      for(i=0;i<256;i++) {
        _gl->setForeground(i | (i << 8) | (i << 16));
        _gl->fillRectangle(rc);
        rc.X+=rc.Width;
      }

      for(i=100;i>0;i-=5) {

        // set the level

        _backlight->setPercentage(i);

        // show the indicator

        rc.X=_gl->getWidth()/4;
        rc.Y=(_gl->getHeight()*6)/8;
        rc.Height=_gl->getHeight()/8;

        // fill

        rc.Width=(_gl->getWidth()/2*i)/100;
        _gl->gradientFillRectangle(rc,Direction::HORIZONTAL,0x008000,0x00ff00);

        // remainder

        rc.X+=rc.Width;
        rc.Width=_gl->getWidth()/2-rc.Width;
        _gl->setForeground(ColourNames::BLACK);
        _gl->fillRectangle(rc);

        // show the percentage

        _gl->setForeground(ColourNames::WHITE);
        *_gl << Point(0,_gl->getHeight()-_font.getHeight()) << "Backlight level: " << i << "%  ";

        // pause

        MillisecondTimer::delay(750);
      }

      // restore backlight

      _backlight->setPercentage(100);
    }


    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::GHOSTWHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  R61523Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/r61523_f051/r61523_f051.cpp
// START FILE: ../examples/r61523_f051/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/r61523_f051/system/LibraryHacks.cpp
// START FILE: ../examples/net_udp_receive/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_udp_receive/system/LibraryHacks.cpp
// START FILE: ../examples/net_udp_receive/net_udp_receive.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/timing.h"
#include "config/usart.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This example demonstrates how to receive UDP packets from a remote host. After obtaining an IP
 * address via DHCP this example will wait for UDP datagrams to arrive on port 12345. When a datagram
 * arrives it will print the first 10 bytes to USART #3.
 *
 * For testing I recommend the Linux NPING utility that allows you to create hand-crafted network
 * packets to send to your device. For example, here's how to send a byte sequence of 1..10 to your
 * device on 192.168.1.5 using nping:
 *
 * nping --udp 192.168.1.10 -p 12345 --data 0102030405060708090a
 *
 * The ICMP protocol is included to demonstrate how you'll get a "port unreachable" error if you try
 * to hit a port other than 12345. This feature can be individually controlled or ICMP can be left out
 * entirely.
 *
 * If there are any errors then they are output to a USART which for me is
 * USART3 57600/8/N/1
 *
 * DHCP lease renewal is not considered here - see the DHCP example for the correct procedure.
 *
 * Here's how the network stack for this example is configured:
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient                 |
 *              +------+---------------------+
 * TRANSPORT:   | Udp | Icmp                 |
 *              +-----++---------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +----------------------------+
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 */

class NetUdpReceiveTest {

  public:

    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp,Icmp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    TextOutputStream *_outputStream;


    /*
     * Run the test
     */

    void run() {

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      UsartPollingOutputStream usartStream(*_usart);
      _outputStream=new TextOutputStream(usartStream);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetUdpReceiveTest::onError));

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      for(;;) {

        uint8_t datagramBytes[10];
        uint16_t size;
        char buffer[20];
        bool printData;

        // receive up to 10 bytes with a 24 hour timeout. If nothing
        // arrives in 60 seconds then false is returned and ERROR_PROVIDER_NET_UDP/E_TIMED_OUT
        // are to be found in the errorProvider instance. 'size' is updated with the
        // number of bytes actually received, which may be less than I asked for.

        size=10;
        printData=false;

        if(!_net->udpReceive(12345,datagramBytes,size,1000*60*60*24)) {

          if(errorProvider.isLastError(ErrorProvider::ERROR_PROVIDER_NET_UDP,Udp<MyNetworkLayer>::E_MSG_SIZE)) {

            // got a datagram but it was too large and got truncated

            *(_outputStream) << "(truncated) ";
            printData=true;
          }
          else
            printData=false;    // another error occurred and no data was received
        }
        else
          printData=true;       // no error, data is ready and all fitted into the buffer

        if(printData) {

          // a datagram has been received, print the address of the sender

          const_cast<IpAddress&>(_net->udpGetRemoteAddress()).toString(buffer);

          *(_outputStream) << "From: " << buffer << ": ";

          // now print out the first 10 bytes

          for(uint16_t i=0;i<size;i++)
            (*_outputStream) << (uint16_t) datagramBytes[i] << " ";

          (*_outputStream) << "\r\n";
        }
      }
    }


    /**
     * Network error event received, report it
     * @param ned
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetUdpReceiveTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_udp_receive/net_udp_receive.cpp
// START FILE: ../examples/hx8347a/hx8347a.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * HX8347A LCD test, show a looping graphics demo
 *
 * It's a 16-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring
 * that you need to do is as follows:
 *
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0    PE11 => D8
 * PD15 => D1    PE12 => D9
 * PD0  => D2    PE13 => D10
 * PD1  => D3    PE14 => D11
 * PE7  => D4    PE15 => D12
 * PE8  => D5    PD8  => D13
 * PE9  => D6    PD9  => D14
 * PE10 => D7    PD10 => D15
 * PD13 => Backlight PWM (if variable backlight)
 *
 * The code works without structural change on both
 * the F1 and F4. I had to additional wait states
 * to the data setup time to get my panel to work on
 * the F4. You may also have to adjust.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class HX8347ATest {

  protected:
    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef HX8347A_Portrait_64K<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11>> pd;

      // set up the FSMC timing. these numbers (particularly the data setup time) are dependent on
      // both the FSMC bus speed and the panel timing parameters.

#if defined(STM32PLUS_F1)
      Fsmc8080LcdTiming fsmcTiming(0,2);
#elif defined(STM32PLUS_F4)
      Fsmc8080LcdTiming fsmcTiming(1,15);
#else
#error Unsupported MCU
#endif

      // set up the FSMC with RS=A16 (PD11)

      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);

      // declare a panel

      _gl=new LcdPanel(*_accessMode);

      // apply gamma settings

      HX8347AGamma gamma(0,7,0,0,0x10,0,0,0x16,0,0,0,0);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        jpegTest();
        lzgTest();
        basicColoursTest();
        textTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        rectTest();
        lineTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      // only draw in portrait mode and if it can fit on screen

      if(_gl->getHeight()>_gl->getWidth() && _gl->getHeight()>=320 && _gl->getWidth()>=240) {

        prompt("JPEG bitmap test");

        // draw it centered

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle((_gl->getWidth()-240)/2,(_gl->getHeight()-320)/2,240,320),compressedData);

        MillisecondTimer::delay(3000);
      }
    }

    void lzgTest() {

      prompt("LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,true,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,false,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,true,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,false,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,true,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle((_gl->getWidth()-width)/2,
                (_gl->getHeight()-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle((_gl->getWidth()-width)/2,
                (_gl->getHeight()-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t before,elapsed;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();

      for(i=0;i<3000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << "Elapsed: " << (int32_t)elapsed << "ms";

      MillisecondTimer::delay(3000);
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      int i;

      prompt("Line test");

      for(i=0;i<5000;i++) {
        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }
    }

    void rectTest() {

      int i;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0;i<1500;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0;i<10000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0;i<1000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0;i<1500;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  HX8347ATest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/hx8347a/hx8347a.cpp
// START FILE: ../examples/hx8347a/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/hx8347a/system/LibraryHacks.cpp
// START FILE: ../examples/net_ping_client/net_ping_client.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/timing.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This example demonstrates the ICMP transport by sending periodic echo requests (pings) to a
 * hardcoded IP address (change it to suit your network).
 *
 * This network stack is about as simple as it gets. We don't even use DHCP for client configuration
 * so you'll need to be connected to a network that understands that you have the static IP address
 * configured in this example.
 *
 * Here's how the network stack for this example is configured:
 *
 *              +----------------+-----------+
 * APPLICATION: | StaticIpClient | Ping      |
 *              +----------------------------+
 * TRANSPORT:   | Icmp                       |
 *              +-----+----------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +-----------------------------
 *
 * This example is also tested using the KSZ8051MLL in MII mode instead of the DP83848C/RMII. The
 * KSZ8051MLL test was performed on the STM32F107. The DP83848C was tested on the STM32F407. To
 * reconfigure this demo for the F107 using remapped MAC pins connected to the KSZ8051MLL change the
 * physical and datalink layers thus:
 *
 * typedef PhysicalLayer<KSZ8051MLL> MyPhysicalLayer;
 * typedef DatalinkLayer<MyPhysicalLayer,RemapMiiInterface,Mac> MyDatalinkLayer;
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 */

class NetPingClientTest {

  public:

    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,Arp,DefaultIp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Icmp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,StaticIpClient,Ping> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * Set by the PHY IRQ when there has been a change to the link status
     */

    volatile bool _linkStatusChanged;


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    UsartPollingOutputStream *_outputStream;

    /*
     * Run the test
     */

    void run() {

      // reset state

      _linkStatusChanged=false;

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      _outputStream=new UsartPollingOutputStream(*_usart);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference.

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      params.base_rtc=&rtc;

      // declare our IP address and subnet mask

      params.staticip_address="192.168.0.10";
      params.staticip_subnetMask="255.255.255.0";
      params.staticip_defaultGateway="192.168.0.1";

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // we'd like to be notified when there's a change in the link status so configure the
      // PHY interrupt mask to report that change. My development board has the PHY interrupt
      // line on PB14 so we'll need an active-low EXTI configured for that

      GpioB<DefaultDigitalInputFeature<14> > pb;
      Exti14 exti(EXTI_Mode_Interrupt,EXTI_Trigger_Falling,pb[14]);

      exti.ExtiInterruptEventSender.insertSubscriber(
          ExtiInterruptEventSourceSlot::bind(this,&NetPingClientTest::onLinkStatusChange)
        );

      if(!_net->phyEnableInterrupts(DP83848C::INTERRUPT_LINK_STATUS_CHANGE))
        error();

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetPingClientTest::onError));

      // start the ethernet MAC Tx/Rx DMA channels

      if(!_net->startup())
        error();

      for(;;) {

        char buf[20];
        uint32_t elapsed;

        // send a ping every 2 seconds

        if(_net->ping("192.168.1.2",elapsed)) {
          StringUtil::modp_uitoa10(elapsed,buf);
          *_outputStream << "Reply received in " << buf << "ms.\r\n";
        }
        else
          *_outputStream << "Timed out waiting for a reply\r\n";

        MillisecondTimer::delay(1000);

        // check on the link state

        if(_linkStatusChanged) {
          *_outputStream << "The link state changed\r\n";
          _linkStatusChanged=false;
        }
      }
    }


    /**
     * Network error event received, report it
     * @param ned
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    /**
     * Interrupt callback from the EXTI interrupt. Set the flag that main loop will act on.
     */

    void onLinkStatusChange(uint8_t /* extiLine */) {
      _linkStatusChanged=true;
      _net->phyClearPendingInterrupts();
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetPingClientTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_ping_client/net_ping_client.cpp
// START FILE: ../examples/net_ping_client/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_ping_client/system/LibraryHacks.cpp
// START FILE: ../examples/ili9325/ili9325.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * ILI9325 LCD test, show a looping graphics demo
 *
 * It's a 16-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring that
 * you need to do is as follows:
 *
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0    PE11 => D8
 * PD15 => D1    PE12 => D9
 * PD0  => D2    PE13 => D10
 * PD1  => D3    PE14 => D11
 * PE7  => D4    PE15 => D12
 * PE8  => D5    PD8  => D13
 * PE9  => D6    PD9  => D14
 * PE10 => D7    PD10 => D15
 * PD13 => Backlight PWM (if variable backlight)
 *
 * The code works without structural change on both the
 * F1 and F4. You will most likely have to change the
 * timing  configuration to suit your panel and FSMC
 * bus speed.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class ILI9325Test {

  protected:
    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef ILI9325_Portrait_262K<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11>> pd;

      // set up the FSMC timing. these numbers (particularly the data setup time) are dependent on
      // both the FSMC bus speed and the panel timing parameters.

      Fsmc8080LcdTiming fsmcTiming(0,2);

      // set up the FSMC with RS=A16 (PD11)

      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);
      _gl=new LcdPanel(*_accessMode);

      // apply gamma settings

      ILI9325Gamma gamma(0x0006,0x0101,0x0003,0x0106,0x0b02,0x0302,0x0707,0x0007,0x0600,0x020b);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        jpegTest();
        lzgTest();
        basicColoursTest();
        textTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        rectTest();
        lineTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      if(_gl->getHeight()==320 && _gl->getWidth()==240) {

        prompt("JPEG bitmap test");

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle(0,0,240,320),compressedData);

        MillisecondTimer::delay(3000);
      }
    }

    void lzgTest() {

      prompt("LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature
      // the syntax is slightly different between the F1 and F4.

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,true,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,false,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,true,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,false,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,true,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t before,elapsed;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();

      for(i=0;i<3000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << "Elapsed: " << (int32_t)elapsed << "ms";

      MillisecondTimer::delay(3000);
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      int i;

      prompt("Line test");

      for(i=0;i<5000;i++) {
        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }
    }

    void rectTest() {

      int i;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0;i<1500;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0;i<10000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0;i<1000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0;i<1500;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  ILI9325Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/ili9325/ili9325.cpp
// START FILE: ../examples/ili9325/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/ili9325/system/LibraryHacks.cpp
// START FILE: ../examples/usb_device_f0_custom_hid/usb_device_f0_custom_hid.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usb/device/device.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * This example demonstrates a custom 'Human Interface Device' (HID). Two neat things about
 * HID devices is that they don't need drivers on the host OS and there's no requirement for
 * them to interface with anything human at all. You can simply use them as useful bi-directional
 * interrupt driven communications channel if you want, and that's what we'll do in this
 * example.
 *
 * As long as there are no errors then this device will send an 11-byte report to the host
 * every second. The 11-bytes are, predictably, "Hello World". It will also listen for a 9-byte
 * report from the host. If it receives these 9 bytes: "stm32plus" then it will light a LED
 * on PB1 for 500ms. Change the LED port to something different if you have a board with
 * a LED on a different pin.
 *
 * Important! The SetSysClock() function in system/f042_48_8/System.c has been modified to set
 * up the system clock from the HSI48 USB clock and to trim it from SOF frames received from
 * the host. It also remaps PA11 and PA12 to PA9-10 for use by USB.
 *
 * Compatible MCU:
 *   STM32F0
 *
 * Tested on devices:
 *   STM32F042F6P6
 */

class UsbDeviceCustomHid {

  protected:

    /*
     * Definition for the LED. Change to suit your board.
     */

    enum { LED_PIN = 1 };
    typedef GpioB<DefaultDigitalOutputFeature<LED_PIN>> LedPort;


    /*
     * The constants in this structure are used to customise the HID to your
     * requirements.
     */

    struct MyHidConfiguration {

      enum {

        /*
         * USB Vendor and Product ID. Unfortunately commercial users will probably have to pay
         * the license fee to get an official VID and 64K PIDs with it. For testing and hacking
         * you can just do some research to find an unused VID and use it as you wish.
         */

        VID = 0xF055,
        PID = 0x7201,

        /*
         * IN and OUT are always with respect to the host. You as a device transmit on an IN
         * endpoint and receive on an OUT endpoint. Define how big your reports are here. 64-bytes
         * is the maximum allowed.
         *
         * Report id #1 is for reports TO the host (IN direction)
         * Report id #2 is for reports FROM the host (OUT direction)
         */

        IN_ENDPOINT_MAX_PACKET_SIZE = 12,   // 1 byte report id + 11-byte report
        OUT_ENDPOINT_MAX_PACKET_SIZE = 10,  // 1 byte report id + 9-byte report

        /*
         * The number of milliamps that our device will use. The maximum you can specify is 510.
         */

        MILLIAMPS = 100,

        /*
         * Additional configuration flags for the device. The available options that can be
         * or'd together are UsbConfigurationFlags::SELF_POWERED and
         * UsbConfigurationFlags::REMOTE_WAKEUP.
         */

        CONFIGURATION_FLAGS = 0,      // we want power from the bus

        /*
         * The language identifier for our strings
         */

        LANGUAGE_ID = 0x0809    // United Kingdom English.
      };

      /*
       * USB devices support a number of Unicode strings that are used to show information
       * about the device such as the manufacturer, product, serial number and some other
       * stuff that's not usually as visible to the user. You need to define all 5 of them
       * here with the correct byte length. Look ahead to where these are defined to see
       * what the byte lengths will be and then come back here and set them accordingly.
       */

      static const uint8_t ManufacturerString[32];
      static const uint8_t ProductString[22];
      static const uint8_t SerialString[12];
      static const uint8_t ConfigurationString[8];
      static const uint8_t InterfaceString[8];
    };


    /*
     * Member variables for this demo
     */

    volatile bool _deviceConfigured;
    volatile uint32_t _receivedReportTime;
    volatile uint32_t _lastTransmitTime;

  public:

    void run() {

      /*
       * Set up the default values for the member variables
       */

      _deviceConfigured=false;
      _receivedReportTime=UINT32_MAX-1000;
      _lastTransmitTime=0;

      /*
       * Declare the LED port and turn off the LED
       */

      LedPort led;
      led[LED_PIN].reset();

      /*
       * Declare the USB custom HID object. This will initialise pins but won't
       * power up the device yet.
       */

      UsbCustomHid<MyHidConfiguration> usb;

      /*
       * Subscribe to all the events
       */

      usb.UsbRxEventSender.insertSubscriber(UsbRxEventSourceSlot::bind(this,&UsbDeviceCustomHid::onReceive));
      usb.UsbTxCompleteEventSender.insertSubscriber(UsbTxCompleteEventSourceSlot::bind(this,&UsbDeviceCustomHid::onTransmitComplete));
      usb.UsbStatusEventSender.insertSubscriber(UsbStatusEventSourceSlot::bind(this,&UsbDeviceCustomHid::onStatusChange));

      /*
       * Start the peripheral. This will pull up the DP line which is the trigger for the host
       * to start enumeration of this device
       */

      usb.start();

      /*
       * Go into an infinite loop running the demo
       */

      for(;;) {

        // keep the LED lit if a report was received in the last 500ms

        led[LED_PIN].setState(!MillisecondTimer::hasTimedOut(_receivedReportTime,500));


        // if we're configured and it's been a second since the last time
        // then send a report to the host

        if(_deviceConfigured && MillisecondTimer::hasTimedOut(_lastTransmitTime,1000)) {

          // there's a race here in which the device could become unconfigured. a real program
          // should check the return value from usb.sendReport() before assuming that any
          // data was actually sent

          // note that the report data is always prefixed with the report ID, for the stm32plus
          // custom HID implementation report id #1 is for the IN direction (to host).

          usb.sendReport("\x01Hello World",12);
          _lastTransmitTime=MillisecondTimer::millis();
        }
      }
    }


    /*
     * Data received from the host
     */

    void onReceive(uint8_t endpointIndex,const uint16_t *data,uint16_t size) {

      // note that the report data is always prefixed with the report id, which is
      // 0x02 in the stm32plus custom HID implementation for reports OUT from the host

      if(endpointIndex==1 && size==10 && memcmp(data,"\x02stm32plus",size)==0)
        _receivedReportTime=MillisecondTimer::millis();
    }


    /*
     * Finished sending data to the host
     */

    void onTransmitComplete(uint8_t /* endpointIndex */,uint16_t /* size */) {
      // ACK received from the host
    }


    /*
     * Device status change event
     */

    void onStatusChange(UsbStatusType newStatus) {

      switch(newStatus) {

        case UsbStatusType::STATE_CONFIGURED:
        _deviceConfigured=true;
        _lastTransmitTime=MillisecondTimer::millis()+5000;    // 5 second delay before starting to send
        break;

        case UsbStatusType::STATE_DEFAULT:
        case UsbStatusType::STATE_ADDRESSED:
        case UsbStatusType::STATE_SUSPENDED:
          _deviceConfigured=false;
          break;

        default:
          break;
      }
    }
};


/*
 * These are the USB device strings in the format required for a USB string descriptor.
 * To change these to suit your device you need only change the unicode string in the
 * last line of each definition to suit your device. Then count up the bytes required for
 * the complete descriptor and go back and insert that byte count in the array declaration
 * in the configuration class.
 */

const uint8_t UsbDeviceCustomHid::MyHidConfiguration::ManufacturerString[sizeof(UsbDeviceCustomHid::MyHidConfiguration::ManufacturerString)]={
  sizeof(UsbDeviceCustomHid::MyHidConfiguration::ManufacturerString),
  USB_DESC_TYPE_STRING,
  'A',0,'n',0,'d',0,'y',0,'\'',0,'s',0,' ',0,'W',0,'o',0,'r',0,'k',0,'s',0,'h',0,'o',0,'p',0
};

const uint8_t UsbDeviceCustomHid::MyHidConfiguration::ProductString[sizeof(UsbDeviceCustomHid::MyHidConfiguration::ProductString)]={
  sizeof(UsbDeviceCustomHid::MyHidConfiguration::ProductString),
  USB_DESC_TYPE_STRING,
  'C',0,'u',0,'s',0,'t',0,'o',0,'m',0,' ',0,'H',0,'I',0,'D',0
};

const uint8_t UsbDeviceCustomHid::MyHidConfiguration::SerialString[sizeof(UsbDeviceCustomHid::MyHidConfiguration::SerialString)]={
  sizeof(UsbDeviceCustomHid::MyHidConfiguration::SerialString),
  USB_DESC_TYPE_STRING,
  '1',0,'.',0,'0',0,'.',0,'0',0
};

const uint8_t UsbDeviceCustomHid::MyHidConfiguration::ConfigurationString[sizeof(UsbDeviceCustomHid::MyHidConfiguration::ConfigurationString)]={
  sizeof(UsbDeviceCustomHid::MyHidConfiguration::ConfigurationString),
  USB_DESC_TYPE_STRING,
  'c',0,'f',0,'g',0
};

const uint8_t UsbDeviceCustomHid::MyHidConfiguration::InterfaceString[sizeof(UsbDeviceCustomHid::MyHidConfiguration::InterfaceString)]={
  sizeof(UsbDeviceCustomHid::MyHidConfiguration::InterfaceString),
  USB_DESC_TYPE_STRING,
  'i',0,'t',0,'f',0
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  UsbDeviceCustomHid hid;
  hid.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usb_device_f0_custom_hid/usb_device_f0_custom_hid.cpp
// START FILE: ../examples/usb_device_f0_custom_hid/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usb_device_f0_custom_hid/system/LibraryHacks.cpp
// START FILE: ../examples/flash_spi_reader/flash_spi_reader.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/flash/spi.h"
#include "config/display/tft.h"


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * This example is closely related to the 'flash_spi_program' example. That example programmed
 * the flash IC with 3 sample JPEG graphics files. This example will read back those graphics
 * files and display them on a TFT LCD.
 *
 * In this example the LCD is an LG KF700 cellphone LCD with an HX8352A controller. You can change
 * the graphics driver to a different one if you need to but be aware that the third JPEG is 480
 * pixels wide and may not fit on your choice of TFT.
 *
 * The SPI flash device is a 'standard' device that is only required to implement the 'fast read'
 * function. The STM32 SPI peripheral is SPI2, which you can change if you need to. The SPI flash
 * library includes an input stream implementation that we use to stream out the data required
 * by the JPEG decoder.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class FlashSpiReader {

  // definitions for the LCD panel

  typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
  typedef LG_KF700_Landscape_64K<LcdAccessMode> LcdPanel;

  LcdAccessMode *_accessMode;
  LcdPanel *_gl;

  // these are the peripherals we will use for the flash access

  typedef Spi2<> MySpi;
  typedef spiflash::StandardSpiFlashDevice<MySpi> MyFlash;

  // declare the peripheral pointers

  MySpi *_spi;
  MyFlash *_flash;

  public:

    void run() {

      // Initialise the SPI peripheral in master mode. The SPI speed is the highest available.
      // Make sure that this is not too fast for your flash device.

      MySpi::Parameters spiParams;
      spiParams.spi_mode=SPI_Mode_Master;
      spiParams.spi_baudRatePrescaler=SPI_BaudRatePrescaler_2;
      spiParams.spi_cpol=SPI_CPOL_Low;
      spiParams.spi_cpha=SPI_CPHA_1Edge;

      _spi=new MySpi(spiParams);

      // initialise the flash device

      _flash=new MyFlash(*_spi);

      // LCD reset is on PE1 and LCD RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11>> pd;

      // set up the FSMC timing. these numbers (particularly the data setup time) are dependent on
      // both the FSMC bus speed and the panel timing parameters.

      Fsmc8080LcdTiming fsmcTiming(0,2);

      // set up the FSMC with RS=A16 (PD11)

      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);
      _gl=new LcdPanel(*_accessMode);

      // apply gamma settings

      HX8352AGamma gamma(0xA0,0x03,0x00,0x45,0x03,0x47,0x23,0x77,0x01,0x1F,0x0F,0x03);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // the 'flash_spi_program' example wrote a sequence of 3 JPEG files to the SPI
      // flash device. For convenience this demo hard-codes the size and location.

      for(;;) {

        copyJpegToLcd(0,57961,367,240);
        copyJpegToLcd(58112,19272,240,160);
        copyJpegToLcd(77568,182190,480,240);
      }
    }


    /*
     * Copy a JPEG from flash to the LCD
     */

    void copyJpegToLcd(uint32_t offset,uint32_t size,int width,int height) {

      // draw in the center

      Rectangle rc(
          (_gl->getWidth()-width)/2,
          (_gl->getHeight()-height)/2,
          width,
          height);

      // clear the display

      _gl->clearScreen();

      // declare an input stream to read the JPEG and then do it

      spiflash::SpiFlashInputStream<MyFlash> is(*_flash,offset,size);
      _gl->drawJpeg(rc,is);

      // wait for 5 seconds

      MillisecondTimer::delay(5000);
    }
};


/*
 * Main entry point
 */

int main() {

  MillisecondTimer::initialise();

  FlashSpiReader test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/flash_spi_reader/flash_spi_reader.cpp
// START FILE: ../examples/flash_spi_reader/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/flash_spi_reader/system/LibraryHacks.cpp
// START FILE: ../examples/debug_semihosting/debug_semihosting.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

/*
 * Enable Semihosting support. This is the only change you need to make to enable
 * and disable semihosting. There is no need to surround your SemiHosting output
 * commands with #ifdef guards because a 'null' SemiHosting class is provided for
 * normal builds that will be optimised to nothing by the optimser. A real project
 * will define this in the project options (make, eclipse, scons etc).
 */

#define SEMIHOSTING


#include "config/stm32plus.h"
#include "config/gpio.h"
#include "config/timing.h"
#include "config/debug.h"


using namespace stm32plus;


/**
 * Semihosting is the useful ability to send debug strings to the host's console using the
 * STLink SWD debugger protocol. To use it with stm32plus ensure that you define SEMIHOSTING
 * (see above) and ensure that your OpenOCD debugger startup options include:
 *
 *   monitor arm semihosting enable
 *
 * If you fail to include the above line then you'll hit a breakpoint in the semihosting
 * implementation code at runtime.
 *
 * This example adds semihosting capabilities to the 'blink' example. It is the most basic
 * example that uses GPIO and the Systick timer to blink a LED on PC8 at 1Hz. PC8 is wired
 * to the blue onboard LED on the F1VL and F0 discovery boards.
 *
 * If the STM32F4DISCOVERY board is your target then change LED_PIN to 13 and the GPIO
 * declation to...
 *
 *  GpioD<DefaultDigitalOutputFeature<LED_PIN> > pd
 *
 * ... and change 2 of "pd[LED_PIN]" to "pd[LED_PIN]" to blink the orange led on the
 * discovery board.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F030R8T6
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F407VGT6
 */

class SemiHostingTest {

  public:

    enum {
      LED_PIN = 8
    };

    void run() {

      // initialise the pin for output

      GpioC<DefaultDigitalOutputFeature<LED_PIN> > pc;

      // loop forever switching it on and off with a 1 second
      // delay in between each cycle

      for(int i=0;;i++) {

        // show the current iteration status in the OpenOCD terminal window

        shost << "Blink loop, iteration " << i << "\n";

        pc[LED_PIN].set();
        MillisecondTimer::delay(1000);

        pc[LED_PIN].reset();
        MillisecondTimer::delay(1000);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  shost.puts("stm32plus blink is starting\n");

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  SemiHostingTest demo;
  demo.run();

  // not reached
  return 0;
}
// END FILE: ../examples/debug_semihosting/debug_semihosting.cpp
// START FILE: ../examples/debug_semihosting/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/debug_semihosting/system/LibraryHacks.cpp
// START FILE: ../examples/ssd1289/ssd1289.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * SSD1289 LCD test, show a looping graphics demo
 *
 * It's a 16-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring that
 * you need to do is as follows:
 *
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0    PE11 => D8
 * PD15 => D1    PE12 => D9
 * PD0  => D2    PE13 => D10
 * PD1  => D3    PE14 => D11
 * PE7  => D4    PE15 => D12
 * PE8  => D5    PD8  => D13
 * PE9  => D6    PD9  => D14
 * PE10 => D7    PD10 => D15
 * PD13 => Backlight PWM (if variable backlight)
 *
 * The code works without structural change on both the
 * F1 and F4. You will most likely have to change the
 * timing  configuration to suit your panel and FSMC
 * bus speed.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6
 */

class SSD1289Test {

  protected:
    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef SSD1289_Portrait_262K<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11> > pd;

      // set up the FSMC timing. these numbers (particularly the data setup time) are dependent on
      // both the FSMC bus speed and the panel timing parameters.

      Fsmc8080LcdTiming fsmcTiming(0,3);

      // set up the FSMC with RS=A16 (PD11)

      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);
      _gl=new LcdPanel(*_accessMode);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        jpegTest();
        lzgTest();
        basicColoursTest();
        textTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        rectTest();
        lineTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      if(_gl->getHeight()==320 && _gl->getWidth()==240) {

        prompt("JPEG bitmap test");

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle(0,0,240,320),compressedData);

        MillisecondTimer::delay(3000);
      }
    }

    void lzgTest() {

      prompt("LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature
      // the syntax is slightly different between the F1 and F4.

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,true,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,false,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,true,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,false,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,true,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t before,elapsed;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();

      for(i=0;i<3000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << "Elapsed: " << (int32_t)elapsed << "ms";

      MillisecondTimer::delay(3000);
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      int i;

      prompt("Line test");

      for(i=0;i<5000;i++) {
        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }
    }

    void rectTest() {

      int i;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0;i<1500;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0;i<10000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0;i<1000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0;i<1500;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  SSD1289Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/ssd1289/ssd1289.cpp
// START FILE: ../examples/ssd1289/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/ssd1289/system/LibraryHacks.cpp
// START FILE: ../examples/hx8352a_gpio/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/hx8352a_gpio/system/LibraryHacks.cpp
// START FILE: ../examples/hx8352a_gpio/hx8352a_gpio.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * This example shows a looping graphics library demo running on an
 * HX8352A display panel. The panel in this demo is from the LG KF700
 * cellphone (see my website for writeup). The access mode is the
 * highly optimised GPIO mode in 64K colours, landscape mode.
 *
 * The pinout is changeable to your needs. The demo setup is as follows.
 *
 * LCD_D0..15 = PD[0..15]       // a whole port is used for the 16 data lines
 * LCD RESET  = PE0             // RESET/WR/RS must be on the same port
 * LCD_WR     = PE1
 * LCD_RS     = PE2
 * LCD_VSYNC  = PE3             // input pin for vsync synchronisation
 *
 * Backlight PWM output = PA1 (connect to LCD_EN pin)
 *
 * Compatible MCU:
 *   STM32F1
 *
 * Tested on devices:
 *   STM32F103VET6
 */

class HX8352ATest {

  public:

    /**
     * Gpio16AccessMode is templated with the HX8352ATest class. Therefore it will expect to
     * find the following constants available for static access
     */

    enum {
      Port_CONTROL = GPIOE_BASE,        // will use [0..2]
      Port_DATA    = GPIOD_BASE,        // will use whole port as data bus D0..15

      Pin_RESET    = GPIO_Pin_0,
      Pin_WR       = GPIO_Pin_1,
      Pin_RS       = GPIO_Pin_2
    };

  protected:
    typedef Gpio16BitAccessMode_HX8352A_64K<HX8352ATest> LcdAccessMode;
    typedef LG_KF700_Landscape_64K<LcdAccessMode> LcdPanel;

    // define the PWM backlight to come from timer5, channel 2 (PA1)

    typedef Backlight<Timer5<Timer5InternalClockFeature,
                             TimerChannel2Feature<>,
                             Timer5GpioFeature<TIMER_REMAP_NONE,TIM5_CH2_OUT>
                             > > MyBacklight;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Exti3 *_exti;
    Font *_font;
    volatile bool _vsync;

  public:
    void run() {

      // set up the access mode

      _accessMode=new LcdAccessMode;

      // declare a panel

      _gl=new LcdPanel(*_accessMode);

      // apply gamma settings

      HX8352AGamma gamma(0xA0,0x03,0x00,0x45,0x03,0x47,0x23,0x77,0x01,0x1F,0x0F,0x03);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // the LG KF700 used for this demo gives us a vsync signal that we can synchronize
      // our drawing with. let's connect it to PE3 but don't subscribe to interrupts
      // until we get to that part of the demo

      GpioE<DefaultDigitalInputFeature<3>> pe;
      _exti=new Exti3(EXTI_Mode_Interrupt,EXTI_Trigger_Rising,pe[3]);

      // create the backlight on timer5, channel2 (PA1)

      MyBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        jpegTest();
        clearTest();
        textTest();
        basicColoursTest();
        rectTest();
        lzgTest();
        lineTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      // only draw if it can fit on screen

      if(_gl->getHeight()>=240 && _gl->getWidth()>=480) {

        prompt("JPEG bitmap test");

        // draw it centered

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle((_gl->getWidth()-480)/2,(_gl->getHeight()-240)/2,480,240),compressedData);

        MillisecondTimer::delay(5000);
      }
    }

    void lzgTest() {

      prompt("LZG bitmap test");

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      _gl->drawBitmap(
          Rectangle((_gl->getWidth()-width)/2,
              (_gl->getHeight()-height)/2,
              width,height),
              decompressor);

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t before,elapsed;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();

      for(i=0;i<3000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << "Elapsed: " << (int32_t)elapsed << "ms";

      MillisecondTimer::delay(3000);
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      int i;
      uint32_t start,duration;

      // first run doesn't synchronise with vsync. tearing will be visible.

      prompt("Clear screen test (no vsync)");

      start=MillisecondTimer::millis();
      for(i=0;i<200;i++) {
        _gl->setBackground(rand());
        _gl->clearScreen();
      }
      duration=(MillisecondTimer::millis()-start)/200;

      _gl->setForeground(ColourNames::WHITE);
      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      stopTimer("to clear one screen",duration);
      MillisecondTimer::delay(3000);

      prompt("Clear screen test (vsync synchronisation enabled)");

      // subscribe to the interrupts

      _exti->ExtiInterruptEventSender.insertSubscriber(
          ExtiInterruptEventSourceSlot::bind(this,&HX8352ATest::onVsyncInterrupt)
        );

      start=MillisecondTimer::millis();
      for(i=0;i<200;i++) {

        _gl->setBackground(rand());

        // wait for the next vsync signal

        _vsync=false;
        while(!_vsync);

        // clear screen and reset the flag

        _gl->clearScreen();
      }
      duration=(MillisecondTimer::millis()-start)/200;

      // unsubscribe from the interrupts

      _exti->ExtiInterruptEventSender.removeSubscriber(
          ExtiInterruptEventSourceSlot::bind(this,&HX8352ATest::onVsyncInterrupt)
        );

      _gl->setForeground(ColourNames::WHITE);
      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      stopTimer("to clear one screen",duration);
      MillisecondTimer::delay(3000);
    }

    /**
     * Interrupt callback from the EXTI interrupt
     */

    void onVsyncInterrupt(uint8_t /* extiLine */) {
      _vsync=true;
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      uint32_t i,start;

      prompt("Line test");

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }

      _gl->setForeground(ColourNames::WHITE);
      _gl->clearScreen();
      *_gl << Point::Origin << i << " lines in 5 seconds";
      MillisecondTimer::delay(3000);
    }

    void rectTest() {

      int i;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0;i<1500;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getYmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0;i<10000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getYmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0;i<1000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0;i<1500;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  HX8352ATest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/hx8352a_gpio/hx8352a_gpio.cpp
// START FILE: ../examples/hx8352a/hx8352a.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * HX8352A LCD test, show a looping graphics demo
 *
 * It's a 16-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring
 * that you need to do is as follows:
 *
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0    PE11 => D8
 * PD15 => D1    PE12 => D9
 * PD0  => D2    PE13 => D10
 * PD1  => D3    PE14 => D11
 * PE7  => D4    PE15 => D12
 * PE8  => D5    PD8  => D13
 * PE9  => D6    PD9  => D14
 * PE10 => D7    PD10 => D15
 * PD13 => Backlight PWM (if variable backlight)
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class HX8352ATest {

  protected:
    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef LG_KF700_Landscape_64K<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11>> pd;

      // Set up the FSMC timing. These numbers (particularly the data setup time) are dependent on
      // both the FSMC bus speed and the panel timing parameters. If you see corrupted graphics then
      // you may need to adjust these to uit the characteristics of your particular panel.

#if defined(STM32PLUS_F4)
      Fsmc8080LcdTiming fsmcTiming(3,6);
#elif defined(STM32PLUS_F1)
      Fsmc8080LcdTiming fsmcTiming(0,2);
#else
#error Invalid MCU
#endif

      // set up the FSMC with RS=A16 (PD11)

      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);

      // declare a panel

      _gl=new LcdPanel(*_accessMode);

      // apply gamma settings

      HX8352AGamma gamma(0xA0,0x03,0x00,0x45,0x03,0x47,0x23,0x77,0x01,0x1F,0x0F,0x03);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        lzgTest();
        rectTest();
        jpegTest();
        basicColoursTest();
        lineTest();
        textTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      // only draw in portrait mode and if it can fit on screen

      if(_gl->getHeight()>_gl->getWidth() && _gl->getHeight()>=320 && _gl->getWidth()>=240) {

        prompt("JPEG bitmap test");

        // draw it centered

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle((_gl->getWidth()-240)/2,(_gl->getHeight()-320)/2,240,320),compressedData);

        MillisecondTimer::delay(3000);
      }
    }

    void lzgTest() {

      prompt("LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,true,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,false,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,true,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,false,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,true,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle((_gl->getWidth()-width)/2,
                (_gl->getHeight()-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle((_gl->getWidth()-width)/2,
                (_gl->getHeight()-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t i,start;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      uint32_t i,start;

      prompt("Line test");

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }

      _gl->setForeground(ColourNames::WHITE);
      _gl->clearScreen();
      *_gl << Point::Origin << i << " lines in 5 seconds";
      MillisecondTimer::delay(3000);
    }

    void rectTest() {

      uint32_t i,start;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getYmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getYmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      uint32_t i,start;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  HX8352ATest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/hx8352a/hx8352a.cpp
// START FILE: ../examples/hx8352a/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/hx8352a/system/LibraryHacks.cpp
// START FILE: ../examples/timer_interrupts/timer_interrupts.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"


using namespace stm32plus;


/**
 * Timer demonstration: This demo uses the advanced control timer Timer1 to do something
 * not very advanced at all. We set the timer to count up and down, basically it oscillates
 * between 0 and 5000 at 1Khz. Each time one of the limits is hit the system raises an
 * 'Update' interrupt. We handle this interrupt by toggling a LED on PF6. The net result
 * of this is that the LED flashes on and off for a second in each of those states.
 *
 * If you are running this on the STM32F4DISCOVERY board then you can replace all reference
 * to PF6 with PD13 to use the onboard LED on that board.
 *
 * If you are running this on the VL or F0 DISCOVERY boards then you can replace all reference
 * to PF6 with PC8 to use the onboard LED on that board.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class TimerInterruptsTest  {

  protected:

    enum { LED_PIN = 6 };

    /*
     * We'll need these as member variables so that we can see them from the interrupt handler
     */

    GpioF<DefaultDigitalOutputFeature<LED_PIN> > _pf;
    bool _ledState;

  public:

    void run() {

      /*
       * Initialise timer1 running from the high speed internal APB2 (APB on the F0)
       * clock with an interrupt feature
       */

      Timer1<
        Timer1InternalClockFeature,       // the timer clock source is APB2 (APB on the F0)
        Timer1InterruptFeature            // gain access to interrupt functionality
      > timer;

      /*
       * We've got a LED on PF[6] and it's active LOW. Set it up here and switch it off.
       */

      _pf[LED_PIN].set();
      _ledState=false;

      /*
       * Set ourselves up as a subscriber for interrupts raised by the timer class.
       */

      timer.TimerInterruptEventSender.insertSubscriber(
          TimerInterruptEventSourceSlot::bind(this,&TimerInterruptsTest::onInterrupt)
        );


      /*
       * Set an up-down-timer up to tick at 5000Hz with an auto-reload value of 4999
       * The timer will count from 0 to 4999 inclusive, raise an Update interrupt and
       * then go backwards back down to 0 where it'll raise another Update interrupt
       * and start again. Each journey from one end to the other takes 1 second.
       *
       * Note that the lowest frequency you can set is 1098 for a 72Mhz timer clock source.
       * This is because the maximum prescaler value is 65536 (72Mhz/65536 = 1098Hz).
       */

      timer.setTimeBaseByFrequency(5000,4999,TIM_CounterMode_CenterAligned3);

      /*
       * Enable just the Update interrupt, clearing any spurious pending flag first
       */

      timer.clearPendingInterruptsFlag(TIM_IT_Update);
      timer.enableInterrupts(TIM_IT_Update);

      /*
       * Start the timer
       */

      timer.enablePeripheral();

      /*
       * It's all running automatically now
       */

      for(;;);
    }

    /*
     * Subscriber callback function. This is called when the update interrupt that we've
     * enabled is fired.
     */

    void onInterrupt(TimerEventType tet,uint8_t /* timerNumber */) {

      if(tet==TimerEventType::EVENT_UPDATE) {

        /*
         * Toggle the LED state.
         */

        _ledState^=true;
        _pf[LED_PIN].setState(_ledState);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // we're using interrupts, initialise NVIC

  Nvic::initialise();

  TimerInterruptsTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_interrupts/timer_interrupts.cpp
// START FILE: ../examples/timer_interrupts/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_interrupts/system/LibraryHacks.cpp
// START FILE: ../examples/usart_send_dma/usart_send_dma.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


using namespace stm32plus;


/**
 * USART test: sending data using the DMA peripheral
 *
 * This example will send the string "Hello World" using the DMA peripheral assigned to USART1. USART1
 * is using standard, unremapped pins.
 *
 * Note that if you are using the STM32F4DISCOVERY board then you cannot use USART1 since the pins
 * clash with onboard peripherals. I have tested this code on that board using USART2.
 *
 * The protocol is 57600/8/N/1
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class UsartSendDmaTest {

  public:

    void run() {

      const char *dataToSend="Hello World";

      /*
       * Declare a USART1 object. Note that an alternative Usart1_Remap object is available
       * if your application demands that you use the alternate pins for USART1. Include the
       * feature class for writing to the USART over DMA.
       */

      Usart1<> usart(57600);

      /*
       * Attach the correct DMA channel to this USART. The DMA channel has a writer feature
       * attached to it, and that writer feature takes a template parameter of the USART
       * peripheral so it knows where it's going to be writing to.
       */

      Usart1TxDmaChannel<UsartDmaWriterFeature<Usart1PeripheralTraits> > dma;

      /*
       * Write out the test string and wait for completion
       */

      dma.beginWrite(dataToSend,strlen(dataToSend));
      dma.waitUntilComplete();

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  UsartSendDmaTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usart_send_dma/usart_send_dma.cpp
// START FILE: ../examples/usart_send_dma/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usart_send_dma/system/LibraryHacks.cpp
// START FILE: ../examples/adc_single_dma_multichan/adc_single_dma_multichan.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timing.h"
#include "config/adc.h"
#include "config/usart.h"
#include "config/string.h"


using namespace stm32plus;


/**
 * This example adds DMA and multi-channel conversion to the mix. We'll use ADC1 to convert
 * three channels plus the internal temperature automatically and in sequence and we'll
 * write out the results to the USART for you to see.
 *
 * On the F0:
 *   The ADC uses the asynchronous 14MHz clock with channel latencies of 28,55,239.
 *
 * On the F1:
 *   The ADC uses PCLK2/6 (e.g. 72MHz/6 = 12MHz) with channel latencies of 7.5,13.5,55.5.
 *
 * On the F4:
 *   The ADC is configured in 'scan mode' which means that it will convert all the
 *   configured channels and, because we are not using continuous mode, it will stop at the end
 *   of the group.
 *
 * The DMA channel for ADC1 is used to move the converted channel data out to SRAM.
 * We configure the 'complete' DMA interrupt to fire when the complete group has
 * finished converting. The converted data is written to the USART, we pause for a second
 * and then do it all again, ad infinitum.
 *
 * USART1 is configured with protocol settings of 57600/8/N/1. The ADC channels are read
 * from PA[0], PA[1], PA[2]. You will need to connect these GPIO inputs to valid levels
 * between GND and VREF to see conversion values.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 *   STM32F107VCT6
 */


class AdcSingleDmaMultiChan {

  private:
    volatile bool _ready;

  public:

    void run() {

      _ready=false;

      /*
       * We're converting 4 channels in circular buffer mode so we need exactly 4 16-bit words
       * for that circular buffer
       */

      volatile uint16_t readBuffer[4];

      /*
       * Declare the ADC1 DMA channel. The default is circular mode for the AdcDmaFeature
       * which means that it wil automatically refill our buffer on each conversion because
       * one conversion exactly matches the size of the memory buffer that we will give
       * to the DMA peripheral.
       */

      Adc1DmaChannel<AdcDmaFeature<Adc1PeripheralTraits>,Adc1DmaChannelInterruptFeature> dma;

#if defined(STM32PLUS_F0)

      /*
       * Declare the ADC peripheral with the asynchronous 14MHz clock, a resolution of
       * 12 bits. We will use 28.5-cycle conversions on ADC channels 0,1 and a 55.5-cycle
       * conversion on ADC channel 2.
       */

      Adc1<
        AdcAsynchronousClockModeFeature,            // the free-running 14MHz HSI
        AdcResolutionFeature<12>,                   // 12 bit resolution
        Adc1Cycle28RegularChannelFeature<0,1>,      // using channels 0,1 on ADC1 with 28.5-cycle latency
        Adc1Cycle55RegularChannelFeature<2>,        // using channel 2 on ADC1 with 55-cycle latency
        Adc1Cycle239TemperatureSensorFeature        // using the temperature sensor channel
      > adc;

#elif defined(STM32PLUS_F1)

      /*
       * Declare the ADC peripheral with a PCLK2 clock prescaler of 6. The ADC clock cannot exceed 14MHz so
       * if PCLK2 is 72MHz then we're operating it at 12MHz here.
       */

      Adc1<
        AdcClockPrescalerFeature<6>,                // PCLK2/6
        Adc1Cycle7RegularChannelFeature<0,1>,       // using channels 0,1 on ADC1 with 7-cycle latency
        Adc1Cycle13RegularChannelFeature<2>,        // using channel 2 on ADC1 with 13-cycle latency
        Adc1Cycle55TemperatureSensorFeature,        // using the temperature sensor channel
        AdcScanModeFeature                          // scan mode feature
      > adc;

#elif defined(STM32PLUS_F4)

      /*
       * Declare the ADC peripheral with an APB2 clock prescaler of 2, a resolution of
       * 12 bits. We will use 144-cycle conversions on ADC channels 0,1 and a 480-cycle
       * conversion on ADC channel 2. Scan mode is used with the default template parameter
       * that causes EOC to be raised at the end of a complete conversion group.
       */

      Adc1<
        AdcClockPrescalerFeature<2>,                // prescaler of 2
        AdcResolutionFeature<12>,                   // 12 bit resolution
        Adc1Cycle144RegularChannelFeature<0,1>,     // using channels 0,1 on ADC1 with 144-cycle latency
        Adc1Cycle480RegularChannelFeature<2>,       // using channel 2 on ADC1 with 480-cycle latency
        Adc1Cycle480TemperatureSensorFeature,       // using the temperature sensor channel
        AdcScanModeFeature<>                        // scan mode with EOC after each group
      > adc;

#endif

      /*
       * Subscribe to the DMA complete interrupt
       */

      dma.DmaInterruptEventSender.insertSubscriber(
          DmaInterruptEventSourceSlot::bind(this,&AdcSingleDmaMultiChan::onComplete)
      );

      /*
       * Enable the DMA interrupt
       */

      dma.enableInterrupts(Adc1DmaChannelInterruptFeature::COMPLETE);

      /*
       * Declare an instance of USART that we'll use to write out the conversion results.
       */

      Usart1<> usart(57600);
      UsartPollingOutputStream outputStream(usart);

      /**
       * start the DMA (i.e. make it ready to receive requests from the ADC peripheral)
       */

      dma.beginRead(readBuffer,4);

      /*
       * Go into an infinite loop converting
       */

      for(;;) {

        /*
         * For this test code we set the 4 words to a known pattern so we can tell if they
         * get properly overwritten by the DMA during conversion
         */

        readBuffer[0]=readBuffer[1]=readBuffer[2]=readBuffer[3]=0xAAAA;

        /*
         * Start a conversion and wait until the interrupt handler tells us
         * that it's finished.
         */

        adc.startRegularConversion();

        while(!_ready);
        _ready=false;

        /*
         * write the values to the USART
         */

        outputStream << "Converted values are "
                     << StringUtil::Ascii(readBuffer[0]) << ", "
                     << StringUtil::Ascii(readBuffer[1]) << ", "
                     << StringUtil::Ascii(readBuffer[2]) << ", temperature="
                     << StringUtil::Ascii(adc.getTemperature(readBuffer[3])) << "\r\n";

        // wait for a second before converting the next set of values

        MillisecondTimer::delay(1000);
      }
    }


    /**
     * Interrupt handler for the DMA complete event. Set the ready flag
     * when it's received.
     */

    void onComplete(DmaEventType det) {
      if(det==DmaEventType::EVENT_COMPLETE)
        _ready=true;
    }
};

int main() {

  // we're using interrupts, initialise NVIC

  Nvic::initialise();

  MillisecondTimer::initialise();

  AdcSingleDmaMultiChan adc;
  adc.run();

  // not reached
  return 0;
}
// END FILE: ../examples/adc_single_dma_multichan/adc_single_dma_multichan.cpp
// START FILE: ../examples/adc_single_dma_multichan/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/adc_single_dma_multichan/system/LibraryHacks.cpp
// START FILE: ../examples/usb_device_hid_mouse/usb_device_hid_mouse.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usb/device/hid.h"
#include "config/spi.h"
#include "config/timer.h"


using namespace stm32plus;
using namespace stm32plus::usb;


/*
 * This example demonstrates using the accelerometer in your STM32F4DISCOVERY board as a mouse
 * by implementing the USB Human interface device (HID) protocol. The MouseHidDevice class is
 * used to implement the USB mouse boot protocol that requires no PC driver installation.
 *
 * By tilting your discovery board in the X,Y directions you will, amusingly, be able to move
 * your computer mouse pointer around the screen. Yes, entire minutes of fun can be had trying
 * to get your mouse pointer to go in the direction you want it to. For extra credit we'll also
 * light up the four LEDs that surround the LIS302DL on the board at an intensity proportional
 * to how much you're tilting the board in the direction of each respective LED.
 *
 * To use this example, compile it and flash it to your STM32F4DISCOVERY board. Attach a USB
 * cable from the micro-USB socket on the discovery board to your PC. The USB device should be
 * recognised automatically. Ensure that the board is held flat when power is first applied
 * because an initial reading is taken and used as the calibration "flat" state.
 *
 * There's no need to detach your real mouse from your PC because the Windows USB HID driver will
 * happily recognise as many mice as you can plug in. Have fun with your mouse!
 *
 * Compatible MCU:
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6 / Windows 8.1 x64 host
 */

class UsbDeviceHidMouseTest {

  public:

    /*
     * declare a type for the the USB stack
     */

    typedef MouseHidDevice<
      InternalFsPhy<>,                    // use the internal full speed PHY with no features
      ManufacturerTextFeature,            // we'll supply a manufacturer name
      ProductTextFeature,                 // ... and a product name
      SerialNumberTextFeature,            // ... and a serial number
      ConfigurationTextFeature,           // ... and a config text string
      InterfaceTextFeature                // ... and an interface text string
    > MyUsb;

    /*
     * Declare the SPI pins. This is almost the same as the default SPI1 except that
     * ST moved NSS (chip-select) to PE3
     */

    enum {
      Port_NSS=GPIOE_BASE,
      Port_SCK=GPIOA_BASE,
      Port_MISO=GPIOA_BASE,
      Port_MOSI=GPIOA_BASE,

      Pin_NSS  = GPIO_Pin_3,
      Pin_SCK  = GPIO_Pin_5,
      Pin_MISO = GPIO_Pin_6,
      Pin_MOSI = GPIO_Pin_7
    };

    /*
     * Declare a SPI type
     */

    typedef Spi1_Custom<UsbDeviceHidMouseTest> MySpi;

    /*
     * Run the example
     */

    void run() {

      /*
       * set up the parameters for the USB hid device. Do not attempt to reuse vid/pid combinations unless
       * you know how to flush your PC's USB driver cache because Windows caches the characteristics of each
       * device and will suspend your device if it suddenly re-appears as a different device type.
       */

      MyUsb::Parameters usbParams;

      usbParams.device_vid=0xDEAD;           // demo vendor ID
      usbParams.device_pid=0xBEEF;           // demo product ID

      usbParams.device_manufacturer_text="Andy's Workshop";   // see params.device_language_[ids/count] to change the languages
      usbParams.device_product_text="stm32plus wacky mouse";
      usbParams.device_serial_text="0123456789";
      usbParams.device_configuration_text="My configuration";
      usbParams.device_interface_text="My interface";

      /*
       * Declare the USB object - this will initialise internal variables but will not
       * start the peripheral
       */

      MyUsb usb;

      /*
       * Start the USB peripheral. It will run asynchronously. There is no requirement
       * for the parameters to remain in scope after the initialise call
       */

      if(!usb.initialise(usbParams))
        for(;;);      // onError has already locked up


      /*
       * Subscribe to errors
       */

      usb.UsbErrorEventSender.insertSubscriber(UsbErrorEventSourceSlot::bind(this,&UsbDeviceHidMouseTest::onError));

      /*
       * The USB device is now up and running. Now we initialise the LIS302DL SPI1 interface
       */

      MySpi::Parameters spiParams;

      /*
       * override some of the default SPI parameters
       */

      spiParams.spi_baudRatePrescaler=SPI_BaudRatePrescaler_4;
      spiParams.spi_cpol=SPI_CPOL_Low;
      spiParams.spi_cpha=SPI_CPHA_1Edge;

      MySpi spi(spiParams);

      /*
       * initialise the accelerometer
       */

      initialiseAccelerometer(spi);

      /*
       * Initialise the 4 LEDs on the board, which are conveniently attached to TIM4
       * channels 1,2,3,4
       */

      Timer4<
        Timer4InternalClockFeature,       // the timer clock source is APB1 (APB on the F0)
        TimerChannel1Feature<>,           // we're going to use channel 1...
        TimerChannel2Feature<>,           // ...and we're going to use channel 2
        TimerChannel3Feature<>,           // ...and we're going to use channel 3
        TimerChannel4Feature<>,           // ...and we're going to use channel 4
        Timer4GpioFeature<                // we want to output something to GPIO
          TIMER_REMAP_FULL,               // the GPIO output will be remapped to PD12..15
          TIM4_CH1_OUT,                   // we will output channel 1 to GPIO...
          TIM4_CH2_OUT,                   // ...and we will output channel 2 to GPIO
          TIM4_CH3_OUT,                   // ...and we will output channel 2 to GPIO
          TIM4_CH4_OUT                    // ...and we will output channel 2 to GPIO
        >
      > timer;

      /**
       * Set the timer clock to 4.2MHz with a reload counter of 2000
       */

      timer.setTimeBaseByFrequency(4200000,2000);

      timer.TimerChannel1Feature<>::initCompareForPwmOutput();
      timer.TimerChannel2Feature<>::initCompareForPwmOutput();
      timer.TimerChannel3Feature<>::initCompareForPwmOutput();
      timer.TimerChannel4Feature<>::initCompareForPwmOutput();

      timer.enablePeripheral();

      /*
       * read the starting position to use as an offset
       */

      int8_t xoffset,yoffset,x,y;

      readXY(spi,xoffset,yoffset);

      /*
       * Go into a loop reading the X and Y position every 10ms (the USB poll frequency)
       */

      for(;;) {

        MillisecondTimer::delay(10);

        readXY(spi,x,y);

        x-=xoffset;
        y-=yoffset;

        // only consider movements >2 pixels

        if(std::abs(x)<=2)
          x=0;

        if(std::abs(y)<=2)
          y=0;

        // cap x,y at (-127 .. +127)

        x=std::min<int8_t>(127,std::max<int8_t>(-127,x));
        y=std::min<int8_t>(127,std::max<int8_t>(-127,y));

        // send the report to the USB host (your PC)

        usb.sendMouseReport(0,x,y);

        // give visual feedback via the LEDs, brighter means faster

        if(x>0) {
          timer.TimerChannel3Feature<>::setDutyCycle(x*2);
          timer.TimerChannel1Feature<>::setDutyCycle(0);
        }
        else if(x<0) {
          timer.TimerChannel3Feature<>::setDutyCycle(0);
          timer.TimerChannel1Feature<>::setDutyCycle(-x*2);
        }
        else {
          timer.TimerChannel3Feature<>::setDutyCycle(0);
          timer.TimerChannel1Feature<>::setDutyCycle(0);
        }

        if(y>0) {
          timer.TimerChannel4Feature<>::setDutyCycle(y*2);
          timer.TimerChannel2Feature<>::setDutyCycle(0);
        }
        else if(y<0) {
          timer.TimerChannel4Feature<>::setDutyCycle(0);
          timer.TimerChannel2Feature<>::setDutyCycle(-y*2);
        }
        else {
          timer.TimerChannel4Feature<>::setDutyCycle(0);
          timer.TimerChannel2Feature<>::setDutyCycle(0);
        }
      }
    }


    /*
     * Read the X and Y position
     */

    void readXY(MySpi& spi,int8_t& x,int8_t& y) {

      const uint8_t cmd=0x29 |    // LIS302DL_OUT_X_ADDR
                        0x80 |    // READWRITE_CMD
                        0x40;     // MULTIPLEBYTE_CMD

      uint8_t output[4];

      // read the data. OUT_X is 29 and OUT_Y is 2B. we'll grab both in one read

      spi.setNss(false);
      spi.send(&cmd,1);
      spi.receive(output,4);
      spi.setNss(true);

      // re-orient the chip so that the "ST" logo is upright

      y=output[0];
      x=output[2];
    }


    /*
     * Initialise the accelerometer by writing to the control register
     */

    void initialiseAccelerometer(MySpi& spi) {

      uint8_t buffer[2];

      buffer[0]=0x20;     // LIS302DL_CTRL_REG1_ADDR
      buffer[1]=0x40 |    // LIS302DL_LOWPOWERMODE_ACTIVE
                0x01 |    // LIS302DL_X_ENABLE
                0x02;     // LIS302DL_Y_ENABLE

      // send the data

      spi.setNss(false);
      while(!spi.readyToSend());
      spi.send(buffer,2);
      spi.setNss(true);

      // wait for ready

      MillisecondTimer::delay(30);
    }


    /**
     * USB error event received
     * @param uee the event descriptor
     */

    void onError(UsbErrorEvent& uee) {

      // ignore unconfigured errors from the HID device

      if(uee.provider==ErrorProvider::ERROR_PROVIDER_USB_DEVICE && uee.code==MyUsb::E_UNCONFIGURED)
        return;

      // flash the RED led on PD5 at 1Hz

      GpioD<DefaultDigitalOutputFeature<5>> pd;

      for(;;) {
        pd[5].reset();
        MillisecondTimer::delay(500);
        pd[5].set();
        MillisecondTimer::delay(500);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // initialise the interrupt controller

  Nvic::initialise();

  // initialise the millisecond timer

  MillisecondTimer::initialise();

  // run the test

  UsbDeviceHidMouseTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usb_device_hid_mouse/usb_device_hid_mouse.cpp
// START FILE: ../examples/usb_device_hid_mouse/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usb_device_hid_mouse/system/LibraryHacks.cpp
// START FILE: ../examples/net_dhcp/net_dhcp.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/timing.h"
#include "config/usart.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This examples demonstrates the use of the DHCP client to fetch your IP address, subnet mask,
 * default gateway and DNS servers.
 *
 * A DHCP lease is time limited. Half way through the lease time you will receive a notification
 * event informing you that the DHCP client is going to automatically renew the lease. An error
 * notification will be raised if the renewal fails.
 *
 * The results and any errors are sent to USART3 (57000/8/N/1).
 *
 * Here's how the network stack for this example is configured:
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient                 |
 *              +----------------------------+
 * TRANSPORT:   | Udp                        |
 *              +-----+----------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +-----------------------------
 *
 * This example is also tested using the KSZ8051MLL in MII mode instead of the DP83848C/RMII. The
 * KSZ8051MLL test was performed on the STM32F107. The DP83848C was tested on the STM32F407. To
 * reconfigure this demo for the F107 using remapped MAC pins connected to the KSZ8051MLL change the
 * physical and datalink layers thus:
 *
 * typedef PhysicalLayer<KSZ8051MLL> MyPhysicalLayer;
 * typedef DatalinkLayer<MyPhysicalLayer,RemapMiiInterface,Mac> MyDatalinkLayer;
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 *   STM32F407ZGT6
 */

class NetDhcpClientTest {

  public:

    /*
     * Define the layers that make up the networking stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    UsartPollingOutputStream *_outputStream;


    /*
     * Run the test
     */

    void run() {

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      _outputStream=new UsartPollingOutputStream(*_usart);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 1970 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // spy on the DHCP announcements for IP address, subnet mask, default gateway and DNS servers
      // by subscribing to the notification events passed around the network stack. we will
      // also receive notification that the DHCP lease will be renewed via this event.

      _net->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&NetDhcpClientTest::onNotification));

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetDhcpClientTest::onError));

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      if(!_net->startup())
        error();

      // nothing more to do

      for(;;);
    }


    /**
     * A notification event was received from the stack. Check for lease renewal
     * notification and new address announcements. This could be IRQ code.
     * @param ned The event descriptor base class
     */

    void onNotification(NetEventDescriptor& ned) {

      char buf[30];
      uint8_t i;

      if(ned.eventType==NetEventDescriptor::NetEventType::DHCP_RENEWAL_DUE)
        *_outputStream << "DHCP lease renewal is happening";
      else if(ned.eventType==NetEventDescriptor::NetEventType::IP_ADDRESS_ANNOUNCEMENT) {
        static_cast<IpAddressAnnouncementEvent&>(ned).ipAddress.toString(buf);
        *_outputStream << "IP Address: " << buf << "\r\n";
      }
      else if(ned.eventType==NetEventDescriptor::NetEventType::SUBNET_MASK_ANNOUNCEMENT) {
        static_cast<IpSubnetMaskAnnouncementEvent&>(ned).subnetMask.toString(buf);
        *_outputStream << "Subnet mask: " << buf << "\r\n";
      }
      else if(ned.eventType==NetEventDescriptor::NetEventType::DEFAULT_GATEWAY_ANNOUNCEMENT) {
        static_cast<IpDefaultGatewayAnnouncementEvent&>(ned).defaultGateway.toString(buf);
        *_outputStream << "Default gateway: " << buf << "\r\n";
      }
      else if(ned.eventType==NetEventDescriptor::NetEventType::DNS_SERVERS_ANNOUNCEMENT) {

        IpDnsServersAnnouncementEvent& dnsevent(static_cast<IpDnsServersAnnouncementEvent&>(ned));

        for(i=0;i<3;i++) {
          if(dnsevent.ipDnsServers[i].isValid()) {
            dnsevent.ipDnsServers[i].toString(buf);
            *_outputStream << "DNS server: " << buf << "\r\n";
          }
        }
      }
    }


    /**
     * Network error event received, report it
     * @param ned The event descriptor base class
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetDhcpClientTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_dhcp/net_dhcp.cpp
// START FILE: ../examples/net_dhcp/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_dhcp/system/LibraryHacks.cpp
// START FILE: ../examples/dma_fill/dma_fill.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dma.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * Demo of the DMA peripheral used to fill a block of memory with a single byte.
 * We will repeatedly fill a buffer with 0xAA and check that it's done OK. If so
 * then a LED on PF6 will blink once per second.
 *
 * DMA1, channel 4 is used for this demo for F1 and F0 devices and DMA2, channel3,
 * stream 4 is used for F4 devices.
 *
 * If this example is to be run on the STM32F4DISCOVERY board then change the LED
 * configuration from PF6 to PD13 and invert the set() / reset() logic because
 * that LED is active HIGH.
 *
 * If this example is to be run on the STM32VLDISCOVERY board then change the LED
 * configuration from PF6 to PC8 and invert the set() / reset() logic because
 * that LED is active HIGH.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class DmaFillTest {

  protected:

    /**
     * The LED is on PF6
     */

    enum { LED_PIN = 6 };

  public:

    void run() {

      uint8_t buffer[256],byteToFill;
      int i;

      // initialise the LED pin

      GpioF<DefaultDigitalOutputFeature<LED_PIN>> pf;

      // lights off (this LED is active low, i.e. PF6 is a sink)

      pf[LED_PIN].set();

      // declare a DMA channel with the memory fill feature
      // F4 users note that only DMA2 can do memory-to-memory transfers.

#if defined(STM32PLUS_F1) || defined(STM32PLUS_F0)

      Dma1Channel4<
        DmaMemoryFillFeature<>        // memory fill with default transfer size (bytes)
      > dma;

#elif defined(STM32PLUS_F4)

      Dma2Channel3Stream4<
        DmaMemoryFillFeature<>        // memory fill with default transfer size (bytes)
      > dma;

#endif

      byteToFill=0xaa;

      for(;;) {

        // clear the target buffer

        memset(buffer,'\0',sizeof(buffer));

        // start the transfer of 256 bytes from buffer1 to buffer2. this executes asynchronously.

        dma.beginCopyMemory(buffer,&byteToFill,sizeof(buffer),DMA_Priority_Medium);

        // wait for transfer complete

        dma.waitUntilComplete();

        // verify the result

        for(i=0;i<256;i++)
          if(buffer[i]!=0xaa)
            for(;;);          // lock up on error

        // flash the LED for a second

        pf[LED_PIN].reset();
        MillisecondTimer::delay(1000);
        pf[LED_PIN].set();
        MillisecondTimer::delay(1000);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  DmaFillTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/dma_fill/dma_fill.cpp
// START FILE: ../examples/dma_fill/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/dma_fill/system/LibraryHacks.cpp
// START FILE: ../examples/i2c_at24c32/i2c_at24c32.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/eeprom.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * The AT24C32 is a 32768kbit (4096kbyte) EEPROM with an I2C serial interface.
 *
 * This test assumes that you've got it connected to I2C#2 with the default pins.
 * These pins are:
 *
 * PB10 => I2C2_SCL
 * PB11 => I2C2_SDA
 *
 * The test will repeatedly write and then read back a pattern from the EEPROM.
 * If it all works then a LED on PF6 will flash for one second. If there is a
 * failure then the LED will flash rapidly forever.
 *
 * To run this example on the F4 DISCOVERY board change the LED pin to PD13 to
 * use the onboard LED. To run on the F1VL or F0 discovery board change the LED
 * pin to PC8 to use the onboard LED.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class AT24C32Test {

  protected:

    enum {
      LED_PIN = 6
    };

  public:

    void run() {

      /*
       * Define a type for the EEPROM
       */

      typedef AT24C32<
        I2C2_Default<I2CTwoByteMasterPollingFeature>    // the EEPROM has 2-byte addresses
      > MyEeprom;

      uint16_t address;
      uint32_t actuallyRead;
      uint8_t i,c,buffer[237];

      /*
       * initialise the LED and switch if off (this LED is
       * active LOW
       */

      GpioF<DefaultDigitalOutputFeature<LED_PIN> > pf;
      pf[LED_PIN].set();

      /*
       * Initialise the AT24C32 on I2C #2. We will be the bus master
       * and we will poll it
       */

      I2C::Parameters params;
      MyEeprom eeprom(params);

      /*
       * Fill a buffer with a simple test pattern
       */

      for(i=0;i<sizeof(buffer);i++)
        buffer[i]=i;

      /*
       * Test forever
       */

      for(;;) {

        /*
         * Reset to position zero and write a byte. Note that the SerialEeprom
         * base class inherits from InputStream and OutputStream so you can use
         * the overloaded << and >> operators to write to and read from the EEPROM
         */

        eeprom.seek(0);

        if(!eeprom.writeByte(0xaa))
          error(pf[LED_PIN]);

        /*
         * Let the device settle after write (10ms max, see datasheet)
         */

        MillisecondTimer::delay(10);

        /*
         * Read back the byte and check it
         */

        eeprom.seek(0);
        c=0;

        if(!eeprom.readByte(c) || c!=0xaa)
          error(pf[LED_PIN]);

        /*
         * Write the 237 byte sequence at a random position
         */

        address=rand() % (MyEeprom::SIZE_IN_BYTES-sizeof(buffer));

        eeprom.seek(address);
        if(!eeprom.write(buffer,sizeof(buffer)))
          error(pf[LED_PIN]);

        /*
         * Let the device settle after write (10ms max, see datasheet)
         */

        MillisecondTimer::delay(10);

        /*
         * Clear the buffer and read back the data
         */

        memset(buffer,0,sizeof(buffer));

        eeprom.seek(address);
        if(!eeprom.read(buffer,sizeof(buffer),actuallyRead))
          error(pf[LED_PIN]);

        for(i=0;i<sizeof(buffer);i++)
          if(buffer[i]!=i)
            error(pf[LED_PIN]);

        /*
         * Success, flash for a second
         */

        pf[LED_PIN].reset();
        MillisecondTimer::delay(1000);
        pf[LED_PIN].set();
        MillisecondTimer::delay(1000);
      }
    }


    /*
     * Error, flash rapidly on and off
     */

    void error(const GpioPinRef& gpio) {
      for(;;) {
        gpio.reset();
        MillisecondTimer::delay(100);
        gpio.set();
        MillisecondTimer::delay(100);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  AT24C32Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/i2c_at24c32/i2c_at24c32.cpp
// START FILE: ../examples/i2c_at24c32/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/i2c_at24c32/system/LibraryHacks.cpp
// START FILE: ../examples/mc2pa8201/mc2pa8201.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * MC2PA8201 LCD test, show a looping graphics demo
 *
 * The MC2PA8201 driver is used by many of the Nokia QVGA
 * cellphone LCDs including 2730, 6300, N82 and N93.
 *
 * It's an 8-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring that
 * you need to do is as follows:
 *
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS
 * PD4  => RD
 * PD5  => WR
 * PD14 => D0
 * PD15 => D1
 * PD0  => D2
 * PD1  => D3
 * PE7  => D4
 * PE8  => D5
 * PE9  => D6
 * PE10 => D7
 * PD13 => Backlight PWM (if variable backlight)
 *
 * There are no special considerations for the F1 versus
 * the F4. The code works on both without any change.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class MC2PA8201Test {

  protected:
    typedef Fsmc8BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef Nokia6300_Portrait_262K_TypeA<LcdAccessMode> LcdPanel;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11>> pd;

      // set up the FSMC with RS=A16 (PD11)

      Fsmc8080LcdTiming fsmcTiming(0,5);
      _accessMode=new LcdAccessMode(fsmcTiming,16,pe[1]);

      // declare a panel

      _gl=new LcdPanel(*_accessMode);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight on timer4, channel2 (PD13)

      DefaultBacklight backlight;

      // fade up to 100% in 4ms steps

      backlight.fadeTo(100,4);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_gl << *_font;

      for(;;) {
        basicColoursTest();
        jpegTest();
        lzgTest();
        textTest();
        scrollTest();
        ellipseTest();
        gradientTest();
        rectTest();
        lineTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      if(_gl->getHeight()==320 && _gl->getWidth()==240) {

        prompt("JPEG bitmap test");

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle(0,0,240,320),compressedData);

        MillisecondTimer::delay(3000);
      }
    }

    void lzgTest() {

      prompt("LZG bitmap test");

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,true,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,false,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,true,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,false,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,true,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle(((_gl->getXmax()+1)-width)/2,
                ((_gl->getYmax()+1)-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      int i;
      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t before,elapsed;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      before=MillisecondTimer::millis();

      for(i=0;i<3000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }

      elapsed=MillisecondTimer::millis()-before;

      _gl->clearScreen();
      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point::Origin << "Elapsed: " << (int32_t)elapsed << "ms";

      MillisecondTimer::delay(3000);
    }


    void scrollTest() {

      int32_t i,j,numRows;
      Point p;

      prompt("Hardware scrolling test");

      _gl->setForeground(0xffffff);
      _gl->setBackground(0);
      _gl->clearScreen();

      numRows=((_gl->getYmax()+1)/_font->getHeight())/3;

      p.X=0;

      for(i=0;i<numRows;i++) {

        p.Y=(numRows+i)*_font->getHeight();
        *_gl << p << "Test row " << i;
      }

      for(j=0;j<15;j++) {

        numRows=(_gl->getYmax()+1)/4;

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(i);
          MillisecondTimer::delay(5);
        }

        for(i=0;i<numRows;i++) {
          _gl->setScrollPosition(numRows-i);
          MillisecondTimer::delay(5);
        }
      }

      _gl->setScrollPosition(0);
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      int i;

      prompt("Line test");

      for(i=0;i<5000;i++) {
        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }
    }

    void rectTest() {

      int i;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0;i<1500;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0;i<10000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getXmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      int16_t i;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0;i<1000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0;i<1500;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }

    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  MC2PA8201Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/mc2pa8201/mc2pa8201.cpp
// START FILE: ../examples/mc2pa8201/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/mc2pa8201/system/LibraryHacks.cpp
// START FILE: ../examples/blink/blink.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/gpio.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * This is the most basic example that uses GPIO and the
 * Systick timer to blink a LED on PC8 at 1Hz. PC8 is wired
 * to the blue onboard LED on the F1VL and F0 discovery boards.
 *
 * If the STM32F4DISCOVERY board is your target then
 * change the GPIO declation to...
 *
 *  GpioD<DefaultDigitalOutputFeature<13> > pd
 *
 * ... and change 2 of "pc[8]" to "pd[13]" to blink the
 * orange led on the discovery board.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 *   STM32F107VCT6
 */

class Blink {

  public:

    void run() {

      // initialise the pin for output

      GpioC<DefaultDigitalOutputFeature<8> > pc;

      // loop forever switching it on and off with a 1 second
      // delay in between each cycle

      for(;;) {

        pc[8].set();
        MillisecondTimer::delay(1000);

        pc[8].reset();
        MillisecondTimer::delay(1000);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  Blink blink;
  blink.run();

  // not reached
  return 0;
}
// END FILE: ../examples/blink/blink.cpp
// START FILE: ../examples/blink/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/blink/system/LibraryHacks.cpp
// START FILE: ../examples/button/button.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/button.h"


using namespace stm32plus;


/**
 * Auto-repeating button demo that doesn't use interrupts
 *
 * This demo assumes that you have a button on PA0 and an
 * LED on PD13. Hold down the button and the LED will
 * flash to indicate the presses. The default
 * configuration of PA0, PD13 and a LOW state when
 * pressed is correct for the STM32F4DISCOVERY board.
 *
 * If you are using this example on the F1VL or F0 discovery board then
 * you can replace "GpioD<DefaultDigitalOutputFeature<13> > pd;" with
 * "GpioC<DefaultDigitalOutputFeature<8> > pc;" and also each occurrence
 * of "pd[13]" with "pc[8]" to flash the blue LED on board the discovery.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class Button {

  protected:

    static const bool BUTTON_PRESSED_HIGH  = false;   // false = LOW when pressed, true = HIGH when pressed
    static const uint32_t INITIAL_DELAY_MS = 600;
    static const uint32_t REPEAT_DELAY_MS  = 150;

  public:
    void run() {

      // initialise the ports

      GpioD<DefaultDigitalOutputFeature<13> > pd;
      GpioA<DefaultDigitalInputFeature<0> > pa;

      // lights off (this LED is active high, i.e. PD13 is a source)

      pd[13].reset();

      // create the button class with parameters

      AutoRepeatPushButton button(pa[0],BUTTON_PRESSED_HIGH,INITIAL_DELAY_MS,REPEAT_DELAY_MS);

      // main loop

      for(;;) {

        // sample the button and swith the LED on (HIGH) or off (LOW)

        if(button.getState()==PushButton::Pressed) {

          // switch the LED on for 10ms

          pd[13].set();
          MillisecondTimer::delay(10);
        }
        else
          pd[13].reset();
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  Button button;
  button.run();

  // not reached
  return 0;
}
// END FILE: ../examples/button/button.cpp
// START FILE: ../examples/button/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/button/system/LibraryHacks.cpp
// START FILE: ../examples/dac_triangle/dac_triangle.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/dac.h"
#include "config/timer.h"


using namespace stm32plus;


/**
 * Demonstration of DAC channel 1 producing a triangular
 * wave superimposed upon a base output of 1/16 Vref.
 * Timer 6 is used as the trigger for each conversion.
 *
 * The output can be seen on PA4. Attach an oscilloscope
 * to see the triangular wave or take a look at
 * waveform_f1.png in the example subdirectory to see
 * how it looks on the STM32F103ZET6.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class DacTriangleTest {

  public:

    void run() {

      /*
       * Set up Timer6 with an internal clock source and configured to be
       * in master mode with update as the trigger
       */

      Timer6<Timer6InternalClockFeature,TimerUpdateMasterFeature> timer;

      /*
       * Configure the timer with a reload value of 255 and no prescaler.
       */

      timer.initialiseTimeBase(255,0,TIM_CKD_DIV1,TIM_CounterMode_Up);

      /*
       * Declare a DAC type with 12 bit right-aligned data.
       */

      typedef Dac1<DacChannel112BitRightAlignmentFeature> MyDac;

      /*
       * Create the DAC parameters. The trigger for conversion will be timer 6's
       * trigger output and the wave generation mode is triangular.
       */

      MyDac::Parameters params;
      params.dac_trigger=DAC_Trigger_T6_TRGO;
      params.dac_waveGeneration=DAC_WaveGeneration_Triangle;
      params.dac_lfsrMaskOrTriangleAmplitude=DAC_TriangleAmplitude_1023;

      /*
       * Declare the DAC object
       */

      MyDac dac(params);

      /*
       * Set a base level of Vref/16. 4096 is the full 12 bit conversion value and that equals
       * an output of Vref. Therefore 4096/16 = 256 for a base level of Vref/16. The triangle
       * wave is added to this base value.
       */

      dac.write(256);

      /*
       * Enable the trigger output and then Start the timer. Each time the update event is
       * generated a DAC conversion is triggered.
       */

      timer.enableMasterFeature();
      timer.enablePeripheral();

      /*
       * Finished. It's all running in the background now.
       */

      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  DacTriangleTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/dac_triangle/dac_triangle.cpp
// START FILE: ../examples/dac_triangle/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/dac_triangle/system/LibraryHacks.cpp
// START FILE: ../examples/usb_device_cdc_com_port/usb_device_cdc_com_port.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usb/device/cdc.h"


using namespace stm32plus;
using namespace stm32plus::usb;


/**
 * This example demonstrates the USB Communications Device Class (CDC) in the form of
 * a virtual COM port. Virtual COM ports allow you to use software on your PC that was designed
 * to talk to a serial port to communicate over USB to your STM32.
 *
 * This example is compatible with the STM32F4 Discovery board. Flash the example code to your
 * board and connect the micro-USB socket to your PC. Now open up your PC's Device Manager
 * and locate "Other Devices -> stm32plus virtual COM port". Right-click, "Update Driver Software..."
 * and use the browse option to go to the "usb_device_cdc_com_port" example directory. Windows
 * should find the .INF file and use it to install the driver for this example. When it's completed
 * you should have a new "Virtual COM Port" entry under the "Ports (COM & LPT)" category.
 *
 * To test, launch a terminal application (I use the free RealTerm program) and connect to the
 * virtual COM port. Set the protocol to 9600/8/N/1. Go ahead and type something. Each character
 * that you type will be echo'd back to the terminal with the message "You pressed: X" where X is
 * the key that you pressed.
 *
 * Compatible MCU:
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6 / Windows 8.1 x64 host
 */

class UsbDeviceCdcComPortTest {

  public:

    /*
     * declare a type for the the USB stack
     */

    typedef ComPortCdcDevice<
      InternalFsPhy<>,                    // use the internal full speed PHY with no features
      ManufacturerTextFeature,            // we'll supply a manufacturer name
      ProductTextFeature,                 // ... and a product name
      SerialNumberTextFeature,            // ... and a serial number
      ConfigurationTextFeature            // ... and a config text string
    > MyUsb;


    /*
     * Flag to communicate between IRQ and non-IRQ code and the message to send back
     */

    enum class LoopState {
      WAITING,
      REPORT_KEYPRESS
    };

    volatile LoopState _loopState;
    char _message[16];


    /*
     * The current line coding (baud rate, parity etc)
     * The CdcLineCoding constructor sets a default of 9600/8/N/1
     */

    CdcLineCoding _lineCoding;


    /*
     * Run the example
     */

    void run() {

      LoopState state;

      // initialise

      _loopState=LoopState::WAITING;
      strncpy(_message,"You pressed: X\r\n",sizeof(_message));

      /*
       * set up the parameters for the USB CDC device. Do not attempt to reuse vid/pid combinations unless
       * you know how to flush your PC's USB driver cache because Windows caches the characteristics of each
       * device and will suspend your device if it suddenly re-appears as a different device type.
       */

      MyUsb::Parameters usbParams;

      usbParams.device_vid=0xDEAD;           // demo vendor ID
      usbParams.device_pid=0x0010;           // demo product ID

      usbParams.device_manufacturer_text="Andy's Workshop";   // see params.device_language_[ids/count] to change the languages
      usbParams.device_product_text="stm32plus virtual COM port";
      usbParams.device_serial_text="0123456789";
      usbParams.device_configuration_text="My configuration";

      usbParams.cdc_com_port_rx_buffer_size=16;  // default of 1Kb is far too big for this app

      /*
       * Declare the USB object - this will initialise internal variables but will not
       * start the peripheral
       */

      MyUsb usb;

      /*
       * Subscribe to errors
       */

      usb.UsbErrorEventSender.insertSubscriber(UsbErrorEventSourceSlot::bind(this,&UsbDeviceCdcComPortTest::onError));

      /*
       * Subscribe to USB events - data received from the host will be notified to us
       * asynchronously.
       */

      usb.UsbEventSender.insertSubscriber(UsbEventSourceSlot::bind(this,&UsbDeviceCdcComPortTest::onEvent));

      /*
       * Start the USB peripheral. It will run asynchronously. There is no requirement
       * for the parameters to remain in scope after the initialise call
       */

      if(!usb.initialise(usbParams))
        for(;;);      // onError() has already locked up

      // loop forever, or until an error interrupts us

      for(;;) {

        // block until a response is ready to send

        while((state=_loopState)==LoopState::WAITING);
        _loopState=LoopState::WAITING;

        if(state==LoopState::REPORT_KEYPRESS) {

          // transmit the reponse

          usb.transmit(_message,sizeof(_message));

          // we're ready to receive the next packet from the host

          usb.beginReceive();
        }
      }
    }


    /**
     * Event callback from the USB stack. Lots of stuff will come through here but
     * we're only interested in data arriving from the host and control messages
     */

    void onEvent(UsbEventDescriptor& ued) {

      // reject all events that we don't care about

      if(ued.eventType==UsbEventDescriptor::EventType::CDC_DATA_RECEIVED)
        onData(static_cast<CdcDataReceivedEvent&>(ued));
      else if(ued.eventType==UsbEventDescriptor::EventType::CDC_CONTROL)
        onControl(static_cast<CdcControlEvent&>(ued));
    }


    /**
     * Control event received from the host
     */

    void onControl(CdcControlEvent& event) {

      switch(event.opcode) {

        /*
         * We don't process these. They're enumerated here so you can
         * see what's available.
         */

        case CdcControlCommand::SEND_ENCAPSULATED_COMMAND:
        case CdcControlCommand::GET_ENCAPSULATED_RESPONSE:
        case CdcControlCommand::SET_COMM_FEATURE:
        case CdcControlCommand::GET_COMM_FEATURE:
        case CdcControlCommand::CLEAR_COMM_FEATURE:
        case CdcControlCommand::SET_CONTROL_LINE_STATE:
        case CdcControlCommand::SEND_BREAK:
          break;

        case CdcControlCommand::SET_LINE_CODING:      // set a new line encoding
          memcpy(&_lineCoding,event.data,sizeof(_lineCoding));
          break;

        case CdcControlCommand::GET_LINE_CODING:      // return the current line encoding
          event.data=reinterpret_cast<uint8_t *>(&_lineCoding);
          break;

        default:
          break;
      }
    }


    /**
     * Data received from the host
     */

    void onData(CdcDataReceivedEvent& event) {

      // add character to the message to send

      _message[13]=event.data[0];

      // signal to the main loop that a response is ready

      _loopState=LoopState::REPORT_KEYPRESS;
    }


    /**
     * USB error event received
     * @param uee the event descriptor
     */

    void onError(UsbErrorEvent& uee) {

      // ignore unconfigured errors from the CDC device

      if(uee.provider==ErrorProvider::ERROR_PROVIDER_USB_DEVICE && uee.code==MyUsb::E_UNCONFIGURED)
        return;

      // flash the RED led on PD5 at 1Hz

      GpioD<DefaultDigitalOutputFeature<5>> pd;

      for(;;) {
        pd[5].reset();
        MillisecondTimer::delay(500);
        pd[5].set();
        MillisecondTimer::delay(500);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // initialise the interrupt controller

  Nvic::initialise();

  // initialise the millisecond timer

  MillisecondTimer::initialise();

  // run the test

  UsbDeviceCdcComPortTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usb_device_cdc_com_port/usb_device_cdc_com_port.cpp
// START FILE: ../examples/usb_device_cdc_com_port/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usb_device_cdc_com_port/system/LibraryHacks.cpp
// START FILE: ../examples/usart_send_interrupts/usart_send_interrupts.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usart.h"


using namespace stm32plus;


/**
 * USART test: asynchronous sending data using interrupts
 *
 * This example will send the string "Hello World" using USART1. Connect an RS232
 * cable from USART1 to your PC and run a terminal program (there are many free
 * terminal programs) to see the data. The default (unremapped) USART1 pins are used.
 *
 * We use interrupts to send the data. The hardware raises a TXE interrupt when it's
 * ready to send a character and we do just that. When we get to the end of the string
 * we disable the TXE interrupt so it doesn't fire again.
 *
 * Note that if you are using the STM32F4DISCOVERY board then you cannot use USARRT1
 * since the pins clash with onboard peripherals. I have tested this code on
 * that board using USART2.
 *
 * The protocol is 57600/8/N/1
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class UsartSendInterruptsTest {

  protected:

    /*
     * The string we are going to send
     */

    const char *_dataToSend;

    /*
     * The USART1 peripheral configured with the interrupt feature
     */

    typedef Usart1InterruptFeature MyUsartInterrupt;
    Usart1<MyUsartInterrupt> _usart;

  public:

    /*
     * Use the constructor base initialiser to set up the USART at 57600
     */

    UsartSendInterruptsTest()
      : _usart(57600) {
    }

    /*
     * Run the test
     */

    void run()  {

      // we're using interrupts, set up the NVIC

      Nvic::initialise();

      // set the initial string pointer

      _dataToSend="Hello World";

      // register ourselves as an observer of the USART interrupts

      _usart.UsartInterruptEventSender.insertSubscriber(
          UsartInterruptEventSourceSlot::bind(this,&UsartSendInterruptsTest::onInterrupt)
        );

      // enable interrupts. this will cause an immediate ready-to-send interrupt

      _usart.enableInterrupts(MyUsartInterrupt::TRANSMIT);

      // finished

      for(;;);
    }


    /*
     * Interrupt callback function. This is called when the TXE interrupt that we've
     * enabled is fired.
     */

    void onInterrupt(UsartEventType uet) {

      if(uet==UsartEventType::EVENT_READY_TO_TRANSMIT && *_dataToSend) {

        // send the next character and increment the pointer

        _usart.send(*_dataToSend++);

        // if we are now at the end of the string then disable further interrupts
        // because we are done

        if(*_dataToSend=='\0')
          _usart.disableInterrupts(MyUsartInterrupt::TRANSMIT);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  UsartSendInterruptsTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usart_send_interrupts/usart_send_interrupts.cpp
// START FILE: ../examples/usart_send_interrupts/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usart_send_interrupts/system/LibraryHacks.cpp
// START FILE: ../examples/exti/exti.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/button.h"
#include "config/exti.h"


using namespace stm32plus;


/**
 * Button demo that uses EXTI interrupts to signal that the button is pressed.
 * EXTI allows you to process input from GPIO pins asynchronously.
 *
 * This demo assumes that you have a button on PA8 and an LED on PF6. The LED
 * will light as long as the button is held down.
 *
 * An Exti8 (external interrupt) is attached to PA8 and is configured to trigger
 * on both rising (pressed) and falling (released) edges.
 *
 * To use this demo on the STM32F4DISCOVERY board you will need to make the
 * following changes to target the onboard button and LEDs:
 *
 *  LED_PIN to 13
 *  BUTTON_PIN to 0
 *  GpioF... to GpioD...
 *  Exti8 to Exit0
 *
 * To use this demo on the STM32VLDISCOVERY or the STM32F0DISCOVERY board you
 * will need to make the following changes to target the onboard button and LEDs:
 *
 *  LED_PIN to 8
 *  BUTTON_PIN to 0
 *  GpioF... to GpioC...
 *  Exti8 to Exti0
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 *   STM32F100RBT6
 *   STM32F103ZET6
 *   STM32F407VGT6
 */

class ExtiTest {

  protected:
    volatile bool _stateChanged;

    enum {
      LED_PIN = 6,
      BUTTON_PIN = 8
    };

  public:
    void run() {

      // initialise the LED and button pins

      GpioF<DefaultDigitalOutputFeature<LED_PIN> > pf;
      GpioA<DefaultDigitalInputFeature<BUTTON_PIN> > pa;

      // enable EXTI on the button pin and subscribe to interrupts

      Exti8 exti(EXTI_Mode_Interrupt,EXTI_Trigger_Rising_Falling,pa[BUTTON_PIN]);

      exti.ExtiInterruptEventSender.insertSubscriber(
          ExtiInterruptEventSourceSlot::bind(this,&ExtiTest::onInterrupt)
        );

      // lights off (this LED is active low, i.e. PF6 is a sink)

      pf[LED_PIN].set();

      // main loop

      for(;;) {

        _stateChanged=false;      // race conditition, but it's demo code...

        // wait for the interrupt to tell us that there's been a button press/release

        while(!_stateChanged);

        // act on the new state and reset for the next run

        pf[LED_PIN].setState(pa[BUTTON_PIN].read());
      }
    }


    /**
     * Interrupt callback from the EXTI interrupt
     */

    void onInterrupt(uint8_t /* extiLine */) {
      _stateChanged=true;
    }
};


/*
 * Main entry point
 */

int main() {

  ExtiTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/exti/exti.cpp
// START FILE: ../examples/exti/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/exti/system/LibraryHacks.cpp
// START FILE: ../examples/timer_pwm_break/timer_pwm_break.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/timer.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * Timer demonstration including the break input feature: Use timer 1 to output a 1MHz PWM wave on
 * channel 1 (PA8). The demo will repeatedly increment the duty cycle from 0 to 100% and back down
 * to 0 over 800ms. When the break input is triggered (low to high) the PWM output will stop and
 * be reset to the programmed idle state (low).
 *
 * Connect up PA8 to a LED pin on your development board to see the output. Connect up the break input
 * (PB12) to GND when you launch the demo.
 *
 * To trigger the break input remove the connection from PB12 to GND. This alone will probably be enough
 * to trigger the break. If not then connect it to the board's VCC voltage (probably 3V or 3.3V). The
 * break interrupt will repeatedly trigger until you reconnect PB12 to ground.
 *
 * It's up to you to recover from the break in the interrupt handler before re-enabling the outputs. If
 * you want the outputs to be automatically re-enabled at the next reload event then call enableAutomaticOutput()
 * during the timer setup.
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6
 *   STM32F051R8T6
 *   STM32F103VET6
 */

class TimerPwmBreakTest {

  public:

    void run() {

      /*
       * Initialise timer1 running from the internal APB2 clock with channel-1 and GPIO output features.
       * The GPIO output feature is itself configured with a channel-1 output feature.
       */

      Timer1<
        Timer1InternalClockFeature,       // the timer clock source is APB1
        UnlockedTimerBreakFeature,        // we want the break functionality
        TimerChannel1Feature<             // we're going to use channel 1 with the OC idle state = low
          TimerChannelOCPWM1ModeFeature,
          TimerChannelOCHighPolarityFeature,
          TimerChannelOCLowIdleFeature
        >,
        Timer1GpioFeature<                // we want to output something to GPIO
          TIMER_REMAP_NONE,               // the GPIO output will not be remapped
          TIM1_CH1_OUT,                   // we will output channel 1 to GPIO
          TIM1_BKIN                       // break input on PB12
        >,
        Timer1InterruptFeature
      > timer;


      /*
       * Set ourselves up as a subscriber for interrupts raised by the timer class.
       */

      timer.TimerInterruptEventSender.insertSubscriber(
          TimerInterruptEventSourceSlot::bind(this,&TimerPwmBreakTest::onInterrupt)
        );

      /*
       * Set an up-timer up to tick at 10MHz with an auto-reload value of 1999
       * The timer will count from 0 to 1999 inclusive then reset back to 0.
       */

      timer.setTimeBaseByFrequency(10000000,1999);

      /*
       * Clear and enable interrupts
       */

      timer.clearPendingInterruptsFlag(TIM_IT_Break);
      timer.enableInterrupts(TIM_IT_Break);

      /*
       * Default duty cycle of zero
       */

      timer.setDutyCycle(0);

      /*
       * Master output enable (timers with the break feature have this disabled after reset)
       */

      timer.enableMainOutput();

      /*
       * Enable the break feature
       */

      timer.setBreakPolarity(UnlockedTimerBreakFeature::BREAK_POLARITY_HIGH);
      timer.enableBreak();

      /*
       * Enable the timer. The PWM output is on PA8.
       */

      timer.enablePeripheral();

      /*
       * It's all running automatically now, use the main CPU to vary the duty cycle up
       * to 100% and back down again
       */

      for(;;) {

        // fade up to 100% in 4ms steps

        for(int8_t i=0;i<=100;i++) {
          timer.setDutyCycle(i);
          MillisecondTimer::delay(4);
        }

        // fade down to 0% in 4ms steps

        for(int8_t i=100;i>=0;i--) {
          timer.setDutyCycle(i);
          MillisecondTimer::delay(4);
        }
      }
    }


    /*
     * Subscriber callback function
     */

    void onInterrupt(TimerEventType tet,uint8_t /* timerNumber */) {

      if(tet==TimerEventType::EVENT_BREAK) {
        // do something to handle the break event
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // we need the SysTick timer

  MillisecondTimer::initialise();

  TimerPwmBreakTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/timer_pwm_break/timer_pwm_break.cpp
// START FILE: ../examples/timer_pwm_break/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/timer_pwm_break/system/LibraryHacks.cpp
// START FILE: ../examples/usb_device_msc_sdcard/usb_device_msc_sdcard.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/usb/device/msc.h"
#include "config/sdcard.h"


using namespace stm32plus;
using namespace stm32plus::usb;


/**
 * This example demonstrates the somewhat over-exampled SD-Card-as-an-external-disk mass storage
 * device, also known as a USB thumb drive. This example is compatible with the F4 discovery
 * board if you connect an external SD card cage to the SDIO pins as follows:
 *
 * PC8  => D0
 * PC9  => D1
 * PC10 => D2
 * PC11 => D3
 * PC12 => CLK
 * PD2  => CMD
 *
 * The internal pullups are activated for D0..3 and CMD so you should not need to add anything
 * externally.
 *
 * This example assumes that an SDCard is inserted and ready when the device is plugged into
 * the host. The card should remain inserted while the device is plugged in. You can unplug
 * the device from the host, change cards, then re-insert the cable to the host. If there's
 * a problem during card initialisation then the red LED on the discovery board (PD5) will
 * light up (that's the one in the middle near the accelerometer).
 *
 * Compatible MCU:
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F407VGT6 / Windows 8.1 x64 host
 */

class UsbDeviceMscSdcardTest {

  public:

    /*
     * declare a type for the the USB stack
     */

    typedef BotMscDevice<
      InternalFsPhy<>,                    // use the internal full speed PHY with no features
      ManufacturerTextFeature,            // we'll supply a manufacturer name
      ProductTextFeature,                 // ... and a product name
      SerialNumberTextFeature,            // ... and a serial number
      ConfigurationTextFeature            // ... and a config text string
    > MyUsb;


    /*
     * Declare the pointer to the SDCard implementation
     */

    scoped_ptr<SdioDmaSdCard> _sdcard;


    /*
     * PD5 is attached to a LED that we use to indicate problems
     */

    GpioPinRef _errorLed;


    /*
     * Run the example
     */

    void run() {

      /*
       * Set up the error LED that we might need later
       */

      GpioD<DefaultDigitalOutputFeature<5>> pd;
      _errorLed=pd[5];

      /*
       * set up the parameters for the USB MSC device. Do not attempt to reuse vid/pid combinations unless
       * you know how to flush your PC's USB driver cache because Windows caches the characteristics of each
       * device and will suspend your device if it suddenly re-appears as a different device type.
       */

      MyUsb::Parameters usbParams;

      usbParams.device_vid=0xDEAD;           // demo vendor ID
      usbParams.device_pid=0x0020;           // demo product ID

      usbParams.device_manufacturer_text="Andy's Workshop";   // see params.device_language_[ids/count] to change the languages
      usbParams.device_product_text="stm32plus flash drive";
      usbParams.device_configuration_text="My configuration";

      /*
       * The serial number is required and important for the MSC device class. See online
       * documentation for the length and format requirements.
       */

      usbParams.device_serial_text="002020141223";

      /*
       * Declare the USB object - this will initialise internal variables but will not
       * start the peripheral
       */

      MyUsb usb;

      /*
       * Subscribe to errors
       */

      usb.UsbErrorEventSender.insertSubscriber(UsbErrorEventSourceSlot::bind(this,&UsbDeviceMscSdcardTest::onError));

      /*
       * Subscribe to USB events
       */

      usb.UsbEventSender.insertSubscriber(UsbEventSourceSlot::bind(this,&UsbDeviceMscSdcardTest::onEvent));

      /*
       * Start the USB peripheral. It will run asynchronously. There is no requirement
       * for the parameters to remain in scope after the initialise call
       */

      if(!usb.initialise(usbParams))
        for(;;);      // onError() has already locked up

      // loop forever, or until an error interrupts us

      for(;;) {
      }
    }


    /**
     * Event callback from the USB stack. Lots of stuff will come through here but
     * we're only interested in data arriving from the host and control messages
     */

    void onEvent(UsbEventDescriptor& ued) {

      switch(ued.eventType) {

        /*
         * CLASS_INIT is called when the device is connecting to the host.
         */

        case UsbEventDescriptor::EventType::CLASS_INIT:
          onInit();
          break;

        /*
         * CLASS_DEINIT is called when the device is removed from the host. i.e. the
         * host is powered down or the cable has been removed.
         */

        case UsbEventDescriptor::EventType::CLASS_DEINIT:
          onDeInit();
          break;

        case UsbEventDescriptor::EventType::MSC_BOT_IS_READY:
          onIsReady(static_cast<MscBotIsReadyEvent&>(ued));
          break;

        case UsbEventDescriptor::EventType::MSC_BOT_GET_ENQUIRY_PAGE:
          onGetEnquiryPage(static_cast<MscBotGetEnquiryPageEvent&>(ued));
          break;

        case UsbEventDescriptor::EventType::MSC_BOT_GET_CAPACITY:
          onGetCapacity(static_cast<MscBotGetCapacityEvent&>(ued));
          break;

        case UsbEventDescriptor::EventType::MSC_BOT_READ:
          onRead(static_cast<MscBotReadEvent&>(ued));
          break;

        case UsbEventDescriptor::EventType::MSC_BOT_WRITE:
          onWrite(static_cast<MscBotWriteEvent&>(ued));
          break;

        case UsbEventDescriptor::EventType::MSC_BOT_IS_WRITE_PROTECTED:
          onIsWriteProtected(static_cast<MscBotIsWriteProtectedEvent&>(ued));
          break;

        default:   // warning suppression
          break;
      }
    }


    /**
     * The device is connecting to the host, create a new SDIO implementation. A card
     * must be inserted and ready and must remain for the duration of the session. This
     * example does not support hot swapping of cards while the device is connected
     * to the host.
     */

    void onInit() {

      // create the new instance, power up the card and initialise

      _sdcard.reset(new SdioDmaSdCard);

      // check for error and delete the instance if not working

      if(errorProvider.hasError()) {
        _sdcard.reset(nullptr);
        _errorLed.set();
      }
      else
        _errorLed.reset();
    }


    /**
     * The device is disconnecting from the host, release the SDIO implementation
     * and power down the card
     */

    void onDeInit() {
      _sdcard.reset(nullptr);
      _errorLed.reset();
    }


    /**
     * Read a number of blocks from the disk
     * @param event
     */

    void onRead(MscBotReadEvent& event) {

      if(_sdcard==nullptr)
        event.success=false;      // card failed to be detected on init
      else {

        // read single/multiblock depending on block count

        if(event.blockCount==1)
          event.success=_sdcard->readBlock(event.buffer,event.blockAddress);
        else
          event.success=_sdcard->readBlocks(event.buffer,event.blockAddress,event.blockCount);
      }
    }


    /**
     * Write a number of blocks to the disk
     * @param event
     */

    void onWrite(MscBotWriteEvent& event) {

      if(_sdcard==nullptr)
        event.success=false;      // card failed to be detected on init
      else {

        // write single/multiblock depending on block count

        if(event.blockCount==1)
          event.success=_sdcard->writeBlock(event.buffer,event.blockAddress);
        else
          event.success=_sdcard->writeBlocks(event.buffer,event.blockAddress,event.blockCount);
      }
    }


    /**
     * Handle the onReady event: the success of the init call determines readiness
     * @param event The event structure
     */

    void onIsReady(MscBotIsReadyEvent& event) {
      event.isReady=_sdcard!=nullptr;
    }


    /**
     * Handle the is-write-protected event: we'll limit this example to always being
     * write-enabled (the WP slider on an SD card is normally mapped to a GPIO but is
     * not a part of the SDIO standard)
     * @param event The event structure
     */

    void onIsWriteProtected(MscBotIsWriteProtectedEvent& event) {
      event.isWriteProtected=false;
    }


    /**
     * Get the capacity for this disk. The LUN index is in the event which will be zero
     * for us. We need to set the block size and count as well as the ready flag that says
     * we have a disk online.
     * @param event event data
     */

    void onGetCapacity(MscBotGetCapacityEvent& event) {

      if(_sdcard==nullptr)
        event.ready=false;            // the card was not initialised successfully
      else {

        // fill in this card's parameters

        event.blockSize=_sdcard->getBlockSizeInBytes();
        event.blockCount=_sdcard->getTotalBlocksOnDevice();
        event.ready=true;
      }
    }


    /**
     * Get the enquiry page for a LUN. Returns some basic stuff about the manufacturer, product
     * and version.
     * @param event event data
     */

    void onGetEnquiryPage(MscBotGetEnquiryPageEvent& event) {

      // we only support a single LUN

      static const uint8_t data[0x24]={
        0,0x80,2,2,0x24-5,0,0,0,
       'A', 'n', 'd', 'y', 'W', 'k', 's', 'p',    // 8 byte manufacturer
       's', 't', 'm', '3', '2', 'p', 'l', 'u','s', ' ', 'S', 'D', 'C', 'a', 'r', 'd',   // 16 byte product
       '4', '.', '0','0',                         // 4 byte version
      };

      event.enquiryPage=data;
    }


    /**
     * USB error event received
     * @param uee the event descriptor
     */

    void onError(UsbErrorEvent& /* uee */) {

      // flash the RED led on PD5 at 1Hz

      for(;;) {
        _errorLed.reset();
        MillisecondTimer::delay(500);
        _errorLed.set();
        MillisecondTimer::delay(500);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  // initialise the interrupt controller

  Nvic::initialise();

  // initialise the millisecond timer

  MillisecondTimer::initialise();

  // run the test

  UsbDeviceMscSdcardTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/usb_device_msc_sdcard/usb_device_msc_sdcard.cpp
// START FILE: ../examples/usb_device_msc_sdcard/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/usb_device_msc_sdcard/system/LibraryHacks.cpp
// START FILE: ../examples/net_llip/net_llip.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/timing.h"
#include "config/usart.h"


using namespace stm32plus;
using namespace stm32plus::net;


/**
 * This examples demonstrates the use of the Link Local IP client to automatically select an unused
 * IP address from the "link local" class B network: 169.254/16. Link-local addresses can be used
 * in a scenario where a DHCP server is not available, such as when a number of computers are directly
 * connected to each other.
 *
 * If an address collision is detected while the stack is running then a new address will be
 * automatically generated and broadcast to the stack modules. You can simulate this condition by using
 * the linux NPING utility to hand-craft a colliding ARP packet. For example, if you have been assigned
 * 169.254.232.52:
 *
 * $ nping 169.254.232.52 --arp --arp-type arp-request --arp-sender-mac \
 *   00:0a:34:30:fe:ae --arp-sender-ip 169.254.232.52 --arp-target-mac \
 *   00:00:00:00:00:00 --arp-target-ip 169.254.232.52
 *
 * You can then use tcpdump or wireshark to observe this module searching for a new address.
 *
 * The results and any errors are sent to USART3 (57000/8/N/1).
 *
 * Here's how the network stack for this example is configured:
 *
 *              +----------------------------+
 * APPLICATION: | LinkLocalIp                |
 *              +----------------------------+
 * TRANSPORT:   | Udp                        |
 *              +-----+----------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +-----------------------------
 *
 * This example is also tested using the KSZ8051MLL in MII mode instead of the DP83848C/RMII.
 * The KSZ8051MLL test was performed on the STM32F107. The DP83848C was tested on the STM32F407. To
 * reconfigure this demo for the F107 using remapped MAC pins connected to the KSZ8051MLL change
 * the physical and datalink layers thus:
 *
 * typedef PhysicalLayer<KSZ8051MLL> MyPhysicalLayer;
 * typedef DatalinkLayer<MyPhysicalLayer,RemapMiiInterface,Mac> MyDatalinkLayer;
 *
 * Tested on devices:
 *   STM32F107VCT6
 *   STM32F407VGT6
 */

class NetLlipClientTest {

  public:

    /*
     * Define the layers that make up the networking stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,LinkLocalIp> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /*
     * The network stack object
     */

    MyNetworkStack *_net;


    /*
     * Declare the USART that we'll use. On my dev board USART3 is mapped to PC10,11
     * and we have that defined as remap #2
     */

    typedef Usart3_Remap2<> MyUsart;
    MyUsart *_usart;
    UsartPollingOutputStream *_outputStream;

    /*
     * Run the test
     */

    void run() {

      // declare an instance of the USART and the stream that we'll use to write to it

      _usart=new MyUsart(57600);
      _outputStream=new UsartPollingOutputStream(*_usart);

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 1970 but that doesn't matter to us

      Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> rtc;
      rtc.setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=&rtc;

      // spy on the LLIP announcements for IP address, subnet mask, default gateway and DNS servers
      // by subscribing to the notification events passed around the network stack. we will
      // also receive notification of any LLIP clashes here.

      _net->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&NetLlipClientTest::onNotification));

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetLlipClientTest::onError));

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      if(!_net->initialise(params))
        error();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the LLIP transaction

      if(!_net->startup())
        error();

      // finished

      for(;;) {
      }
    }


    /**
     * A notification event was received from the stack. Check for lease renewal
     * notification and new address announcements. This could be IRQ code.
     * @param ned The event descriptor base class
     */

    void onNotification(NetEventDescriptor& ned) {

      char buf[30];

      if(ned.eventType==NetEventDescriptor::NetEventType::IP_ADDRESS_ANNOUNCEMENT) {
        static_cast<IpAddressAnnouncementEvent&>(ned).ipAddress.toString(buf);
        *_outputStream << "IP Address: " << buf << "\r\n";
      }
      else if(ned.eventType==NetEventDescriptor::NetEventType::SUBNET_MASK_ANNOUNCEMENT) {
        static_cast<IpSubnetMaskAnnouncementEvent&>(ned).subnetMask.toString(buf);
        *_outputStream << "Subnet mask: " << buf << "\r\n";
      }
    }


    /**
     * Network error event received, report it
     * @param ned The event descriptor base class
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      char buf[20];

      *_outputStream << "Error (provider/code/cause) ";

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      *_outputStream << buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      *_outputStream << "/" << buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      *_outputStream << "/" << buf << "\r\n";
    }


    void error() {
      *_outputStream << "Aborted execution due to an unexpected error\r\n";
      for(;;);
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetLlipClientTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_llip/net_llip.cpp
// START FILE: ../examples/net_llip/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_llip/system/LibraryHacks.cpp
// START FILE: ../examples/spi_send_interrupts/spi_send_interrupts.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/spi.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * This demo illustrates sending and receiving using the SPI peripherals. A block of test
 * data is sent from SPI2 to SPI1 and, if successfully received, then a LED on PF6 is
 * flashed for 1 second. The test repeats continuously.
 *
 * SPI2 is used to send the data and it's received by the SPI1 interrupt.
 *
 * If you intend to run this example on the F4 DISCOVERY board then replace PF6 with PD13
 * to use the onboard LED.
 *
 * If you intend to run this example on the VL or F0 DISCOVERY board then replace PF6 with PC8 to
 * use the onboard LED.
 *
 * For this demo I'm going to need you to do a little wiring to hook up SPI1 to SPI2 so that
 * we can exchange data over the MOSI pin. Here are the connections that you need to make.
 *
 * 1MOSI/2MOSI: PA7  => PB15
 * NSS:         PA4 <=> PB12
 * SCLK:        PA5 <=> PB13
 *
 * Compatible MCU:
 *   STM32F0
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F051R8T6
 *   STM32F103ZET6
 *   STM32F407VGT6
 *   STM32F100RBT6
 */


static const uint8_t *dataToSend=(const uint8_t *)"Hello World";


class SpiSendInterruptsTest {

  protected:

    enum { LED_PIN = 6 };

    /*
     * These instance variables will be used by the interrupt to
     * co-ordinate the send and receive process.
     */

    uint8_t _receiveBuffer[12];
    volatile uint8_t _receiveIndex;
    uint8_t _sendIndex;

    /*
     * Declare the SPI sender/receiver.
     */

    typedef Spi2<> MySender;
    typedef Spi1<Spi1InterruptFeature> MyReceiver;

    MySender *_sender;
    MyReceiver *_receiver;

  public:

    void run() {

      // initialise the LED on PF6. It's active LOW so we set it HIGH to turn it off

      GpioF<DefaultDigitalOutputFeature<LED_PIN> > pf;
      pf[LED_PIN].set();

      /*
       * We're using interrupts, set up the NVIC
       */

      Nvic::initialise();

      /**
       * Create the sender and receiver objects as master and slave
       */

      MySender::Parameters senderParams;
      MyReceiver::Parameters receiverParams;

      senderParams.spi_mode=SPI_Mode_Master;
      receiverParams.spi_mode=SPI_Mode_Slave;

      _sender=new MySender(senderParams);
      _receiver=new MyReceiver(receiverParams);

      /*
       * register ourselves as an observer of the SPI receive interrupt
       */

      _receiver->SpiInterruptEventSender.insertSubscriber(
          SpiInterruptEventSourceSlot::bind(this,&SpiSendInterruptsTest::onInterrupt)
        );

      for(;;) {

        uint8_t i;

        /*
         * Reset the instance variables
         */

        _sendIndex=0;
        _receiveIndex=0;

        memset(_receiveBuffer,0,sizeof(_receiveBuffer));

        /*
         * Enable the receive interrupt
         */

        _receiver->enableInterrupts(SPI_I2S_IT_RXNE);

        /*
         * NSS (slave select) is active LOW. ST made such a mess of the hardware implementation of NSS
         * that we always control it through software. Here it's pulled LOW ready for transmission.
         */

        _sender->setNss(false);

        /*
         * Send the block of data from SPI2 to SPI1. Note the lack of flow control. Don't built a
         * real system like this.
         */

        for(i=0;i<12;i++) {

          /*
           * Wait for the sender to signal it's ready and then send a byte
           */

          while(!_sender->readyToSend());
          _sender->send(&dataToSend[i],1);
        }

        /*
         * Wait for the receive interrupt handler to signal that it's finished
         */

        while(_receiveIndex!=12);

        /*
         * Wait for idle and de-select NSS
         */

        _sender->waitForIdle();
        _sender->setNss(true);

        /*
         * Test the received buffer. If the data is incorrect then lock up
         */

        if(memcmp(_receiveBuffer,dataToSend,sizeof(_receiveBuffer))!=0)
          for(;;);

        /*
         * The data is correct, flash the LED on PF6 for one second
         */

        pf[LED_PIN].reset();
        MillisecondTimer::delay(1000);
        pf[LED_PIN].set();
        MillisecondTimer::delay(1000);
      }
    }


    /*
     * Interrupt callback function. This is called when the TXE and RXNE interrupts that we've
     * enabled are fired.
     */

    void onInterrupt(SpiEventType set) {

      if(set==SpiEventType::EVENT_RECEIVE) {

        // receive a byte

        _receiver->receive(_receiveBuffer[_receiveIndex]);
        _receiveIndex++;

        // if all is received, disable interrupts and signal finished

        if(_receiveIndex==sizeof(_receiveBuffer))
          _receiver->disableInterrupts(SPI_I2S_IT_RXNE);
      }
    }
};


/*
 * Main entry point
 */

int main() {

  MillisecondTimer::initialise();

  SpiSendInterruptsTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/spi_send_interrupts/spi_send_interrupts.cpp
// START FILE: ../examples/spi_send_interrupts/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/spi_send_interrupts/system/LibraryHacks.cpp
// START FILE: ../examples/rtc/rtc_f1.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F1)

#include "config/rtc.h"
#include "config/gpio.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * Real time clock (RTC) demo.
 *
 * This demo sets up the RTC to flash a LED on PF6 every second. Additionally, an alarm is set
 * to go off every 10 seconds and when it does the LED is flashed rapidly 5 times.
 *
 * The RTC on the F1 is quite different to the F4 so I have elected to provide separate demos
 * for the F1 and F4 (STM32F4DISCOVERY)
 *
 * If you want to try this on the STM32VLDISCOVERY board then change LED_PIN to 8 and GpioF
 * to GpioC to use the blue LED on the board.
 *
 * Compatible MCU:
 *   STM32F1
 *
 * Tested devices:
 *   STM32F103ZET6
 *   STM32F100RBT6
 */

class RtcTest {

  protected:
    uint32_t _alarmTick;
    bool _ledState;

    volatile bool _ticked;
    volatile bool _alarmed;

    enum {
      LED_PIN = 6
    };

  public:

    void run() {

      // initialise the LED port

      GpioF<DefaultDigitalOutputFeature<LED_PIN> > pf;

      // lights off (this LED is active low, i.e. PF6 is a sink)

      _ledState=true;
      pf[LED_PIN].set();

      // declare an RTC instance customised with just the features we will use.
      // a clock source is mandatory. The interrupt features are optional and
      // will pull in the relevant methods and features for us to use

      Rtc<
        RtcLseClockFeature,             // we'll clock it from the LSE clock
        RtcSecondInterruptFeature,      // we want per-second interrupts
        RtcAlarmInterruptFeature        // we also want the alarm interrupt
      > rtc;

      // insert ourselves as subscribers to the per-second and alarm interrupts.

      rtc.RtcSecondInterruptEventSender.insertSubscriber(RtcSecondInterruptEventSourceSlot::bind(this,&RtcTest::onTick));
      rtc.RtcAlarmInterruptEventSender.insertSubscriber(RtcAlarmInterruptEventSourceSlot::bind(this,&RtcTest::onAlarm));

      _ticked=_alarmed=false;

      // start the second interrupt

      rtc.enableSecondInterrupt();

      // configure the alarm to go off after 10 seconds

      rtc.setAlarm(_alarmTick=10);

      // main loop

      for(;;) {

        // if we ticked, toggle LED state

        if(_ticked) {
          _ledState^=true;
          pf[LED_PIN].setState(_ledState);

          // reset for next time

          _ticked=false;
        }

        // if the alarm went off then flash rapidly

        if(_alarmed) {

          for(int i=0;i<5;i++) {
            pf[LED_PIN].reset();
            MillisecondTimer::delay(50);
            pf[LED_PIN].set();
            MillisecondTimer::delay(50);
          }

          // put the LED back where it was

          pf[LED_PIN].setState(_ledState);

          // bump forward the alarm by 10 seconds

          _alarmTick+=10;
          rtc.setAlarm(_alarmTick);

          // reset for next time

          _alarmed=false;
        }
      }
    }


    /*
     * The RTC has ticked
     */

    void onTick() {
      _ticked=true;
    }


    /*
     * The RTC has alarmed
     */

    void onAlarm() {
      _alarmed=true;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  RtcTest test;
  test.run();

  // not reached
  return 0;
}

#endif // STM32PLUS_F1
// END FILE: ../examples/rtc/rtc_f1.cpp
// START FILE: ../examples/rtc/rtc_f0.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F0)

#include "config/rtc.h"
#include "config/gpio.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * Real time clock (RTC) demo.
 *
 * This demo sets up the RTC to flash a LED on PC8 rapidly every 5 seconds. The clock source is the
 * HSI (8MHz) oscillator that we will calibrate using timer 14.
 *
 * The RTC on the F0 is quite different to the F1 but is similar to the F4 though it lacks the per-second
 * interrupt that you get with the F4 peripheral and you only get one alarm.
 *
 * Compatible MCU:
 *   STM32F0
 *
 * Tested devices:
 *   STM32F042F6P6
 *   STM32F051R8T6
 */

class RtcTest {

  protected:

    enum { LED_PIN = 8 };

    volatile bool _alarmed;

  public:

    void run() {

      // initialise the LED port

      GpioC<DefaultDigitalOutputFeature<LED_PIN> > pc;

      // lights off (this LED is active high, i.e. PC8 is a source)

      pc[LED_PIN].reset();

      // declare an RTC instance customised with just the features we will use.
      // a clock source is mandatory. The interrupt feature is optional and
      // will pull in the relevant methods and features for us to use

      Rtc<
        RtcLsiClockFeature<RtcMeasuredLsiFrequencyProvider>,  // we'll clock it from the LSI clock and calibrate the HSI using a timer
        RtcAlarmInterruptFeature                              // we also want the alarm A interrupt
      > rtc;

      // insert ourselves as a subscriber to the alarm interrupt

      rtc.RtcAlarmInterruptFeature::ExtiInterruptEventSender.insertSubscriber(ExtiInterruptEventSourceSlot::bind(this,&RtcTest::onAlarm));

      // set the time to midnight

      rtc.setTime(0,0,0);

      _alarmed=false;

      // configure the alarm to go off on 10s time match. i.e. 0:0:10, 0:1:10, 0:2:10 etc...

      rtc.setAlarm(RTC_AlarmMask_DateWeekDay | RTC_AlarmMask_Hours | RTC_AlarmMask_Minutes,   // only consider seconds as the trigger
                   RTC_AlarmDateWeekDaySel_Date,      // don't care
                   0,                                 // day/date (don't care)
                   0,                                 // hour (don't care)
                   0,                                 // minute (don't care)
                   10);                               // second - on the 10's.

      // main loop

      for(;;) {

        // if the alarm went off then flash rapidly

        if(_alarmed) {

          for(int i=0;i<5;i++) {
            pc[LED_PIN].set();
            MillisecondTimer::delay(50);
            pc[LED_PIN].reset();
            MillisecondTimer::delay(50);
          }

          // reset for next time (in another 10 seconds)

          rtc.setTime(0,0,0);
          _alarmed=false;
        }
      }
    }

    /*
     * the RTC has alarmed
     */

    void onAlarm(uint8_t /* extiNumber */) {
      _alarmed=true;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution

  MillisecondTimer::initialise();

  // we're using interrupts, initialise NVIC

  Nvic::initialise();

  RtcTest test;
  test.run();

  // not reached
  return 0;
}

#endif // STM32PLUS_F0
// END FILE: ../examples/rtc/rtc_f0.cpp
// START FILE: ../examples/rtc/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/rtc/system/LibraryHacks.cpp
// START FILE: ../examples/rtc/rtc_f4.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"

#if defined(STM32PLUS_F4)

#include "config/rtc.h"
#include "config/gpio.h"
#include "config/timing.h"


using namespace stm32plus;


/**
 * Real time clock (RTC) demo.
 *
 * This demo sets up the RTC to flash a LED on PD13 every second. Additionally, an alarm is set
 * to go off every 10 seconds and when it does the LED is flashed rapidly 5 times. The clock source
 * is the LSI assumed to be 32768Hz.
 *
 * The RTC on the F1 is quite different to the F4 so I have elected to provide separate demos
 * for the F1 and F4 (STM32F4DISCOVERY). This is the F4 demo.
 *
 * Compatible MCU:
 *   STM32F4
 *
 * Tested devices:
 *   STM32F407VGT6
 */

class RtcTest {

  protected:

    enum { LED_PIN = 13 };

    bool _ledState;

    volatile bool _ticked;
    volatile bool _alarmed;

  public:

    void run() {

      // initialise the LED port

      GpioD<DefaultDigitalOutputFeature<LED_PIN> > pd;

      // lights off (this LED is active high, i.e. PD13 is a source)

      _ledState=true;
      pd[LED_PIN].reset();

      // declare an RTC instance customised with just the features we will use.
      // a clock source is mandatory. The interrupt features are optional and
      // will pull in the relevant methods and features for us to use

      Rtc<
        RtcLsiClockFeature<RtcMeasuredLsiFrequencyProvider>,  // we'll clock it from the LSI clock and calibrate the LSI using a timer
        RtcSecondInterruptFeature,                            // we want per-second interrupts
        RtcAlarmAInterruptFeature                             // we also want the alarm A interrupt
      > rtc;

      // insert ourselves as subscribers to the per-second and alarm interrupts.
      // we need to qualify ExtiInterruptSender with the name of its containing class because
      // there are two ExtiInterruptSender's in the hierarchy.

      rtc.RtcSecondInterruptFeature::ExtiInterruptEventSender.insertSubscriber(ExtiInterruptEventSourceSlot::bind(this,&RtcTest::onTick));
      rtc.RtcAlarmInterruptFeature::ExtiInterruptEventSender.insertSubscriber(ExtiInterruptEventSourceSlot::bind(this,&RtcTest::onAlarm));

      // set the time to midnight

      rtc.setTime(0,0,0);

      _ticked=_alarmed=false;

      // start the second interrupt

      rtc.enableSecondInterrupt();

      // configure the alarm to go off on 10s time match. i.e. 0:0:10, 0:1:10, 0:2:10 etc...

      rtc.setAlarm(RTC_AlarmMask_DateWeekDay | RTC_AlarmMask_Hours | RTC_AlarmMask_Minutes,   // only consider seconds as the trigger
                   RTC_AlarmDateWeekDaySel_Date,      // don't care
                   0,                                 // day/date (don't care)
                   0,                                 // hour (don't care)
                   0,                                 // minute (don't care)
                   10);                               // second - on the 10's.

      // main loop

      for(;;) {

        // if we ticked, toggle LED state

        if(_ticked) {
          _ledState^=true;
          pd[LED_PIN].setState(_ledState);

          // reset for next time

          _ticked=false;
        }

        // if the alarm went off then flash rapidly

        if(_alarmed) {

          for(int i=0;i<5;i++) {
            pd[LED_PIN].set();
            MillisecondTimer::delay(50);
            pd[LED_PIN].reset();
            MillisecondTimer::delay(50);
          }

          // put the LED back where it was

          pd[LED_PIN].setState(_ledState);

          // reset for next time (in another 60 seconds)

          _alarmed=false;
        }
      }
    }

    /*
     * the RTC has ticked
     */

    void onTick(uint8_t /* extiNumber */) {
      _ticked=true;
    }

    /*
     * the RTC has alarmed
     */

    void onAlarm(uint8_t /* extiNumber */) {
      _alarmed=true;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution

  MillisecondTimer::initialise();

  // we're using interrupts, initialise NVIC

  Nvic::initialise();

  RtcTest test;
  test.run();

  // not reached
  return 0;
}

#endif // STM32PLUS_F4
// END FILE: ../examples/rtc/rtc_f4.cpp
// START FILE: ../examples/fsmc_sram/fsmc_sram.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/sram.h"
#include "config/timing.h"
#include "config/stream.h"


using namespace stm32plus;


/**
 * Demo of an SRAM chip connected to the FSMC on an STM32F103ZET6 (LQFP144).
 * In this case it's an ISSI IS61LV25616 256K x 16 (4Mbit) SRAM on bank #3.
 *
 * This demo will write a repeating pattern to the SRAM and read it back
 * afterwards. If it is successful then a LED attached to PF6 will be
 * flashed for 500ms.
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103ZET6
 */

class FsmcSramTest  {

  protected:

    /**
     * The pin number of the LED
     */

    enum { LED_PIN = 6 };

    /**
     * The SRAM and FSMC location typedef
     */

    typedef IS61LV25616<FsmcBank1NorSram3> MySram;

  public:

    void run() {

      GpioF<DefaultDigitalOutputFeature<LED_PIN> > pf;

      // initialise the SRAM

      MySram sram(MySram::TEN_NS);

      // lights off (this LED is active low, i.e. PF6 is a sink)

      pf[6].set();

      for(;;) {
        testDirect(pf[LED_PIN]);
        testStream(sram,pf[LED_PIN]);
      }
    }


    /**
     * Test by directly accessing the memory locations
     */

    void testDirect(GpioPinRef led) {

      uint32_t i;
      uint16_t *ptr;

      // write a pattern

      ptr=FsmcBank1NorSram3::getBaseAddress<uint16_t>();
      for(i=0;i<MySram::SIZE_IN_BYTES/2;i++)
        *ptr++=0xaa55;

      // read it back

      ptr=FsmcBank1NorSram3::getBaseAddress<uint16_t>();
      for(i=0;i<MySram::SIZE_IN_BYTES/2;i++)
        if(*ptr++!=0xaa55)
          for(;;);                  // lock up

      // switch the LED on and off for 500ms

      led.reset();
      MillisecondTimer::delay(500);
      led.set();
      MillisecondTimer::delay(500);
    }


    /**
     * Test by accessing as a stream. This test writes out a string repeatedly
     * until the SRAM is full and then reads it back to make sure it's good.
     */

    void testStream(MySram& sram,GpioPinRef led) {

      int32_t available;
      uint32_t actuallyRead;
      char buffer[28];

      {
        // initialise a buffered output stream on to the memory

        BlockDeviceOutputStream os(sram,0,true);

        // write out a pattern to the stream

        for(available=MySram::SIZE_IN_BYTES;available>=27;available-=27)
          os.write("Hello world, this is a test",27);     // 27 bytes
      }

      // initialise an input stream on to the memory

      BlockDeviceInputStream is(sram,0);

      // read back the data

      buffer[27]='\0';

      for(available=MySram::SIZE_IN_BYTES;available>=27;available-=27) {

        // get 27 bytes from the stream

        if(!is.read(buffer,27,actuallyRead) || actuallyRead!=27)
          for(;;);

        // ensure it's what we expect

        if(strcmp(buffer,"Hello world, this is a test")!=0)
          for(;;);
      }

      // switch the LED on and off for 500ms

      led.reset();
      MillisecondTimer::delay(500);
      led.set();
      MillisecondTimer::delay(500);
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  FsmcSramTest test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/fsmc_sram/fsmc_sram.cpp
// START FILE: ../examples/fsmc_sram/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/fsmc_sram/system/LibraryHacks.cpp
// START FILE: ../examples/net_web_pframe/MyTcpClientConnection.h
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#pragma once


namespace stm32plus {
  namespace net {


    /**
     * subclass TCP connection so that we can tune the buffer parameters
     */

    class MyTcpClientConnection : public TcpClientConnection {

      public:
        MyTcpClientConnection();
    };


    /**
     * Constructor
     */

    inline MyTcpClientConnection::MyTcpClientConnection() {

      // the TCP connection has taken a reference to the _params Parameters
      // class but it has not yet initialised itself from those parameters
      // therefore we are able to tune them for our needs

      // increase receive buffer size to 3xMSL for better throughput

      _params.tcp_receiveBufferSize=4380;
    }
  }
}
// END FILE: ../examples/net_web_pframe/MyTcpClientConnection.h
// START FILE: ../examples/net_web_pframe/net_web_pframe.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/net.h"
#include "config/net_http.h"
#include "config/display/tft.h"
#include "config/timing.h"
#include "config/usart.h"
#include "MyTcpClientConnection.h"


using namespace stm32plus;
using namespace stm32plus::net;
using namespace stm32plus::display;

extern uint32_t ErrorPixels,ErrorPixelsSize;


/**
 * This example demonstrates a cycling 'picture frame' of JPEG images downloaded from the internet and
 * displayed on the attached LCD screen. The images are pre-sized to fit the QVGA screen and are located
 * in a directory on my website.
 *
 * The examples works by reading an 'index' text file from the web site which tells it how many images
 * there are and what their URLs are. The example then goes into a loop retrieving each JPEG image
 * and displaying it on the LCD.
 *
 *              +----------------------------+
 * APPLICATION: | DhcpClient | Dns           |
 *              +------+---------------------+
 * TRANSPORT:   | Tcp | Udp                  |
 *              +-----++---------------------+
 * NETWORK      | DefaultIp | Arp            |
 *              +-----+----------------+-----+
 * DATALINK:    | DefaultRmiiInterface | Mac |
 *              +----------------------+-----+
 * PHYSICAL:    | DP83848C                   |
 *              +----------------------------+
 *
 * This is example is only compatible with the F4 because it requires the FSMC peripheral to drive
 * the LCD.
 *
 * Tested on devices:
 *   STM32F407VGT6
 */

class NetWebPictureFrame {

  public:

    /**
     * Types that define the LCD that we'll be using
     */

    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef ST7783_Portrait_64K<LcdAccessMode> LcdPanel;


    /**
     * LCD member variables
     */

    LcdAccessMode *_accessMode;
    LcdPanel *_tft;
    Font *_font;
    DefaultBacklight *_backlight;
    uint16_t _line;


    /**
     * The RTC that the stack requires
     */

    typedef Rtc<RtcLsiClockFeature<Rtc32kHzLsiFrequencyProvider>,RtcSecondInterruptFeature> MyRtc;
    MyRtc *_rtc;


    /**
     * Types that define the network stack
     */

    typedef PhysicalLayer<DP83848C> MyPhysicalLayer;
    typedef DatalinkLayer<MyPhysicalLayer,DefaultRmiiInterface,Mac> MyDatalinkLayer;
    typedef NetworkLayer<MyDatalinkLayer,DefaultIp,Arp> MyNetworkLayer;
    typedef TransportLayer<MyNetworkLayer,Udp,Tcp> MyTransportLayer;
    typedef ApplicationLayer<MyTransportLayer,DhcpClient,Dns> MyApplicationLayer;
    typedef NetworkStack<MyApplicationLayer> MyNetworkStack;


    /**
     * The network stack object
     */

    MyNetworkStack *_net;


    /**
     * Program variables
     */

    constexpr static const char *WEB_SERVER = "www.andybrown.me.uk";
    constexpr static const uint16_t WEB_SERVER_PORT = 80;
    constexpr static const char *PICTURE_INDEX_URI = "/wk/public/net_web_pframe/index.txt";

    std::slist<std::string> _pictureUriList;
    IpAddress _serverAddress;


    /**
     * Run the picture frame
     */

    void run() {

      // initialise the LCD and then the network

      initialiseLcd();
      initialiseNetwork();

      // do a DNS lookup for the server and read the index file

      lookupServerAddress();
      readPictureIndex();

      // give a small delay so that the user can see the startup info

      writeLine("Starting in 5 seconds");
      MillisecondTimer::delay(5000);

      // go into an infinite loop showing the pictures with a 10 second
      // delay between each one

      for(;;) {
        for(auto it=_pictureUriList.begin();it!=_pictureUriList.end();it++) {
          showPicture(*it);
          MillisecondTimer::delay(10000);
        }
      }
    }


    /**
     * Initialise the LCD
     */

    void initialiseLcd() {

      // reset is on PE1 and RS (D/CX) is on PE3

      GpioE<DefaultDigitalOutputFeature<1>,
            DefaultFsmcAlternateFunctionFeature<3>> pe;

      // set up the FSMC timing. these numbers (particularly the data setup time) are dependent on
      // both the FSMC bus speed and the panel timing parameters.

      Fsmc8080LcdTiming fsmcTiming(2,4);

      // set up the FSMC with RS=A19 (PE3)

      _accessMode=new LcdAccessMode(fsmcTiming,19,pe[1]);
      _tft=new LcdPanel(*_accessMode);

      // apply gamma settings

      ST7783Gamma gamma(0,0x0107,0,0x0203,0x0402,0,0x0207,0,0x0203,0x0403);
      _tft->applyGamma(gamma);

      // clear to black while the lights are out

      _tft->setBackground(ColourNames::BLACK);
      _tft->setForeground(ColourNames::WHITE);
      _tft->clearScreen();

      // fade up to 100% in 4ms steps

      _backlight=new DefaultBacklight;
      _backlight->fadeTo(100,4);

      // create a font

      _font=new Font_VOLTER__28GOLDFISH_299;
      *_tft << *_font;
      _line=0;
    }


    /**
     * Initialise the network
     */

    void initialiseNetwork() {

      // declare the RTC that that stack requires. it's used for cache timeouts, DHCP lease expiry
      // and such like so it does not have to be calibrated for accuracy. A few seconds here or there
      // over a 24 hour period isn't going to make any difference. Start it ticking at zero which is
      // some way back in 2000 but that doesn't matter to us

      _rtc=new MyRtc;
      _rtc->setTick(0);

      // declare an instance of the network stack

      MyNetworkStack::Parameters params;
      _net=new MyNetworkStack;

      // the stack requires the RTC

      params.base_rtc=_rtc;

      // It's nice to give the DHCP client a host name because then it'll show up in DHCP
      // 'active leases' page. In a home router this is often called 'attached devices'

      params.dhcp_hostname="stm32plus";

      // spy on the DHCP announcements for IP address, subnet mask, default gateway and DNS servers
      // by subscribing to the notification events passed around the network stack. we will
      // also receive notification that the DHCP lease will be renewed via this event.

      _net->NetworkNotificationEventSender.insertSubscriber(NetworkNotificationEventSourceSlot::bind(this,&NetWebPictureFrame::onNotification));

      // subscribe to error events from the network stack

      _net->NetworkErrorEventSender.insertSubscriber(NetworkErrorEventSourceSlot::bind(this,&NetWebPictureFrame::onError));

      // Initialise the stack. This will reset the PHY, initialise the MAC
      // and attempt to create a link to our link partner. Ensure your cable
      // is plugged in when you run this or be prepared to handle the error

      writeLine("Initialising network...");

      if(!_net->initialise(params))
        errorRestart();

      // start the ethernet MAC Tx/Rx DMA channels
      // this will trigger the DHCP transaction

      writeLine("Starting network...");

      if(!_net->startup())
        errorRestart();
    }


    /**
     * Lookup the web server address
     */

    void lookupServerAddress() {

      writeLine("Looking up the web server address...");

      // do the DNS query

      if(!_net->dnsHostnameQuery(WEB_SERVER,_serverAddress))
        error("Failed to lookup web server address");
    }


    /**
     * The picture index is a text file on the web server. The format of the file is one URI per line
     * and the last line must be "#end"
     */

    void readPictureIndex() {

      writeLine("Connecting to server...");

      // create the connection

      MyTcpClientConnection *ptr;

      if(!_net->tcpConnect<MyTcpClientConnection>(_serverAddress,WEB_SERVER_PORT,ptr))
        error("Failed to connect to web server");

      {
        // manage the connection pointer in a scoped_ptr so it's automatically deleted (and closed)
        // when it goes out of scope

        scoped_ptr<MyTcpClientConnection> conn(ptr);
        HttpClient httpClient(*conn);

        // set the parameters for the HTTP GET

        httpClient.setUri(PICTURE_INDEX_URI);
        httpClient.setHost(WEB_SERVER);
        httpClient.setVersion(HttpVersion::HTTP_1_0);

        // send it

        writeLine("Sending request for index...");

        if(!httpClient.sendRequest())
          error("Failed to send the request to the server");

        // read the response lines up to max of 200 per line

        TcpTextLineReceiver lineReceiver(200);

        writeLine("Reading index...");
        _pictureUriList.clear();

        for(;;) {

          if(!lineReceiver.add(*conn))
            error("Failed to index data");

          if(lineReceiver.ready()) {

            if(!strcasecmp(lineReceiver.str().c_str(),"#end"))
              break;

            _pictureUriList.push_front(lineReceiver.str());
            lineReceiver.reset();
          }
        }
      }

      char buf[100];
      StringUtil::modp_uitoa10(_pictureUriList.size(),buf);
      strcat(buf," images indexed");
      writeLine(buf);
    }


    /**
     * Read and show the JPEG
     * @param uri The URI of the JPEG
     */

    void showPicture(const std::string& uri) {

      // fade down the backlight to 10%, 4ms per step

      _backlight->fadeTo(10,4);

      // clear the screen

      _tft->setBackground(ColourNames::BLACK);
      _tft->clearScreen();

      // we're using a custom TCP client connection that processes incoming data on the receive IRQ
      // so that we avoid advertising a zero receive window back to the server with the performance
      // hit that we would take

      MyTcpClientConnection *conn;

      if(!_net->tcpConnect<MyTcpClientConnection>(_serverAddress,WEB_SERVER_PORT,conn))
        error("Failed to connect to web server");

      // manage the connection pointer in a scoped_ptr so it's automatically deleted (and closed)
      // when it goes out of scope

      HttpClient httpClient(*conn);

      // set the parameters for the HTTP GET

      httpClient.setUri(uri);
      httpClient.setHost(WEB_SERVER);
      httpClient.setVersion(HttpVersion::HTTP_1_0);       // connection to close after we get the image

      if(!httpClient.sendRequest()) {
        delete conn;
        error("Failed to send the request to the server");
      }

      // use a read-ahead input stream wrapped around a TCP input stream
      // with a read-ahead buffer of 256 bytes

      TcpInputStream tcis(*conn);

      // if the JPEG will fit then display it centered on screen, otherwise ignore it

      Size size;
      JpegDecoder<LcdPanel> jpeg;

      if(!jpeg.beginDecode(tcis,size)) {
        delete conn;
        error("Failed to decode JPEG image");
      }

      if(size.Height<=_tft->getHeight() && size.Width<=_tft->getWidth()) {

        // it fits, stream it in

        Point pt;

        pt.X=(_tft->getWidth()-size.Width)/2;
        pt.Y=(_tft->getHeight()-size.Height)/2;

        jpeg.endDecode(pt,*_tft);
      }

      delete conn;

      // fade up the backklight to 100%, 4ms per step

      _backlight->fadeTo(100,4);
    }


    /**
     * A notification event was received from the stack. Check for lease renewal
     * notification and new address announcements. This could be IRQ code.
     * @param ned The event descriptor base class
     */

    void onNotification(NetEventDescriptor& ned) {

      char buf[100];
      uint8_t i;

      if(ned.eventType==NetEventDescriptor::NetEventType::IP_ADDRESS_ANNOUNCEMENT) {
        strcpy(buf,"IP address: ");
        static_cast<IpAddressAnnouncementEvent&>(ned).ipAddress.toString(buf+12);
        writeLine(buf);
      }
      else if(ned.eventType==NetEventDescriptor::NetEventType::SUBNET_MASK_ANNOUNCEMENT) {
        strcpy(buf,"Subnet mask: ");
        static_cast<IpSubnetMaskAnnouncementEvent&>(ned).subnetMask.toString(buf+13);
        writeLine(buf);
      }
      else if(ned.eventType==NetEventDescriptor::NetEventType::DEFAULT_GATEWAY_ANNOUNCEMENT) {
        strcpy(buf,"Default gateway: ");
        static_cast<IpDefaultGatewayAnnouncementEvent&>(ned).defaultGateway.toString(buf+17);
        writeLine(buf);
      }
      else if(ned.eventType==NetEventDescriptor::NetEventType::DNS_SERVERS_ANNOUNCEMENT) {

        IpDnsServersAnnouncementEvent& dnsevent(static_cast<IpDnsServersAnnouncementEvent&>(ned));

        for(i=0;i<3;i++) {
          if(dnsevent.ipDnsServers[i].isValid()) {
            strcpy(buf,"DNS server: ");
            dnsevent.ipDnsServers[i].toString(buf+12);
            writeLine(buf);
          }
        }
      }
    }


    /**
     * Write a status line to the LCD
     * @param line The status line
     */

    void writeLine(const std::string& line) {
      *_tft << Point(0,_line*10) << line.c_str();
      _line++;
    }


    /**
     * Network error event received, report it and restart after a delay
     * @param ned
     */

    void onError(NetEventDescriptor& ned) {

      NetworkErrorEvent& errorEvent(static_cast<NetworkErrorEvent&>(ned));

      std::string str("Network error: ");
      char buf[20];

      StringUtil::modp_uitoa10(errorEvent.provider,buf);
      strcat(buf,"/");
      str+=buf;

      StringUtil::modp_uitoa10(errorEvent.code,buf);
      strcat(buf,"/");
      str+=buf;

      StringUtil::modp_uitoa10(errorEvent.cause,buf);
      str+=buf;

      _tft->setBackground(ColourNames::BLACK);
      _tft->setForeground(ColourNames::WHITE);

      _tft->clearRectangle(
          Rectangle(0,
                    _tft->getHeight()-_font->getHeight(),
                    _tft->getWidth(),
                    _font->getHeight()));

      *_tft << Point(0,_tft->getHeight()-_font->getHeight()) << str.c_str();
    }


    /**
     * Display the error code, then pause and reset
     * @param str
     */

    void error(const std::string& str) {

      _tft->setBackground(ColourNames::WHITE);
      _tft->setForeground(ColourNames::BLACK);
      _tft->clearScreen();

      LinearBufferInputOutputStream compressedData((uint8_t *)&ErrorPixels,(uint32_t)&ErrorPixelsSize);
      _tft->drawJpeg(Rectangle(95,135,50,50),compressedData);

      *_tft << Point(2,2) << str.c_str();

      errorRestart();
    }


    /**
     * Pause then restart the MCU
     */

    void errorRestart() {
      MillisecondTimer::delay(10000);
      NVIC_SystemReset();
    }
};


/*
 * Main entry point
 */

int main() {

  // interrupts
  Nvic::initialise();

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  NetWebPictureFrame test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/net_web_pframe/net_web_pframe.cpp
// START FILE: ../examples/net_web_pframe/system/LibraryHacks.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */


#include <cstdlib>
#include <sys/types.h>
#include "config/stm32plus.h"
#include "config/net.h"


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * The net code needs the heap to re-entrant so we need to ensure that an
 * IRQ cannot be raised while the heap structures are updated
 */

extern "C" {
  void __malloc_lock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::suspend();
  }

  void __malloc_unlock(struct _reent * /* reent */) {
    stm32plus::IrqSuspend::resume();
  }
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/net_web_pframe/system/LibraryHacks.cpp
// START FILE: ../examples/r61523/r61523.cpp
/*
 * This file is a part of the open source stm32plus library.
 * Copyright (c) 2011,2012,2013,2014 Andy Brown <www.andybrown.me.uk>
 * Please see website for licensing terms.
 */

#include "config/stm32plus.h"
#include "config/display/tft.h"


extern uint32_t BulbPixelsSize,BulbPixels;
extern uint32_t AudioPixelsSize,AudioPixels;
extern uint32_t FlagPixelsSize,FlagPixels;
extern uint32_t DocPixelsSize,DocPixels;
extern uint32_t GlobePixelsSize,GlobePixels;
extern uint32_t JpegTest0Pixels,JpegTest0PixelsSize;


using namespace stm32plus;
using namespace stm32plus::display;


/**
 * R61523 LCD test, show a looping graphics demo. We will make
 * use of the built-in PWM generator to control the backlight.
 * This saves us an MCU output pin and a timer peripheral.
 *
 * It's a 16-bit device and we control it in this demo
 * using the FSMC peripheral on bank 1. The wiring
 * that you need to do is as follows:
 *
 * VCC  => 3.0V / 3.3V
 * GND  => GND
 * PE1  => RESET
 * PD11 => RS (D/CX)
 * PD7  => CS (or tie to GND)
 * PD4  => RD (or tie to VCC)
 * PD5  => WR
 * PD14 => D0    PE11 => D8
 * PD15 => D1    PE12 => D9
 * PD0  => D2    PE13 => D10
 * PD1  => D3    PE14 => D11
 * PE7  => D4    PE15 => D12
 * PE8  => D5    PD8  => D13
 * PE9  => D6    PD9  => D14
 * PE10 => D7    PD10 => D15
 *
 * And for the backlight, connect together the following
 * two pins on the LCD breakout board:
 *
 * BL_PWM => EN
 *
 * Compatible MCU:
 *   STM32F1
 *   STM32F4
 *
 * Tested on devices:
 *   STM32F103VET6
 *   STM32F407VGT6
 */

class R61523Test {

  protected:
    typedef Fsmc16BitAccessMode<FsmcBank1NorSram1> LcdAccessMode;
    typedef R61523_Landscape_16M<LcdAccessMode> LcdPanel;           // type A panel or...
//  typedef R61523_Landscape_16M_TypeB<LcdAccessMode> LcdPanel;     // ...type B panel
    typedef R61523PwmBacklight<LcdAccessMode> LcdBacklight;

    LcdAccessMode *_accessMode;
    LcdPanel *_gl;
    LcdBacklight *_backlight;
    Font *_font;

  public:
    void run() {

      // reset is on PE1 and RS (D/CX) is on PD11

      GpioE<DefaultDigitalOutputFeature<1> > pe;
      GpioD<DefaultFsmcAlternateFunctionFeature<11>> pd;

      // Set up the FSMC timing. These numbers (particularly the data setup time) are dependent on
      // both the FSMC bus speed and the panel timing parameters. If you see corrupted graphics then
      // you may need to adjust these to fit the characteristics of your particular panel.

#if defined(STM32PLUS_F4)
      Fsmc8080LcdTiming fsmcReadTiming(0,20);
      Fsmc8080LcdTiming fsmcWriteTiming(0,5);
#elif defined(STM32PLUS_F1)
      Fsmc8080LcdTiming fsmcReadTiming(0,20);
      Fsmc8080LcdTiming fsmcWriteTiming(0,4);
#else
#error Invalid MCU
#endif

      // set up the FSMC with RS=A16 (PD11)

      _accessMode=new LcdAccessMode(fsmcReadTiming,fsmcWriteTiming,16,pe[1]);

      // declare a panel

      _gl=new LcdPanel(*_accessMode);

      // apply the gamma curve. Note that gammas are panel specific. This curve is appropriate
      // to a replacement (non-original) panel obtained from ebay.

      uint8_t levels[13]={ 0xe,0,1,1,0,0,0,0,0,0,3,4,0 };
      R61523Gamma gamma(levels);
      _gl->applyGamma(gamma);

      // clear to black while the lights are out

      _gl->setBackground(0);
      _gl->clearScreen();

      // create the backlight using default template parameters

      _backlight=new LcdBacklight(*_accessMode);

      // fade up the backlight to 100% using the hardware to do the smooth fade

      _backlight->setPercentage(100);

      // Create a font. A wide range of sample fonts are available. See the
      // "lib/include/display/graphic/fonts" directory for a full list and
      // you can always download and convert your own using the FontConv utility.

      _font=new Font_PROGGYCLEAN16;
      *_gl << *_font;

      for(;;) {
        lzgTest();
        jpegTest();
        basicColoursTest();
        backlightTest();
        gradientTest();
        textTest();
        rectTest();
        lineTest();
        ellipseTest();
        clearTest();
        sleepTest();
      }
    }

    void sleepTest() {

      prompt("Sleep test");

      // go to sleep

      *_gl << Point::Origin << "Sleeping now...";
      MillisecondTimer::delay(1000);
      _gl->sleep();
      MillisecondTimer::delay(3000);

      // wake up

      _gl->wake();
      _gl->clearScreen();
      *_gl << Point::Origin << "Woken up again...";
      MillisecondTimer::delay(3000);
    }

    void jpegTest() {

      // only draw if it can fit on screen

      if(_gl->getHeight()==360 && _gl->getWidth()==640) {

        prompt("JPEG bitmap test");

        // draw it centered

        LinearBufferInputOutputStream compressedData((uint8_t *)&JpegTest0Pixels,(uint32_t)&JpegTest0PixelsSize);
        _gl->drawJpeg(Rectangle(0,0,640,360),compressedData);

        MillisecondTimer::delay(3000);
      }
    }

    void lzgTest() {

      prompt("LZG bitmap test");

      // declare a DMA instance with a copy-to-fsmc feature

#if defined(STM32PLUS_F1)
      Dma1Channel6<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#elif defined(STM32PLUS_F4)
      Dma2Channel1Stream2<DmaFsmcLcdMemoryCopyFeature<LcdAccessMode> > dma;
#endif

      drawCompressedBitmap((uint8_t *)&BulbPixels,(uint32_t)&BulbPixelsSize,89,148,true,dma);
      drawCompressedBitmap((uint8_t *)&AudioPixels,(uint32_t)&AudioPixelsSize,150,161,false,dma);
      drawCompressedBitmap((uint8_t *)&FlagPixels,(uint32_t)&FlagPixelsSize,144,220,true,dma);
      drawCompressedBitmap((uint8_t *)&DocPixels,(uint32_t)&DocPixelsSize,200,240,false,dma);
      drawCompressedBitmap((uint8_t *)&GlobePixels,(uint32_t)&GlobePixelsSize,193,219,true,dma);
    }


    void drawCompressedBitmap(uint8_t *pixels,uint32_t size,uint16_t width,uint16_t height,bool useDma,DmaFsmcLcdMemoryCopyFeature<LcdAccessMode>& dma) {

      _gl->setBackground(ColourNames::WHITE);
      _gl->clearScreen();

      LinearBufferInputOutputStream compressedData(pixels,size);
      LzgDecompressionStream decompressor(compressedData,size);

      if(useDma) {
        _gl->drawBitmap(
            Rectangle((_gl->getWidth()-width)/2,
                (_gl->getHeight()-height)/2,
                width,height),
                decompressor,
                dma);
      }
      else {
        _gl->drawBitmap(
            Rectangle((_gl->getWidth()-width)/2,
                (_gl->getHeight()-height)/2,
                width,height),
                decompressor);
      }

      MillisecondTimer::delay(3000);
    }


    void textTest() {

      const char *str="The quick brown fox";
      Size size;
      Point p;
      uint32_t i,start;

      prompt("Stream operators test");

      *_gl << Point::Origin << "Let's see PI:";

      for(i=0;i<=7;i++)
        *_gl << Point(0,(1+i)*_font->getHeight()) << DoublePrecision(3.1415926535,i);

      MillisecondTimer::delay(5000);

      prompt("Opaque text test");

      size=_gl->measureString(*_font,str);

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=rand() % (_gl->getXmax()-size.Width);
        p.Y=rand() % (_gl->getYmax()-size.Height);

        _gl->setForeground(rand());
        _gl->writeString(p,*_font,str);
      }
    }


    void clearTest() {

      int i;
      uint32_t start;

      prompt("Clear screen test");

      for(i=0;i<200;i++) {
        _gl->setBackground(rand());

        start=MillisecondTimer::millis();
        _gl->clearScreen();
        stopTimer(" to clear",MillisecondTimer::millis()-start);
      }
    }


    void basicColoursTest() {

      uint16_t i;

      static const uint32_t colours[8]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::BLACK,
        ColourNames::WHITE,
      };

      prompt("Basic colours test");

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {
        _gl->setBackground(colours[i]);
        _gl->clearScreen();

        MillisecondTimer::delay(500);
      }
    }


    void lineTest() {

      Point p1,p2;
      uint32_t i,start;

      prompt("Line test");

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p1.X=rand() % _gl->getXmax();
        p1.Y=rand() % _gl->getYmax();
        p2.X=rand() % _gl->getXmax();
        p2.Y=rand() % _gl->getYmax();

        _gl->setForeground(rand());
        _gl->drawLine(p1,p2);
      }

      _gl->setForeground(ColourNames::WHITE);
      _gl->clearScreen();
      *_gl << Point::Origin << i << " lines in 5 seconds";
      MillisecondTimer::delay(3000);
    }

    void rectTest() {

      uint32_t i,start;
      Rectangle rc;

      prompt("Rectangle test");

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getYmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->fillRectangle(rc);
      }

      _gl->clearScreen();

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        rc.X=(rand() % _gl->getXmax()/2);
        rc.Y=(rand() % _gl->getYmax()/2);
        rc.Width=rand() % (_gl->getXmax()-rc.X);
        rc.Height=rand() % (_gl->getYmax()-rc.Y);

        _gl->setForeground(rand());
        _gl->drawRectangle(rc);

        if(i % 1000 ==0)
          _gl->clearScreen();
      }
    }


    void ellipseTest() {

      uint32_t i,start;
      Point p;
      Size s;

      prompt("Ellipse test");
      _gl->setBackground(0);

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        _gl->setForeground(rand());
        _gl->fillEllipse(p,s);
      }

      _gl->clearScreen();

      for(i=0,start=MillisecondTimer::millis();MillisecondTimer::millis()-start<5000;i++) {

        p.X=_gl->getXmax()/4+(rand() % (_gl->getXmax()/2));
        p.Y=_gl->getYmax()/4+(rand() % (_gl->getYmax()/2));

        if(p.X<_gl->getXmax()/2)
          s.Width=rand() % p.X;
        else
          s.Width=rand() % (_gl->getXmax()-p.X);

        if(p.Y<_gl->getYmax()/2)
          s.Height=rand() % p.Y;
        else
          s.Height=rand() % (_gl->getYmax()-p.Y);

        if(s.Height>0 && s.Width>0 && p.X+s.Width<_gl->getXmax() && p.Y+s.Height<_gl->getYmax()) {
          _gl->setForeground(rand());
          _gl->drawEllipse(p,s);
        }

        if(i % 500==0)
          _gl->clearScreen();
      }
    }

    void doGradientFills(Direction dir) {

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[7]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
      };


      rc.Width=_gl->getXmax()+1;
      rc.Height=(_gl->getYmax()+1)/2;

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        rc.X=0;
        rc.Y=0;

        _gl->gradientFillRectangle(rc,dir,ColourNames::BLACK,colours[i]);
        rc.Y=rc.Height;
        _gl->gradientFillRectangle(rc,dir,colours[i],ColourNames::BLACK);

        MillisecondTimer::delay(1000);
      }
    }

    void gradientTest() {

      prompt("Gradient test");

      doGradientFills(HORIZONTAL);
      doGradientFills(VERTICAL);
    }


    void backlightTest() {

      prompt("Backlight test");

      Rectangle rc;
      uint16_t i;
      static uint32_t colours[8]={
        ColourNames::RED,
        ColourNames::GREEN,
        ColourNames::BLUE,
        ColourNames::CYAN,
        ColourNames::MAGENTA,
        ColourNames::YELLOW,
        ColourNames::WHITE,
        ColourNames::BLACK,
      };

      // draw a row of solid colours

      rc.X=0;
      rc.Y=0;
      rc.Height=_gl->getHeight()/2;
      rc.Width=_gl->getWidth()/(sizeof(colours)/sizeof(colours[0]));

      for(i=0;i<sizeof(colours)/sizeof(colours[0]);i++) {

        _gl->setForeground(colours[i]);
        _gl->fillRectangle(rc);

        rc.X+=rc.Width;
      }

      // draw a greyscale

      rc.X=0;
      rc.Y=rc.Height;
      rc.Height=rc.Height/4;
      rc.Width=_gl->getWidth()/256;

      for(i=0;i<256;i++) {
        _gl->setForeground(i | (i << 8) | (i << 16));
        _gl->fillRectangle(rc);
        rc.X+=rc.Width;
      }

      for(i=100;i>0;i-=5) {

        // set the level

        _backlight->setPercentage(i);

        // show the indicator

        rc.X=_gl->getWidth()/4;
        rc.Y=(_gl->getHeight()*6)/8;
        rc.Height=_gl->getHeight()/8;

        // fill

        rc.Width=(_gl->getWidth()/2*i)/100;
        _gl->gradientFillRectangle(rc,Direction::HORIZONTAL,0x008000,0x00ff00);

        // remainder

        rc.X+=rc.Width;
        rc.Width=_gl->getWidth()/2-rc.Width;
        _gl->setForeground(ColourNames::BLACK);
        _gl->fillRectangle(rc);

        // show the percentage

        _gl->setForeground(ColourNames::WHITE);
        *_gl << Point(0,_gl->getHeight()-_font->getHeight()) << "Backlight level: " << i << "%  ";

        // pause

        MillisecondTimer::delay(750);
      }

      // restore backlight

      _backlight->setPercentage(100);
    }


    void prompt(const char *prompt) {

      _gl->setBackground(ColourNames::BLACK);
      _gl->clearScreen();

      _gl->setForeground(ColourNames::WHITE);
      *_gl << Point(0,0) << prompt;

      MillisecondTimer::delay(2000);
      _gl->clearScreen();
    }


    void stopTimer(const char *prompt,uint32_t elapsed) {

      _gl->setForeground(0xffffff);
      *_gl << Point(0,0) << (int32_t)elapsed << "ms " << prompt;
    }
};


/*
 * Main entry point
 */

int main() {

  // set up SysTick at 1ms resolution
  MillisecondTimer::initialise();

  R61523Test test;
  test.run();

  // not reached
  return 0;
}
// END FILE: ../examples/r61523/r61523.cpp
// START FILE: ../examples/r61523/system/LibraryHacks.cpp
/*
 * LibraryHacks.cpp
 *
 *  Created on: 23 Jan 2011
 *      Author: Andy
 */

#include <cstdlib>
#include <sys/types.h>


/*
 * The default pulls in 70K of garbage
 */

namespace __gnu_cxx {

  void __verbose_terminate_handler() {
    for(;;);
  }
}


/*
 * The default pulls in about 12K of garbage
 */

extern "C" void __cxa_pure_virtual() {
  for(;;);
}


/*
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size) {
  return malloc(size);
}

void *operator new(size_t,void *ptr) {
  return ptr;
}

void *operator new[](size_t size) {
  return malloc(size);
}

void *operator new[](size_t,void *ptr) {
  return ptr;
}

void operator delete(void *p) {
  free(p);
}

void operator delete[](void *p) {
  free(p);
}

void operator delete [](void *p, unsigned int) {
  free(p);
}

void operator delete(void *p, unsigned int) {
  free(p);
}


/*
 * EABI builds can generate reams of stack unwind code for system generated exceptions
 * e.g. (divide-by-zero). Since we don't support exceptions we'll wrap out these
 * symbols and save a lot of flash space.
 */

extern "C" void __wrap___aeabi_unwind_cpp_pr0() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr1() {}
extern "C" void __wrap___aeabi_unwind_cpp_pr2() {}


/*
 * sbrk function for getting space for malloc and friends
 */

extern int  _end;

extern "C" {
  caddr_t _sbrk ( int incr ) __attribute__((used));
  caddr_t _sbrk ( int incr ) {

    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) {
      heap = (unsigned char *)&_end;
    }
    prev_heap = heap;
    /* check removed to show basic approach */

    heap += incr;

    return (caddr_t) prev_heap;
  }

  int __wrap_atexit (void (*)(void)) {
         return 0;
  }
}
// END FILE: ../examples/r61523/system/LibraryHacks.cpp
// START FILE: ../README.md
Introduction
============
Firstly, welcome to stm32plus, the C++ library that eases the burden of programming the STM32F030, F042, F051, F100, F103, F107 and F4 devices.

The main introduction and getting started guide can be found at [my website](http://www.andybrown.me.uk).

### Travis CI build status

A representative sample of the stm32plus configurations are configured to automatically build with the Travis CI system. The badge below shows the current state of the builds.

[![Build Status](https://travis-ci.org/andysworkshop/stm32plus.svg?branch=master)](https://travis-ci.org/andysworkshop/stm32plus)

How to compile the library
==========================

Before you can use the library you need to build it because, although much of the library is provided _header-only_ there is a substantial amount of compiled code that you must link to.

Please see the INSTALL.md file for detailed compilation instructions.

Releases
========

After cloning this repo you are going to have a choice of what to build based on the branches and tags that have been created. Your options are:

* Download a [release](https://github.com/andysworkshop/stm32plus/releases) and build from that. This is the safe option. Every now and then I will create a tag from the current master branch that represents a release. You can be sure that a release will be fully tested against all the supported MCUs.

* Checkout the `master` branch (the default) and build from that. This is the quite-safe option. The `master` branch is guaranteed to build on all MCUs but the examples may not have been fully regression tested.

* Checkout a named feature or bug-fix branch and build from that. This is the hardcore option. Feature branches  that have not been merged back into `master` represent work in progress and should build but may be incomplete and have bugs.     

Where are the examples?
=======================

In the _examples_ subdirectory you will find dozens of examples nearly all of which will work without modification on the F0, F1 and F4 devices. The examples are heavily commented to help you understand what's going on.

The examples are configured to run out-of-the-box on the following MCUs:

| Device | Flash | SRAM | CPU Clock | External Oscillator |
|--------|-------|------|-----------|---------------------|
| F40x | 1024Kb | 192Kb | 168Mhz | 8 MHz |
| F103 HD | 512Kb | 64Kb | 72 MHz | 8 MHz |
| F107 | 256Kb | 64Kb | 72 MHz | 25 MHz |
| F100 MD VL | 128Kb | 8Kb | 24 MHz | 8 MHz |
| F042 | 32Kb | 6Kb | 48 MHz | none (uses 8MHz internal) |
| F051 | 64Kb | 8Kb | 48 MHz | none (uses 8MHz internal) |
| F030 | 64Kb | 8Kb | 48 MHz | none (uses 8MHz internal) |

If your device is listed but your board has a different oscillator or core clock speed then you may need to adjust `System.c` in the `system` subdirectory
of the example that you are looking at. If your memory configuration is different then you will need to adjust `Linker.ld` in the `system` subdirectory. 

Documentation
=============

HTML documentation can be found in the doc/html subdirectory. This documentation is auto-generated by the [doxygen](http://www.doxygen.org/) tool from the comments in the source code.

I freely admit that the documentation lags in both quantity and quality behind the code itself and it's a future task for me to improve it. In the meantime I hope that the heavily commented examples are enough to get you started.

Contributing
============

Contributions to stm32plus are welcome. Please follow these steps to ensure a smooth workflow:

* Clone the main stm32plus repo into your personal account and create a branch off `master` for your work. Give it a short meaningful name that allows people to get a good idea _at-a-glance_ of what you've done.

* When you're happy with your code, first do a merge back from the current master to ensure you're still compatible and then send me a pull request. I will code-review the pull-request and when we're all happy I will accept it and do the merge back into `master`.

Working in Eclipse
------------------
I do all my development in Eclipse Kepler using the CDT and the [GNU ARM Eclipse plugin](http://gnuarmeclipse.livius.net/blog/). The `.project` and `.cproject` files for the main library and all the examples are included. You can use Eclipse's import option on the root checkout directory to bring them all into your workspace in one go. I recommend that you create a _working set_ to contain all the stm32plus projects because there's a lot of them.

I have found that the recent updates to the plugin have been stable and non-breaking so you can probably just get the latest version. At the time of writing I am using version *1.10.2.201407190854* of the _Cross Compiler Support_ plugin.

How do I report a bug?
======================

If you think that you've found a bug then please enter an issue against the project on github. It really helps if you can give me enough information to reproduce the bug myself.

Alternatively you can fix it yourself and send me a pull-request.

A short walk around the directories
===================================

`/INSTALL.md`: The installation guide. This file explains how to build the library. If you read nothing else, read this!

`/SConstruct`: The top level scons build file, broadly equivalent to a Makefile for those that have not used scons before.

`lib/`: The root directory containing the library source code.

`lib/include`: The include files for the library. This directory and the parent stm32plus directory must be on the include path of any programs that you write. As of 2.0.0 the only include files that you need to know about are those in the `config` subdirectory. It should only ever be necessary to include `config/stm32plus.h` and one each for the peripherals that you want to use, for example `config/usart.h` or `config/spi.h`. These high level files take care of including everything else that they need.

`lib/src`: The C++ source files that make up the library. Everything in here is considered internal.

`lib/fwlib`: Source code to the ST Microelectronics standard peripheral libraries for the F0, F1 and F4 processors.

`examples/`: The examples that demonstrate the features of the library. There is one subdirectory for each example. All the examples follow the same general format. There is the main example source code and a `system` subdirectory. The `system` subdirectory is the same for every example and contains the startup and initialisation code required for the F0, F1 and F4 MCUs. The `SConscript` file takes care of selecting the appropriate code for your target MCU. To build modified example, run `scons` again from the root directory. scons is smart enough to only build changed files and their dependents.

`utils/bm2rgbi`: This PC utility is for converting graphics files (jpeg, png, gif etc.) into an internal format suitable for efficient transfer to a TFT. It also supports compression using the LZG format that results in files roughly the same size as a PNG. You'll need this utility if you decide to use the bitmap functions in the graphics library.

`utils/FontConv`: This PC utility is for converting TrueType bitmap fonts such as those you can download for free from www.dafont.com into font files suitable for compiling and using with the stm32plus text output graphics library functions.

`utils/LzgFontConv`: This PC utility is for converting TrueType vector anti-aliased fonts into compressed graphical representations suitable for compiling and using with the stm32plus bitmap text output graphics library functions.

A quick guide to flashing using OpenOCD
=======================================

At the time of writing the lastest version of openocd is 0.8.0 and it contains full support for the STM32 connected via JTAG and also via ST-Link (e.g. the STM32F4DISCOVERY  and STM32VLDISCOVERY boards). The following guide assumes that you are using either Linux or Windows with a Unix-like shell (cygwin or mingw) and that you have built the binaries.

Flashing the stm32f4discovery board
-----------------------------------

`cd` into the openocd directory and run it with the flags required for the discovery board. For me on Windows 7 x64/cygwin this is:

	$ bin-x64/openocd-x64-0.8.0.exe -f scripts/board/stm32f4discovery.cfg
	Open On-Chip Debugger 0.8.0 (2012-10-07-10:39)
	Licensed under GNU GPL v2
	For bug reports, read
	http://openocd.sourceforge.net/doc/doxygen/bugs.html
	adapter speed: 1000 kHz
	srst_only separate srst_nogate srst_open_drain
	Info : clock speed 1000 kHz
	libusbx: info [cache_config_descriptors] could not access
	configuration descriptor (dummy) for
	'\\.\USB#VID_0424&PID_2504#6&247B17EE&0&1':
	[31] A device attached to the system is not functioning.
	libusbx: info [cache_config_descriptors] could not access
	configuration
	descriptor (dummy) for
	'\\.\USB#VID_1A40&PID_0101#5&476FB6F&0&4':
	[31] A device attached to the system is not functioning.
	Info : stm32f4x.cpu: hardware has 6 breakpoints, 4 watchpoints

openocd is now up and running waiting for you to do something. Don't worry about the libusb 'errors', they are harmless.

Now telnet to openocd and flash your hex image:

	$ telnet localhost 4444
	Trying 127.0.0.1...
	Connected to localhost.
	Escape character is '^]'.
	Open On-Chip Debugger

Reset the device and halt it:

	> reset init
	target state: halted
	target halted due to debug-request, current mode: Thread 
	xPSR: 0x01000000 pc: 0x08000b9c msp: 0x20020000

Flash your hex image:

	> flash write_image erase p:/button.hex
	auto erase enabled
	target state: halted
	target halted due to breakpoint, current mode: Thread 
	xPSR: 0x61000000 pc: 0x20000042 msp: 0x20020000
	wrote 16384 bytes from file p:/button.hex in 1.147065s (13.949 KiB/s)

Reset the device to run the program:

	> reset

Flashing an F1 board using JTAG
-------------------------------

The procedure is much the same as the F4. We will start openocd and then use a telnet connection to flash the image. First start openocd. I can't give you the exact startup command for openocd because it will vary according to the JTAG dongle that you have purchased. I use the Olimex ARM-USB-TINY-H device that has an OpenOCD configuration file dedicated to it. Here's what openocd reports when I start it up:

	Open On-Chip Debugger 0.5.0-dev-00852-gf9feeac-dirty (2011-07-27-21:58)
	Licensed under GNU GPL v2
	For bug reports, read
	   http://openocd.berlios.de/doc/doxygen/bugs.html
	Info : only one transport option; autoselect 'jtag'
	1000 kHz
	adapter_nsrst_delay: 100
	jtag_ntrst_delay: 100
	cortex_m3 reset_config sysresetreq
	Info : device: 6 "2232H"
	Info : deviceID: 364511274
	Info : SerialNumber: OLTMERUA
	Info : Description: Olimex OpenOCD JTAG ARM-USB-TINY-H A
	Info : max TCK change to: 30000 kHz 
	Info : clock speed 1000 kHz
	Info : JTAG tap: stm32.cpu tap/device found: 0x3ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x3)
	Info : JTAG tap: stm32.bs tap/device found: 0x06414041 (mfg: 0x020, part: 0x6414, ver: 0x0)
	Info : stm32.cpu: hardware has 6 breakpoints, 4 watchpoints

Now we can telnet to openocd:

	$ telnet localhost 4444
	Trying 127.0.0.1...
	Connected to localhost.
	Escape character is '^]'.
	Open On-Chip Debugger

And now we can reset the device
 
	> reset init
	JTAG tap: stm32.cpu tap/device found: 0x3ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x3)
	JTAG tap: stm32.bs tap/device found: 0x06414041 (mfg: 0x020, part: 0x6414, ver: 0x0)
	target state: halted
	target halted due to debug-request, current mode: Thread 
	xPSR: 0x01000000 pc: 0x08000a84 msp: 0x2000fffc

Flash the program hex image to the board:

	> flash write_image erase /tmp/pframe.hex
	auto erase enabled
	device id = 0x10036414
	flash size = 512kbytes
	Padding image section 0 with 4 bytes

Reset the MCU to start the program:

	> reset
	JTAG tap: stm32.cpu tap/device found: 0x3ba00477 (mfg: 0x23b, part: 0xba00, ver: 0x3)
	JTAG tap: stm32.bs tap/device found: 0x06414041 (mfg: 0x020, part: 0x6414, ver: 0x0)

Flashing the stm32vldiscovery board
-----------------------------------

Windows users need to ensure that they can connect to the ST-Link V1 debugger on the VL discovery board using OpenOCD. If the instructions below fail then you probably need to replace the default mass storage USB drivers with the WinUSB or libusb drivers using the [zadig](https://sourceforge.net/projects/libwdi/files/zadig) utility.

`cd` into the openocd directory and run it with the flags required for the discovery board. For me on Windows 7 x64/cygwin this is:

	$ bin-x64/openocd-x64-0.8.0.exe -f scripts/board/stm32vldiscovery.cfg 
	Open On-Chip Debugger 0.8.0 (2012-10-07-10:39)
	Licensed under GNU GPL v2
	For bug reports, read
	        http://openocd.sourceforge.net/doc/doxygen/bugs.html
	adapter speed: 1000 kHz
	Info : clock speed 1000 kHz
	libusbx: info [cache_config_descriptors] could not access configuration descriptor (dummy) for '\\.\USB#VID_0424&PID_2504#6&3734C893&0&1': [31] A device attached to the system is not functioning.
	Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints

openocd is now up and running waiting for you to do something. Don't worry about the libusb 'errors', they are harmless.

Now telnet to openocd and flash your hex image:

	$ telnet localhost 4444
	Trying 127.0.0.1...
	Connected to localhost.
	Escape character is '^]'.
	Open On-Chip Debugger

Reset the device and halt it:

	> reset init
	target state: halted
	target halted due to debug-request, current mode: Thread 
	xPSR: 0x01000000 pc: 0x08000b84 msp: 0x20002000

Flash your hex image:

	> flash write_image erase p:/blink.hex
	auto erase enabled
	device id = 0x10016420
	flash size = 128kbytes
	target state: halted
	target halted due to breakpoint, current mode: Thread 
	xPSR: 0x61000000 pc: 0x2000003a msp: 0x20002000
	wrote 3072 bytes from file p:/blink.hex in 0.653037s (4.594 KiB/s)

Reset the device to run the program:

	> reset

Flashing the stm32f0discovery board
--
This is one of the more recent _discovery_ boards from ST and as such it comes equipped with version 2 of the ST-Link debugger on board. Using it with OpenOCD is a very similar procedure to the F4.

`cd` into the openocd directory and run it with the flags required for the discovery board. For me on Windows 7 x64/cygwin this is:

	$ bin-x64/openocd-x64-0.8.0.exe -f scripts/board/stm32f0discovery.cfg
	Open On-Chip Debugger 0.8.0 (2013-05-05-10:44)
	Licensed under GNU GPL v2
	For bug reports, read
	        http://openocd.sourceforge.net/doc/doxygen/bugs.html
	srst_only separate srst_nogate srst_open_drain connect_deassert_srst
	Info : This adapter doesn't support configurable speed
	Info : STLINK v2 JTAG v14 API v2 SWIM v0 VID 0x0483 PID 0x3748
	Info : Target voltage: 2.886506
	Info : stm32f0x.cpu: hardware has 4 breakpoints, 2 watchpoints

openocd is now up and running waiting for you to do something.

Now telnet to openocd and flash your hex image:

	$ telnet localhost 4444
	Trying 127.0.0.1...
	Connected to localhost.
	Escape character is '^]'.
	Open On-Chip Debugger

Reset the device and halt it:

	> reset init
	target state: halted
	target halted due to debug-request, current mode: Thread 
	xPSR: 0xc1000000 pc: 0x080009b8 msp: 0x20002000

Flash your hex image:

	> flash write_image erase p:/blink.hex
	auto erase enabled
	device id = 0x20006440
	flash size = 64kbytes
	wrote 2048 bytes from file p:/blink.hex in 0.423024s (4.728 KiB/s)

Reset the device to run the program:

	> reset

That's all, I hope my experience with OpenOCD can help you get started.
// END FILE: ../README.md
